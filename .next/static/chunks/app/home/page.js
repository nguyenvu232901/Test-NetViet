/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/home/page"],{

/***/ "(app-pages-browser)/./node_modules/axios/lib/adapters/adapters.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/adapters/adapters.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./http.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/null.js\");\n/* harmony import */ var _xhr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xhr.js */ \"(app-pages-browser)/./node_modules/axios/lib/adapters/xhr.js\");\n/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetch.js */ \"(app-pages-browser)/./node_modules/axios/lib/adapters/fetch.js\");\n/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/AxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\");\n\n\n\n\n\n\nconst knownAdapters = {\n  http: _http_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  xhr: _xhr_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  fetch: _fetch_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n}\n\n_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => _utils_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isFunction(adapter) || adapter === null || adapter === false;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  getAdapter: (adapters) => {\n    adapters = _utils_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n        'as no adapter specified';\n\n      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\n        `There is no suitable adapter to dispatch the request ` + s,\n        'ERR_NOT_SUPPORT'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMvYWRhcHRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWdDO0FBQ0k7QUFDRjtBQUNJO0FBQ1M7O0FBRS9DO0FBQ0EsUUFBUSxnREFBVztBQUNuQixPQUFPLCtDQUFVO0FBQ2pCLFNBQVMsaURBQVk7QUFDckI7O0FBRUEsaURBQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0MsTUFBTTtBQUNOO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBLENBQUM7O0FBRUQsc0NBQXNDLE9BQU87O0FBRTdDLHNDQUFzQyxpREFBSzs7QUFFM0MsaUVBQWU7QUFDZjtBQUNBLGVBQWUsaURBQUs7O0FBRXBCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwyREFBVSxxQkFBcUIsR0FBRztBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLDJEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGFkYXB0ZXJzXFxhZGFwdGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IGh0dHBBZGFwdGVyIGZyb20gJy4vaHR0cC5qcyc7XG5pbXBvcnQgeGhyQWRhcHRlciBmcm9tICcuL3hoci5qcyc7XG5pbXBvcnQgZmV0Y2hBZGFwdGVyIGZyb20gJy4vZmV0Y2guanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuXG5jb25zdCBrbm93bkFkYXB0ZXJzID0ge1xuICBodHRwOiBodHRwQWRhcHRlcixcbiAgeGhyOiB4aHJBZGFwdGVyLFxuICBmZXRjaDogZmV0Y2hBZGFwdGVyXG59XG5cbnV0aWxzLmZvckVhY2goa25vd25BZGFwdGVycywgKGZuLCB2YWx1ZSkgPT4ge1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHt2YWx1ZX0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdhZGFwdGVyTmFtZScsIHt2YWx1ZX0pO1xuICB9XG59KTtcblxuY29uc3QgcmVuZGVyUmVhc29uID0gKHJlYXNvbikgPT4gYC0gJHtyZWFzb259YDtcblxuY29uc3QgaXNSZXNvbHZlZEhhbmRsZSA9IChhZGFwdGVyKSA9PiB1dGlscy5pc0Z1bmN0aW9uKGFkYXB0ZXIpIHx8IGFkYXB0ZXIgPT09IG51bGwgfHwgYWRhcHRlciA9PT0gZmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0QWRhcHRlcjogKGFkYXB0ZXJzKSA9PiB7XG4gICAgYWRhcHRlcnMgPSB1dGlscy5pc0FycmF5KGFkYXB0ZXJzKSA/IGFkYXB0ZXJzIDogW2FkYXB0ZXJzXTtcblxuICAgIGNvbnN0IHtsZW5ndGh9ID0gYWRhcHRlcnM7XG4gICAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gICAgbGV0IGFkYXB0ZXI7XG5cbiAgICBjb25zdCByZWplY3RlZFJlYXNvbnMgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWVPckFkYXB0ZXIgPSBhZGFwdGVyc1tpXTtcbiAgICAgIGxldCBpZDtcblxuICAgICAgYWRhcHRlciA9IG5hbWVPckFkYXB0ZXI7XG5cbiAgICAgIGlmICghaXNSZXNvbHZlZEhhbmRsZShuYW1lT3JBZGFwdGVyKSkge1xuICAgICAgICBhZGFwdGVyID0ga25vd25BZGFwdGVyc1soaWQgPSBTdHJpbmcobmFtZU9yQWRhcHRlcikpLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgVW5rbm93biBhZGFwdGVyICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWRhcHRlcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmVqZWN0ZWRSZWFzb25zW2lkIHx8ICcjJyArIGldID0gYWRhcHRlcjtcbiAgICB9XG5cbiAgICBpZiAoIWFkYXB0ZXIpIHtcblxuICAgICAgY29uc3QgcmVhc29ucyA9IE9iamVjdC5lbnRyaWVzKHJlamVjdGVkUmVhc29ucylcbiAgICAgICAgLm1hcCgoW2lkLCBzdGF0ZV0pID0+IGBhZGFwdGVyICR7aWR9IGAgK1xuICAgICAgICAgIChzdGF0ZSA9PT0gZmFsc2UgPyAnaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQnIDogJ2lzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJ1aWxkJylcbiAgICAgICAgKTtcblxuICAgICAgbGV0IHMgPSBsZW5ndGggP1xuICAgICAgICAocmVhc29ucy5sZW5ndGggPiAxID8gJ3NpbmNlIDpcXG4nICsgcmVhc29ucy5tYXAocmVuZGVyUmVhc29uKS5qb2luKCdcXG4nKSA6ICcgJyArIHJlbmRlclJlYXNvbihyZWFzb25zWzBdKSkgOlxuICAgICAgICAnYXMgbm8gYWRhcHRlciBzcGVjaWZpZWQnO1xuXG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIG5vIHN1aXRhYmxlIGFkYXB0ZXIgdG8gZGlzcGF0Y2ggdGhlIHJlcXVlc3QgYCArIHMsXG4gICAgICAgICdFUlJfTk9UX1NVUFBPUlQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBhZGFwdGVyO1xuICB9LFxuICBhZGFwdGVyczoga25vd25BZGFwdGVyc1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/adapters/adapters.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/adapters/fetch.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/adapters/fetch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\");\n/* harmony import */ var _helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/composeSignals.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/composeSignals.js\");\n/* harmony import */ var _helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/trackStream.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/trackStream.js\");\n/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosHeaders.js\");\n/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/progressEventReducer.js\");\n/* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/resolveConfig.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/resolveConfig.js\");\n/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/settle.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/settle.js\");\n\n\n\n\n\n\n\n\n\n\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\n);\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n}\n\nconst supportsRequestStream = isReadableStreamSupported && test(() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  return duplexAccessed && !hasContentType;\n});\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst supportsResponseStream = isReadableStreamSupported &&\n  test(() => _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isReadableStream(new Response('').body));\n\n\nconst resolvers = {\n  stream: supportsResponseStream && ((res) => res.body)\n};\n\nisFetchSupported && (((res) => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isFunction(res[type]) ? (res) => res[type]() :\n      (_, config) => {\n        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](`Response type '${type}' is not supported`, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ERR_NOT_SUPPORT, config);\n      })\n  });\n})(new Response));\n\nconst getBodyLength = async (body) => {\n  if (body == null) {\n    return 0;\n  }\n\n  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isBlob(body)) {\n    return body.size;\n  }\n\n  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isSpecCompliantForm(body)) {\n    const _request = new Request(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].origin, {\n      method: 'POST',\n      body,\n    });\n    return (await _request.arrayBuffer()).byteLength;\n  }\n\n  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isArrayBufferView(body) || _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isArrayBuffer(body)) {\n    return body.byteLength;\n  }\n\n  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isURLSearchParams(body)) {\n    body = body + '';\n  }\n\n  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n}\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].toFiniteNumber(headers.getContentLength());\n\n  return length == null ? getBodyLength(body) : length;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFetchSupported && (async (config) => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = (0,_helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(config);\n\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n  let composedSignal = (0,_helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n  let request;\n\n  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n  });\n\n  let requestContentLength;\n\n  try {\n    if (\n      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n    ) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n\n      let contentTypeHeader;\n\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader)\n      }\n\n      if (_request.body) {\n        const [onProgress, flush] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventDecorator)(\n          requestContentLength,\n          (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.asyncDecorator)(onUploadProgress))\n        );\n\n        data = (0,_helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__.trackStream)(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n      }\n    }\n\n    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isString(withCredentials)) {\n      withCredentials = withCredentials ? 'include' : 'omit';\n    }\n\n    // Cloudflare Workers throws when credentials are defined\n    // see https://github.com/cloudflare/workerd/issues/902\n    const isCredentialsSupported = \"credentials\" in Request.prototype;\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      credentials: isCredentialsSupported ? withCredentials : undefined\n    });\n\n    let response = await fetch(request);\n\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n      const options = {};\n\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n\n      const responseContentLength = _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].toFiniteNumber(response.headers.get('content-length'));\n\n      const [onProgress, flush] = onDownloadProgress && (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventDecorator)(\n        responseContentLength,\n        (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.asyncDecorator)(onDownloadProgress), true)\n      ) || [];\n\n      response = new Response(\n        (0,_helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__.trackStream)(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }),\n        options\n      );\n    }\n\n    responseType = responseType || 'text';\n\n    let responseData = await resolvers[_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].findKey(resolvers, responseType) || 'text'](response, config);\n\n    !isStreamResponse && unsubscribe && unsubscribe();\n\n    return await new Promise((resolve, reject) => {\n      (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(resolve, reject, {\n        data: responseData,\n        headers: _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      })\n    })\n  } catch (err) {\n    unsubscribe && unsubscribe();\n\n    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n      throw Object.assign(\n        new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('Network Error', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ERR_NETWORK, config, request),\n        {\n          cause: err.cause || err\n        }\n      )\n    }\n\n    throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].from(err, err && err.code, config, request);\n  }\n}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE0QztBQUNaO0FBQ2U7QUFDVztBQUNKO0FBQ0g7QUFDNkQ7QUFDeEQ7QUFDakI7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLDBEQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQSxhQUFhLGlEQUFLOzs7QUFHbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsaURBQUs7QUFDaEQ7QUFDQSxrQkFBa0IsMkRBQVUsbUJBQW1CLEtBQUsscUJBQXFCLDJEQUFVO0FBQ25GLE9BQU87QUFDUCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLGlEQUFLO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLLGlEQUFLO0FBQ1YsaUNBQWlDLDBEQUFRO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLLGlEQUFLLDRCQUE0QixpREFBSztBQUMzQztBQUNBOztBQUVBLEtBQUssaURBQUs7QUFDVjtBQUNBOztBQUVBLEtBQUssaURBQUs7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsaURBQUs7O0FBRXRCO0FBQ0E7O0FBRUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksRUFBRSxxRUFBYTs7QUFFbkI7O0FBRUEsdUJBQXVCLHNFQUFjOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBLFVBQVUsaURBQUs7QUFDZjtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLHdGQUFzQjtBQUMxRDtBQUNBLFVBQVUsc0ZBQW9CLENBQUMsZ0ZBQWM7QUFDN0M7O0FBRUEsZUFBZSxvRUFBVztBQUMxQjtBQUNBOztBQUVBLFNBQVMsaURBQUs7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVAsb0NBQW9DLGlEQUFLOztBQUV6Qyx3REFBd0Qsd0ZBQXNCO0FBQzlFO0FBQ0EsUUFBUSxzRkFBb0IsQ0FBQyxnRkFBYztBQUMzQzs7QUFFQTtBQUNBLFFBQVEsb0VBQVc7QUFDbkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDLGlEQUFLOztBQUU1Qzs7QUFFQTtBQUNBLE1BQU0sMkRBQU07QUFDWjtBQUNBLGlCQUFpQiw2REFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxZQUFZLDJEQUFVLGtCQUFrQiwyREFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsMkRBQVU7QUFDcEI7QUFDQSxDQUFDLENBQUMsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGFkYXB0ZXJzXFxmZXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGxhdGZvcm0gZnJvbSBcIi4uL3BsYXRmb3JtL2luZGV4LmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tIFwiLi4vY29yZS9BeGlvc0Vycm9yLmpzXCI7XG5pbXBvcnQgY29tcG9zZVNpZ25hbHMgZnJvbSBcIi4uL2hlbHBlcnMvY29tcG9zZVNpZ25hbHMuanNcIjtcbmltcG9ydCB7dHJhY2tTdHJlYW19IGZyb20gXCIuLi9oZWxwZXJzL3RyYWNrU3RyZWFtLmpzXCI7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuLi9jb3JlL0F4aW9zSGVhZGVycy5qc1wiO1xuaW1wb3J0IHtwcm9ncmVzc0V2ZW50UmVkdWNlciwgcHJvZ3Jlc3NFdmVudERlY29yYXRvciwgYXN5bmNEZWNvcmF0b3J9IGZyb20gXCIuLi9oZWxwZXJzL3Byb2dyZXNzRXZlbnRSZWR1Y2VyLmpzXCI7XG5pbXBvcnQgcmVzb2x2ZUNvbmZpZyBmcm9tIFwiLi4vaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzXCI7XG5pbXBvcnQgc2V0dGxlIGZyb20gXCIuLi9jb3JlL3NldHRsZS5qc1wiO1xuXG5jb25zdCBpc0ZldGNoU3VwcG9ydGVkID0gdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgPSBpc0ZldGNoU3VwcG9ydGVkICYmIHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gdXNlZCBvbmx5IGluc2lkZSB0aGUgZmV0Y2ggYWRhcHRlclxuY29uc3QgZW5jb2RlVGV4dCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgKChlbmNvZGVyKSA9PiAoc3RyKSA9PiBlbmNvZGVyLmVuY29kZShzdHIpKShuZXcgVGV4dEVuY29kZXIoKSkgOlxuICAgIGFzeW5jIChzdHIpID0+IG5ldyBVaW50OEFycmF5KGF3YWl0IG5ldyBSZXNwb25zZShzdHIpLmFycmF5QnVmZmVyKCkpXG4pO1xuXG5jb25zdCB0ZXN0ID0gKGZuLCAuLi5hcmdzKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZm4oLi4uYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5jb25zdCBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gPSBpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkICYmIHRlc3QoKCkgPT4ge1xuICBsZXQgZHVwbGV4QWNjZXNzZWQgPSBmYWxzZTtcblxuICBjb25zdCBoYXNDb250ZW50VHlwZSA9IG5ldyBSZXF1ZXN0KHBsYXRmb3JtLm9yaWdpbiwge1xuICAgIGJvZHk6IG5ldyBSZWFkYWJsZVN0cmVhbSgpLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGdldCBkdXBsZXgoKSB7XG4gICAgICBkdXBsZXhBY2Nlc3NlZCA9IHRydWU7XG4gICAgICByZXR1cm4gJ2hhbGYnO1xuICAgIH0sXG4gIH0pLmhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKTtcblxuICByZXR1cm4gZHVwbGV4QWNjZXNzZWQgJiYgIWhhc0NvbnRlbnRUeXBlO1xufSk7XG5cbmNvbnN0IERFRkFVTFRfQ0hVTktfU0laRSA9IDY0ICogMTAyNDtcblxuY29uc3Qgc3VwcG9ydHNSZXNwb25zZVN0cmVhbSA9IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiZcbiAgdGVzdCgoKSA9PiB1dGlscy5pc1JlYWRhYmxlU3RyZWFtKG5ldyBSZXNwb25zZSgnJykuYm9keSkpO1xuXG5cbmNvbnN0IHJlc29sdmVycyA9IHtcbiAgc3RyZWFtOiBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmICgocmVzKSA9PiByZXMuYm9keSlcbn07XG5cbmlzRmV0Y2hTdXBwb3J0ZWQgJiYgKCgocmVzKSA9PiB7XG4gIFsndGV4dCcsICdhcnJheUJ1ZmZlcicsICdibG9iJywgJ2Zvcm1EYXRhJywgJ3N0cmVhbSddLmZvckVhY2godHlwZSA9PiB7XG4gICAgIXJlc29sdmVyc1t0eXBlXSAmJiAocmVzb2x2ZXJzW3R5cGVdID0gdXRpbHMuaXNGdW5jdGlvbihyZXNbdHlwZV0pID8gKHJlcykgPT4gcmVzW3R5cGVdKCkgOlxuICAgICAgKF8sIGNvbmZpZykgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgUmVzcG9uc2UgdHlwZSAnJHt0eXBlfScgaXMgbm90IHN1cHBvcnRlZGAsIEF4aW9zRXJyb3IuRVJSX05PVF9TVVBQT1JULCBjb25maWcpO1xuICAgICAgfSlcbiAgfSk7XG59KShuZXcgUmVzcG9uc2UpKTtcblxuY29uc3QgZ2V0Qm9keUxlbmd0aCA9IGFzeW5jIChib2R5KSA9PiB7XG4gIGlmIChib2R5ID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmKHV0aWxzLmlzQmxvYihib2R5KSkge1xuICAgIHJldHVybiBib2R5LnNpemU7XG4gIH1cblxuICBpZih1dGlscy5pc1NwZWNDb21wbGlhbnRGb3JtKGJvZHkpKSB7XG4gICAgY29uc3QgX3JlcXVlc3QgPSBuZXcgUmVxdWVzdChwbGF0Zm9ybS5vcmlnaW4sIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keSxcbiAgICB9KTtcbiAgICByZXR1cm4gKGF3YWl0IF9yZXF1ZXN0LmFycmF5QnVmZmVyKCkpLmJ5dGVMZW5ndGg7XG4gIH1cblxuICBpZih1dGlscy5pc0FycmF5QnVmZmVyVmlldyhib2R5KSB8fCB1dGlscy5pc0FycmF5QnVmZmVyKGJvZHkpKSB7XG4gICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIGlmKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG4gICAgYm9keSA9IGJvZHkgKyAnJztcbiAgfVxuXG4gIGlmKHV0aWxzLmlzU3RyaW5nKGJvZHkpKSB7XG4gICAgcmV0dXJuIChhd2FpdCBlbmNvZGVUZXh0KGJvZHkpKS5ieXRlTGVuZ3RoO1xuICB9XG59XG5cbmNvbnN0IHJlc29sdmVCb2R5TGVuZ3RoID0gYXN5bmMgKGhlYWRlcnMsIGJvZHkpID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gdXRpbHMudG9GaW5pdGVOdW1iZXIoaGVhZGVycy5nZXRDb250ZW50TGVuZ3RoKCkpO1xuXG4gIHJldHVybiBsZW5ndGggPT0gbnVsbCA/IGdldEJvZHlMZW5ndGgoYm9keSkgOiBsZW5ndGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgKGFzeW5jIChjb25maWcpID0+IHtcbiAgbGV0IHtcbiAgICB1cmwsXG4gICAgbWV0aG9kLFxuICAgIGRhdGEsXG4gICAgc2lnbmFsLFxuICAgIGNhbmNlbFRva2VuLFxuICAgIHRpbWVvdXQsXG4gICAgb25Eb3dubG9hZFByb2dyZXNzLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3MsXG4gICAgcmVzcG9uc2VUeXBlLFxuICAgIGhlYWRlcnMsXG4gICAgd2l0aENyZWRlbnRpYWxzID0gJ3NhbWUtb3JpZ2luJyxcbiAgICBmZXRjaE9wdGlvbnNcbiAgfSA9IHJlc29sdmVDb25maWcoY29uZmlnKTtcblxuICByZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgPyAocmVzcG9uc2VUeXBlICsgJycpLnRvTG93ZXJDYXNlKCkgOiAndGV4dCc7XG5cbiAgbGV0IGNvbXBvc2VkU2lnbmFsID0gY29tcG9zZVNpZ25hbHMoW3NpZ25hbCwgY2FuY2VsVG9rZW4gJiYgY2FuY2VsVG9rZW4udG9BYm9ydFNpZ25hbCgpXSwgdGltZW91dCk7XG5cbiAgbGV0IHJlcXVlc3Q7XG5cbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBjb21wb3NlZFNpZ25hbCAmJiBjb21wb3NlZFNpZ25hbC51bnN1YnNjcmliZSAmJiAoKCkgPT4ge1xuICAgICAgY29tcG9zZWRTaWduYWwudW5zdWJzY3JpYmUoKTtcbiAgfSk7XG5cbiAgbGV0IHJlcXVlc3RDb250ZW50TGVuZ3RoO1xuXG4gIHRyeSB7XG4gICAgaWYgKFxuICAgICAgb25VcGxvYWRQcm9ncmVzcyAmJiBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gJiYgbWV0aG9kICE9PSAnZ2V0JyAmJiBtZXRob2QgIT09ICdoZWFkJyAmJlxuICAgICAgKHJlcXVlc3RDb250ZW50TGVuZ3RoID0gYXdhaXQgcmVzb2x2ZUJvZHlMZW5ndGgoaGVhZGVycywgZGF0YSkpICE9PSAwXG4gICAgKSB7XG4gICAgICBsZXQgX3JlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgIGR1cGxleDogXCJoYWxmXCJcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgY29udGVudFR5cGVIZWFkZXI7XG5cbiAgICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpICYmIChjb250ZW50VHlwZUhlYWRlciA9IF9yZXF1ZXN0LmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkpIHtcbiAgICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZShjb250ZW50VHlwZUhlYWRlcilcbiAgICAgIH1cblxuICAgICAgaWYgKF9yZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgY29uc3QgW29uUHJvZ3Jlc3MsIGZsdXNoXSA9IHByb2dyZXNzRXZlbnREZWNvcmF0b3IoXG4gICAgICAgICAgcmVxdWVzdENvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25VcGxvYWRQcm9ncmVzcykpXG4gICAgICAgICk7XG5cbiAgICAgICAgZGF0YSA9IHRyYWNrU3RyZWFtKF9yZXF1ZXN0LmJvZHksIERFRkFVTFRfQ0hVTktfU0laRSwgb25Qcm9ncmVzcywgZmx1c2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdXRpbHMuaXNTdHJpbmcod2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgd2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ29taXQnO1xuICAgIH1cblxuICAgIC8vIENsb3VkZmxhcmUgV29ya2VycyB0aHJvd3Mgd2hlbiBjcmVkZW50aWFscyBhcmUgZGVmaW5lZFxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRmbGFyZS93b3JrZXJkL2lzc3Vlcy85MDJcbiAgICBjb25zdCBpc0NyZWRlbnRpYWxzU3VwcG9ydGVkID0gXCJjcmVkZW50aWFsc1wiIGluIFJlcXVlc3QucHJvdG90eXBlO1xuICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgIHNpZ25hbDogY29tcG9zZWRTaWduYWwsXG4gICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgaGVhZGVyczogaGVhZGVycy5ub3JtYWxpemUoKS50b0pTT04oKSxcbiAgICAgIGJvZHk6IGRhdGEsXG4gICAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgICAgY3JlZGVudGlhbHM6IGlzQ3JlZGVudGlhbHNTdXBwb3J0ZWQgPyB3aXRoQ3JlZGVudGlhbHMgOiB1bmRlZmluZWRcbiAgICB9KTtcblxuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xuXG4gICAgY29uc3QgaXNTdHJlYW1SZXNwb25zZSA9IHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gJiYgKHJlc3BvbnNlVHlwZSA9PT0gJ3N0cmVhbScgfHwgcmVzcG9uc2VUeXBlID09PSAncmVzcG9uc2UnKTtcblxuICAgIGlmIChzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmIChvbkRvd25sb2FkUHJvZ3Jlc3MgfHwgKGlzU3RyZWFtUmVzcG9uc2UgJiYgdW5zdWJzY3JpYmUpKSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBbJ3N0YXR1cycsICdzdGF0dXNUZXh0JywgJ2hlYWRlcnMnXS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBvcHRpb25zW3Byb3BdID0gcmVzcG9uc2VbcHJvcF07XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50TGVuZ3RoID0gdXRpbHMudG9GaW5pdGVOdW1iZXIocmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykpO1xuXG4gICAgICBjb25zdCBbb25Qcm9ncmVzcywgZmx1c2hdID0gb25Eb3dubG9hZFByb2dyZXNzICYmIHByb2dyZXNzRXZlbnREZWNvcmF0b3IoXG4gICAgICAgIHJlc3BvbnNlQ29udGVudExlbmd0aCxcbiAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25Eb3dubG9hZFByb2dyZXNzKSwgdHJ1ZSlcbiAgICAgICkgfHwgW107XG5cbiAgICAgIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKFxuICAgICAgICB0cmFja1N0cmVhbShyZXNwb25zZS5ib2R5LCBERUZBVUxUX0NIVU5LX1NJWkUsIG9uUHJvZ3Jlc3MsICgpID0+IHtcbiAgICAgICAgICBmbHVzaCAmJiBmbHVzaCgpO1xuICAgICAgICAgIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIHJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZSB8fCAndGV4dCc7XG5cbiAgICBsZXQgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzb2x2ZXJzW3V0aWxzLmZpbmRLZXkocmVzb2x2ZXJzLCByZXNwb25zZVR5cGUpIHx8ICd0ZXh0J10ocmVzcG9uc2UsIGNvbmZpZyk7XG5cbiAgICAhaXNTdHJlYW1SZXNwb25zZSAmJiB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuXG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBoZWFkZXJzOiBBeGlvc0hlYWRlcnMuZnJvbShyZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSlcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuXG4gICAgaWYgKGVyciAmJiBlcnIubmFtZSA9PT0gJ1R5cGVFcnJvcicgJiYgL0xvYWQgZmFpbGVkfGZldGNoL2kudGVzdChlcnIubWVzc2FnZSkpIHtcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIG5ldyBBeGlvc0Vycm9yKCdOZXR3b3JrIEVycm9yJywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0KSxcbiAgICAgICAge1xuICAgICAgICAgIGNhdXNlOiBlcnIuY2F1c2UgfHwgZXJyXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZXJyLCBlcnIgJiYgZXJyLmNvZGUsIGNvbmZpZywgcmVxdWVzdCk7XG4gIH1cbn0pO1xuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/adapters/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../core/settle.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/settle.js\");\n/* harmony import */ var _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defaults/transitional.js */ \"(app-pages-browser)/./node_modules/axios/lib/defaults/transitional.js\");\n/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\");\n/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../cancel/CanceledError.js */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/CanceledError.js\");\n/* harmony import */ var _helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/parseProtocol.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/parseProtocol.js\");\n/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/index.js\");\n/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosHeaders.js\");\n/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/progressEventReducer.js\");\n/* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/resolveConfig.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/resolveConfig.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = (0,_helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(config);\n    let requestData = _config.data;\n    const requestHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].from(_config.headers).normalize();\n    let {responseType, onUploadProgress, onDownloadProgress} = _config;\n    let onCanceled;\n    let uploadThrottled, downloadThrottled;\n    let flushUpload, flushDownload;\n\n    function done() {\n      flushUpload && flushUpload(); // flush events\n      flushDownload && flushDownload(); // flush events\n\n      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);\n\n      _config.signal && _config.signal.removeEventListener('abort', onCanceled);\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('Request aborted', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('Network Error', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ETIMEDOUT : _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      _utils_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!_utils_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (onDownloadProgress) {\n      ([downloadThrottled, flushDownload] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)(onDownloadProgress, true));\n      request.addEventListener('progress', downloadThrottled);\n    }\n\n    // Not all browsers support upload events\n    if (onUploadProgress && request.upload) {\n      ([uploadThrottled, flushUpload] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)(onUploadProgress));\n\n      request.upload.addEventListener('progress', uploadThrottled);\n\n      request.upload.addEventListener('loadend', flushUpload);\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = (0,_helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(_config.url);\n\n    if (protocol && _platform_index_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].protocols.indexOf(protocol) === -1) {\n      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('Unsupported protocol ' + protocol + ':', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ087QUFDc0I7QUFDaEI7QUFDUTtBQUNDO0FBQ1o7QUFDTztBQUNxQjtBQUNoQjs7QUFFeEQ7O0FBRUEsaUVBQWU7QUFDZjtBQUNBLG9CQUFvQixxRUFBYTtBQUNqQztBQUNBLDJCQUEyQiw2REFBWTtBQUN2QyxTQUFTLG9EQUFvRDtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEMsd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2REFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSwyREFBTTtBQUNaO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiwyREFBVSxvQkFBb0IsMkRBQVU7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBVSxrQkFBa0IsMkRBQVU7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUVBQW9CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBVTtBQUMzQjtBQUNBLDJDQUEyQywyREFBVSxhQUFhLDJEQUFVO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0saURBQUs7QUFDWDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLFNBQVMsaURBQUs7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsc0ZBQW9CO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxzRkFBb0I7O0FBRTVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0VBQWE7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHFFQUFhOztBQUVsQyxvQkFBb0IsMERBQVE7QUFDNUIsaUJBQWlCLDJEQUFVLDJDQUEyQywyREFBVTtBQUNoRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxhZGFwdGVyc1xceGhyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBzZXR0bGUgZnJvbSAnLi8uLi9jb3JlL3NldHRsZS5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgcGFyc2VQcm90b2NvbCBmcm9tICcuLi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuaW1wb3J0IHtwcm9ncmVzc0V2ZW50UmVkdWNlcn0gZnJvbSAnLi4vaGVscGVycy9wcm9ncmVzc0V2ZW50UmVkdWNlci5qcyc7XG5pbXBvcnQgcmVzb2x2ZUNvbmZpZyBmcm9tIFwiLi4vaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzXCI7XG5cbmNvbnN0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCAmJiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgY29uc3QgX2NvbmZpZyA9IHJlc29sdmVDb25maWcoY29uZmlnKTtcbiAgICBsZXQgcmVxdWVzdERhdGEgPSBfY29uZmlnLmRhdGE7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShfY29uZmlnLmhlYWRlcnMpLm5vcm1hbGl6ZSgpO1xuICAgIGxldCB7cmVzcG9uc2VUeXBlLCBvblVwbG9hZFByb2dyZXNzLCBvbkRvd25sb2FkUHJvZ3Jlc3N9ID0gX2NvbmZpZztcbiAgICBsZXQgb25DYW5jZWxlZDtcbiAgICBsZXQgdXBsb2FkVGhyb3R0bGVkLCBkb3dubG9hZFRocm90dGxlZDtcbiAgICBsZXQgZmx1c2hVcGxvYWQsIGZsdXNoRG93bmxvYWQ7XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgZmx1c2hVcGxvYWQgJiYgZmx1c2hVcGxvYWQoKTsgLy8gZmx1c2ggZXZlbnRzXG4gICAgICBmbHVzaERvd25sb2FkICYmIGZsdXNoRG93bmxvYWQoKTsgLy8gZmx1c2ggZXZlbnRzXG5cbiAgICAgIF9jb25maWcuY2FuY2VsVG9rZW4gJiYgX2NvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcblxuICAgICAgX2NvbmZpZy5zaWduYWwgJiYgX2NvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICB9XG5cbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgcmVxdWVzdC5vcGVuKF9jb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIF9jb25maWcudXJsLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gX2NvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShcbiAgICAgICAgJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCAmJiByZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICBsZXQgdGltZW91dEVycm9yTWVzc2FnZSA9IF9jb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBfY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnIDogJ3RpbWVvdXQgZXhjZWVkZWQnO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbmFsID0gX2NvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICBpZiAoX2NvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBfY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gQXhpb3NFcnJvci5FVElNRURPVVQgOiBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgcmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCAmJiByZXF1ZXN0SGVhZGVycy5zZXRDb250ZW50VHlwZShudWxsKTtcblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLnRvSlNPTigpLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChfY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFfY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBfY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKG9uRG93bmxvYWRQcm9ncmVzcykge1xuICAgICAgKFtkb3dubG9hZFRocm90dGxlZCwgZmx1c2hEb3dubG9hZF0gPSBwcm9ncmVzc0V2ZW50UmVkdWNlcihvbkRvd25sb2FkUHJvZ3Jlc3MsIHRydWUpKTtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBkb3dubG9hZFRocm90dGxlZCk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAob25VcGxvYWRQcm9ncmVzcyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgKFt1cGxvYWRUaHJvdHRsZWQsIGZsdXNoVXBsb2FkXSA9IHByb2dyZXNzRXZlbnRSZWR1Y2VyKG9uVXBsb2FkUHJvZ3Jlc3MpKTtcblxuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB1cGxvYWRUaHJvdHRsZWQpO1xuXG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZmx1c2hVcGxvYWQpO1xuICAgIH1cblxuICAgIGlmIChfY29uZmlnLmNhbmNlbFRva2VuIHx8IF9jb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxdWVzdCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgX2NvbmZpZy5jYW5jZWxUb2tlbiAmJiBfY29uZmlnLmNhbmNlbFRva2VuLnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIGlmIChfY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBfY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gb25DYW5jZWxlZCgpIDogX2NvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm90b2NvbCA9IHBhcnNlUHJvdG9jb2woX2NvbmZpZy51cmwpO1xuXG4gICAgaWYgKHByb3RvY29sICYmIHBsYXRmb3JtLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJyArIHByb3RvY29sICsgJzonLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhIHx8IG51bGwpO1xuICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/adapters/xhr.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/bind.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/bind.js\");\n/* harmony import */ var _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Axios.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/Axios.js\");\n/* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/mergeConfig.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/mergeConfig.js\");\n/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaults/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/defaults/index.js\");\n/* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./helpers/formDataToJSON.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/formDataToJSON.js\");\n/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cancel/CanceledError.js */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/CanceledError.js\");\n/* harmony import */ var _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cancel/CancelToken.js */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/CancelToken.js\");\n/* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cancel/isCancel.js */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/isCancel.js\");\n/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./env/data.js */ \"(app-pages-browser)/./node_modules/axios/lib/env/data.js\");\n/* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./helpers/toFormData.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/toFormData.js\");\n/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/AxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\");\n/* harmony import */ var _helpers_spread_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./helpers/spread.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/spread.js\");\n/* harmony import */ var _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./helpers/isAxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/isAxiosError.js\");\n/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/AxiosHeaders.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosHeaders.js\");\n/* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./adapters/adapters.js */ \"(app-pages-browser)/./node_modules/axios/lib/adapters/adapters.js\");\n/* harmony import */ var _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./helpers/HttpStatusCode.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/HttpStatusCode.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](defaultConfig);\n  const instance = (0,_helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_core_Axios_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype.request, context);\n\n  // Copy axios.prototype to instance\n  _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].extend(instance, _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance((0,_core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(_defaults_index_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n\n// Expose Cancel & CancelToken\naxios.CanceledError = _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\naxios.CancelToken = _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\naxios.isCancel = _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\naxios.VERSION = _env_data_js__WEBPACK_IMPORTED_MODULE_8__.VERSION;\naxios.toFormData = _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"];\n\n// Expose AxiosError class\naxios.AxiosError = _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"];\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = _helpers_spread_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"];\n\n// Expose isAxiosError\naxios.isAxiosError = _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"];\n\n// Expose mergeConfig\naxios.mergeConfig = _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n\naxios.AxiosHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"];\n\naxios.formToJSON = thing => (0,_helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"].getAdapter;\n\naxios.HttpStatusCode = _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__[\"default\"];\n\naxios.default = axios;\n\n// this module should only have a default export\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axios);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7O0FBRWtCO0FBQ007QUFDRDtBQUNZO0FBQ0w7QUFDYztBQUNIO0FBQ0o7QUFDTjtBQUNOO0FBQ1c7QUFDSDtBQUNMO0FBQ1k7QUFDSDtBQUNKO0FBQ1c7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFLO0FBQzNCLG1CQUFtQiw0REFBSSxDQUFDLHNEQUFLOztBQUU3QjtBQUNBLEVBQUUsaURBQUssa0JBQWtCLHNEQUFLLHNCQUFzQixpQkFBaUI7O0FBRXJFO0FBQ0EsRUFBRSxpREFBSyxrQ0FBa0MsaUJBQWlCOztBQUUxRDtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFXO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsMERBQVE7O0FBRXJDO0FBQ0EsY0FBYyxzREFBSzs7QUFFbkI7QUFDQSxzQkFBc0IsZ0VBQWE7QUFDbkMsb0JBQW9CLDhEQUFXO0FBQy9CLGlCQUFpQiwyREFBUTtBQUN6QixnQkFBZ0IsaURBQU87QUFDdkIsbUJBQW1CLDhEQUFVOztBQUU3QjtBQUNBLG1CQUFtQiw0REFBVTs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLDJEQUFNOztBQUVyQjtBQUNBLHFCQUFxQixpRUFBWTs7QUFFakM7QUFDQSxvQkFBb0IsNERBQVc7O0FBRS9CLHFCQUFxQiw4REFBWTs7QUFFakMsNEJBQTRCLHVFQUFjLENBQUMsaURBQUs7O0FBRWhELG1CQUFtQiw4REFBUTs7QUFFM0IsdUJBQXVCLG1FQUFjOztBQUVyQzs7QUFFQTtBQUNBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxheGlvcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcbmltcG9ydCBBeGlvcyBmcm9tICcuL2NvcmUvQXhpb3MuanMnO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gJy4vY29yZS9tZXJnZUNvbmZpZy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbFRva2VuIGZyb20gJy4vY2FuY2VsL0NhbmNlbFRva2VuLmpzJztcbmltcG9ydCBpc0NhbmNlbCBmcm9tICcuL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4vZW52L2RhdGEuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHNwcmVhZCBmcm9tICcuL2hlbHBlcnMvc3ByZWFkLmpzJztcbmltcG9ydCBpc0F4aW9zRXJyb3IgZnJvbSAnLi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuL2NvcmUvQXhpb3NIZWFkZXJzLmpzXCI7XG5pbXBvcnQgYWRhcHRlcnMgZnJvbSAnLi9hZGFwdGVycy9hZGFwdGVycy5qcyc7XG5pbXBvcnQgSHR0cFN0YXR1c0NvZGUgZnJvbSAnLi9oZWxwZXJzL0h0dHBTdGF0dXNDb2RlLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm5zIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICBjb25zdCBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICBjb25zdCBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0LCB7YWxsT3duS2V5czogdHJ1ZX0pO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQsIG51bGwsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuICBpbnN0YW5jZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgaW5zdGFuY2VDb25maWcpKTtcbiAgfTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxuY29uc3QgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWxlZEVycm9yID0gQ2FuY2VsZWRFcnJvcjtcbmF4aW9zLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG5heGlvcy5pc0NhbmNlbCA9IGlzQ2FuY2VsO1xuYXhpb3MuVkVSU0lPTiA9IFZFUlNJT047XG5heGlvcy50b0Zvcm1EYXRhID0gdG9Gb3JtRGF0YTtcblxuLy8gRXhwb3NlIEF4aW9zRXJyb3IgY2xhc3NcbmF4aW9zLkF4aW9zRXJyb3IgPSBBeGlvc0Vycm9yO1xuXG4vLyBhbGlhcyBmb3IgQ2FuY2VsZWRFcnJvciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuYXhpb3MuQ2FuY2VsID0gYXhpb3MuQ2FuY2VsZWRFcnJvcjtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcblxuYXhpb3Muc3ByZWFkID0gc3ByZWFkO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSBpc0F4aW9zRXJyb3I7XG5cbi8vIEV4cG9zZSBtZXJnZUNvbmZpZ1xuYXhpb3MubWVyZ2VDb25maWcgPSBtZXJnZUNvbmZpZztcblxuYXhpb3MuQXhpb3NIZWFkZXJzID0gQXhpb3NIZWFkZXJzO1xuXG5heGlvcy5mb3JtVG9KU09OID0gdGhpbmcgPT4gZm9ybURhdGFUb0pTT04odXRpbHMuaXNIVE1MRm9ybSh0aGluZykgPyBuZXcgRm9ybURhdGEodGhpbmcpIDogdGhpbmcpO1xuXG5heGlvcy5nZXRBZGFwdGVyID0gYWRhcHRlcnMuZ2V0QWRhcHRlcjtcblxuYXhpb3MuSHR0cFN0YXR1c0NvZGUgPSBIdHRwU3RhdHVzQ29kZTtcblxuYXhpb3MuZGVmYXVsdCA9IGF4aW9zO1xuXG4vLyB0aGlzIG1vZHVsZSBzaG91bGQgb25seSBoYXZlIGEgZGVmYXVsdCBleHBvcnRcbmV4cG9ydCBkZWZhdWx0IGF4aW9zXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/axios.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanceledError.js */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/CanceledError.js\");\n\n\n\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  toAbortSignal() {\n    const controller = new AbortController();\n\n    const abort = (err) => {\n      controller.abort(err);\n    };\n\n    this.subscribe(abort);\n\n    controller.signal.unsubscribe = () => this.unsubscribe(abort);\n\n    return controller.signal;\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CancelToken);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7O0FBRWtDOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHlEQUFhO0FBQ3RDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFdBQVcsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGNhbmNlbFxcQ2FuY2VsVG9rZW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuL0NhbmNlbGVkRXJyb3IuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxUb2tlbn1cbiAqL1xuY2xhc3MgQ2FuY2VsVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG5cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbihjYW5jZWwgPT4ge1xuICAgICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICAgIGxldCBpID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIHRva2VuLl9saXN0ZW5lcnNbaV0oY2FuY2VsKTtcbiAgICAgIH1cbiAgICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbiA9IG9uZnVsZmlsbGVkID0+IHtcbiAgICAgIGxldCBfcmVzb2x2ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRva2VuLnN1YnNjcmliZShyZXNvbHZlKTtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAgICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHRvQWJvcnRTaWduYWwoKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuICAgIGNvbnN0IGFib3J0ID0gKGVycikgPT4ge1xuICAgICAgY29udHJvbGxlci5hYm9ydChlcnIpO1xuICAgIH07XG5cbiAgICB0aGlzLnN1YnNjcmliZShhYm9ydCk7XG5cbiAgICBjb250cm9sbGVyLnNpZ25hbC51bnN1YnNjcmliZSA9ICgpID0+IHRoaXMudW5zdWJzY3JpYmUoYWJvcnQpO1xuXG4gICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAgICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAgICovXG4gIHN0YXRpYyBzb3VyY2UoKSB7XG4gICAgbGV0IGNhbmNlbDtcbiAgICBjb25zdCB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgICBjYW5jZWwgPSBjO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbixcbiAgICAgIGNhbmNlbFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsVG9rZW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/cancel/CancelToken.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n\n\n\n\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].call(this, message == null ? 'canceled' : message, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\n_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inherits(CanceledError, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], {\n  __CANCEL__: true\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanceledError);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7O0FBRWtDO0FBQ2Y7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkRBQVUsb0RBQW9ELDJEQUFVO0FBQzFFO0FBQ0E7O0FBRUEsaURBQUsseUJBQXlCLDJEQUFVO0FBQ3hDO0FBQ0EsQ0FBQzs7QUFFRCxpRUFBZSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxjYW5jZWxcXENhbmNlbGVkRXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBBIGBDYW5jZWxlZEVycm9yYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3Q9fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gcmVxdWVzdCBUaGUgcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJucyB7Q2FuY2VsZWRFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbGVkRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBBeGlvc0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSA9PSBudWxsID8gJ2NhbmNlbGVkJyA6IG1lc3NhZ2UsIEF4aW9zRXJyb3IuRVJSX0NBTkNFTEVELCBjb25maWcsIHJlcXVlc3QpO1xuICB0aGlzLm5hbWUgPSAnQ2FuY2VsZWRFcnJvcic7XG59XG5cbnV0aWxzLmluaGVyaXRzKENhbmNlbGVkRXJyb3IsIEF4aW9zRXJyb3IsIHtcbiAgX19DQU5DRUxfXzogdHJ1ZVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbGVkRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/cancel/CanceledError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isCancel)\n/* harmony export */ });\n\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBYTs7QUFFRTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxjYW5jZWxcXGlzQ2FuY2VsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/cancel/isCancel.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/buildURL.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/buildURL.js\");\n/* harmony import */ var _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InterceptorManager.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/InterceptorManager.js\");\n/* harmony import */ var _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dispatchRequest.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/dispatchRequest.js\");\n/* harmony import */ var _mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mergeConfig.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/mergeConfig.js\");\n/* harmony import */ var _buildFullPath_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./buildFullPath.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/buildFullPath.js\");\n/* harmony import */ var _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/validator.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/validator.js\");\n/* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AxiosHeaders.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosHeaders.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst validators = _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig || {};\n    this.interceptors = {\n      request: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](),\n      response: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy = {};\n\n        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, '') : '';\n        try {\n          if (!err.stack) {\n            err.stack = stack;\n            // match without the 2 top stack lines\n          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, ''))) {\n            err.stack += '\\n' + stack\n          }\n        } catch (e) {\n          // ignore the case where \"stack\" is an un-writable property\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = (0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        }\n      } else {\n        _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assertOptions(paramsSerializer, {\n          encode: validators.function,\n          serialize: validators.function\n        }, true);\n      }\n    }\n\n    // Set config.allowAbsoluteUrls\n    if (config.allowAbsoluteUrls !== undefined) {\n      // do nothing\n    } else if (this.defaults.allowAbsoluteUrls !== undefined) {\n      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;\n    } else {\n      config.allowAbsoluteUrls = true;\n    }\n\n    _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assertOptions(config, {\n      baseUrl: validators.spelling('baseURL'),\n      withXsrfToken: validators.spelling('withXSRFToken')\n    }, true);\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && _utils_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && _utils_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [_dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = (0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.defaults, config);\n    const fullPath = (0,_buildFullPath_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(config.baseURL, config.url, config.allowAbsoluteUrls);\n    return (0,_helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\n_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request((0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\n_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request((0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Axios);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTs7QUFFcUI7QUFDWTtBQUNXO0FBQ047QUFDUjtBQUNJO0FBQ0M7QUFDSDs7QUFFN0MsbUJBQW1CLDZEQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4REFBa0I7QUFDckMsb0JBQW9CLDhEQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLGFBQWEsMkRBQVc7O0FBRXhCLFdBQVcseUNBQXlDOztBQUVwRDtBQUNBLE1BQU0sNkRBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxVQUFVLGlEQUFLO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVEsNkRBQVM7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLElBQUksNkRBQVM7QUFDYjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGlEQUFLO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGlEQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHdEQUFZOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMkRBQWU7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsMkRBQWU7QUFDL0IsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsMkRBQVc7QUFDeEIscUJBQXFCLDZEQUFhO0FBQ2xDLFdBQVcsZ0VBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBLGlEQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QiwyREFBVyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRCxpREFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVcsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVELGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGNvcmVcXEF4aW9zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gJy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IEludGVyY2VwdG9yTWFuYWdlciBmcm9tICcuL0ludGVyY2VwdG9yTWFuYWdlci5qcyc7XG5pbXBvcnQgZGlzcGF0Y2hSZXF1ZXN0IGZyb20gJy4vZGlzcGF0Y2hSZXF1ZXN0LmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4vYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJy4uL2hlbHBlcnMvdmFsaWRhdG9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi9BeGlvc0hlYWRlcnMuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmNsYXNzIEF4aW9zIHtcbiAgY29uc3RydWN0b3IoaW5zdGFuY2VDb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWcgfHwge307XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBsZXQgZHVtbXkgPSB7fTtcblxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGR1bW15KSA6IChkdW1teSA9IG5ldyBFcnJvcigpKTtcblxuICAgICAgICAvLyBzbGljZSBvZmYgdGhlIEVycm9yOiAuLi4gbGluZVxuICAgICAgICBjb25zdCBzdGFjayA9IGR1bW15LnN0YWNrID8gZHVtbXkuc3RhY2sucmVwbGFjZSgvXi4rXFxuLywgJycpIDogJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIGVyci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgLy8gbWF0Y2ggd2l0aG91dCB0aGUgMiB0b3Agc3RhY2sgbGluZXNcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrICYmICFTdHJpbmcoZXJyLnN0YWNrKS5lbmRzV2l0aChzdGFjay5yZXBsYWNlKC9eLitcXG4uK1xcbi8sICcnKSkpIHtcbiAgICAgICAgICAgIGVyci5zdGFjayArPSAnXFxuJyArIHN0YWNrXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaWdub3JlIHRoZSBjYXNlIHdoZXJlIFwic3RhY2tcIiBpcyBhbiB1bi13cml0YWJsZSBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBfcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICAgIGlmICh0eXBlb2YgY29uZmlnT3JVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICBjb25maWcudXJsID0gY29uZmlnT3JVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZ09yVXJsIHx8IHt9O1xuICAgIH1cblxuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICBjb25zdCB7dHJhbnNpdGlvbmFsLCBwYXJhbXNTZXJpYWxpemVyLCBoZWFkZXJzfSA9IGNvbmZpZztcblxuICAgIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICAgIHNpbGVudEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKVxuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXNTZXJpYWxpemVyICE9IG51bGwpIHtcbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcmFtc1NlcmlhbGl6ZXIpKSB7XG4gICAgICAgIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyID0ge1xuICAgICAgICAgIHNlcmlhbGl6ZTogcGFyYW1zU2VyaWFsaXplclxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhwYXJhbXNTZXJpYWxpemVyLCB7XG4gICAgICAgICAgZW5jb2RlOiB2YWxpZGF0b3JzLmZ1bmN0aW9uLFxuICAgICAgICAgIHNlcmlhbGl6ZTogdmFsaWRhdG9ycy5mdW5jdGlvblxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzXG4gICAgaWYgKGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLmFsbG93QWJzb2x1dGVVcmxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyA9IHRoaXMuZGVmYXVsdHMuYWxsb3dBYnNvbHV0ZVVybHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMoY29uZmlnLCB7XG4gICAgICBiYXNlVXJsOiB2YWxpZGF0b3JzLnNwZWxsaW5nKCdiYXNlVVJMJyksXG4gICAgICB3aXRoWHNyZlRva2VuOiB2YWxpZGF0b3JzLnNwZWxsaW5nKCd3aXRoWFNSRlRva2VuJylcbiAgICB9LCB0cnVlKTtcblxuICAgIC8vIFNldCBjb25maWcubWV0aG9kXG4gICAgY29uZmlnLm1ldGhvZCA9IChjb25maWcubWV0aG9kIHx8IHRoaXMuZGVmYXVsdHMubWV0aG9kIHx8ICdnZXQnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gICAgbGV0IGNvbnRleHRIZWFkZXJzID0gaGVhZGVycyAmJiB1dGlscy5tZXJnZShcbiAgICAgIGhlYWRlcnMuY29tbW9uLFxuICAgICAgaGVhZGVyc1tjb25maWcubWV0aG9kXVxuICAgICk7XG5cbiAgICBoZWFkZXJzICYmIHV0aWxzLmZvckVhY2goXG4gICAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICAgIChtZXRob2QpID0+IHtcbiAgICAgICAgZGVsZXRlIGhlYWRlcnNbbWV0aG9kXTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuY29uY2F0KGNvbnRleHRIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgICBjb25zdCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIGxldCBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJvbWlzZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbjtcblxuICAgIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgICBjb25zdCBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QuYmluZCh0aGlzKSwgdW5kZWZpbmVkXTtcbiAgICAgIGNoYWluLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGNoYWluLnB1c2guYXBwbHkoY2hhaW4sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBsZW4gPSBjaGFpbi5sZW5ndGg7XG5cbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbltpKytdLCBjaGFpbltpKytdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgbGVuID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgbGV0IG5ld0NvbmZpZyA9IGNvbmZpZztcblxuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIGNvbnN0IG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIG9uUmVqZWN0ZWQuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0LmNhbGwodGhpcywgbmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBsZW4gPSByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFVyaShjb25maWcpIHtcbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCwgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzKTtcbiAgICByZXR1cm4gYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcbiAgfVxufVxuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBnZW5lcmF0ZUhUVFBNZXRob2QoKTtcblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kICsgJ0Zvcm0nXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCh0cnVlKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/Axios.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n\n\n\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  if (response) {\n    this.response = response;\n    this.status = response.status ? response.status : null;\n  }\n}\n\n_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toJSONObject(this.config),\n      code: this.code,\n      status: this.status\n    };\n  }\n});\n\nconst prototype = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(prototype);\n\n  _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosError);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0Vycm9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7O0FBRW1COztBQUVoQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpREFBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsQ0FBQzs7QUFFRDtBQUNBLGtEQUFrRCxZQUFZOztBQUU5RDtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxpREFBSztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLFVBQVUsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGNvcmVcXEF4aW9zRXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQXhpb3NFcnJvcihtZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gIH1cblxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLm5hbWUgPSAnQXhpb3NFcnJvcic7XG4gIGNvZGUgJiYgKHRoaXMuY29kZSA9IGNvZGUpO1xuICBjb25maWcgJiYgKHRoaXMuY29uZmlnID0gY29uZmlnKTtcbiAgcmVxdWVzdCAmJiAodGhpcy5yZXF1ZXN0ID0gcmVxdWVzdCk7XG4gIGlmIChyZXNwb25zZSkge1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cyA/IHJlc3BvbnNlLnN0YXR1cyA6IG51bGw7XG4gIH1cbn1cblxudXRpbHMuaW5oZXJpdHMoQXhpb3NFcnJvciwgRXJyb3IsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdXRpbHMudG9KU09OT2JqZWN0KHRoaXMuY29uZmlnKSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXNcbiAgICB9O1xuICB9XG59KTtcblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NFcnJvci5wcm90b3R5cGU7XG5jb25zdCBkZXNjcmlwdG9ycyA9IHt9O1xuXG5bXG4gICdFUlJfQkFEX09QVElPTl9WQUxVRScsXG4gICdFUlJfQkFEX09QVElPTicsXG4gICdFQ09OTkFCT1JURUQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VSUl9ORVRXT1JLJyxcbiAgJ0VSUl9GUl9UT09fTUFOWV9SRURJUkVDVFMnLFxuICAnRVJSX0RFUFJFQ0FURUQnLFxuICAnRVJSX0JBRF9SRVNQT05TRScsXG4gICdFUlJfQkFEX1JFUVVFU1QnLFxuICAnRVJSX0NBTkNFTEVEJyxcbiAgJ0VSUl9OT1RfU1VQUE9SVCcsXG4gICdFUlJfSU5WQUxJRF9VUkwnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXS5mb3JFYWNoKGNvZGUgPT4ge1xuICBkZXNjcmlwdG9yc1tjb2RlXSA9IHt2YWx1ZTogY29kZX07XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXhpb3NFcnJvciwgZGVzY3JpcHRvcnMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2lzQXhpb3NFcnJvcicsIHt2YWx1ZTogdHJ1ZX0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuQXhpb3NFcnJvci5mcm9tID0gKGVycm9yLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlLCBjdXN0b21Qcm9wcykgPT4ge1xuICBjb25zdCBheGlvc0Vycm9yID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuXG4gIHV0aWxzLnRvRmxhdE9iamVjdChlcnJvciwgYXhpb3NFcnJvciwgZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IEVycm9yLnByb3RvdHlwZTtcbiAgfSwgcHJvcCA9PiB7XG4gICAgcmV0dXJuIHByb3AgIT09ICdpc0F4aW9zRXJyb3InO1xuICB9KTtcblxuICBBeGlvc0Vycm9yLmNhbGwoYXhpb3NFcnJvciwgZXJyb3IubWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgYXhpb3NFcnJvci5jYXVzZSA9IGVycm9yO1xuXG4gIGF4aW9zRXJyb3IubmFtZSA9IGVycm9yLm5hbWU7XG5cbiAgY3VzdG9tUHJvcHMgJiYgT2JqZWN0LmFzc2lnbihheGlvc0Vycm9yLCBjdXN0b21Qcm9wcyk7XG5cbiAgcmV0dXJuIGF4aW9zRXJyb3I7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc0Vycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/AxiosHeaders.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosHeaders.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/parseHeaders.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/parseHeaders.js\");\n\n\n\n\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(value)) return;\n\n  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders((0,_helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(header), valueOrRewrite);\n    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(header) && _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isIterable(header)) {\n      let obj = {}, dest, key;\n      for (const entry of header) {\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(entry)) {\n          throw TypeError('Object iterator must return a key-value pair');\n        }\n\n        obj[key = entry[0]] = (dest = obj[key]) ?\n          (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];\n      }\n\n      setHeaders(obj, valueOrRewrite)\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].forEach(this, (value, header) => {\n      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  getSetCookie() {\n    return this.get(\"set-cookie\") || [];\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\n_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\n_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].freezeMethods(AxiosHeaders);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosHeaders);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0hlYWRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7O0FBRW1CO0FBQ3NCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxpREFBSztBQUNkOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTSxpREFBSztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU8saURBQUs7O0FBRVosTUFBTSxpREFBSztBQUNYO0FBQ0E7O0FBRUEsTUFBTSxpREFBSztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHVCQUF1QixpREFBSzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlEQUFLOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0saURBQUs7O0FBRVgsUUFBUSxpREFBSztBQUNiO0FBQ0EsTUFBTSxRQUFRLGlEQUFLO0FBQ25CLGlCQUFpQixvRUFBWTtBQUM3QixNQUFNLFNBQVMsaURBQUsscUJBQXFCLGlEQUFLO0FBQzlDLGtCQUFrQjtBQUNsQjtBQUNBLGFBQWEsaURBQUs7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsaURBQUs7QUFDaEI7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaURBQUs7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGlEQUFLO0FBQ2pCO0FBQ0E7O0FBRUEsWUFBWSxpREFBSztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaURBQUs7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpREFBSzs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlEQUFLO0FBQ2I7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksaURBQUs7QUFDVCxrQkFBa0IsaURBQUs7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksaURBQUs7QUFDVCxzRUFBc0UsaURBQUs7QUFDM0UsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpREFBSzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpREFBSyw2Q0FBNkMsTUFBTTtBQUN4RCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpREFBSzs7QUFFTCxpRUFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxjb3JlXFxBeGlvc0hlYWRlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHBhcnNlSGVhZGVycyBmcm9tICcuLi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyc7XG5cbmNvbnN0ICRpbnRlcm5hbHMgPSBTeW1ib2woJ2ludGVybmFscycpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXIoaGVhZGVyKSB7XG4gIHJldHVybiBoZWFkZXIgJiYgU3RyaW5nKGhlYWRlcikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB1dGlscy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChub3JtYWxpemVWYWx1ZSkgOiBTdHJpbmcodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRva2VucyhzdHIpIHtcbiAgY29uc3QgdG9rZW5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgdG9rZW5zUkUgPSAvKFteXFxzLDs9XSspXFxzKig/Oj1cXHMqKFteLDtdKykpPy9nO1xuICBsZXQgbWF0Y2g7XG5cbiAgd2hpbGUgKChtYXRjaCA9IHRva2Vuc1JFLmV4ZWMoc3RyKSkpIHtcbiAgICB0b2tlbnNbbWF0Y2hbMV1dID0gbWF0Y2hbMl07XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5jb25zdCBpc1ZhbGlkSGVhZGVyTmFtZSA9IChzdHIpID0+IC9eWy1fYS16QS1aMC05XmB8fiwhIyQlJicqKy5dKyQvLnRlc3Qoc3RyLnRyaW0oKSk7XG5cbmZ1bmN0aW9uIG1hdGNoSGVhZGVyVmFsdWUoY29udGV4dCwgdmFsdWUsIGhlYWRlciwgZmlsdGVyLCBpc0hlYWRlck5hbWVGaWx0ZXIpIHtcbiAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXIuY2FsbCh0aGlzLCB2YWx1ZSwgaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChpc0hlYWRlck5hbWVGaWx0ZXIpIHtcbiAgICB2YWx1ZSA9IGhlYWRlcjtcbiAgfVxuXG4gIGlmICghdXRpbHMuaXNTdHJpbmcodmFsdWUpKSByZXR1cm47XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKGZpbHRlcikpIHtcbiAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihmaWx0ZXIpICE9PSAtMTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc1JlZ0V4cChmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlci50ZXN0KHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRIZWFkZXIoaGVhZGVyKSB7XG4gIHJldHVybiBoZWFkZXIudHJpbSgpXG4gICAgLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvKFthLXpcXGRdKShcXHcqKS9nLCAodywgY2hhciwgc3RyKSA9PiB7XG4gICAgICByZXR1cm4gY2hhci50b1VwcGVyQ2FzZSgpICsgc3RyO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBidWlsZEFjY2Vzc29ycyhvYmosIGhlYWRlcikge1xuICBjb25zdCBhY2Nlc3Nvck5hbWUgPSB1dGlscy50b0NhbWVsQ2FzZSgnICcgKyBoZWFkZXIpO1xuXG4gIFsnZ2V0JywgJ3NldCcsICdoYXMnXS5mb3JFYWNoKG1ldGhvZE5hbWUgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG1ldGhvZE5hbWUgKyBhY2Nlc3Nvck5hbWUsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIHJldHVybiB0aGlzW21ldGhvZE5hbWVdLmNhbGwodGhpcywgaGVhZGVyLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNsYXNzIEF4aW9zSGVhZGVycyB7XG4gIGNvbnN0cnVjdG9yKGhlYWRlcnMpIHtcbiAgICBoZWFkZXJzICYmIHRoaXMuc2V0KGhlYWRlcnMpO1xuICB9XG5cbiAgc2V0KGhlYWRlciwgdmFsdWVPclJld3JpdGUsIHJld3JpdGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWxIZWFkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZWFkZXIgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHNlbGYsIGxIZWFkZXIpO1xuXG4gICAgICBpZigha2V5IHx8IHNlbGZba2V5XSA9PT0gdW5kZWZpbmVkIHx8IF9yZXdyaXRlID09PSB0cnVlIHx8IChfcmV3cml0ZSA9PT0gdW5kZWZpbmVkICYmIHNlbGZba2V5XSAhPT0gZmFsc2UpKSB7XG4gICAgICAgIHNlbGZba2V5IHx8IF9oZWFkZXJdID0gbm9ybWFsaXplVmFsdWUoX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZXRIZWFkZXJzID0gKGhlYWRlcnMsIF9yZXdyaXRlKSA9PlxuICAgICAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCAoX3ZhbHVlLCBfaGVhZGVyKSA9PiBzZXRIZWFkZXIoX3ZhbHVlLCBfaGVhZGVyLCBfcmV3cml0ZSkpO1xuXG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QoaGVhZGVyKSB8fCBoZWFkZXIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICBzZXRIZWFkZXJzKGhlYWRlciwgdmFsdWVPclJld3JpdGUpXG4gICAgfSBlbHNlIGlmKHV0aWxzLmlzU3RyaW5nKGhlYWRlcikgJiYgKGhlYWRlciA9IGhlYWRlci50cmltKCkpICYmICFpc1ZhbGlkSGVhZGVyTmFtZShoZWFkZXIpKSB7XG4gICAgICBzZXRIZWFkZXJzKHBhcnNlSGVhZGVycyhoZWFkZXIpLCB2YWx1ZU9yUmV3cml0ZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdChoZWFkZXIpICYmIHV0aWxzLmlzSXRlcmFibGUoaGVhZGVyKSkge1xuICAgICAgbGV0IG9iaiA9IHt9LCBkZXN0LCBrZXk7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGhlYWRlcikge1xuICAgICAgICBpZiAoIXV0aWxzLmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdPYmplY3QgaXRlcmF0b3IgbXVzdCByZXR1cm4gYSBrZXktdmFsdWUgcGFpcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqW2tleSA9IGVudHJ5WzBdXSA9IChkZXN0ID0gb2JqW2tleV0pID9cbiAgICAgICAgICAodXRpbHMuaXNBcnJheShkZXN0KSA/IFsuLi5kZXN0LCBlbnRyeVsxXV0gOiBbZGVzdCwgZW50cnlbMV1dKSA6IGVudHJ5WzFdO1xuICAgICAgfVxuXG4gICAgICBzZXRIZWFkZXJzKG9iaiwgdmFsdWVPclJld3JpdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlciAhPSBudWxsICYmIHNldEhlYWRlcih2YWx1ZU9yUmV3cml0ZSwgaGVhZGVyLCByZXdyaXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldChoZWFkZXIsIHBhcnNlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleSh0aGlzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trZXldO1xuXG4gICAgICAgIGlmICghcGFyc2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVRva2Vucyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihwYXJzZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlLCBrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzUmVnRXhwKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmV4ZWModmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyc2VyIG11c3QgYmUgYm9vbGVhbnxyZWdleHB8ZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYXMoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIHJldHVybiAhIShrZXkgJiYgdGhpc1trZXldICE9PSB1bmRlZmluZWQgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUodGhpcywgdGhpc1trZXldLCBrZXksIG1hdGNoZXIpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZGVsZXRlKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBkZWxldGVIZWFkZXIoX2hlYWRlcikge1xuICAgICAgX2hlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKF9oZWFkZXIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShzZWxmLCBfaGVhZGVyKTtcblxuICAgICAgICBpZiAoa2V5ICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHNlbGYsIHNlbGZba2V5XSwga2V5LCBtYXRjaGVyKSkpIHtcbiAgICAgICAgICBkZWxldGUgc2VsZltrZXldO1xuXG4gICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheShoZWFkZXIpKSB7XG4gICAgICBoZWFkZXIuZm9yRWFjaChkZWxldGVIZWFkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVIZWFkZXIoaGVhZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIGNsZWFyKG1hdGNoZXIpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gICAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUodGhpcywgdGhpc1trZXldLCBrZXksIG1hdGNoZXIsIHRydWUpKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgbm9ybWFsaXplKGZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcblxuICAgIHV0aWxzLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoaGVhZGVycywgaGVhZGVyKTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBzZWxmW2tleV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGRlbGV0ZSBzZWxmW2hlYWRlcl07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGZvcm1hdCA/IGZvcm1hdEhlYWRlcihoZWFkZXIpIDogU3RyaW5nKGhlYWRlcikudHJpbSgpO1xuXG4gICAgICBpZiAobm9ybWFsaXplZCAhPT0gaGVhZGVyKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmW2hlYWRlcl07XG4gICAgICB9XG5cbiAgICAgIHNlbGZbbm9ybWFsaXplZF0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25jYXQoLi4udGFyZ2V0cykge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNvbmNhdCh0aGlzLCAuLi50YXJnZXRzKTtcbiAgfVxuXG4gIHRvSlNPTihhc1N0cmluZ3MpIHtcbiAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UgJiYgKG9ialtoZWFkZXJdID0gYXNTdHJpbmdzICYmIHV0aWxzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCAnKSA6IHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSlbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudG9KU09OKCkpLm1hcCgoW2hlYWRlciwgdmFsdWVdKSA9PiBoZWFkZXIgKyAnOiAnICsgdmFsdWUpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZ2V0U2V0Q29va2llKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInNldC1jb29raWVcIikgfHwgW107XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdBeGlvc0hlYWRlcnMnO1xuICB9XG5cbiAgc3RhdGljIGZyb20odGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiB0aGlzID8gdGhpbmcgOiBuZXcgdGhpcyh0aGluZyk7XG4gIH1cblxuICBzdGF0aWMgY29uY2F0KGZpcnN0LCAuLi50YXJnZXRzKSB7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBuZXcgdGhpcyhmaXJzdCk7XG5cbiAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4gY29tcHV0ZWQuc2V0KHRhcmdldCkpO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkO1xuICB9XG5cbiAgc3RhdGljIGFjY2Vzc29yKGhlYWRlcikge1xuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNbJGludGVybmFsc10gPSAodGhpc1skaW50ZXJuYWxzXSA9IHtcbiAgICAgIGFjY2Vzc29yczoge31cbiAgICB9KTtcblxuICAgIGNvbnN0IGFjY2Vzc29ycyA9IGludGVybmFscy5hY2Nlc3NvcnM7XG4gICAgY29uc3QgcHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVBY2Nlc3NvcihfaGVhZGVyKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWFjY2Vzc29yc1tsSGVhZGVyXSkge1xuICAgICAgICBidWlsZEFjY2Vzc29ycyhwcm90b3R5cGUsIF9oZWFkZXIpO1xuICAgICAgICBhY2Nlc3NvcnNbbEhlYWRlcl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzLmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlci5mb3JFYWNoKGRlZmluZUFjY2Vzc29yKSA6IGRlZmluZUFjY2Vzc29yKGhlYWRlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5BeGlvc0hlYWRlcnMuYWNjZXNzb3IoWydDb250ZW50LVR5cGUnLCAnQ29udGVudC1MZW5ndGgnLCAnQWNjZXB0JywgJ0FjY2VwdC1FbmNvZGluZycsICdVc2VyLUFnZW50JywgJ0F1dGhvcml6YXRpb24nXSk7XG5cbi8vIHJlc2VydmVkIG5hbWVzIGhvdGZpeFxudXRpbHMucmVkdWNlRGVzY3JpcHRvcnMoQXhpb3NIZWFkZXJzLnByb3RvdHlwZSwgKHt2YWx1ZX0sIGtleSkgPT4ge1xuICBsZXQgbWFwcGVkID0ga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7IC8vIG1hcCBgc2V0YCA9PiBgU2V0YFxuICByZXR1cm4ge1xuICAgIGdldDogKCkgPT4gdmFsdWUsXG4gICAgc2V0KGhlYWRlclZhbHVlKSB7XG4gICAgICB0aGlzW21hcHBlZF0gPSBoZWFkZXJWYWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG51dGlscy5mcmVlemVNZXRob2RzKEF4aW9zSGVhZGVycyk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zSGVhZGVycztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/AxiosHeaders.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n\n\n\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InterceptorManager);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTs7QUFFcUI7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxJQUFJLGlEQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsaUVBQWUsa0JBQWtCLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxjb3JlXFxJbnRlcmNlcHRvck1hbmFnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgZnVsZmlsbGVkLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbnRlcmNlcHRvciB3YXMgcmVtb3ZlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG4gIGVqZWN0KGlkKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpbnRlcmNlcHRvcnMgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgICBmbihoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcmNlcHRvck1hbmFnZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/InterceptorManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildFullPath)\n/* harmony export */ });\n/* harmony import */ var _helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/isAbsoluteURL.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\n/* harmony import */ var _helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/combineURLs.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/combineURLs.js\");\n\n\n\n\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {\n  let isRelativeUrl = !(0,_helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(requestedURL);\n  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {\n    return (0,_helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFhOztBQUUyQztBQUNKOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNlO0FBQ2YsdUJBQXVCLHFFQUFhO0FBQ3BDO0FBQ0EsV0FBVyxtRUFBVztBQUN0QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxjb3JlXFxidWlsZEZ1bGxQYXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGlzQWJzb2x1dGVVUkwgZnJvbSAnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMLmpzJztcbmltcG9ydCBjb21iaW5lVVJMcyBmcm9tICcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMLCBhbGxvd0Fic29sdXRlVXJscykge1xuICBsZXQgaXNSZWxhdGl2ZVVybCA9ICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCk7XG4gIGlmIChiYXNlVVJMICYmIChpc1JlbGF0aXZlVXJsIHx8IGFsbG93QWJzb2x1dGVVcmxzID09IGZhbHNlKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/buildFullPath.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ dispatchRequest)\n/* harmony export */ });\n/* harmony import */ var _transformData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transformData.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/transformData.js\");\n/* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cancel/isCancel.js */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/isCancel.js\");\n/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defaults/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/defaults/index.js\");\n/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cancel/CanceledError.js */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/CanceledError.js\");\n/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosHeaders.js\");\n/* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../adapters/adapters.js */ \"(app-pages-browser)/./node_modules/axios/lib/adapters/adapters.js\");\n\n\n\n\n\n\n\n\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].from(config.headers);\n\n  // Transform request data\n  config.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getAdapter(config.adapter || _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!(0,_cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFhOztBQUVrQztBQUNGO0FBQ0Q7QUFDVztBQUNKO0FBQ0o7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxnRUFBYTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNlO0FBQ2Y7O0FBRUEsbUJBQW1CLDZEQUFZOztBQUUvQjtBQUNBLGdCQUFnQix5REFBYTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiw2REFBUSw4QkFBOEIsMERBQVE7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IseURBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDZEQUFZOztBQUVuQztBQUNBLEdBQUc7QUFDSCxTQUFTLCtEQUFRO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IseURBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkRBQVk7QUFDOUM7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGNvcmVcXGRpc3BhdGNoUmVxdWVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0cmFuc2Zvcm1EYXRhIGZyb20gJy4vdHJhbnNmb3JtRGF0YS5qcyc7XG5pbXBvcnQgaXNDYW5jZWwgZnJvbSAnLi4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCBhZGFwdGVycyBmcm9tIFwiLi4vYWRhcHRlcnMvYWRhcHRlcnMuanNcIjtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2lnbmFsICYmIGNvbmZpZy5zaWduYWwuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICBjb25maWcuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbmZpZy5oZWFkZXJzKTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIGlmIChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uaW5kZXhPZihjb25maWcubWV0aG9kKSAhPT0gLTEpIHtcbiAgICBjb25maWcuaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgZmFsc2UpO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXIoY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcik7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICByZXNwb25zZVxuICAgICk7XG5cbiAgICByZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/dispatchRequest.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mergeConfig)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxiosHeaders.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosHeaders.js\");\n\n\n\n\n\nconst headersToObject = (thing) => thing instanceof _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, prop, caseless) {\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isPlainObject(target) && _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isPlainObject(source)) {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].merge.call({caseless}, target, source);\n    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isPlainObject(source)) {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].merge({}, source);\n    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, prop , caseless) {\n    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isUndefined(b)) {\n      return getMergedValue(a, b, prop , caseless);\n    } else if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isUndefined(a)) {\n      return getMergedValue(undefined, a, prop , caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)\n  };\n\n  _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTs7QUFFbUI7QUFDYTs7QUFFN0Msb0RBQW9ELHdEQUFZLEtBQUssV0FBVzs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGlEQUFLLDBCQUEwQixpREFBSztBQUM1QyxhQUFhLGlEQUFLLGFBQWEsU0FBUztBQUN4QyxNQUFNLFNBQVMsaURBQUs7QUFDcEIsYUFBYSxpREFBSyxTQUFTO0FBQzNCLE1BQU0sU0FBUyxpREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxpREFBSztBQUNkO0FBQ0EsTUFBTSxVQUFVLGlEQUFLO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxpREFBSztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxpREFBSztBQUNkO0FBQ0EsTUFBTSxVQUFVLGlEQUFLO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxpREFBSyxxQ0FBcUM7QUFDNUM7QUFDQTtBQUNBLEtBQUssaURBQUs7QUFDVixHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxjb3JlXFxtZXJnZUNvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuL0F4aW9zSGVhZGVycy5qc1wiO1xuXG5jb25zdCBoZWFkZXJzVG9PYmplY3QgPSAodGhpbmcpID0+IHRoaW5nIGluc3RhbmNlb2YgQXhpb3NIZWFkZXJzID8geyAuLi50aGluZyB9IDogdGhpbmc7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIGNvbnN0IGNvbmZpZyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlLCBwcm9wLCBjYXNlbGVzcykge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UuY2FsbCh7Y2FzZWxlc3N9LCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMoYSwgYiwgcHJvcCAsIGNhc2VsZXNzKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIsIHByb3AgLCBjYXNlbGVzcyk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEsIHByb3AgLCBjYXNlbGVzcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhhLCBiLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIpO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXJnZU1hcCA9IHtcbiAgICB1cmw6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgbWV0aG9kOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGRhdGE6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgYmFzZVVSTDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHBhcmFtc1NlcmlhbGl6ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0TWVzc2FnZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aFhTUkZUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBhZGFwdGVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlVHlwZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmQ29va2llTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmSGVhZGVyTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvblVwbG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uRG93bmxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBkZWNvbXByZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heENvbnRlbnRMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Qm9keUxlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBiZWZvcmVSZWRpcmVjdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc3BvcnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cEFnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBzQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgY2FuY2VsVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgc29ja2V0UGF0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZUVuY29kaW5nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHZhbGlkYXRlU3RhdHVzOiBtZXJnZURpcmVjdEtleXMsXG4gICAgaGVhZGVyczogKGEsIGIgLCBwcm9wKSA9PiBtZXJnZURlZXBQcm9wZXJ0aWVzKGhlYWRlcnNUb09iamVjdChhKSwgaGVhZGVyc1RvT2JqZWN0KGIpLHByb3AsIHRydWUpXG4gIH07XG5cbiAgdXRpbHMuZm9yRWFjaChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCBjb25maWcxLCBjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBtZXJnZU1hcFtwcm9wXSB8fCBtZXJnZURlZXBQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNvbmZpZ1ZhbHVlID0gbWVyZ2UoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSwgcHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/mergeConfig.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ settle)\n/* harmony export */ });\n/* harmony import */ var _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\");\n\n\n\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n      'Request failed with status code ' + response.status,\n      [_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ERR_BAD_REQUEST, _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTs7QUFFNEI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZUFBZSxzREFBVTtBQUN6QjtBQUNBLE9BQU8sc0RBQVUsa0JBQWtCLHNEQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGNvcmVcXHNldHRsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4vQXhpb3NFcnJvci5qcyc7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIHJlc3BvbnNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICBjb25zdCB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgW0F4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0VdW01hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/settle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ transformData)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../defaults/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/defaults/index.js\");\n/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosHeaders.js\");\n\n\n\n\n\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  const config = this || _defaults_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n  const context = response || config;\n  const headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].from(context.headers);\n  let data = context.data;\n\n  _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBYTs7QUFFcUI7QUFDVTtBQUNPOztBQUVuRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDZTtBQUNmLHlCQUF5QiwwREFBUTtBQUNqQztBQUNBLGtCQUFrQiw2REFBWTtBQUM5Qjs7QUFFQSxFQUFFLGlEQUFLO0FBQ1A7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxjb3JlXFx0cmFuc2Zvcm1EYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcGFyYW0gez9PYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZm5zLCByZXNwb25zZSkge1xuICBjb25zdCBjb25maWcgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICBjb25zdCBjb250ZXh0ID0gcmVzcG9uc2UgfHwgY29uZmlnO1xuICBjb25zdCBoZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29udGV4dC5oZWFkZXJzKTtcbiAgbGV0IGRhdGEgPSBjb250ZXh0LmRhdGE7XG5cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbmZpZywgZGF0YSwgaGVhZGVycy5ub3JtYWxpemUoKSwgcmVzcG9uc2UgPyByZXNwb25zZS5zdGF0dXMgOiB1bmRlZmluZWQpO1xuICB9KTtcblxuICBoZWFkZXJzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/core/transformData.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/AxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\");\n/* harmony import */ var _transitional_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transitional.js */ \"(app-pages-browser)/./node_modules/axios/lib/defaults/transitional.js\");\n/* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/toFormData.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/toFormData.js\");\n/* harmony import */ var _helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/toURLEncodedForm.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/toURLEncodedForm.js\");\n/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/index.js\");\n/* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/formDataToJSON.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/formDataToJSON.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: _transitional_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n\n  adapter: ['xhr', 'http', 'fetch'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(data);\n\n    if (isObjectPayload && _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify((0,_helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(data)) : data;\n    }\n\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArrayBuffer(data) ||\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isBuffer(data) ||\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isStream(data) ||\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFile(data) ||\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isBlob(data) ||\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isReadableStream(data)\n    ) {\n      return data;\n    }\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return (0,_helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return (0,_helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isResponse(data) || _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isReadableStream(data)) {\n      return data;\n    }\n\n    if (data && _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].from(e, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: _platform_index_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].classes.FormData,\n    Blob: _platform_index_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\n_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaults);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBYTs7QUFFbUI7QUFDZTtBQUNNO0FBQ0g7QUFDWTtBQUNsQjtBQUNjOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNLGlEQUFLO0FBQ1g7QUFDQTtBQUNBLGFBQWEsaURBQUs7QUFDbEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0Isd0RBQW9COztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaURBQUs7O0FBRWpDLDJCQUEyQixpREFBSztBQUNoQztBQUNBOztBQUVBLHVCQUF1QixpREFBSzs7QUFFNUI7QUFDQSxpREFBaUQsc0VBQWM7QUFDL0Q7O0FBRUEsUUFBUSxpREFBSztBQUNiLE1BQU0saURBQUs7QUFDWCxNQUFNLGlEQUFLO0FBQ1gsTUFBTSxpREFBSztBQUNYLE1BQU0saURBQUs7QUFDWCxNQUFNLGlEQUFLO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpREFBSztBQUNiO0FBQ0E7QUFDQSxRQUFRLGlEQUFLO0FBQ2IsZ0VBQWdFO0FBQ2hFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsd0VBQWdCO0FBQy9COztBQUVBLHdCQUF3QixpREFBSztBQUM3Qjs7QUFFQSxlQUFlLGtFQUFVO0FBQ3pCLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxpREFBSyxxQkFBcUIsaURBQUs7QUFDdkM7QUFDQTs7QUFFQSxnQkFBZ0IsaURBQUs7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQVUsU0FBUywyREFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsMERBQVE7QUFDdEIsVUFBVSwwREFBUTtBQUNsQixHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVELGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGRlZmF1bHRzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHRyYW5zaXRpb25hbERlZmF1bHRzIGZyb20gJy4vdHJhbnNpdGlvbmFsLmpzJztcbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4uL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgdG9VUkxFbmNvZGVkRm9ybSBmcm9tICcuLi9oZWxwZXJzL3RvVVJMRW5jb2RlZEZvcm0uanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBmb3JtRGF0YVRvSlNPTiBmcm9tICcuLi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzJztcblxuLyoqXG4gKiBJdCB0YWtlcyBhIHN0cmluZywgdHJpZXMgdG8gcGFyc2UgaXQsIGFuZCBpZiBpdCBmYWlscywgaXQgcmV0dXJucyB0aGUgc3RyaW5naWZpZWQgdmVyc2lvblxuICogb2YgdGhlIGlucHV0XG4gKlxuICogQHBhcmFtIHthbnl9IHJhd1ZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHN0cmluZ2lmaWVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyc2VyIC0gQSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBhIHN0cmluZyBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVyIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmFsdWUgYW5kIHJldHVybnMgYSBzdHJpbmcuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmdpZmllZCB2ZXJzaW9uIG9mIHRoZSByYXdWYWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5U2FmZWx5KHJhd1ZhbHVlLCBwYXJzZXIsIGVuY29kZXIpIHtcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJhd1ZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICAocGFyc2VyIHx8IEpTT04ucGFyc2UpKHJhd1ZhbHVlKTtcbiAgICAgIHJldHVybiB1dGlscy50cmltKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lICE9PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChlbmNvZGVyIHx8IEpTT04uc3RyaW5naWZ5KShyYXdWYWx1ZSk7XG59XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuXG4gIHRyYW5zaXRpb25hbDogdHJhbnNpdGlvbmFsRGVmYXVsdHMsXG5cbiAgYWRhcHRlcjogWyd4aHInLCAnaHR0cCcsICdmZXRjaCddLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0Q29udGVudFR5cGUoKSB8fCAnJztcbiAgICBjb25zdCBoYXNKU09OQ29udGVudFR5cGUgPSBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMTtcbiAgICBjb25zdCBpc09iamVjdFBheWxvYWQgPSB1dGlscy5pc09iamVjdChkYXRhKTtcblxuICAgIGlmIChpc09iamVjdFBheWxvYWQgJiYgdXRpbHMuaXNIVE1MRm9ybShkYXRhKSkge1xuICAgICAgZGF0YSA9IG5ldyBGb3JtRGF0YShkYXRhKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0Zvcm1EYXRhID0gdXRpbHMuaXNGb3JtRGF0YShkYXRhKTtcblxuICAgIGlmIChpc0Zvcm1EYXRhKSB7XG4gICAgICByZXR1cm4gaGFzSlNPTkNvbnRlbnRUeXBlID8gSlNPTi5zdHJpbmdpZnkoZm9ybURhdGFUb0pTT04oZGF0YSkpIDogZGF0YTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNSZWFkYWJsZVN0cmVhbShkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04JywgZmFsc2UpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGaWxlTGlzdDtcblxuICAgIGlmIChpc09iamVjdFBheWxvYWQpIHtcbiAgICAgIGlmIChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0b1VSTEVuY29kZWRGb3JtKGRhdGEsIHRoaXMuZm9ybVNlcmlhbGl6ZXIpLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaXNGaWxlTGlzdCA9IHV0aWxzLmlzRmlsZUxpc3QoZGF0YSkpIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ211bHRpcGFydC9mb3JtLWRhdGEnKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IF9Gb3JtRGF0YSA9IHRoaXMuZW52ICYmIHRoaXMuZW52LkZvcm1EYXRhO1xuXG4gICAgICAgIHJldHVybiB0b0Zvcm1EYXRhKFxuICAgICAgICAgIGlzRmlsZUxpc3QgPyB7J2ZpbGVzW10nOiBkYXRhfSA6IGRhdGEsXG4gICAgICAgICAgX0Zvcm1EYXRhICYmIG5ldyBfRm9ybURhdGEoKSxcbiAgICAgICAgICB0aGlzLmZvcm1TZXJpYWxpemVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCB8fCBoYXNKU09OQ29udGVudFR5cGUgKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi9qc29uJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgdHJhbnNpdGlvbmFsID0gdGhpcy50cmFuc2l0aW9uYWwgfHwgZGVmYXVsdHMudHJhbnNpdGlvbmFsO1xuICAgIGNvbnN0IGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICBjb25zdCBKU09OUmVxdWVzdGVkID0gdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmICh1dGlscy5pc1Jlc3BvbnNlKGRhdGEpIHx8IHV0aWxzLmlzUmVhZGFibGVTdHJlYW0oZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmICgoZm9yY2VkSlNPTlBhcnNpbmcgJiYgIXRoaXMucmVzcG9uc2VUeXBlKSB8fCBKU09OUmVxdWVzdGVkKSkge1xuICAgICAgY29uc3Qgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgICAgY29uc3Qgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgSlNPTlJlcXVlc3RlZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0UsIHRoaXMsIG51bGwsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICBlbnY6IHtcbiAgICBGb3JtRGF0YTogcGxhdGZvcm0uY2xhc3Nlcy5Gb3JtRGF0YSxcbiAgICBCbG9iOiBwbGF0Zm9ybS5jbGFzc2VzLkJsb2JcbiAgfSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9LFxuXG4gIGhlYWRlcnM6IHtcbiAgICBjb21tb246IHtcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgKG1ldGhvZCkgPT4ge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0cztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/defaults/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBYTs7QUFFYixpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGRlZmF1bHRzXFx0cmFuc2l0aW9uYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2Vcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/defaults/transitional.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION)\n/* harmony export */ });\nconst VERSION = \"1.9.0\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcYXhpb3NcXGxpYlxcZW52XFxkYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBWRVJTSU9OID0gXCIxLjkuMFwiOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/env/data.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/AxiosURLSearchParams.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFormData.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/toFormData.js\");\n\n\n\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && (0,_toFormData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(params, this, options);\n}\n\nconst prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosURLSearchParams);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhOztBQUU0Qjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLFlBQVksMERBQVU7QUFDdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXEF4aW9zVVJMU2VhcmNoUGFyYW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi90b0Zvcm1EYXRhLmpzJztcblxuLyoqXG4gKiBJdCBlbmNvZGVzIGEgc3RyaW5nIGJ5IHJlcGxhY2luZyBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgaW4gdGhlIHVucmVzZXJ2ZWQgc2V0IHdpdGhcbiAqIHRoZWlyIHBlcmNlbnQtZW5jb2RlZCBlcXVpdmFsZW50c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgY29uc3QgY2hhck1hcCA9IHtcbiAgICAnISc6ICclMjEnLFxuICAgIFwiJ1wiOiAnJTI3JyxcbiAgICAnKCc6ICclMjgnLFxuICAgICcpJzogJyUyOScsXG4gICAgJ34nOiAnJTdFJyxcbiAgICAnJTIwJzogJysnLFxuICAgICclMDAnOiAnXFx4MDAnXG4gIH07XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKX5dfCUyMHwlMDAvZywgZnVuY3Rpb24gcmVwbGFjZXIobWF0Y2gpIHtcbiAgICByZXR1cm4gY2hhck1hcFttYXRjaF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGFyYW1zIG9iamVjdCBhbmQgY29udmVydHMgaXQgdG8gYSBGb3JtRGF0YSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIGJlIGNvbnZlcnRlZCB0byBhIEZvcm1EYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBwYXNzZWQgdG8gdGhlIEF4aW9zIGNvbnN0cnVjdG9yLlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgdGhpcy5fcGFpcnMgPSBbXTtcblxuICBwYXJhbXMgJiYgdG9Gb3JtRGF0YShwYXJhbXMsIHRoaXMsIG9wdGlvbnMpO1xufVxuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc1VSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5fcGFpcnMucHVzaChbbmFtZSwgdmFsdWVdKTtcbn07XG5cbnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGVuY29kZXIpIHtcbiAgY29uc3QgX2VuY29kZSA9IGVuY29kZXIgPyBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBlbmNvZGVyLmNhbGwodGhpcywgdmFsdWUsIGVuY29kZSk7XG4gIH0gOiBlbmNvZGU7XG5cbiAgcmV0dXJuIHRoaXMuX3BhaXJzLm1hcChmdW5jdGlvbiBlYWNoKHBhaXIpIHtcbiAgICByZXR1cm4gX2VuY29kZShwYWlyWzBdKSArICc9JyArIF9lbmNvZGUocGFpclsxXSk7XG4gIH0sICcnKS5qb2luKCcmJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc1VSTFNlYXJjaFBhcmFtcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/HttpStatusCode.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/HttpStatusCode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HttpStatusCode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpRUFBZSxjQUFjLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxoZWxwZXJzXFxIdHRwU3RhdHVzQ29kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBIdHRwU3RhdHVzQ29kZSA9IHtcbiAgQ29udGludWU6IDEwMCxcbiAgU3dpdGNoaW5nUHJvdG9jb2xzOiAxMDEsXG4gIFByb2Nlc3Npbmc6IDEwMixcbiAgRWFybHlIaW50czogMTAzLFxuICBPazogMjAwLFxuICBDcmVhdGVkOiAyMDEsXG4gIEFjY2VwdGVkOiAyMDIsXG4gIE5vbkF1dGhvcml0YXRpdmVJbmZvcm1hdGlvbjogMjAzLFxuICBOb0NvbnRlbnQ6IDIwNCxcbiAgUmVzZXRDb250ZW50OiAyMDUsXG4gIFBhcnRpYWxDb250ZW50OiAyMDYsXG4gIE11bHRpU3RhdHVzOiAyMDcsXG4gIEFscmVhZHlSZXBvcnRlZDogMjA4LFxuICBJbVVzZWQ6IDIyNixcbiAgTXVsdGlwbGVDaG9pY2VzOiAzMDAsXG4gIE1vdmVkUGVybWFuZW50bHk6IDMwMSxcbiAgRm91bmQ6IDMwMixcbiAgU2VlT3RoZXI6IDMwMyxcbiAgTm90TW9kaWZpZWQ6IDMwNCxcbiAgVXNlUHJveHk6IDMwNSxcbiAgVW51c2VkOiAzMDYsXG4gIFRlbXBvcmFyeVJlZGlyZWN0OiAzMDcsXG4gIFBlcm1hbmVudFJlZGlyZWN0OiAzMDgsXG4gIEJhZFJlcXVlc3Q6IDQwMCxcbiAgVW5hdXRob3JpemVkOiA0MDEsXG4gIFBheW1lbnRSZXF1aXJlZDogNDAyLFxuICBGb3JiaWRkZW46IDQwMyxcbiAgTm90Rm91bmQ6IDQwNCxcbiAgTWV0aG9kTm90QWxsb3dlZDogNDA1LFxuICBOb3RBY2NlcHRhYmxlOiA0MDYsXG4gIFByb3h5QXV0aGVudGljYXRpb25SZXF1aXJlZDogNDA3LFxuICBSZXF1ZXN0VGltZW91dDogNDA4LFxuICBDb25mbGljdDogNDA5LFxuICBHb25lOiA0MTAsXG4gIExlbmd0aFJlcXVpcmVkOiA0MTEsXG4gIFByZWNvbmRpdGlvbkZhaWxlZDogNDEyLFxuICBQYXlsb2FkVG9vTGFyZ2U6IDQxMyxcbiAgVXJpVG9vTG9uZzogNDE0LFxuICBVbnN1cHBvcnRlZE1lZGlhVHlwZTogNDE1LFxuICBSYW5nZU5vdFNhdGlzZmlhYmxlOiA0MTYsXG4gIEV4cGVjdGF0aW9uRmFpbGVkOiA0MTcsXG4gIEltQVRlYXBvdDogNDE4LFxuICBNaXNkaXJlY3RlZFJlcXVlc3Q6IDQyMSxcbiAgVW5wcm9jZXNzYWJsZUVudGl0eTogNDIyLFxuICBMb2NrZWQ6IDQyMyxcbiAgRmFpbGVkRGVwZW5kZW5jeTogNDI0LFxuICBUb29FYXJseTogNDI1LFxuICBVcGdyYWRlUmVxdWlyZWQ6IDQyNixcbiAgUHJlY29uZGl0aW9uUmVxdWlyZWQ6IDQyOCxcbiAgVG9vTWFueVJlcXVlc3RzOiA0MjksXG4gIFJlcXVlc3RIZWFkZXJGaWVsZHNUb29MYXJnZTogNDMxLFxuICBVbmF2YWlsYWJsZUZvckxlZ2FsUmVhc29uczogNDUxLFxuICBJbnRlcm5hbFNlcnZlckVycm9yOiA1MDAsXG4gIE5vdEltcGxlbWVudGVkOiA1MDEsXG4gIEJhZEdhdGV3YXk6IDUwMixcbiAgU2VydmljZVVuYXZhaWxhYmxlOiA1MDMsXG4gIEdhdGV3YXlUaW1lb3V0OiA1MDQsXG4gIEh0dHBWZXJzaW9uTm90U3VwcG9ydGVkOiA1MDUsXG4gIFZhcmlhbnRBbHNvTmVnb3RpYXRlczogNTA2LFxuICBJbnN1ZmZpY2llbnRTdG9yYWdlOiA1MDcsXG4gIExvb3BEZXRlY3RlZDogNTA4LFxuICBOb3RFeHRlbmRlZDogNTEwLFxuICBOZXR3b3JrQXV0aGVudGljYXRpb25SZXF1aXJlZDogNTExLFxufTtcblxuT2JqZWN0LmVudHJpZXMoSHR0cFN0YXR1c0NvZGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICBIdHRwU3RhdHVzQ29kZVt2YWx1ZV0gPSBrZXk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgSHR0cFN0YXR1c0NvZGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/HttpStatusCode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ bind)\n/* harmony export */ });\n\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBYTs7QUFFRTtBQUNmO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcYXhpb3NcXGxpYlxcaGVscGVyc1xcYmluZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/bind.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildURL)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/AxiosURLSearchParams.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\");\n\n\n\n\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?(object|Function)} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || encode;\n\n  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(options)) {\n    options = {\n      serialize: options\n    };\n  } \n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isURLSearchParams(params) ?\n      params.toString() :\n      new _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTs7QUFFbUI7QUFDc0M7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLGlEQUFLO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSix1QkFBdUIsaURBQUs7QUFDNUI7QUFDQSxVQUFVLHdFQUFvQjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXGJ1aWxkVVJMLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBmcm9tICcuLi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzJztcblxuLyoqXG4gKiBJdCByZXBsYWNlcyBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjaGFyYWN0ZXJzIGA6YCwgYCRgLCBgLGAsIGArYCwgYFtgLCBhbmQgYF1gIHdpdGggdGhlaXJcbiAqIFVSSSBlbmNvZGVkIGNvdW50ZXJwYXJ0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgVGhlIHZhbHVlIHRvIGJlIGVuY29kZWQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcGFyYW0gez8ob2JqZWN0fEZ1bmN0aW9uKX0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgXG4gIGNvbnN0IF9lbmNvZGUgPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RlIHx8IGVuY29kZTtcblxuICBpZiAodXRpbHMuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzZXJpYWxpemU6IG9wdGlvbnNcbiAgICB9O1xuICB9IFxuXG4gIGNvbnN0IHNlcmlhbGl6ZUZuID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZTtcblxuICBsZXQgc2VyaWFsaXplZFBhcmFtcztcblxuICBpZiAoc2VyaWFsaXplRm4pIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gc2VyaWFsaXplRm4ocGFyYW1zLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gdXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSA/XG4gICAgICBwYXJhbXMudG9TdHJpbmcoKSA6XG4gICAgICBuZXcgQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKS50b1N0cmluZyhfZW5jb2RlKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgY29uc3QgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcblxuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/buildURL.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ combineURLs)\n/* harmony export */ });\n\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxoZWxwZXJzXFxjb21iaW5lVVJMcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8/XFwvJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/combineURLs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/composeSignals.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/composeSignals.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cancel/CanceledError.js */ \"(app-pages-browser)/./node_modules/axios/lib/cancel/CanceledError.js\");\n/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n\n\n\n\nconst composeSignals = (signals, timeout) => {\n  const {length} = (signals = signals ? signals.filter(Boolean) : []);\n\n  if (timeout || length) {\n    let controller = new AbortController();\n\n    let aborted;\n\n    const onabort = function (reason) {\n      if (!aborted) {\n        aborted = true;\n        unsubscribe();\n        const err = reason instanceof Error ? reason : this.reason;\n        controller.abort(err instanceof _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] ? err : new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](err instanceof Error ? err.message : err));\n      }\n    }\n\n    let timer = timeout && setTimeout(() => {\n      timer = null;\n      onabort(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](`timeout ${timeout} of ms exceeded`, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ETIMEDOUT))\n    }, timeout)\n\n    const unsubscribe = () => {\n      if (signals) {\n        timer && clearTimeout(timer);\n        timer = null;\n        signals.forEach(signal => {\n          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);\n        });\n        signals = null;\n      }\n    }\n\n    signals.forEach((signal) => signal.addEventListener('abort', onabort));\n\n    const {signal} = controller;\n\n    signal.unsubscribe = () => _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].asap(unsubscribe);\n\n    return signal;\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (composeSignals);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21wb3NlU2lnbmFscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVEO0FBQ1I7QUFDZjs7QUFFaEM7QUFDQSxTQUFTLFFBQVE7O0FBRWpCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyREFBVSxhQUFhLGdFQUFhO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQiwyREFBVSxZQUFZLFNBQVMsaUJBQWlCLDJEQUFVO0FBQzVFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLFFBQVE7O0FBRW5CLCtCQUErQixpREFBSzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGNBQWMsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXGNvbXBvc2VTaWduYWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gXCIuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qc1wiO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuY29uc3QgY29tcG9zZVNpZ25hbHMgPSAoc2lnbmFscywgdGltZW91dCkgPT4ge1xuICBjb25zdCB7bGVuZ3RofSA9IChzaWduYWxzID0gc2lnbmFscyA/IHNpZ25hbHMuZmlsdGVyKEJvb2xlYW4pIDogW10pO1xuXG4gIGlmICh0aW1lb3V0IHx8IGxlbmd0aCkge1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gICAgbGV0IGFib3J0ZWQ7XG5cbiAgICBjb25zdCBvbmFib3J0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKCFhYm9ydGVkKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBjb25zdCBlcnIgPSByZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IHJlYXNvbiA6IHRoaXMucmVhc29uO1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KGVyciBpbnN0YW5jZW9mIEF4aW9zRXJyb3IgPyBlcnIgOiBuZXcgQ2FuY2VsZWRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogZXJyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHRpbWVyID0gdGltZW91dCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIG9uYWJvcnQobmV3IEF4aW9zRXJyb3IoYHRpbWVvdXQgJHt0aW1lb3V0fSBvZiBtcyBleGNlZWRlZGAsIEF4aW9zRXJyb3IuRVRJTUVET1VUKSlcbiAgICB9LCB0aW1lb3V0KVxuXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICBpZiAoc2lnbmFscykge1xuICAgICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIHNpZ25hbHMuZm9yRWFjaChzaWduYWwgPT4ge1xuICAgICAgICAgIHNpZ25hbC51bnN1YnNjcmliZSA/IHNpZ25hbC51bnN1YnNjcmliZShvbmFib3J0KSA6IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2lnbmFscyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uYWJvcnQpKTtcblxuICAgIGNvbnN0IHtzaWduYWx9ID0gY29udHJvbGxlcjtcblxuICAgIHNpZ25hbC51bnN1YnNjcmliZSA9ICgpID0+IHV0aWxzLmFzYXAodW5zdWJzY3JpYmUpO1xuXG4gICAgcmV0dXJuIHNpZ25hbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlU2lnbmFscztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/composeSignals.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/index.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + '=' + encodeURIComponent(value)];\n\n      _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n\n      _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isString(path) && cookie.push('path=' + path);\n\n      _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isString(domain) && cookie.push('domain=' + domain);\n\n      secure === true && cookie.push('secure');\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrQztBQUNVOztBQUU1QyxpRUFBZSwwREFBUTs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxpREFBSzs7QUFFWCxNQUFNLGlEQUFLOztBQUVYLE1BQU0saURBQUs7O0FBRVg7O0FBRUEsdUNBQXVDO0FBQ3ZDLEtBQUs7O0FBRUw7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxoZWxwZXJzXFxjb29raWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gIHtcbiAgICB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgIGNvbnN0IGNvb2tpZSA9IFtuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKV07XG5cbiAgICAgIHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpICYmIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcblxuICAgICAgdXRpbHMuaXNTdHJpbmcocGF0aCkgJiYgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuXG4gICAgICB1dGlscy5pc1N0cmluZyhkb21haW4pICYmIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG5cbiAgICAgIHNlY3VyZSA9PT0gdHJ1ZSAmJiBjb29raWUucHVzaCgnc2VjdXJlJyk7XG5cbiAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgIH0sXG5cbiAgICByZWFkKG5hbWUpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgfSxcblxuICAgIHJlbW92ZShuYW1lKSB7XG4gICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgIH1cbiAgfVxuXG4gIDpcblxuICAvLyBOb24tc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIHtcbiAgICB3cml0ZSgpIHt9LFxuICAgIHJlYWQoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHJlbW92ZSgpIHt9XG4gIH07XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/cookies.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/formDataToJSON.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/formDataToJSON.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n\n\n\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFormData(formData) && _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(formData.entries)) {\n    const obj = {};\n\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formDataToJSON);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhOztBQUVtQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlEQUFLO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQUs7O0FBRXpCO0FBQ0EsVUFBVSxpREFBSztBQUNmO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsaURBQUs7QUFDL0I7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsaURBQUs7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU0saURBQUsseUJBQXlCLGlEQUFLO0FBQ3pDOztBQUVBLElBQUksaURBQUs7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLGNBQWMsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXGZvcm1EYXRhVG9KU09OLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBJdCB0YWtlcyBhIHN0cmluZyBsaWtlIGBmb29beF1beV1bel1gIGFuZCByZXR1cm5zIGFuIGFycmF5IGxpa2UgYFsnZm9vJywgJ3gnLCAneScsICd6J11cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQcm9wUGF0aChuYW1lKSB7XG4gIC8vIGZvb1t4XVt5XVt6XVxuICAvLyBmb28ueC55LnpcbiAgLy8gZm9vLXgteS16XG4gIC8vIGZvbyB4IHkgelxuICByZXR1cm4gdXRpbHMubWF0Y2hBbGwoL1xcdyt8XFxbKFxcdyopXS9nLCBuYW1lKS5tYXAobWF0Y2ggPT4ge1xuICAgIHJldHVybiBtYXRjaFswXSA9PT0gJ1tdJyA/ICcnIDogbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNvbnZlcnQgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYW5kIHZhbHVlcyBhcyB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJyKTtcbiAgbGV0IGk7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQga2V5O1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIG9ialtrZXldID0gYXJyW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIEZvcm1EYXRhIG9iamVjdCBhbmQgcmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gY29udmVydCB0byBKU09OLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBhbnk+IHwgbnVsbH0gVGhlIGNvbnZlcnRlZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGZvcm1EYXRhVG9KU09OKGZvcm1EYXRhKSB7XG4gIGZ1bmN0aW9uIGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0LCBpbmRleCkge1xuICAgIGxldCBuYW1lID0gcGF0aFtpbmRleCsrXTtcblxuICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykgcmV0dXJuIHRydWU7XG5cbiAgICBjb25zdCBpc051bWVyaWNLZXkgPSBOdW1iZXIuaXNGaW5pdGUoK25hbWUpO1xuICAgIGNvbnN0IGlzTGFzdCA9IGluZGV4ID49IHBhdGgubGVuZ3RoO1xuICAgIG5hbWUgPSAhbmFtZSAmJiB1dGlscy5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQubGVuZ3RoIDogbmFtZTtcblxuICAgIGlmIChpc0xhc3QpIHtcbiAgICAgIGlmICh1dGlscy5oYXNPd25Qcm9wKHRhcmdldCwgbmFtZSkpIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gW3RhcmdldFtuYW1lXSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0W25hbWVdIHx8ICF1dGlscy5pc09iamVjdCh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldFtuYW1lXSwgaW5kZXgpO1xuXG4gICAgaWYgKHJlc3VsdCAmJiB1dGlscy5pc0FycmF5KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IGFycmF5VG9PYmplY3QodGFyZ2V0W25hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc0Zvcm1EYXRhKGZvcm1EYXRhKSAmJiB1dGlscy5pc0Z1bmN0aW9uKGZvcm1EYXRhLmVudHJpZXMpKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoRW50cnkoZm9ybURhdGEsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgYnVpbGRQYXRoKHBhcnNlUHJvcFBhdGgobmFtZSksIHZhbHVlLCBvYmosIDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtRGF0YVRvSlNPTjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/formDataToJSON.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isAbsoluteURL)\n/* harmony export */ });\n\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxoZWxwZXJzXFxpc0Fic29sdXRlVVJMLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/isAbsoluteURL.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isAxiosError)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n\n\n\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(payload) && (payload.isAxiosError === true);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTs7QUFFcUI7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ2U7QUFDZixTQUFTLGlEQUFLO0FBQ2QiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxoZWxwZXJzXFxpc0F4aW9zRXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiB1dGlscy5pc09iamVjdChwYXlsb2FkKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/isAxiosError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/index.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {\n  url = new URL(url, _platform_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].origin);\n\n  return (\n    origin.protocol === url.protocol &&\n    origin.host === url.host &&\n    (isMSIE || origin.port === url.port)\n  );\n})(\n  new URL(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].origin),\n  _platform_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].navigator && /(msie|trident)/i.test(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].navigator.userAgent)\n) : () => true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7O0FBRTVDLGlFQUFlLDBEQUFRO0FBQ3ZCLHFCQUFxQiwwREFBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLDBEQUFRO0FBQ2xCLEVBQUUsMERBQVEscUNBQXFDLDBEQUFRO0FBQ3ZELGNBQWMsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXGlzVVJMU2FtZU9yaWdpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgPyAoKG9yaWdpbiwgaXNNU0lFKSA9PiAodXJsKSA9PiB7XG4gIHVybCA9IG5ldyBVUkwodXJsLCBwbGF0Zm9ybS5vcmlnaW4pO1xuXG4gIHJldHVybiAoXG4gICAgb3JpZ2luLnByb3RvY29sID09PSB1cmwucHJvdG9jb2wgJiZcbiAgICBvcmlnaW4uaG9zdCA9PT0gdXJsLmhvc3QgJiZcbiAgICAoaXNNU0lFIHx8IG9yaWdpbi5wb3J0ID09PSB1cmwucG9ydClcbiAgKTtcbn0pKFxuICBuZXcgVVJMKHBsYXRmb3JtLm9yaWdpbiksXG4gIHBsYXRmb3JtLm5hdmlnYXRvciAmJiAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KHBsYXRmb3JtLm5hdmlnYXRvci51c2VyQWdlbnQpXG4pIDogKCkgPT4gdHJ1ZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/isURLSameOrigin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/null.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/null.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// eslint-disable-next-line strict\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (null);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9udWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGlFQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXG51bGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHN0cmljdFxuZXhwb3J0IGRlZmF1bHQgbnVsbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/null.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n\n\n\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTs7QUFFcUI7O0FBRWxDO0FBQ0E7QUFDQSwwQkFBMEIsaURBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcYXhpb3NcXGxpYlxcaGVscGVyc1xccGFyc2VIZWFkZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vLyBSYXdBeGlvc0hlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG5jb25zdCBpZ25vcmVEdXBsaWNhdGVPZiA9IHV0aWxzLnRvT2JqZWN0U2V0KFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dKTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0hlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHJhd0hlYWRlcnMgPT4ge1xuICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcbiAgbGV0IGk7XG5cbiAgcmF3SGVhZGVycyAmJiByYXdIZWFkZXJzLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IGxpbmUuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IGxpbmUuc3Vic3RyaW5nKGkgKyAxKS50cmltKCk7XG5cbiAgICBpZiAoIWtleSB8fCAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2Zba2V5XSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSkge1xuICAgICAgICBwYXJzZWRba2V5XS5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IFt2YWxdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/parseHeaders.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ parseProtocol)\n/* harmony export */ });\n\n\nfunction parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZVByb3RvY29sLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBYTs7QUFFRTtBQUNmLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxoZWxwZXJzXFxwYXJzZVByb3RvY29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VQcm90b2NvbCh1cmwpIHtcbiAgY29uc3QgbWF0Y2ggPSAvXihbLStcXHddezEsMjV9KSg6P1xcL1xcL3w6KS8uZXhlYyh1cmwpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/parseProtocol.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/progressEventReducer.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/progressEventReducer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asyncDecorator: () => (/* binding */ asyncDecorator),\n/* harmony export */   progressEventDecorator: () => (/* binding */ progressEventDecorator),\n/* harmony export */   progressEventReducer: () => (/* binding */ progressEventReducer)\n/* harmony export */ });\n/* harmony import */ var _speedometer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedometer.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/speedometer.js\");\n/* harmony import */ var _throttle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./throttle.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/throttle.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n\n\n\n\nconst progressEventReducer = (listener, isDownloadStream, freq = 3) => {\n  let bytesNotified = 0;\n  const _speedometer = (0,_speedometer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(50, 250);\n\n  return (0,_throttle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e,\n      lengthComputable: total != null,\n      [isDownloadStream ? 'download' : 'upload']: true\n    };\n\n    listener(data);\n  }, freq);\n}\n\nconst progressEventDecorator = (total, throttled) => {\n  const lengthComputable = total != null;\n\n  return [(loaded) => throttled[0]({\n    lengthComputable,\n    total,\n    loaded\n  }), throttled[1]];\n}\n\nconst asyncDecorator = (fn) => (...args) => _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].asap(() => fn(...args));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wcm9ncmVzc0V2ZW50UmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkM7QUFDTjtBQUNMOztBQUV6QjtBQUNQO0FBQ0EsdUJBQXVCLDJEQUFXOztBQUVsQyxTQUFTLHdEQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPLDRDQUE0QyxpREFBSyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXHByb2dyZXNzRXZlbnRSZWR1Y2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzcGVlZG9tZXRlciBmcm9tIFwiLi9zcGVlZG9tZXRlci5qc1wiO1xuaW1wb3J0IHRocm90dGxlIGZyb20gXCIuL3Rocm90dGxlLmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBwcm9ncmVzc0V2ZW50UmVkdWNlciA9IChsaXN0ZW5lciwgaXNEb3dubG9hZFN0cmVhbSwgZnJlcSA9IDMpID0+IHtcbiAgbGV0IGJ5dGVzTm90aWZpZWQgPSAwO1xuICBjb25zdCBfc3BlZWRvbWV0ZXIgPSBzcGVlZG9tZXRlcig1MCwgMjUwKTtcblxuICByZXR1cm4gdGhyb3R0bGUoZSA9PiB7XG4gICAgY29uc3QgbG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgY29uc3QgdG90YWwgPSBlLmxlbmd0aENvbXB1dGFibGUgPyBlLnRvdGFsIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByb2dyZXNzQnl0ZXMgPSBsb2FkZWQgLSBieXRlc05vdGlmaWVkO1xuICAgIGNvbnN0IHJhdGUgPSBfc3BlZWRvbWV0ZXIocHJvZ3Jlc3NCeXRlcyk7XG4gICAgY29uc3QgaW5SYW5nZSA9IGxvYWRlZCA8PSB0b3RhbDtcblxuICAgIGJ5dGVzTm90aWZpZWQgPSBsb2FkZWQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbG9hZGVkLFxuICAgICAgdG90YWwsXG4gICAgICBwcm9ncmVzczogdG90YWwgPyAobG9hZGVkIC8gdG90YWwpIDogdW5kZWZpbmVkLFxuICAgICAgYnl0ZXM6IHByb2dyZXNzQnl0ZXMsXG4gICAgICByYXRlOiByYXRlID8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGVzdGltYXRlZDogcmF0ZSAmJiB0b3RhbCAmJiBpblJhbmdlID8gKHRvdGFsIC0gbG9hZGVkKSAvIHJhdGUgOiB1bmRlZmluZWQsXG4gICAgICBldmVudDogZSxcbiAgICAgIGxlbmd0aENvbXB1dGFibGU6IHRvdGFsICE9IG51bGwsXG4gICAgICBbaXNEb3dubG9hZFN0cmVhbSA/ICdkb3dubG9hZCcgOiAndXBsb2FkJ106IHRydWVcbiAgICB9O1xuXG4gICAgbGlzdGVuZXIoZGF0YSk7XG4gIH0sIGZyZXEpO1xufVxuXG5leHBvcnQgY29uc3QgcHJvZ3Jlc3NFdmVudERlY29yYXRvciA9ICh0b3RhbCwgdGhyb3R0bGVkKSA9PiB7XG4gIGNvbnN0IGxlbmd0aENvbXB1dGFibGUgPSB0b3RhbCAhPSBudWxsO1xuXG4gIHJldHVybiBbKGxvYWRlZCkgPT4gdGhyb3R0bGVkWzBdKHtcbiAgICBsZW5ndGhDb21wdXRhYmxlLFxuICAgIHRvdGFsLFxuICAgIGxvYWRlZFxuICB9KSwgdGhyb3R0bGVkWzFdXTtcbn1cblxuZXhwb3J0IGNvbnN0IGFzeW5jRGVjb3JhdG9yID0gKGZuKSA9PiAoLi4uYXJncykgPT4gdXRpbHMuYXNhcCgoKSA9PiBmbiguLi5hcmdzKSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/progressEventReducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/resolveConfig.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/resolveConfig.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isURLSameOrigin.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\n/* harmony import */ var _cookies_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cookies.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/cookies.js\");\n/* harmony import */ var _core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/buildFullPath.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/buildFullPath.js\");\n/* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/mergeConfig.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/mergeConfig.js\");\n/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosHeaders.js\");\n/* harmony import */ var _buildURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buildURL.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/buildURL.js\");\n\n\n\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((config) => {\n  const newConfig = (0,_core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, config);\n\n  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;\n\n  newConfig.headers = headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].from(headers);\n\n  newConfig.url = (0,_buildURL_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,_core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);\n\n  // HTTP basic authentication\n  if (auth) {\n    headers.set('Authorization', 'Basic ' +\n      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))\n    );\n  }\n\n  let contentType;\n\n  if (_utils_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isFormData(data)) {\n    if (_platform_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].hasStandardBrowserEnv || _platform_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].hasStandardBrowserWebWorkerEnv) {\n      headers.setContentType(undefined); // Let the browser set it\n    } else if ((contentType = headers.getContentType()) !== false) {\n      // fix semicolon duplication issue for ReactNative FormData implementation\n      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];\n      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));\n    }\n  }\n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we're in a web worker, or react-native.\n\n  if (_platform_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].hasStandardBrowserEnv) {\n    withXSRFToken && _utils_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));\n\n    if (withXSRFToken || (withXSRFToken !== false && (0,_isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(newConfig.url))) {\n      // Add xsrf header\n      const xsrfValue = xsrfHeaderName && xsrfCookieName && _cookies_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].read(xsrfCookieName);\n\n      if (xsrfValue) {\n        headers.set(xsrfHeaderName, xsrfValue);\n      }\n    }\n  }\n\n  return newConfig;\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE0QztBQUNaO0FBQ21CO0FBQ2hCO0FBQ2tCO0FBQ0o7QUFDRTtBQUNkOztBQUVyQyxpRUFBZTtBQUNmLG9CQUFvQixnRUFBVyxHQUFHOztBQUVsQyxPQUFPLG9FQUFvRTs7QUFFM0UsZ0NBQWdDLDZEQUFZOztBQUU1QyxrQkFBa0Isd0RBQVEsQ0FBQyxrRUFBYTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0saURBQUs7QUFDWCxRQUFRLDBEQUFRLDBCQUEwQiwwREFBUTtBQUNsRCx5Q0FBeUM7QUFDekMsTUFBTTtBQUNOO0FBQ0Esa0VBQWtFO0FBQ2xFLGdGQUFnRjtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLDBEQUFRO0FBQ2QscUJBQXFCLGlEQUFLOztBQUUxQixxREFBcUQsK0RBQWU7QUFDcEU7QUFDQSw0REFBNEQsbURBQU87O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcYXhpb3NcXGxpYlxcaGVscGVyc1xccmVzb2x2ZUNvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGxhdGZvcm0gZnJvbSBcIi4uL3BsYXRmb3JtL2luZGV4LmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgaXNVUkxTYW1lT3JpZ2luIGZyb20gXCIuL2lzVVJMU2FtZU9yaWdpbi5qc1wiO1xuaW1wb3J0IGNvb2tpZXMgZnJvbSBcIi4vY29va2llcy5qc1wiO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSBcIi4uL2NvcmUvYnVpbGRGdWxsUGF0aC5qc1wiO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gXCIuLi9jb3JlL21lcmdlQ29uZmlnLmpzXCI7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuLi9jb3JlL0F4aW9zSGVhZGVycy5qc1wiO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gXCIuL2J1aWxkVVJMLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChjb25maWcpID0+IHtcbiAgY29uc3QgbmV3Q29uZmlnID0gbWVyZ2VDb25maWcoe30sIGNvbmZpZyk7XG5cbiAgbGV0IHtkYXRhLCB3aXRoWFNSRlRva2VuLCB4c3JmSGVhZGVyTmFtZSwgeHNyZkNvb2tpZU5hbWUsIGhlYWRlcnMsIGF1dGh9ID0gbmV3Q29uZmlnO1xuXG4gIG5ld0NvbmZpZy5oZWFkZXJzID0gaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGhlYWRlcnMpO1xuXG4gIG5ld0NvbmZpZy51cmwgPSBidWlsZFVSTChidWlsZEZ1bGxQYXRoKG5ld0NvbmZpZy5iYXNlVVJMLCBuZXdDb25maWcudXJsLCBuZXdDb25maWcuYWxsb3dBYnNvbHV0ZVVybHMpLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcik7XG5cbiAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICBpZiAoYXV0aCkge1xuICAgIGhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgK1xuICAgICAgYnRvYSgoYXV0aC51c2VybmFtZSB8fCAnJykgKyAnOicgKyAoYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChhdXRoLnBhc3N3b3JkKSkgOiAnJykpXG4gICAgKTtcbiAgfVxuXG4gIGxldCBjb250ZW50VHlwZTtcblxuICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSkge1xuICAgIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgfHwgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKHVuZGVmaW5lZCk7IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9IGVsc2UgaWYgKChjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0Q29udGVudFR5cGUoKSkgIT09IGZhbHNlKSB7XG4gICAgICAvLyBmaXggc2VtaWNvbG9uIGR1cGxpY2F0aW9uIGlzc3VlIGZvciBSZWFjdE5hdGl2ZSBGb3JtRGF0YSBpbXBsZW1lbnRhdGlvblxuICAgICAgY29uc3QgW3R5cGUsIC4uLnRva2Vuc10gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JykubWFwKHRva2VuID0+IHRva2VuLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKFt0eXBlIHx8ICdtdWx0aXBhcnQvZm9ybS1kYXRhJywgLi4udG9rZW5zXS5qb2luKCc7ICcpKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG5cbiAgaWYgKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudikge1xuICAgIHdpdGhYU1JGVG9rZW4gJiYgdXRpbHMuaXNGdW5jdGlvbih3aXRoWFNSRlRva2VuKSAmJiAod2l0aFhTUkZUb2tlbiA9IHdpdGhYU1JGVG9rZW4obmV3Q29uZmlnKSk7XG5cbiAgICBpZiAod2l0aFhTUkZUb2tlbiB8fCAod2l0aFhTUkZUb2tlbiAhPT0gZmFsc2UgJiYgaXNVUkxTYW1lT3JpZ2luKG5ld0NvbmZpZy51cmwpKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICBjb25zdCB4c3JmVmFsdWUgPSB4c3JmSGVhZGVyTmFtZSAmJiB4c3JmQ29va2llTmFtZSAmJiBjb29raWVzLnJlYWQoeHNyZkNvb2tpZU5hbWUpO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KHhzcmZIZWFkZXJOYW1lLCB4c3JmVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdDb25maWc7XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/resolveConfig.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/speedometer.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/speedometer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (speedometer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcGVlZG9tZXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7O0FBRWI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFdBQVcsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXHNwZWVkb21ldGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGF0YSBtYXhSYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW3NhbXBsZXNDb3VudD0gMTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbj0gMTAwMF1cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gc3BlZWRvbWV0ZXIoc2FtcGxlc0NvdW50LCBtaW4pIHtcbiAgc2FtcGxlc0NvdW50ID0gc2FtcGxlc0NvdW50IHx8IDEwO1xuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBjb25zdCB0aW1lc3RhbXBzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGxldCBoZWFkID0gMDtcbiAgbGV0IHRhaWwgPSAwO1xuICBsZXQgZmlyc3RTYW1wbGVUUztcblxuICBtaW4gPSBtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IDEwMDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1c2goY2h1bmtMZW5ndGgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgY29uc3Qgc3RhcnRlZEF0ID0gdGltZXN0YW1wc1t0YWlsXTtcblxuICAgIGlmICghZmlyc3RTYW1wbGVUUykge1xuICAgICAgZmlyc3RTYW1wbGVUUyA9IG5vdztcbiAgICB9XG5cbiAgICBieXRlc1toZWFkXSA9IGNodW5rTGVuZ3RoO1xuICAgIHRpbWVzdGFtcHNbaGVhZF0gPSBub3c7XG5cbiAgICBsZXQgaSA9IHRhaWw7XG4gICAgbGV0IGJ5dGVzQ291bnQgPSAwO1xuXG4gICAgd2hpbGUgKGkgIT09IGhlYWQpIHtcbiAgICAgIGJ5dGVzQ291bnQgKz0gYnl0ZXNbaSsrXTtcbiAgICAgIGkgPSBpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGhlYWQgPSAoaGVhZCArIDEpICUgc2FtcGxlc0NvdW50O1xuXG4gICAgaWYgKGhlYWQgPT09IHRhaWwpIHtcbiAgICAgIHRhaWwgPSAodGFpbCArIDEpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGlmIChub3cgLSBmaXJzdFNhbXBsZVRTIDwgbWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFzc2VkID0gc3RhcnRlZEF0ICYmIG5vdyAtIHN0YXJ0ZWRBdDtcblxuICAgIHJldHVybiBwYXNzZWQgPyBNYXRoLnJvdW5kKGJ5dGVzQ291bnQgKiAxMDAwIC8gcGFzc2VkKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3BlZWRvbWV0ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/speedometer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ spread)\n/* harmony export */ });\n\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxoZWxwZXJzXFxzcHJlYWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/spread.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/throttle.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/throttle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Throttle decorator\n * @param {Function} fn\n * @param {Number} freq\n * @return {Function}\n */\nfunction throttle(fn, freq) {\n  let timestamp = 0;\n  let threshold = 1000 / freq;\n  let lastArgs;\n  let timer;\n\n  const invoke = (args, now = Date.now()) => {\n    timestamp = now;\n    lastArgs = null;\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    fn.apply(null, args);\n  }\n\n  const throttled = (...args) => {\n    const now = Date.now();\n    const passed = now - timestamp;\n    if ( passed >= threshold) {\n      invoke(args, now);\n    } else {\n      lastArgs = args;\n      if (!timer) {\n        timer = setTimeout(() => {\n          timer = null;\n          invoke(lastArgs)\n        }, threshold - passed);\n      }\n    }\n  }\n\n  const flush = () => lastArgs && invoke(lastArgs);\n\n  return [throttled, flush];\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (throttle);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90aHJvdHRsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXHRocm90dGxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhyb3R0bGUgZGVjb3JhdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IGZyZXFcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmbiwgZnJlcSkge1xuICBsZXQgdGltZXN0YW1wID0gMDtcbiAgbGV0IHRocmVzaG9sZCA9IDEwMDAgLyBmcmVxO1xuICBsZXQgbGFzdEFyZ3M7XG4gIGxldCB0aW1lcjtcblxuICBjb25zdCBpbnZva2UgPSAoYXJncywgbm93ID0gRGF0ZS5ub3coKSkgPT4ge1xuICAgIHRpbWVzdGFtcCA9IG5vdztcbiAgICBsYXN0QXJncyA9IG51bGw7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgfVxuXG4gIGNvbnN0IHRocm90dGxlZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBwYXNzZWQgPSBub3cgLSB0aW1lc3RhbXA7XG4gICAgaWYgKCBwYXNzZWQgPj0gdGhyZXNob2xkKSB7XG4gICAgICBpbnZva2UoYXJncywgbm93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgICAgaWYgKCF0aW1lcikge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICBpbnZva2UobGFzdEFyZ3MpXG4gICAgICAgIH0sIHRocmVzaG9sZCAtIHBhc3NlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZmx1c2ggPSAoKSA9PiBsYXN0QXJncyAmJiBpbnZva2UobGFzdEFyZ3MpO1xuXG4gIHJldHVybiBbdGhyb3R0bGVkLCBmbHVzaF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRocm90dGxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/throttle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\");\n/* harmony import */ var _platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/node/classes/FormData.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/null.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\n\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isPlainObject(thing) || _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toFlatObject(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (_platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isSpecCompliantForm(formData);\n\n  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isBlob(value)) {\n      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArrayBuffer(value) || _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isArray(value) && isFlatArray(value)) ||\n        ((_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isFileList(value) || _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].endsWith(key, '[]')) && (arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].forEach(value, function each(el, key) {\n      const result = !(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isUndefined(el) || el === null) && visitor.call(\n        formData, el, _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toFormData);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90b0Zvcm1EYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7O0FBRW1CO0FBQ2U7QUFDL0M7QUFDb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUyxpREFBSyx5QkFBeUIsaURBQUs7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTLGlEQUFLO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTLGlEQUFLO0FBQ2Q7O0FBRUEsbUJBQW1CLGlEQUFLLGNBQWMsaURBQUssSUFBSTtBQUMvQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8saURBQUs7QUFDWjtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDBFQUFnQjs7QUFFOUM7QUFDQSxZQUFZLGlEQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksaURBQUs7QUFDakIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQUs7O0FBRWhDLE9BQU8saURBQUs7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUSxpREFBSztBQUNiO0FBQ0E7O0FBRUEsb0JBQW9CLGlEQUFLO0FBQ3pCLGdCQUFnQiwyREFBVTtBQUMxQjs7QUFFQSxRQUFRLGlEQUFLLHlCQUF5QixpREFBSztBQUMzQyx5RUFBeUUsTUFBTTtBQUMvRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxzQkFBc0I7QUFDbkMsWUFBWTtBQUNaO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsaURBQUssa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFNBQVMsaURBQUs7QUFDZCxVQUFVLGlEQUFLLHNCQUFzQixpREFBSyxnQ0FBZ0MsaURBQUs7QUFDL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxpREFBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsUUFBUSxpREFBSzs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSSxpREFBSztBQUNULHVCQUF1QixpREFBSztBQUM1QixzQkFBc0IsaURBQUs7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLE9BQU8saURBQUs7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcYXhpb3NcXGxpYlxcaGVscGVyc1xcdG9Gb3JtRGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuLy8gdGVtcG9yYXJ5IGhvdGZpeCB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIHVudGlsIEF4aW9zVVJMU2VhcmNoUGFyYW1zIGlzIHJlZmFjdG9yZWRcbmltcG9ydCBQbGF0Zm9ybUZvcm1EYXRhIGZyb20gJy4uL3BsYXRmb3JtL25vZGUvY2xhc3Nlcy9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gdGhpbmcgaXMgYSBhcnJheSBvciBqcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRoaW5nIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSB2aXNpdGVkLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Zpc2l0YWJsZSh0aGluZykge1xuICByZXR1cm4gdXRpbHMuaXNQbGFpbk9iamVjdCh0aGluZykgfHwgdXRpbHMuaXNBcnJheSh0aGluZyk7XG59XG5cbi8qKlxuICogSXQgcmVtb3ZlcyB0aGUgYnJhY2tldHMgZnJvbSB0aGUgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmFtZXRlci5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUga2V5IHdpdGhvdXQgdGhlIGJyYWNrZXRzLlxuICovXG5mdW5jdGlvbiByZW1vdmVCcmFja2V0cyhrZXkpIHtcbiAgcmV0dXJuIHV0aWxzLmVuZHNXaXRoKGtleSwgJ1tdJykgPyBrZXkuc2xpY2UoMCwgLTIpIDoga2V5O1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGF0aCwgYSBrZXksIGFuZCBhIGJvb2xlYW4sIGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgY3VycmVudCBvYmplY3QgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkb3RzIC0gSWYgdHJ1ZSwgdGhlIGtleSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggZG90cyBpbnN0ZWFkIG9mIGJyYWNrZXRzLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IGtleS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cykge1xuICBpZiAoIXBhdGgpIHJldHVybiBrZXk7XG4gIHJldHVybiBwYXRoLmNvbmNhdChrZXkpLm1hcChmdW5jdGlvbiBlYWNoKHRva2VuLCBpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdG9rZW4gPSByZW1vdmVCcmFja2V0cyh0b2tlbik7XG4gICAgcmV0dXJuICFkb3RzICYmIGkgPyAnWycgKyB0b2tlbiArICddJyA6IHRva2VuO1xuICB9KS5qb2luKGRvdHMgPyAnLicgOiAnJyk7XG59XG5cbi8qKlxuICogSWYgdGhlIGFycmF5IGlzIGFuIGFycmF5IGFuZCBub25lIG9mIGl0cyBlbGVtZW50cyBhcmUgdmlzaXRhYmxlLCB0aGVuIGl0J3MgYSBmbGF0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmxhdEFycmF5KGFycikge1xuICByZXR1cm4gdXRpbHMuaXNBcnJheShhcnIpICYmICFhcnIuc29tZShpc1Zpc2l0YWJsZSk7XG59XG5cbmNvbnN0IHByZWRpY2F0ZXMgPSB1dGlscy50b0ZsYXRPYmplY3QodXRpbHMsIHt9LCBudWxsLCBmdW5jdGlvbiBmaWx0ZXIocHJvcCkge1xuICByZXR1cm4gL15pc1tBLVpdLy50ZXN0KHByb3ApO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIGRhdGEgb2JqZWN0IHRvIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHs/T2JqZWN0fSBbZm9ybURhdGFdXG4gKiBAcGFyYW0gez9PYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmlzaXRvcl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWV0YVRva2VucyA9IHRydWVdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvdHMgPSBmYWxzZV1cbiAqIEBwYXJhbSB7P0Jvb2xlYW59IFtvcHRpb25zLmluZGV4ZXMgPSBmYWxzZV1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICoqL1xuXG4vKipcbiAqIEl0IGNvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gZm9ybSBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIC0gVGhlIEZvcm1EYXRhIG9iamVjdCB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB0b0Zvcm1EYXRhKG9iaiwgZm9ybURhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZm9ybURhdGEgPSBmb3JtRGF0YSB8fCBuZXcgKFBsYXRmb3JtRm9ybURhdGEgfHwgRm9ybURhdGEpKCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIG9wdGlvbnMgPSB1dGlscy50b0ZsYXRPYmplY3Qob3B0aW9ucywge1xuICAgIG1ldGFUb2tlbnM6IHRydWUsXG4gICAgZG90czogZmFsc2UsXG4gICAgaW5kZXhlczogZmFsc2VcbiAgfSwgZmFsc2UsIGZ1bmN0aW9uIGRlZmluZWQob3B0aW9uLCBzb3VyY2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICByZXR1cm4gIXV0aWxzLmlzVW5kZWZpbmVkKHNvdXJjZVtvcHRpb25dKTtcbiAgfSk7XG5cbiAgY29uc3QgbWV0YVRva2VucyA9IG9wdGlvbnMubWV0YVRva2VucztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGNvbnN0IHZpc2l0b3IgPSBvcHRpb25zLnZpc2l0b3IgfHwgZGVmYXVsdFZpc2l0b3I7XG4gIGNvbnN0IGRvdHMgPSBvcHRpb25zLmRvdHM7XG4gIGNvbnN0IGluZGV4ZXMgPSBvcHRpb25zLmluZGV4ZXM7XG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucy5CbG9iIHx8IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBCbG9iO1xuICBjb25zdCB1c2VCbG9iID0gX0Jsb2IgJiYgdXRpbHMuaXNTcGVjQ29tcGxpYW50Rm9ybShmb3JtRGF0YSk7XG5cbiAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uKHZpc2l0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmlzaXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgaWYgKHV0aWxzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghdXNlQmxvYiAmJiB1dGlscy5pc0Jsb2IodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignQmxvYiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYSBCdWZmZXIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHwgdXRpbHMuaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHVzZUJsb2IgJiYgdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgPyBuZXcgQmxvYihbdmFsdWVdKSA6IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCB2aXNpdG9yLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5XG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nfE51bWJlcj59IHBhdGhcbiAgICogQHRoaXMge0Zvcm1EYXRhfVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgdG8gdmlzaXQgdGhlIGVhY2ggcHJvcCBvZiB0aGUgdmFsdWUgcmVjdXJzaXZlbHlcbiAgICovXG4gIGZ1bmN0aW9uIGRlZmF1bHRWaXNpdG9yKHZhbHVlLCBrZXksIHBhdGgpIHtcbiAgICBsZXQgYXJyID0gdmFsdWU7XG5cbiAgICBpZiAodmFsdWUgJiYgIXBhdGggJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHV0aWxzLmVuZHNXaXRoKGtleSwgJ3t9JykpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IG1ldGFUb2tlbnMgPyBrZXkgOiBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAodXRpbHMuaXNBcnJheSh2YWx1ZSkgJiYgaXNGbGF0QXJyYXkodmFsdWUpKSB8fFxuICAgICAgICAoKHV0aWxzLmlzRmlsZUxpc3QodmFsdWUpIHx8IHV0aWxzLmVuZHNXaXRoKGtleSwgJ1tdJykpICYmIChhcnIgPSB1dGlscy50b0FycmF5KHZhbHVlKSlcbiAgICAgICAgKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gcmVtb3ZlQnJhY2tldHMoa2V5KTtcblxuICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiBlYWNoKGVsLCBpbmRleCkge1xuICAgICAgICAgICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIGluZGV4ZXMgPT09IHRydWUgPyByZW5kZXJLZXkoW2tleV0sIGluZGV4LCBkb3RzKSA6IChpbmRleGVzID09PSBudWxsID8ga2V5IDoga2V5ICsgJ1tdJyksXG4gICAgICAgICAgICBjb252ZXJ0VmFsdWUoZWwpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNWaXNpdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3JtRGF0YS5hcHBlbmQocmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cyksIGNvbnZlcnRWYWx1ZSh2YWx1ZSkpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICBjb25zdCBleHBvc2VkSGVscGVycyA9IE9iamVjdC5hc3NpZ24ocHJlZGljYXRlcywge1xuICAgIGRlZmF1bHRWaXNpdG9yLFxuICAgIGNvbnZlcnRWYWx1ZSxcbiAgICBpc1Zpc2l0YWJsZVxuICB9KTtcblxuICBmdW5jdGlvbiBidWlsZCh2YWx1ZSwgcGF0aCkge1xuICAgIGlmICh1dGlscy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHJldHVybjtcblxuICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQgaW4gJyArIHBhdGguam9pbignLicpKTtcbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbHVlKTtcblxuICAgIHV0aWxzLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uIGVhY2goZWwsIGtleSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gISh1dGlscy5pc1VuZGVmaW5lZChlbCkgfHwgZWwgPT09IG51bGwpICYmIHZpc2l0b3IuY2FsbChcbiAgICAgICAgZm9ybURhdGEsIGVsLCB1dGlscy5pc1N0cmluZyhrZXkpID8ga2V5LnRyaW0oKSA6IGtleSwgcGF0aCwgZXhwb3NlZEhlbHBlcnNcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgYnVpbGQoZWwsIHBhdGggPyBwYXRoLmNvbmNhdChrZXkpIDogW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICBidWlsZChvYmopO1xuXG4gIHJldHVybiBmb3JtRGF0YTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Gb3JtRGF0YTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/toFormData.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/toURLEncodedForm.js":
/*!************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toURLEncodedForm.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ toURLEncodedForm)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/utils.js\");\n/* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFormData.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/toFormData.js\");\n/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/index.js\");\n\n\n\n\n\n\nfunction toURLEncodedForm(data, options) {\n  return (0,_toFormData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(data, new _platform_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (_platform_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isNode && _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90b1VSTEVuY29kZWRGb3JtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBYTs7QUFFbUI7QUFDUztBQUNHOztBQUU3QjtBQUNmLFNBQVMsMERBQVUsV0FBVywwREFBUTtBQUN0QztBQUNBLFVBQVUsMERBQVEsV0FBVyxpREFBSztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXHRvVVJMRW5jb2RlZEZvcm0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Gb3JtRGF0YShkYXRhLCBuZXcgcGxhdGZvcm0uY2xhc3Nlcy5VUkxTZWFyY2hQYXJhbXMoKSwgT2JqZWN0LmFzc2lnbih7XG4gICAgdmlzaXRvcjogZnVuY3Rpb24odmFsdWUsIGtleSwgcGF0aCwgaGVscGVycykge1xuICAgICAgaWYgKHBsYXRmb3JtLmlzTm9kZSAmJiB1dGlscy5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWxwZXJzLmRlZmF1bHRWaXNpdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCBvcHRpb25zKSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/toURLEncodedForm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/trackStream.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/trackStream.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   readBytes: () => (/* binding */ readBytes),\n/* harmony export */   streamChunk: () => (/* binding */ streamChunk),\n/* harmony export */   trackStream: () => (/* binding */ trackStream)\n/* harmony export */ });\n\nconst streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n}\n\nconst readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n}\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n}\n\nconst trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  }\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90cmFja1N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcYXhpb3NcXGxpYlxcaGVscGVyc1xcdHJhY2tTdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5leHBvcnQgY29uc3Qgc3RyZWFtQ2h1bmsgPSBmdW5jdGlvbiogKGNodW5rLCBjaHVua1NpemUpIHtcbiAgbGV0IGxlbiA9IGNodW5rLmJ5dGVMZW5ndGg7XG5cbiAgaWYgKCFjaHVua1NpemUgfHwgbGVuIDwgY2h1bmtTaXplKSB7XG4gICAgeWllbGQgY2h1bms7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBlbmQ7XG5cbiAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgIGVuZCA9IHBvcyArIGNodW5rU2l6ZTtcbiAgICB5aWVsZCBjaHVuay5zbGljZShwb3MsIGVuZCk7XG4gICAgcG9zID0gZW5kO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZWFkQnl0ZXMgPSBhc3luYyBmdW5jdGlvbiogKGl0ZXJhYmxlLCBjaHVua1NpemUpIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZWFkU3RyZWFtKGl0ZXJhYmxlKSkge1xuICAgIHlpZWxkKiBzdHJlYW1DaHVuayhjaHVuaywgY2h1bmtTaXplKTtcbiAgfVxufVxuXG5jb25zdCByZWFkU3RyZWFtID0gYXN5bmMgZnVuY3Rpb24qIChzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICB5aWVsZCogc3RyZWFtO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgdHJ5IHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCB7ZG9uZSwgdmFsdWV9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdHJhY2tTdHJlYW0gPSAoc3RyZWFtLCBjaHVua1NpemUsIG9uUHJvZ3Jlc3MsIG9uRmluaXNoKSA9PiB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gcmVhZEJ5dGVzKHN0cmVhbSwgY2h1bmtTaXplKTtcblxuICBsZXQgYnl0ZXMgPSAwO1xuICBsZXQgZG9uZTtcbiAgbGV0IF9vbkZpbmlzaCA9IChlKSA9PiB7XG4gICAgaWYgKCFkb25lKSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIG9uRmluaXNoICYmIG9uRmluaXNoKGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgX29uRmluaXNoKCk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgIGxldCBsb2FkZWRCeXRlcyA9IGJ5dGVzICs9IGxlbjtcbiAgICAgICAgICBvblByb2dyZXNzKGxvYWRlZEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfb25GaW5pc2goZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsKHJlYXNvbikge1xuICAgICAgX29uRmluaXNoKHJlYXNvbik7XG4gICAgICByZXR1cm4gaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgfVxuICB9LCB7XG4gICAgaGlnaFdhdGVyTWFyazogMlxuICB9KVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/trackStream.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env/data.js */ \"(app-pages-browser)/./node_modules/axios/lib/env/data.js\");\n/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosError.js */ \"(app-pages-browser)/./node_modules/axios/lib/core/AxiosError.js\");\n\n\n\n\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + _env_data_js__WEBPACK_IMPORTED_MODULE_0__.VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\nvalidators.spelling = function spelling(correctSpelling) {\n  return (value, opt) => {\n    // eslint-disable-next-line no-console\n    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);\n    return true;\n  }\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('options must be an object', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('option ' + opt + ' must be ' + result, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Unknown option ' + opt, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ERR_BAD_OPTION);\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  assertOptions,\n  validators\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7O0FBRTBCO0FBQ1E7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFPO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBVTtBQUMxQjtBQUNBLFFBQVEsMkRBQVU7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUssNkJBQTZCLGdCQUFnQjtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMkRBQVUsOEJBQThCLDJEQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFVLHlDQUF5QywyREFBVTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBVSwwQkFBMEIsMkRBQVU7QUFDOUQ7QUFDQTtBQUNBOztBQUVBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBLENBQUMsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXGhlbHBlcnNcXHZhbGlkYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi4vZW52L2RhdGEuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcblxuY29uc3QgdmFsaWRhdG9ycyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnZnVuY3Rpb24nLCAnc3RyaW5nJywgJ3N5bWJvbCddLmZvckVhY2goKHR5cGUsIGkpID0+IHtcbiAgdmFsaWRhdG9yc1t0eXBlXSA9IGZ1bmN0aW9uIHZhbGlkYXRvcih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IHR5cGUgfHwgJ2EnICsgKGkgPCAxID8gJ24gJyA6ICcgJykgKyB0eXBlO1xuICB9O1xufSk7XG5cbmNvbnN0IGRlcHJlY2F0ZWRXYXJuaW5ncyA9IHt9O1xuXG4vKipcbiAqIFRyYW5zaXRpb25hbCBvcHRpb24gdmFsaWRhdG9yXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbnxib29sZWFuP30gdmFsaWRhdG9yIC0gc2V0IHRvIGZhbHNlIGlmIHRoZSB0cmFuc2l0aW9uYWwgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWRcbiAqIEBwYXJhbSB7c3RyaW5nP30gdmVyc2lvbiAtIGRlcHJlY2F0ZWQgdmVyc2lvbiAvIHJlbW92ZWQgc2luY2UgdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmc/fSBtZXNzYWdlIC0gc29tZSBtZXNzYWdlIHdpdGggYWRkaXRpb25hbCBpbmZvXG4gKlxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICovXG52YWxpZGF0b3JzLnRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25hbCh2YWxpZGF0b3IsIHZlcnNpb24sIG1lc3NhZ2UpIHtcbiAgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShvcHQsIGRlc2MpIHtcbiAgICByZXR1cm4gJ1tBeGlvcyB2JyArIFZFUlNJT04gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuICh2YWx1ZSwgb3B0LCBvcHRzKSA9PiB7XG4gICAgaWYgKHZhbGlkYXRvciA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKG9wdCwgJyBoYXMgYmVlbiByZW1vdmVkJyArICh2ZXJzaW9uID8gJyBpbiAnICsgdmVyc2lvbiA6ICcnKSksXG4gICAgICAgIEF4aW9zRXJyb3IuRVJSX0RFUFJFQ0FURURcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gJiYgIWRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdKSB7XG4gICAgICBkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSA9IHRydWU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBmb3JtYXRNZXNzYWdlKFxuICAgICAgICAgIG9wdCxcbiAgICAgICAgICAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdicgKyB2ZXJzaW9uICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZWFyIGZ1dHVyZSdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yID8gdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdHMpIDogdHJ1ZTtcbiAgfTtcbn07XG5cbnZhbGlkYXRvcnMuc3BlbGxpbmcgPSBmdW5jdGlvbiBzcGVsbGluZyhjb3JyZWN0U3BlbGxpbmcpIHtcbiAgcmV0dXJuICh2YWx1ZSwgb3B0KSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oYCR7b3B0fSBpcyBsaWtlbHkgYSBtaXNzcGVsbGluZyBvZiAke2NvcnJlY3RTcGVsbGluZ31gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBBc3NlcnQgb2JqZWN0J3MgcHJvcGVydGllcyB0eXBlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGFsbG93VW5rbm93blxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIGFsbG93VW5rbm93bikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnLCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgY29uc3Qgb3B0ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9uICcgKyBvcHQgKyAnIG11c3QgYmUgJyArIHJlc3VsdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93VW5rbm93biAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ1Vua25vd24gb3B0aW9uICcgKyBvcHQsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT04pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnNcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/helpers/validator.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/platform/browser/classes/Blob.js":
/*!*****************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/Blob.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof Blob !== 'undefined' ? Blob : null);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL0Jsb2IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFZOztBQUVaLGlFQUFlLHlDQUF5QyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXHBsYXRmb3JtXFxicm93c2VyXFxjbGFzc2VzXFxCbG9iLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iIDogbnVsbFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/platform/browser/classes/Blob.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/platform/browser/classes/FormData.js":
/*!*********************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/FormData.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof FormData !== 'undefined' ? FormData : null);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL0Zvcm1EYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBYTs7QUFFYixpRUFBZSxpREFBaUQsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGF4aW9zXFxsaWJcXHBsYXRmb3JtXFxicm93c2VyXFxjbGFzc2VzXFxGb3JtRGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBGb3JtRGF0YSA6IG51bGw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/platform/browser/classes/FormData.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../helpers/AxiosURLSearchParams.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhOztBQUUrRDtBQUM1RSxpRUFBZSwyREFBMkQsd0VBQW9CLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxwbGF0Zm9ybVxcYnJvd3NlclxcY2xhc3Nlc1xcVVJMU2VhcmNoUGFyYW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4uLy4uLy4uL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMnO1xuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgPyBVUkxTZWFyY2hQYXJhbXMgOiBBeGlvc1VSTFNlYXJjaFBhcmFtcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/platform/browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes/URLSearchParams.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js\");\n/* harmony import */ var _classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/FormData.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/browser/classes/FormData.js\");\n/* harmony import */ var _classes_Blob_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/Blob.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/browser/classes/Blob.js\");\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  isBrowser: true,\n  classes: {\n    URLSearchParams: _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    FormData: _classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    Blob: _classes_Blob_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBEO0FBQ2Q7QUFDUjs7QUFFcEMsaUVBQWU7QUFDZjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFlBQVk7QUFDWixRQUFRO0FBQ1IsR0FBRztBQUNIO0FBQ0EsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcYXhpb3NcXGxpYlxccGxhdGZvcm1cXGJyb3dzZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcydcbmltcG9ydCBGb3JtRGF0YSBmcm9tICcuL2NsYXNzZXMvRm9ybURhdGEuanMnXG5pbXBvcnQgQmxvYiBmcm9tICcuL2NsYXNzZXMvQmxvYi5qcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0Jyb3dzZXI6IHRydWUsXG4gIGNsYXNzZXM6IHtcbiAgICBVUkxTZWFyY2hQYXJhbXMsXG4gICAgRm9ybURhdGEsXG4gICAgQmxvYlxuICB9LFxuICBwcm90b2NvbHM6IFsnaHR0cCcsICdodHRwcycsICdmaWxlJywgJ2Jsb2InLCAndXJsJywgJ2RhdGEnXVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/platform/browser/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/platform/common/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/platform/common/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasBrowserEnv: () => (/* binding */ hasBrowserEnv),\n/* harmony export */   hasStandardBrowserEnv: () => (/* binding */ hasStandardBrowserEnv),\n/* harmony export */   hasStandardBrowserWebWorkerEnv: () => (/* binding */ hasStandardBrowserWebWorkerEnv),\n/* harmony export */   navigator: () => (/* binding */ _navigator),\n/* harmony export */   origin: () => (/* binding */ origin)\n/* harmony export */ });\nconst hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst _navigator = typeof navigator === 'object' && navigator || undefined;\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = hasBrowserEnv &&\n  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nconst origin = hasBrowserEnv && window.location.href || 'http://localhost';\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vY29tbW9uL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBUUMiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxheGlvc1xcbGliXFxwbGF0Zm9ybVxcY29tbW9uXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoYXNCcm93c2VyRW52ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuY29uc3QgX25hdmlnYXRvciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvciB8fCB1bmRlZmluZWQ7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJFbnYgPSBoYXNCcm93c2VyRW52ICYmXG4gICghX25hdmlnYXRvciB8fCBbJ1JlYWN0TmF0aXZlJywgJ05hdGl2ZVNjcmlwdCcsICdOUyddLmluZGV4T2YoX25hdmlnYXRvci5wcm9kdWN0KSA8IDApO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciB3ZWJXb3JrZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBBbHRob3VnaCB0aGUgYGlzU3RhbmRhcmRCcm93c2VyRW52YCBtZXRob2QgaW5kaWNhdGVzIHRoYXRcbiAqIGBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlcmAsIHRoZSBXZWJXb3JrZXIgd2lsbCBzdGlsbCBiZVxuICogZmlsdGVyZWQgb3V0IGR1ZSB0byBpdHMganVkZ21lbnQgc3RhbmRhcmRcbiAqIGB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnYC5cbiAqIFRoaXMgbGVhZHMgdG8gYSBwcm9ibGVtIHdoZW4gYXhpb3MgcG9zdCBgRm9ybURhdGFgIGluIHdlYldvcmtlclxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYgPSAoKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICB0eXBlb2Ygc2VsZi5pbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nXG4gICk7XG59KSgpO1xuXG5jb25zdCBvcmlnaW4gPSBoYXNCcm93c2VyRW52ICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICdodHRwOi8vbG9jYWxob3N0JztcblxuZXhwb3J0IHtcbiAgaGFzQnJvd3NlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBoYXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIF9uYXZpZ2F0b3IgYXMgbmF2aWdhdG9yLFxuICBvcmlnaW5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/platform/common/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/platform/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/platform/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node/index.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/browser/index.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/utils.js */ \"(app-pages-browser)/./node_modules/axios/lib/platform/common/utils.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  ..._common_utils_js__WEBPACK_IMPORTED_MODULE_0__,\n  ..._node_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVDO0FBQ0k7O0FBRTNDLGlFQUFlO0FBQ2YsS0FBSyw2Q0FBSztBQUNWLEtBQUssc0RBQVE7QUFDYixDQUFDIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcYXhpb3NcXGxpYlxccGxhdGZvcm1cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL25vZGUvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9jb21tb24vdXRpbHMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC4uLnV0aWxzLFxuICAuLi5wbGF0Zm9ybVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/platform/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/bind.js */ \"(app-pages-browser)/./node_modules/axios/lib/helpers/bind.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\nconst {iterator, toStringTag} = Symbol;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n}\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\nconst [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  }\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = (0,_helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[iterator];\n\n  const _iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = _iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n}\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n}\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  }\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n}\n\nconst noop = () => {}\n\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n}\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  }\n\n  return visit(obj, 0);\n}\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\n// original code\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener(\"message\", ({source, data}) => {\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n\n    return (cb) => {\n      callbacks.push(cb);\n      _global.postMessage(token, \"*\");\n    }\n  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);\n})(\n  typeof setImmediate === 'function',\n  isFunction(_global.postMessage)\n);\n\nconst asap = typeof queueMicrotask !== 'undefined' ?\n  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);\n\n// *********************\n\n\nconst isIterable = (thing) => thing != null && isFunction(thing[iterator]);\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable,\n  setImmediate: _setImmediate,\n  asap,\n  isIterable\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7O0FBRXdCOztBQUVyQzs7QUFFQSxPQUFPLFVBQVU7QUFDakIsT0FBTyxnQkFBZ0I7QUFDdkIsT0FBTyx1QkFBdUI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsT0FBTyxTQUFTOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0EsMkJBQTJCLG9CQUFvQixJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTLEdBQUcsU0FBUztBQUM1Qyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0NBQWtDO0FBQ2xDLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZ0NBQWdDLFdBQVcsSUFBSTtBQUMvQztBQUNBO0FBQ0EsZUFBZSw0REFBSTtBQUNuQixNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUcsR0FBRyxXQUFXO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGVBQWU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFdBQVcsY0FBYztBQUM1QixDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLE9BQU8sb0JBQW9CLE9BQU87O0FBRTVFOzs7QUFHQTs7O0FBR0EsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcYXhpb3NcXGxpYlxcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgYmluZCBmcm9tICcuL2hlbHBlcnMvYmluZC5qcyc7XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbmNvbnN0IHt0b1N0cmluZ30gPSBPYmplY3QucHJvdG90eXBlO1xuY29uc3Qge2dldFByb3RvdHlwZU9mfSA9IE9iamVjdDtcbmNvbnN0IHtpdGVyYXRvciwgdG9TdHJpbmdUYWd9ID0gU3ltYm9sO1xuXG5jb25zdCBraW5kT2YgPSAoY2FjaGUgPT4gdGhpbmcgPT4ge1xuICAgIGNvbnN0IHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5jb25zdCBraW5kT2ZUZXN0ID0gKHR5cGUpID0+IHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICh0aGluZykgPT4ga2luZE9mKHRoaW5nKSA9PT0gdHlwZVxufVxuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24odmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKSAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJpbmcgPSB0eXBlT2ZUZXN0KCdzdHJpbmcnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Z1bmN0aW9uID0gdHlwZU9mVGVzdCgnZnVuY3Rpb24nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc051bWJlciA9IHR5cGVPZlRlc3QoJ251bWJlcicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJvb2xlYW5cbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSB0aGluZyA9PiB0aGluZyA9PT0gdHJ1ZSB8fCB0aGluZyA9PT0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgISh0b1N0cmluZ1RhZyBpbiB2YWwpICYmICEoaXRlcmF0b3IgaW4gdmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRGF0ZSA9IGtpbmRPZlRlc3QoJ0RhdGUnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZSA9IGtpbmRPZlRlc3QoJ0ZpbGUnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQmxvYiA9IGtpbmRPZlRlc3QoJ0Jsb2InKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVMaXN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0ZpbGVMaXN0ID0ga2luZE9mVGVzdCgnRmlsZUxpc3QnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1N0cmVhbSA9ICh2YWwpID0+IGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRm9ybURhdGEgPSAodGhpbmcpID0+IHtcbiAgbGV0IGtpbmQ7XG4gIHJldHVybiB0aGluZyAmJiAoXG4gICAgKHR5cGVvZiBGb3JtRGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGluZyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB8fCAoXG4gICAgICBpc0Z1bmN0aW9uKHRoaW5nLmFwcGVuZCkgJiYgKFxuICAgICAgICAoa2luZCA9IGtpbmRPZih0aGluZykpID09PSAnZm9ybWRhdGEnIHx8XG4gICAgICAgIC8vIGRldGVjdCBmb3JtLWRhdGEgaW5zdGFuY2VcbiAgICAgICAgKGtpbmQgPT09ICdvYmplY3QnICYmIGlzRnVuY3Rpb24odGhpbmcudG9TdHJpbmcpICYmIHRoaW5nLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IEZvcm1EYXRhXScpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VSTFNlYXJjaFBhcmFtcyA9IGtpbmRPZlRlc3QoJ1VSTFNlYXJjaFBhcmFtcycpO1xuXG5jb25zdCBbaXNSZWFkYWJsZVN0cmVhbSwgaXNSZXF1ZXN0LCBpc1Jlc3BvbnNlLCBpc0hlYWRlcnNdID0gWydSZWFkYWJsZVN0cmVhbScsICdSZXF1ZXN0JywgJ1Jlc3BvbnNlJywgJ0hlYWRlcnMnXS5tYXAoa2luZE9mVGVzdCk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmNvbnN0IHRyaW0gPSAoc3RyKSA9PiBzdHIudHJpbSA/XG4gIHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXMgPSBmYWxzZV1cbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbiwge2FsbE93bktleXMgPSBmYWxzZX0gPSB7fSkge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBsZXQgbDtcblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAoaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IGFsbE93bktleXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iaiwga2V5KSB7XG4gIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IF9rZXk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgX2tleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA9PT0gX2tleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gX2tleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IF9nbG9iYWwgPSAoKCkgPT4ge1xuICAvKmVzbGludCBuby11bmRlZjowKi9cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbn0pKCk7XG5cbmNvbnN0IGlzQ29udGV4dERlZmluZWQgPSAoY29udGV4dCkgPT4gIWlzVW5kZWZpbmVkKGNvbnRleHQpICYmIGNvbnRleHQgIT09IF9nbG9iYWw7XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgY29uc3Qge2Nhc2VsZXNzfSA9IGlzQ29udGV4dERlZmluZWQodGhpcykgJiYgdGhpcyB8fCB7fTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGFzc2lnblZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gY2FzZWxlc3MgJiYgZmluZEtleShyZXN1bHQsIGtleSkgfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2UocmVzdWx0W3RhcmdldEtleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXSAmJiBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzXVxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5jb25zdCBleHRlbmQgPSAoYSwgYiwgdGhpc0FyZywge2FsbE93bktleXN9PSB7fSkgPT4ge1xuICBmb3JFYWNoKGIsICh2YWwsIGtleSkgPT4ge1xuICAgIGlmICh0aGlzQXJnICYmIGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9LCB7YWxsT3duS2V5c30pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuY29uc3Qgc3RyaXBCT00gPSAoY29udGVudCkgPT4ge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgaW5oZXJpdHMgPSAoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IsIHByb3BzLCBkZXNjcmlwdG9ycykgPT4ge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCBkZXNjcmlwdG9ycyk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdzdXBlcicsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgfSk7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdE9ial1cbiAqIEBwYXJhbSB7RnVuY3Rpb258Qm9vbGVhbn0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wRmlsdGVyXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IHRvRmxhdE9iamVjdCA9IChzb3VyY2VPYmosIGRlc3RPYmosIGZpbHRlciwgcHJvcEZpbHRlcikgPT4ge1xuICBsZXQgcHJvcHM7XG4gIGxldCBpO1xuICBsZXQgcHJvcDtcbiAgY29uc3QgbWVyZ2VkID0ge307XG5cbiAgZGVzdE9iaiA9IGRlc3RPYmogfHwge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBpZiAoc291cmNlT2JqID09IG51bGwpIHJldHVybiBkZXN0T2JqO1xuXG4gIGRvIHtcbiAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZU9iaik7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKCghcHJvcEZpbHRlciB8fCBwcm9wRmlsdGVyKHByb3AsIHNvdXJjZU9iaiwgZGVzdE9iaikpICYmICFtZXJnZWRbcHJvcF0pIHtcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcbiAgICAgICAgbWVyZ2VkW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlT2JqID0gZmlsdGVyICE9PSBmYWxzZSAmJiBnZXRQcm90b3R5cGVPZihzb3VyY2VPYmopO1xuICB9IHdoaWxlIChzb3VyY2VPYmogJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNvdXJjZU9iaiwgZGVzdE9iaikpICYmIHNvdXJjZU9iaiAhPT0gT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgcmV0dXJuIGRlc3RPYmo7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIHNwZWNpZmllZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPSAwXVxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBlbmRzV2l0aCA9IChzdHIsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pID0+IHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID4gc3RyLmxlbmd0aCkge1xuICAgIHBvc2l0aW9uID0gc3RyLmxlbmd0aDtcbiAgfVxuICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBsYXN0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqXG4gKiBAcGFyYW0geyp9IFt0aGluZ11cbiAqXG4gKiBAcmV0dXJucyB7P0FycmF5fVxuICovXG5jb25zdCB0b0FycmF5ID0gKHRoaW5nKSA9PiB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICBpZiAoaXNBcnJheSh0aGluZykpIHJldHVybiB0aGluZztcbiAgbGV0IGkgPSB0aGluZy5sZW5ndGg7XG4gIGlmICghaXNOdW1iZXIoaSkpIHJldHVybiBudWxsO1xuICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgYXJyW2ldID0gdGhpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBDaGVja2luZyBpZiB0aGUgVWludDhBcnJheSBleGlzdHMgYW5kIGlmIGl0IGRvZXMsIGl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGVcbiAqIHRoaW5nIHBhc3NlZCBpbiBpcyBhbiBpbnN0YW5jZSBvZiBVaW50OEFycmF5XG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbmNvbnN0IGlzVHlwZWRBcnJheSA9IChUeXBlZEFycmF5ID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIHRoaW5nID0+IHtcbiAgICByZXR1cm4gVHlwZWRBcnJheSAmJiB0aGluZyBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7XG4gIH07XG59KSh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xuXG4vKipcbiAqIEZvciBlYWNoIGVudHJ5IGluIHRoZSBvYmplY3QsIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGtleSBhbmQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggZW50cnkuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGZvckVhY2hFbnRyeSA9IChvYmosIGZuKSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9IG9iaiAmJiBvYmpbaXRlcmF0b3JdO1xuXG4gIGNvbnN0IF9pdGVyYXRvciA9IGdlbmVyYXRvci5jYWxsKG9iaik7XG5cbiAgbGV0IHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IF9pdGVyYXRvci5uZXh0KCkpICYmICFyZXN1bHQuZG9uZSkge1xuICAgIGNvbnN0IHBhaXIgPSByZXN1bHQudmFsdWU7XG4gICAgZm4uY2FsbChvYmosIHBhaXJbMF0sIHBhaXJbMV0pO1xuICB9XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gYW5kIGEgc3RyaW5nLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnRXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxib29sZWFuPn1cbiAqL1xuY29uc3QgbWF0Y2hBbGwgPSAocmVnRXhwLCBzdHIpID0+IHtcbiAgbGV0IG1hdGNoZXM7XG4gIGNvbnN0IGFyciA9IFtdO1xuXG4gIHdoaWxlICgobWF0Y2hlcyA9IHJlZ0V4cC5leGVjKHN0cikpICE9PSBudWxsKSB7XG4gICAgYXJyLnB1c2gobWF0Y2hlcyk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG4vKiBDaGVja2luZyBpZiB0aGUga2luZE9mVGVzdCBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2hlbiBwYXNzZWQgYW4gSFRNTEZvcm1FbGVtZW50LiAqL1xuY29uc3QgaXNIVE1MRm9ybSA9IGtpbmRPZlRlc3QoJ0hUTUxGb3JtRWxlbWVudCcpO1xuXG5jb25zdCB0b0NhbWVsQ2FzZSA9IHN0ciA9PiB7XG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9cXHNdKFthLXpcXGRdKShcXHcqKS9nLFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG0sIHAxLCBwMikge1xuICAgICAgcmV0dXJuIHAxLnRvVXBwZXJDYXNlKCkgKyBwMjtcbiAgICB9XG4gICk7XG59O1xuXG4vKiBDcmVhdGluZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjaGVjayBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9ICgoe2hhc093blByb3BlcnR5fSkgPT4gKG9iaiwgcHJvcCkgPT4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKShPYmplY3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzUmVnRXhwID0ga2luZE9mVGVzdCgnUmVnRXhwJyk7XG5cbmNvbnN0IHJlZHVjZURlc2NyaXB0b3JzID0gKG9iaiwgcmVkdWNlcikgPT4ge1xuICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaik7XG4gIGNvbnN0IHJlZHVjZWREZXNjcmlwdG9ycyA9IHt9O1xuXG4gIGZvckVhY2goZGVzY3JpcHRvcnMsIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgbGV0IHJldDtcbiAgICBpZiAoKHJldCA9IHJlZHVjZXIoZGVzY3JpcHRvciwgbmFtZSwgb2JqKSkgIT09IGZhbHNlKSB7XG4gICAgICByZWR1Y2VkRGVzY3JpcHRvcnNbbmFtZV0gPSByZXQgfHwgZGVzY3JpcHRvcjtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgcmVkdWNlZERlc2NyaXB0b3JzKTtcbn1cblxuLyoqXG4gKiBNYWtlcyBhbGwgbWV0aG9kcyByZWFkLW9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5jb25zdCBmcmVlemVNZXRob2RzID0gKG9iaikgPT4ge1xuICByZWR1Y2VEZXNjcmlwdG9ycyhvYmosIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgLy8gc2tpcCByZXN0cmljdGVkIHByb3BzIGluIHN0cmljdCBtb2RlXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSAmJiBbJ2FyZ3VtZW50cycsICdjYWxsZXInLCAnY2FsbGVlJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybjtcblxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvcikge1xuICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2FuIG5vdCByZXdyaXRlIHJlYWQtb25seSBtZXRob2QgXFwnJyArIG5hbWUgKyAnXFwnJyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHRvT2JqZWN0U2V0ID0gKGFycmF5T3JTdHJpbmcsIGRlbGltaXRlcikgPT4ge1xuICBjb25zdCBvYmogPSB7fTtcblxuICBjb25zdCBkZWZpbmUgPSAoYXJyKSA9PiB7XG4gICAgYXJyLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgb2JqW3ZhbHVlXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBpc0FycmF5KGFycmF5T3JTdHJpbmcpID8gZGVmaW5lKGFycmF5T3JTdHJpbmcpIDogZGVmaW5lKFN0cmluZyhhcnJheU9yU3RyaW5nKS5zcGxpdChkZWxpbWl0ZXIpKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY29uc3QgdG9GaW5pdGVOdW1iZXIgPSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUgPSArdmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogSWYgdGhlIHRoaW5nIGlzIGEgRm9ybURhdGEgb2JqZWN0LCByZXR1cm4gdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHRoaW5nIC0gVGhlIHRoaW5nIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NwZWNDb21wbGlhbnRGb3JtKHRoaW5nKSB7XG4gIHJldHVybiAhISh0aGluZyAmJiBpc0Z1bmN0aW9uKHRoaW5nLmFwcGVuZCkgJiYgdGhpbmdbdG9TdHJpbmdUYWddID09PSAnRm9ybURhdGEnICYmIHRoaW5nW2l0ZXJhdG9yXSk7XG59XG5cbmNvbnN0IHRvSlNPTk9iamVjdCA9IChvYmopID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgQXJyYXkoMTApO1xuXG4gIGNvbnN0IHZpc2l0ID0gKHNvdXJjZSwgaSkgPT4ge1xuXG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGlmIChzdGFjay5pbmRleE9mKHNvdXJjZSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKCEoJ3RvSlNPTicgaW4gc291cmNlKSkge1xuICAgICAgICBzdGFja1tpXSA9IHNvdXJjZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaXNBcnJheShzb3VyY2UpID8gW10gOiB7fTtcblxuICAgICAgICBmb3JFYWNoKHNvdXJjZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VkVmFsdWUgPSB2aXNpdCh2YWx1ZSwgaSArIDEpO1xuICAgICAgICAgICFpc1VuZGVmaW5lZChyZWR1Y2VkVmFsdWUpICYmICh0YXJnZXRba2V5XSA9IHJlZHVjZWRWYWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0YWNrW2ldID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiB2aXNpdChvYmosIDApO1xufVxuXG5jb25zdCBpc0FzeW5jRm4gPSBraW5kT2ZUZXN0KCdBc3luY0Z1bmN0aW9uJyk7XG5cbmNvbnN0IGlzVGhlbmFibGUgPSAodGhpbmcpID0+XG4gIHRoaW5nICYmIChpc09iamVjdCh0aGluZykgfHwgaXNGdW5jdGlvbih0aGluZykpICYmIGlzRnVuY3Rpb24odGhpbmcudGhlbikgJiYgaXNGdW5jdGlvbih0aGluZy5jYXRjaCk7XG5cbi8vIG9yaWdpbmFsIGNvZGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EaWdpdGFsQnJhaW5KUy9BeGlvc1Byb21pc2UvYmxvYi8xNmRlYWIxMzcxMGVjMDk3Nzk5MjIxMzFmM2ZhNTk1NDMyMGY4M2FiL2xpYi91dGlscy5qcyNMMTEtTDM0XG5cbmNvbnN0IF9zZXRJbW1lZGlhdGUgPSAoKHNldEltbWVkaWF0ZVN1cHBvcnRlZCwgcG9zdE1lc3NhZ2VTdXBwb3J0ZWQpID0+IHtcbiAgaWYgKHNldEltbWVkaWF0ZVN1cHBvcnRlZCkge1xuICAgIHJldHVybiBzZXRJbW1lZGlhdGU7XG4gIH1cblxuICByZXR1cm4gcG9zdE1lc3NhZ2VTdXBwb3J0ZWQgPyAoKHRva2VuLCBjYWxsYmFja3MpID0+IHtcbiAgICBfZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh7c291cmNlLCBkYXRhfSkgPT4ge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gX2dsb2JhbCAmJiBkYXRhID09PSB0b2tlbikge1xuICAgICAgICBjYWxsYmFja3MubGVuZ3RoICYmIGNhbGxiYWNrcy5zaGlmdCgpKCk7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgX2dsb2JhbC5wb3N0TWVzc2FnZSh0b2tlbiwgXCIqXCIpO1xuICAgIH1cbiAgfSkoYGF4aW9zQCR7TWF0aC5yYW5kb20oKX1gLCBbXSkgOiAoY2IpID0+IHNldFRpbWVvdXQoY2IpO1xufSkoXG4gIHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicsXG4gIGlzRnVuY3Rpb24oX2dsb2JhbC5wb3N0TWVzc2FnZSlcbik7XG5cbmNvbnN0IGFzYXAgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgIT09ICd1bmRlZmluZWQnID9cbiAgcXVldWVNaWNyb3Rhc2suYmluZChfZ2xvYmFsKSA6ICggdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MubmV4dFRpY2sgfHwgX3NldEltbWVkaWF0ZSk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKlxuXG5cbmNvbnN0IGlzSXRlcmFibGUgPSAodGhpbmcpID0+IHRoaW5nICE9IG51bGwgJiYgaXNGdW5jdGlvbih0aGluZ1tpdGVyYXRvcl0pO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXIsXG4gIGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZyxcbiAgaXNOdW1iZXIsXG4gIGlzQm9vbGVhbixcbiAgaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzUmVxdWVzdCxcbiAgaXNSZXNwb25zZSxcbiAgaXNIZWFkZXJzLFxuICBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlLFxuICBpc0ZpbGUsXG4gIGlzQmxvYixcbiAgaXNSZWdFeHAsXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNUeXBlZEFycmF5LFxuICBpc0ZpbGVMaXN0LFxuICBmb3JFYWNoLFxuICBtZXJnZSxcbiAgZXh0ZW5kLFxuICB0cmltLFxuICBzdHJpcEJPTSxcbiAgaW5oZXJpdHMsXG4gIHRvRmxhdE9iamVjdCxcbiAga2luZE9mLFxuICBraW5kT2ZUZXN0LFxuICBlbmRzV2l0aCxcbiAgdG9BcnJheSxcbiAgZm9yRWFjaEVudHJ5LFxuICBtYXRjaEFsbCxcbiAgaXNIVE1MRm9ybSxcbiAgaGFzT3duUHJvcGVydHksXG4gIGhhc093blByb3A6IGhhc093blByb3BlcnR5LCAvLyBhbiBhbGlhcyB0byBhdm9pZCBFU0xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIGRldGVjdGlvblxuICByZWR1Y2VEZXNjcmlwdG9ycyxcbiAgZnJlZXplTWV0aG9kcyxcbiAgdG9PYmplY3RTZXQsXG4gIHRvQ2FtZWxDYXNlLFxuICBub29wLFxuICB0b0Zpbml0ZU51bWJlcixcbiAgZmluZEtleSxcbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBpc0NvbnRleHREZWZpbmVkLFxuICBpc1NwZWNDb21wbGlhbnRGb3JtLFxuICB0b0pTT05PYmplY3QsXG4gIGlzQXN5bmNGbixcbiAgaXNUaGVuYWJsZSxcbiAgc2V0SW1tZWRpYXRlOiBfc2V0SW1tZWRpYXRlLFxuICBhc2FwLFxuICBpc0l0ZXJhYmxlXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/axios/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fancy-canvas/canvas-element-bitmap-size.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/fancy-canvas/canvas-element-bitmap-size.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bindTo: () => (/* binding */ bindTo)\n/* harmony export */ });\n/* harmony import */ var _size_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./size.mjs */ \"(app-pages-browser)/./node_modules/fancy-canvas/size.mjs\");\n/* harmony import */ var _device_pixel_ratio_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./device-pixel-ratio.mjs */ \"(app-pages-browser)/./node_modules/fancy-canvas/device-pixel-ratio.mjs\");\n\n\nvar DevicePixelContentBoxBinding = /** @class */ (function () {\n    function DevicePixelContentBoxBinding(canvasElement, transformBitmapSize, options) {\n        var _a;\n        this._canvasElement = null;\n        this._bitmapSizeChangedListeners = [];\n        this._suggestedBitmapSize = null;\n        this._suggestedBitmapSizeChangedListeners = [];\n        // devicePixelRatio approach\n        this._devicePixelRatioObservable = null;\n        // ResizeObserver approach\n        this._canvasElementResizeObserver = null;\n        this._canvasElement = canvasElement;\n        this._canvasElementClientSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: this._canvasElement.clientWidth,\n            height: this._canvasElement.clientHeight,\n        });\n        this._transformBitmapSize = transformBitmapSize !== null && transformBitmapSize !== void 0 ? transformBitmapSize : (function (size) { return size; });\n        this._allowResizeObserver = (_a = options === null || options === void 0 ? void 0 : options.allowResizeObserver) !== null && _a !== void 0 ? _a : true;\n        this._chooseAndInitObserver();\n        // we MAY leave the constuctor without any bitmap size observation mechanics initialized\n    }\n    DevicePixelContentBoxBinding.prototype.dispose = function () {\n        var _a, _b;\n        if (this._canvasElement === null) {\n            throw new Error('Object is disposed');\n        }\n        (_a = this._canvasElementResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this._canvasElementResizeObserver = null;\n        (_b = this._devicePixelRatioObservable) === null || _b === void 0 ? void 0 : _b.dispose();\n        this._devicePixelRatioObservable = null;\n        this._suggestedBitmapSizeChangedListeners.length = 0;\n        this._bitmapSizeChangedListeners.length = 0;\n        this._canvasElement = null;\n    };\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"canvasElement\", {\n        get: function () {\n            if (this._canvasElement === null) {\n                throw new Error('Object is disposed');\n            }\n            return this._canvasElement;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"canvasElementClientSize\", {\n        get: function () {\n            return this._canvasElementClientSize;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"bitmapSize\", {\n        get: function () {\n            return (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: this.canvasElement.width,\n                height: this.canvasElement.height,\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Use this function to change canvas element client size until binding is disposed\n     * @param clientSize New client size for bound HTMLCanvasElement\n     */\n    DevicePixelContentBoxBinding.prototype.resizeCanvasElement = function (clientSize) {\n        this._canvasElementClientSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)(clientSize);\n        this.canvasElement.style.width = \"\".concat(this._canvasElementClientSize.width, \"px\");\n        this.canvasElement.style.height = \"\".concat(this._canvasElementClientSize.height, \"px\");\n        this._invalidateBitmapSize();\n    };\n    DevicePixelContentBoxBinding.prototype.subscribeBitmapSizeChanged = function (listener) {\n        this._bitmapSizeChangedListeners.push(listener);\n    };\n    DevicePixelContentBoxBinding.prototype.unsubscribeBitmapSizeChanged = function (listener) {\n        this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function (l) { return l !== listener; });\n    };\n    Object.defineProperty(DevicePixelContentBoxBinding.prototype, \"suggestedBitmapSize\", {\n        get: function () {\n            return this._suggestedBitmapSize;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DevicePixelContentBoxBinding.prototype.subscribeSuggestedBitmapSizeChanged = function (listener) {\n        this._suggestedBitmapSizeChangedListeners.push(listener);\n    };\n    DevicePixelContentBoxBinding.prototype.unsubscribeSuggestedBitmapSizeChanged = function (listener) {\n        this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function (l) { return l !== listener; });\n    };\n    DevicePixelContentBoxBinding.prototype.applySuggestedBitmapSize = function () {\n        if (this._suggestedBitmapSize === null) {\n            // nothing to apply\n            return;\n        }\n        var oldSuggestedSize = this._suggestedBitmapSize;\n        this._suggestedBitmapSize = null;\n        this._resizeBitmap(oldSuggestedSize);\n        this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, this._suggestedBitmapSize);\n    };\n    DevicePixelContentBoxBinding.prototype._resizeBitmap = function (newSize) {\n        var oldSize = this.bitmapSize;\n        if ((0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(oldSize, newSize)) {\n            return;\n        }\n        this.canvasElement.width = newSize.width;\n        this.canvasElement.height = newSize.height;\n        this._emitBitmapSizeChanged(oldSize, newSize);\n    };\n    DevicePixelContentBoxBinding.prototype._emitBitmapSizeChanged = function (oldSize, newSize) {\n        var _this = this;\n        this._bitmapSizeChangedListeners.forEach(function (listener) { return listener.call(_this, oldSize, newSize); });\n    };\n    DevicePixelContentBoxBinding.prototype._suggestNewBitmapSize = function (newSize) {\n        var oldSuggestedSize = this._suggestedBitmapSize;\n        var finalNewSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)(this._transformBitmapSize(newSize, this._canvasElementClientSize));\n        var newSuggestedSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this.bitmapSize, finalNewSize) ? null : finalNewSize;\n        if (oldSuggestedSize === null && newSuggestedSize === null) {\n            return;\n        }\n        if (oldSuggestedSize !== null && newSuggestedSize !== null\n            && (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(oldSuggestedSize, newSuggestedSize)) {\n            return;\n        }\n        this._suggestedBitmapSize = newSuggestedSize;\n        this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, newSuggestedSize);\n    };\n    DevicePixelContentBoxBinding.prototype._emitSuggestedBitmapSizeChanged = function (oldSize, newSize) {\n        var _this = this;\n        this._suggestedBitmapSizeChangedListeners.forEach(function (listener) { return listener.call(_this, oldSize, newSize); });\n    };\n    DevicePixelContentBoxBinding.prototype._chooseAndInitObserver = function () {\n        var _this = this;\n        if (!this._allowResizeObserver) {\n            this._initDevicePixelRatioObservable();\n            return;\n        }\n        isDevicePixelContentBoxSupported()\n            .then(function (isSupported) {\n            return isSupported ?\n                _this._initResizeObserver() :\n                _this._initDevicePixelRatioObservable();\n        });\n    };\n    // devicePixelRatio approach\n    DevicePixelContentBoxBinding.prototype._initDevicePixelRatioObservable = function () {\n        var _this = this;\n        if (this._canvasElement === null) {\n            // it looks like we are already dead\n            return;\n        }\n        var win = canvasElementWindow(this._canvasElement);\n        if (win === null) {\n            throw new Error('No window is associated with the canvas');\n        }\n        this._devicePixelRatioObservable = (0,_device_pixel_ratio_mjs__WEBPACK_IMPORTED_MODULE_1__.createObservable)(win);\n        this._devicePixelRatioObservable.subscribe(function () { return _this._invalidateBitmapSize(); });\n        this._invalidateBitmapSize();\n    };\n    DevicePixelContentBoxBinding.prototype._invalidateBitmapSize = function () {\n        var _a, _b;\n        if (this._canvasElement === null) {\n            // it looks like we are already dead\n            return;\n        }\n        var win = canvasElementWindow(this._canvasElement);\n        if (win === null) {\n            return;\n        }\n        var ratio = (_b = (_a = this._devicePixelRatioObservable) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : win.devicePixelRatio;\n        var canvasRects = this._canvasElement.getClientRects();\n        var newSize = \n        // eslint-disable-next-line no-negated-condition\n        canvasRects[0] !== undefined ?\n            predictedBitmapSize(canvasRects[0], ratio) :\n            (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: this._canvasElementClientSize.width * ratio,\n                height: this._canvasElementClientSize.height * ratio,\n            });\n        this._suggestNewBitmapSize(newSize);\n    };\n    // ResizeObserver approach\n    DevicePixelContentBoxBinding.prototype._initResizeObserver = function () {\n        var _this = this;\n        if (this._canvasElement === null) {\n            // it looks like we are already dead\n            return;\n        }\n        this._canvasElementResizeObserver = new ResizeObserver(function (entries) {\n            var entry = entries.find(function (entry) { return entry.target === _this._canvasElement; });\n            if (!entry || !entry.devicePixelContentBoxSize || !entry.devicePixelContentBoxSize[0]) {\n                return;\n            }\n            var entrySize = entry.devicePixelContentBoxSize[0];\n            var newSize = (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n                width: entrySize.inlineSize,\n                height: entrySize.blockSize,\n            });\n            _this._suggestNewBitmapSize(newSize);\n        });\n        this._canvasElementResizeObserver.observe(this._canvasElement, { box: 'device-pixel-content-box' });\n    };\n    return DevicePixelContentBoxBinding;\n}());\nfunction bindTo(canvasElement, target) {\n    if (target.type === 'device-pixel-content-box') {\n        return new DevicePixelContentBoxBinding(canvasElement, target.transform, target.options);\n    }\n    throw new Error('Unsupported binding target');\n}\nfunction canvasElementWindow(canvasElement) {\n    // According to DOM Level 2 Core specification, ownerDocument should never be null for HTMLCanvasElement\n    // see https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#node-ownerDoc\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return canvasElement.ownerDocument.defaultView;\n}\nfunction isDevicePixelContentBoxSupported() {\n    return new Promise(function (resolve) {\n        var ro = new ResizeObserver(function (entries) {\n            resolve(entries.every(function (entry) { return 'devicePixelContentBoxSize' in entry; }));\n            ro.disconnect();\n        });\n        ro.observe(document.body, { box: 'device-pixel-content-box' });\n    })\n        .catch(function () { return false; });\n}\nfunction predictedBitmapSize(canvasRect, ratio) {\n    return (0,_size_mjs__WEBPACK_IMPORTED_MODULE_0__.size)({\n        width: Math.round(canvasRect.left * ratio + canvasRect.width * ratio) -\n            Math.round(canvasRect.left * ratio),\n        height: Math.round(canvasRect.top * ratio + canvasRect.height * ratio) -\n            Math.round(canvasRect.top * ratio),\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvY2FudmFzLWVsZW1lbnQtYml0bWFwLXNpemUubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNrRDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0NBQUk7QUFDNUM7QUFDQTtBQUNBLFNBQVM7QUFDVCw4SUFBOEksY0FBYztBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBSTtBQUN2QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0NBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyx3QkFBd0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCx3QkFBd0I7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsZ0RBQWdEO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQ0FBSTtBQUMvQiwrQkFBK0IscURBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGdEQUFnRDtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlFQUFnQztBQUMzRSxpRUFBaUUsdUNBQXVDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQUk7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwrQ0FBK0M7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQUk7QUFDOUI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCx5RUFBeUUsaUNBQWlDO0FBQzFHO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDhDQUE4QztBQUNuRztBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsaUNBQWlDO0FBQ3JFLEtBQUs7QUFDTCw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0EsV0FBVywrQ0FBSTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcZmFuY3ktY2FudmFzXFxjYW52YXMtZWxlbWVudC1iaXRtYXAtc2l6ZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXF1YWxTaXplcywgc2l6ZSB9IGZyb20gXCIuL3NpemUubWpzXCI7XG5pbXBvcnQgeyBjcmVhdGVPYnNlcnZhYmxlIGFzIGNyZWF0ZURldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlIH0gZnJvbSBcIi4vZGV2aWNlLXBpeGVsLXJhdGlvLm1qc1wiO1xudmFyIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZyhjYW52YXNFbGVtZW50LCB0cmFuc2Zvcm1CaXRtYXBTaXplLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fY2FudmFzRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycyA9IFtdO1xuICAgICAgICAvLyBkZXZpY2VQaXhlbFJhdGlvIGFwcHJvYWNoXG4gICAgICAgIHRoaXMuX2RldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlID0gbnVsbDtcbiAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXBwcm9hY2hcbiAgICAgICAgdGhpcy5fY2FudmFzRWxlbWVudFJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FudmFzRWxlbWVudCA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnRDbGllbnRTaXplID0gc2l6ZSh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5fY2FudmFzRWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5fY2FudmFzRWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1CaXRtYXBTaXplID0gdHJhbnNmb3JtQml0bWFwU2l6ZSAhPT0gbnVsbCAmJiB0cmFuc2Zvcm1CaXRtYXBTaXplICE9PSB2b2lkIDAgPyB0cmFuc2Zvcm1CaXRtYXBTaXplIDogKGZ1bmN0aW9uIChzaXplKSB7IHJldHVybiBzaXplOyB9KTtcbiAgICAgICAgdGhpcy5fYWxsb3dSZXNpemVPYnNlcnZlciA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbGxvd1Jlc2l6ZU9ic2VydmVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgICAgICB0aGlzLl9jaG9vc2VBbmRJbml0T2JzZXJ2ZXIoKTtcbiAgICAgICAgLy8gd2UgTUFZIGxlYXZlIHRoZSBjb25zdHVjdG9yIHdpdGhvdXQgYW55IGJpdG1hcCBzaXplIG9ic2VydmF0aW9uIG1lY2hhbmljcyBpbml0aWFsaXplZFxuICAgIH1cbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5fY2FudmFzRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QgaXMgZGlzcG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9jYW52YXNFbGVtZW50UmVzaXplT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnRSZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICAgIChfYiA9IHRoaXMuX2RldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2JpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnQgPSBudWxsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLCBcImNhbnZhc0VsZW1lbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW52YXNFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QgaXMgZGlzcG9zZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNFbGVtZW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLCBcImNhbnZhc0VsZW1lbnRDbGllbnRTaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzRWxlbWVudENsaWVudFNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUsIFwiYml0bWFwU2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemUoe1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byBjaGFuZ2UgY2FudmFzIGVsZW1lbnQgY2xpZW50IHNpemUgdW50aWwgYmluZGluZyBpcyBkaXNwb3NlZFxuICAgICAqIEBwYXJhbSBjbGllbnRTaXplIE5ldyBjbGllbnQgc2l6ZSBmb3IgYm91bmQgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKi9cbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5yZXNpemVDYW52YXNFbGVtZW50ID0gZnVuY3Rpb24gKGNsaWVudFNpemUpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzRWxlbWVudENsaWVudFNpemUgPSBzaXplKGNsaWVudFNpemUpO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdCh0aGlzLl9jYW52YXNFbGVtZW50Q2xpZW50U2l6ZS53aWR0aCwgXCJweFwiKTtcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KHRoaXMuX2NhbnZhc0VsZW1lbnRDbGllbnRTaXplLmhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZUJpdG1hcFNpemUoKTtcbiAgICB9O1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLnN1YnNjcmliZUJpdG1hcFNpemVDaGFuZ2VkID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2JpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH07XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUudW5zdWJzY3JpYmVCaXRtYXBTaXplQ2hhbmdlZCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9iaXRtYXBTaXplQ2hhbmdlZExpc3RlbmVycyA9IHRoaXMuX2JpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbCAhPT0gbGlzdGVuZXI7IH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLCBcInN1Z2dlc3RlZEJpdG1hcFNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS51bnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzID0gdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsICE9PSBsaXN0ZW5lcjsgfSk7XG4gICAgfTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5hcHBseVN1Z2dlc3RlZEJpdG1hcFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGFwcGx5XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZFN1Z2dlc3RlZFNpemUgPSB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplO1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzaXplQml0bWFwKG9sZFN1Z2dlc3RlZFNpemUpO1xuICAgICAgICB0aGlzLl9lbWl0U3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQob2xkU3VnZ2VzdGVkU2l6ZSwgdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZSk7XG4gICAgfTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5fcmVzaXplQml0bWFwID0gZnVuY3Rpb24gKG5ld1NpemUpIHtcbiAgICAgICAgdmFyIG9sZFNpemUgPSB0aGlzLmJpdG1hcFNpemU7XG4gICAgICAgIGlmIChlcXVhbFNpemVzKG9sZFNpemUsIG5ld1NpemUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLl9lbWl0Qml0bWFwU2l6ZUNoYW5nZWQob2xkU2l6ZSwgbmV3U2l6ZSk7XG4gICAgfTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5fZW1pdEJpdG1hcFNpemVDaGFuZ2VkID0gZnVuY3Rpb24gKG9sZFNpemUsIG5ld1NpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYml0bWFwU2l6ZUNoYW5nZWRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyLmNhbGwoX3RoaXMsIG9sZFNpemUsIG5ld1NpemUpOyB9KTtcbiAgICB9O1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLl9zdWdnZXN0TmV3Qml0bWFwU2l6ZSA9IGZ1bmN0aW9uIChuZXdTaXplKSB7XG4gICAgICAgIHZhciBvbGRTdWdnZXN0ZWRTaXplID0gdGhpcy5fc3VnZ2VzdGVkQml0bWFwU2l6ZTtcbiAgICAgICAgdmFyIGZpbmFsTmV3U2l6ZSA9IHNpemUodGhpcy5fdHJhbnNmb3JtQml0bWFwU2l6ZShuZXdTaXplLCB0aGlzLl9jYW52YXNFbGVtZW50Q2xpZW50U2l6ZSkpO1xuICAgICAgICB2YXIgbmV3U3VnZ2VzdGVkU2l6ZSA9IGVxdWFsU2l6ZXModGhpcy5iaXRtYXBTaXplLCBmaW5hbE5ld1NpemUpID8gbnVsbCA6IGZpbmFsTmV3U2l6ZTtcbiAgICAgICAgaWYgKG9sZFN1Z2dlc3RlZFNpemUgPT09IG51bGwgJiYgbmV3U3VnZ2VzdGVkU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRTdWdnZXN0ZWRTaXplICE9PSBudWxsICYmIG5ld1N1Z2dlc3RlZFNpemUgIT09IG51bGxcbiAgICAgICAgICAgICYmIGVxdWFsU2l6ZXMob2xkU3VnZ2VzdGVkU2l6ZSwgbmV3U3VnZ2VzdGVkU2l6ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRCaXRtYXBTaXplID0gbmV3U3VnZ2VzdGVkU2l6ZTtcbiAgICAgICAgdGhpcy5fZW1pdFN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKG9sZFN1Z2dlc3RlZFNpemUsIG5ld1N1Z2dlc3RlZFNpemUpO1xuICAgIH07XG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuX2VtaXRTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGRTaXplLCBuZXdTaXplKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lci5jYWxsKF90aGlzLCBvbGRTaXplLCBuZXdTaXplKTsgfSk7XG4gICAgfTtcbiAgICBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nLnByb3RvdHlwZS5fY2hvb3NlQW5kSW5pdE9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX2FsbG93UmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXREZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlzRGV2aWNlUGl4ZWxDb250ZW50Qm94U3VwcG9ydGVkKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkID9cbiAgICAgICAgICAgICAgICBfdGhpcy5faW5pdFJlc2l6ZU9ic2VydmVyKCkgOlxuICAgICAgICAgICAgICAgIF90aGlzLl9pbml0RGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBkZXZpY2VQaXhlbFJhdGlvIGFwcHJvYWNoXG4gICAgRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZy5wcm90b3R5cGUuX2luaXREZXZpY2VQaXhlbFJhdGlvT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhc0VsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGl0IGxvb2tzIGxpa2Ugd2UgYXJlIGFscmVhZHkgZGVhZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW4gPSBjYW52YXNFbGVtZW50V2luZG93KHRoaXMuX2NhbnZhc0VsZW1lbnQpO1xuICAgICAgICBpZiAod2luID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHdpbmRvdyBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIGNhbnZhcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RldmljZVBpeGVsUmF0aW9PYnNlcnZhYmxlID0gY3JlYXRlRGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUod2luKTtcbiAgICAgICAgdGhpcy5fZGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9pbnZhbGlkYXRlQml0bWFwU2l6ZSgpOyB9KTtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZUJpdG1hcFNpemUoKTtcbiAgICB9O1xuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLl9pbnZhbGlkYXRlQml0bWFwU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhc0VsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGl0IGxvb2tzIGxpa2Ugd2UgYXJlIGFscmVhZHkgZGVhZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW4gPSBjYW52YXNFbGVtZW50V2luZG93KHRoaXMuX2NhbnZhc0VsZW1lbnQpO1xuICAgICAgICBpZiAod2luID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhdGlvID0gKF9iID0gKF9hID0gdGhpcy5fZGV2aWNlUGl4ZWxSYXRpb09ic2VydmFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogd2luLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIHZhciBjYW52YXNSZWN0cyA9IHRoaXMuX2NhbnZhc0VsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgdmFyIG5ld1NpemUgPSBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG4gICAgICAgIGNhbnZhc1JlY3RzWzBdICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgcHJlZGljdGVkQml0bWFwU2l6ZShjYW52YXNSZWN0c1swXSwgcmF0aW8pIDpcbiAgICAgICAgICAgIHNpemUoe1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl9jYW52YXNFbGVtZW50Q2xpZW50U2l6ZS53aWR0aCAqIHJhdGlvLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5fY2FudmFzRWxlbWVudENsaWVudFNpemUuaGVpZ2h0ICogcmF0aW8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc3VnZ2VzdE5ld0JpdG1hcFNpemUobmV3U2l6ZSk7XG4gICAgfTtcbiAgICAvLyBSZXNpemVPYnNlcnZlciBhcHByb2FjaFxuICAgIERldmljZVBpeGVsQ29udGVudEJveEJpbmRpbmcucHJvdG90eXBlLl9pbml0UmVzaXplT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9jYW52YXNFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpdCBsb29rcyBsaWtlIHdlIGFyZSBhbHJlYWR5IGRlYWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYW52YXNFbGVtZW50UmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LnRhcmdldCA9PT0gX3RoaXMuX2NhbnZhc0VsZW1lbnQ7IH0pO1xuICAgICAgICAgICAgaWYgKCFlbnRyeSB8fCAhZW50cnkuZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZSB8fCAhZW50cnkuZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZVswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbnRyeVNpemUgPSBlbnRyeS5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplWzBdO1xuICAgICAgICAgICAgdmFyIG5ld1NpemUgPSBzaXplKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogZW50cnlTaXplLmlubGluZVNpemUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBlbnRyeVNpemUuYmxvY2tTaXplLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5fc3VnZ2VzdE5ld0JpdG1hcFNpemUobmV3U2l6ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jYW52YXNFbGVtZW50UmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9jYW52YXNFbGVtZW50LCB7IGJveDogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGV2aWNlUGl4ZWxDb250ZW50Qm94QmluZGluZztcbn0oKSk7XG5leHBvcnQgZnVuY3Rpb24gYmluZFRvKGNhbnZhc0VsZW1lbnQsIHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQudHlwZSA9PT0gJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXZpY2VQaXhlbENvbnRlbnRCb3hCaW5kaW5nKGNhbnZhc0VsZW1lbnQsIHRhcmdldC50cmFuc2Zvcm0sIHRhcmdldC5vcHRpb25zKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBiaW5kaW5nIHRhcmdldCcpO1xufVxuZnVuY3Rpb24gY2FudmFzRWxlbWVudFdpbmRvdyhjYW52YXNFbGVtZW50KSB7XG4gICAgLy8gQWNjb3JkaW5nIHRvIERPTSBMZXZlbCAyIENvcmUgc3BlY2lmaWNhdGlvbiwgb3duZXJEb2N1bWVudCBzaG91bGQgbmV2ZXIgYmUgbnVsbCBmb3IgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDAvUkVDLURPTS1MZXZlbC0yLUNvcmUtMjAwMDExMTMvY29yZS5odG1sI25vZGUtb3duZXJEb2NcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIHJldHVybiBjYW52YXNFbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG59XG5mdW5jdGlvbiBpc0RldmljZVBpeGVsQ29udGVudEJveFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHJvID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICByZXNvbHZlKGVudHJpZXMuZXZlcnkoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiAnZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZScgaW4gZW50cnk7IH0pKTtcbiAgICAgICAgICAgIHJvLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvLm9ic2VydmUoZG9jdW1lbnQuYm9keSwgeyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH0pO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSk7XG59XG5mdW5jdGlvbiBwcmVkaWN0ZWRCaXRtYXBTaXplKGNhbnZhc1JlY3QsIHJhdGlvKSB7XG4gICAgcmV0dXJuIHNpemUoe1xuICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChjYW52YXNSZWN0LmxlZnQgKiByYXRpbyArIGNhbnZhc1JlY3Qud2lkdGggKiByYXRpbykgLVxuICAgICAgICAgICAgTWF0aC5yb3VuZChjYW52YXNSZWN0LmxlZnQgKiByYXRpbyksXG4gICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChjYW52YXNSZWN0LnRvcCAqIHJhdGlvICsgY2FudmFzUmVjdC5oZWlnaHQgKiByYXRpbykgLVxuICAgICAgICAgICAgTWF0aC5yb3VuZChjYW52YXNSZWN0LnRvcCAqIHJhdGlvKSxcbiAgICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fancy-canvas/canvas-element-bitmap-size.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fancy-canvas/canvas-rendering-target.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/fancy-canvas/canvas-rendering-target.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasRenderingTarget2D: () => (/* binding */ CanvasRenderingTarget2D),\n/* harmony export */   createCanvasRenderingTarget2D: () => (/* binding */ createCanvasRenderingTarget2D),\n/* harmony export */   tryCreateCanvasRenderingTarget2D: () => (/* binding */ tryCreateCanvasRenderingTarget2D)\n/* harmony export */ });\n/**\n * @experimental\n */\nvar CanvasRenderingTarget2D = /** @class */ (function () {\n    function CanvasRenderingTarget2D(context, mediaSize, bitmapSize) {\n        if (mediaSize.width === 0 || mediaSize.height === 0) {\n            throw new TypeError('Rendering target could only be created on a media with positive width and height');\n        }\n        this._mediaSize = mediaSize;\n        // !Number.isInteger(bitmapSize.width) || !Number.isInteger(bitmapSize.height)\n        if (bitmapSize.width === 0 || bitmapSize.height === 0) {\n            throw new TypeError('Rendering target could only be created using a bitmap with positive integer width and height');\n        }\n        this._bitmapSize = bitmapSize;\n        this._context = context;\n    }\n    CanvasRenderingTarget2D.prototype.useMediaCoordinateSpace = function (f) {\n        try {\n            this._context.save();\n            // do not use resetTransform to support old versions of Edge\n            this._context.setTransform(1, 0, 0, 1, 0, 0);\n            this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio);\n            return f({\n                context: this._context,\n                mediaSize: this._mediaSize,\n            });\n        }\n        finally {\n            this._context.restore();\n        }\n    };\n    CanvasRenderingTarget2D.prototype.useBitmapCoordinateSpace = function (f) {\n        try {\n            this._context.save();\n            // do not use resetTransform to support old versions of Edge\n            this._context.setTransform(1, 0, 0, 1, 0, 0);\n            return f({\n                context: this._context,\n                mediaSize: this._mediaSize,\n                bitmapSize: this._bitmapSize,\n                horizontalPixelRatio: this._horizontalPixelRatio,\n                verticalPixelRatio: this._verticalPixelRatio,\n            });\n        }\n        finally {\n            this._context.restore();\n        }\n    };\n    Object.defineProperty(CanvasRenderingTarget2D.prototype, \"_horizontalPixelRatio\", {\n        get: function () {\n            return this._bitmapSize.width / this._mediaSize.width;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CanvasRenderingTarget2D.prototype, \"_verticalPixelRatio\", {\n        get: function () {\n            return this._bitmapSize.height / this._mediaSize.height;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return CanvasRenderingTarget2D;\n}());\n\n/**\n * @experimental\n */\nfunction createCanvasRenderingTarget2D(binding, contextOptions) {\n    var mediaSize = binding.canvasElementClientSize;\n    var bitmapSize = binding.bitmapSize;\n    var context = binding.canvasElement.getContext('2d', contextOptions);\n    if (context === null) {\n        throw new Error('Could not get 2d drawing context from bound canvas element. Has the canvas already been set to a different context mode?');\n    }\n    return new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);\n}\n/**\n * @experimental\n */\nfunction tryCreateCanvasRenderingTarget2D(binding, contextOptions) {\n    var mediaSize = binding.canvasElementClientSize;\n    if (mediaSize.width === 0 || mediaSize.height === 0) {\n        return null;\n    }\n    var bitmapSize = binding.bitmapSize;\n    if (bitmapSize.width === 0 || bitmapSize.height === 0) {\n        return null;\n    }\n    var context = binding.canvasElement.getContext('2d', contextOptions);\n    if (context === null) {\n        return null;\n    }\n    return new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvY2FudmFzLXJlbmRlcmluZy10YXJnZXQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcZmFuY3ktY2FudmFzXFxjYW52YXMtcmVuZGVyaW5nLXRhcmdldC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW52YXNSZW5kZXJpbmdUYXJnZXQyRChjb250ZXh0LCBtZWRpYVNpemUsIGJpdG1hcFNpemUpIHtcbiAgICAgICAgaWYgKG1lZGlhU2l6ZS53aWR0aCA9PT0gMCB8fCBtZWRpYVNpemUuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZW5kZXJpbmcgdGFyZ2V0IGNvdWxkIG9ubHkgYmUgY3JlYXRlZCBvbiBhIG1lZGlhIHdpdGggcG9zaXRpdmUgd2lkdGggYW5kIGhlaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21lZGlhU2l6ZSA9IG1lZGlhU2l6ZTtcbiAgICAgICAgLy8gIU51bWJlci5pc0ludGVnZXIoYml0bWFwU2l6ZS53aWR0aCkgfHwgIU51bWJlci5pc0ludGVnZXIoYml0bWFwU2l6ZS5oZWlnaHQpXG4gICAgICAgIGlmIChiaXRtYXBTaXplLndpZHRoID09PSAwIHx8IGJpdG1hcFNpemUuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZW5kZXJpbmcgdGFyZ2V0IGNvdWxkIG9ubHkgYmUgY3JlYXRlZCB1c2luZyBhIGJpdG1hcCB3aXRoIHBvc2l0aXZlIGludGVnZXIgd2lkdGggYW5kIGhlaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JpdG1hcFNpemUgPSBiaXRtYXBTaXplO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQucHJvdG90eXBlLnVzZU1lZGlhQ29vcmRpbmF0ZVNwYWNlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgLy8gZG8gbm90IHVzZSByZXNldFRyYW5zZm9ybSB0byBzdXBwb3J0IG9sZCB2ZXJzaW9ucyBvZiBFZGdlXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2NhbGUodGhpcy5faG9yaXpvbnRhbFBpeGVsUmF0aW8sIHRoaXMuX3ZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICByZXR1cm4gZih7XG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5fY29udGV4dCxcbiAgICAgICAgICAgICAgICBtZWRpYVNpemU6IHRoaXMuX21lZGlhU2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbnZhc1JlbmRlcmluZ1RhcmdldDJELnByb3RvdHlwZS51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAvLyBkbyBub3QgdXNlIHJlc2V0VHJhbnNmb3JtIHRvIHN1cHBvcnQgb2xkIHZlcnNpb25zIG9mIEVkZ2VcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuIGYoe1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuX2NvbnRleHQsXG4gICAgICAgICAgICAgICAgbWVkaWFTaXplOiB0aGlzLl9tZWRpYVNpemUsXG4gICAgICAgICAgICAgICAgYml0bWFwU2l6ZTogdGhpcy5fYml0bWFwU2l6ZSxcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsUGl4ZWxSYXRpbzogdGhpcy5faG9yaXpvbnRhbFBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgICAgdmVydGljYWxQaXhlbFJhdGlvOiB0aGlzLl92ZXJ0aWNhbFBpeGVsUmF0aW8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQucHJvdG90eXBlLCBcIl9ob3Jpem9udGFsUGl4ZWxSYXRpb1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpdG1hcFNpemUud2lkdGggLyB0aGlzLl9tZWRpYVNpemUud2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQucHJvdG90eXBlLCBcIl92ZXJ0aWNhbFBpeGVsUmF0aW9cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iaXRtYXBTaXplLmhlaWdodCAvIHRoaXMuX21lZGlhU2l6ZS5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQ7XG59KCkpO1xuZXhwb3J0IHsgQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQgfTtcbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQoYmluZGluZywgY29udGV4dE9wdGlvbnMpIHtcbiAgICB2YXIgbWVkaWFTaXplID0gYmluZGluZy5jYW52YXNFbGVtZW50Q2xpZW50U2l6ZTtcbiAgICB2YXIgYml0bWFwU2l6ZSA9IGJpbmRpbmcuYml0bWFwU2l6ZTtcbiAgICB2YXIgY29udGV4dCA9IGJpbmRpbmcuY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcsIGNvbnRleHRPcHRpb25zKTtcbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgMmQgZHJhd2luZyBjb250ZXh0IGZyb20gYm91bmQgY2FudmFzIGVsZW1lbnQuIEhhcyB0aGUgY2FudmFzIGFscmVhZHkgYmVlbiBzZXQgdG8gYSBkaWZmZXJlbnQgY29udGV4dCBtb2RlPycpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENhbnZhc1JlbmRlcmluZ1RhcmdldDJEKGNvbnRleHQsIG1lZGlhU2l6ZSwgYml0bWFwU2l6ZSk7XG59XG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEKGJpbmRpbmcsIGNvbnRleHRPcHRpb25zKSB7XG4gICAgdmFyIG1lZGlhU2l6ZSA9IGJpbmRpbmcuY2FudmFzRWxlbWVudENsaWVudFNpemU7XG4gICAgaWYgKG1lZGlhU2l6ZS53aWR0aCA9PT0gMCB8fCBtZWRpYVNpemUuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgYml0bWFwU2l6ZSA9IGJpbmRpbmcuYml0bWFwU2l6ZTtcbiAgICBpZiAoYml0bWFwU2l6ZS53aWR0aCA9PT0gMCB8fCBiaXRtYXBTaXplLmhlaWdodCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNvbnRleHQgPSBiaW5kaW5nLmNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQoY29udGV4dCwgbWVkaWFTaXplLCBiaXRtYXBTaXplKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fancy-canvas/canvas-rendering-target.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fancy-canvas/device-pixel-ratio.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/fancy-canvas/device-pixel-ratio.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createObservable: () => (/* binding */ createObservable)\n/* harmony export */ });\nvar Observable = /** @class */ (function () {\n    function Observable(win) {\n        var _this = this;\n        this._resolutionListener = function () { return _this._onResolutionChanged(); };\n        this._resolutionMediaQueryList = null;\n        this._observers = [];\n        this._window = win;\n        this._installResolutionListener();\n    }\n    Observable.prototype.dispose = function () {\n        this._uninstallResolutionListener();\n        this._window = null;\n    };\n    Object.defineProperty(Observable.prototype, \"value\", {\n        get: function () {\n            return this._window.devicePixelRatio;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Observable.prototype.subscribe = function (next) {\n        var _this = this;\n        var observer = { next: next };\n        this._observers.push(observer);\n        return {\n            unsubscribe: function () {\n                _this._observers = _this._observers.filter(function (o) { return o !== observer; });\n            },\n        };\n    };\n    Observable.prototype._installResolutionListener = function () {\n        if (this._resolutionMediaQueryList !== null) {\n            throw new Error('Resolution listener is already installed');\n        }\n        var dppx = this._window.devicePixelRatio;\n        this._resolutionMediaQueryList = this._window.matchMedia(\"all and (resolution: \".concat(dppx, \"dppx)\"));\n        // IE and some versions of Edge do not support addEventListener/removeEventListener, and we are going to use the deprecated addListener/removeListener\n        this._resolutionMediaQueryList.addListener(this._resolutionListener);\n    };\n    Observable.prototype._uninstallResolutionListener = function () {\n        if (this._resolutionMediaQueryList !== null) {\n            // IE and some versions of Edge do not support addEventListener/removeEventListener, and we are going to use the deprecated addListener/removeListener\n            this._resolutionMediaQueryList.removeListener(this._resolutionListener);\n            this._resolutionMediaQueryList = null;\n        }\n    };\n    Observable.prototype._reinstallResolutionListener = function () {\n        this._uninstallResolutionListener();\n        this._installResolutionListener();\n    };\n    Observable.prototype._onResolutionChanged = function () {\n        var _this = this;\n        this._observers.forEach(function (observer) { return observer.next(_this._window.devicePixelRatio); });\n        this._reinstallResolutionListener();\n    };\n    return Observable;\n}());\nfunction createObservable(win) {\n    return new Observable(win);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvZGV2aWNlLXBpeGVsLXJhdGlvLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHdCQUF3QjtBQUNsRyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHVEQUF1RDtBQUM3RztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcZmFuY3ktY2FudmFzXFxkZXZpY2UtcGl4ZWwtcmF0aW8ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBPYnNlcnZhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUod2luKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vblJlc29sdXRpb25DaGFuZ2VkKCk7IH07XG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25NZWRpYVF1ZXJ5TGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLl93aW5kb3cgPSB3aW47XG4gICAgICAgIHRoaXMuX2luc3RhbGxSZXNvbHV0aW9uTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdW5pbnN0YWxsUmVzb2x1dGlvbkxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JzZXJ2YWJsZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHsgbmV4dDogbmV4dCB9O1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9vYnNlcnZlcnMgPSBfdGhpcy5fb2JzZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAobykgeyByZXR1cm4gbyAhPT0gb2JzZXJ2ZXI7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9pbnN0YWxsUmVzb2x1dGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x1dGlvbk1lZGlhUXVlcnlMaXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdXRpb24gbGlzdGVuZXIgaXMgYWxyZWFkeSBpbnN0YWxsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHBweCA9IHRoaXMuX3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB0aGlzLl9yZXNvbHV0aW9uTWVkaWFRdWVyeUxpc3QgPSB0aGlzLl93aW5kb3cubWF0Y2hNZWRpYShcImFsbCBhbmQgKHJlc29sdXRpb246IFwiLmNvbmNhdChkcHB4LCBcImRwcHgpXCIpKTtcbiAgICAgICAgLy8gSUUgYW5kIHNvbWUgdmVyc2lvbnMgb2YgRWRnZSBkbyBub3Qgc3VwcG9ydCBhZGRFdmVudExpc3RlbmVyL3JlbW92ZUV2ZW50TGlzdGVuZXIsIGFuZCB3ZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBkZXByZWNhdGVkIGFkZExpc3RlbmVyL3JlbW92ZUxpc3RlbmVyXG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25NZWRpYVF1ZXJ5TGlzdC5hZGRMaXN0ZW5lcih0aGlzLl9yZXNvbHV0aW9uTGlzdGVuZXIpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3VuaW5zdGFsbFJlc29sdXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdXRpb25NZWRpYVF1ZXJ5TGlzdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSUUgYW5kIHNvbWUgdmVyc2lvbnMgb2YgRWRnZSBkbyBub3Qgc3VwcG9ydCBhZGRFdmVudExpc3RlbmVyL3JlbW92ZUV2ZW50TGlzdGVuZXIsIGFuZCB3ZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBkZXByZWNhdGVkIGFkZExpc3RlbmVyL3JlbW92ZUxpc3RlbmVyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHV0aW9uTWVkaWFRdWVyeUxpc3QucmVtb3ZlTGlzdGVuZXIodGhpcy5fcmVzb2x1dGlvbkxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdXRpb25NZWRpYVF1ZXJ5TGlzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9yZWluc3RhbGxSZXNvbHV0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VuaW5zdGFsbFJlc29sdXRpb25MaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLl9pbnN0YWxsUmVzb2x1dGlvbkxpc3RlbmVyKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fb25SZXNvbHV0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBvYnNlcnZlci5uZXh0KF90aGlzLl93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7IH0pO1xuICAgICAgICB0aGlzLl9yZWluc3RhbGxSZXNvbHV0aW9uTGlzdGVuZXIoKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSgpKTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlKHdpbikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSh3aW4pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fancy-canvas/device-pixel-ratio.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fancy-canvas/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/fancy-canvas/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasRenderingTarget2D: () => (/* reexport safe */ _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__.CanvasRenderingTarget2D),\n/* harmony export */   bindCanvasElementBitmapSizeTo: () => (/* reexport safe */ _canvas_element_bitmap_size_mjs__WEBPACK_IMPORTED_MODULE_1__.bindTo),\n/* harmony export */   createCanvasRenderingTarget2D: () => (/* reexport safe */ _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__.createCanvasRenderingTarget2D),\n/* harmony export */   equalSizes: () => (/* reexport safe */ _size_mjs__WEBPACK_IMPORTED_MODULE_0__.equalSizes),\n/* harmony export */   size: () => (/* reexport safe */ _size_mjs__WEBPACK_IMPORTED_MODULE_0__.size),\n/* harmony export */   tryCreateCanvasRenderingTarget2D: () => (/* reexport safe */ _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__.tryCreateCanvasRenderingTarget2D)\n/* harmony export */ });\n/* harmony import */ var _size_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./size.mjs */ \"(app-pages-browser)/./node_modules/fancy-canvas/size.mjs\");\n/* harmony import */ var _canvas_element_bitmap_size_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas-element-bitmap-size.mjs */ \"(app-pages-browser)/./node_modules/fancy-canvas/canvas-element-bitmap-size.mjs\");\n/* harmony import */ var _canvas_rendering_target_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvas-rendering-target.mjs */ \"(app-pages-browser)/./node_modules/fancy-canvas/canvas-rendering-target.mjs\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE4QztBQUM4QztBQUM4QyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXGZhbmN5LWNhbnZhc1xcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IHNpemUsIGVxdWFsU2l6ZXMgfSBmcm9tIFwiLi9zaXplLm1qc1wiO1xuZXhwb3J0IHsgYmluZFRvIGFzIGJpbmRDYW52YXNFbGVtZW50Qml0bWFwU2l6ZVRvLCB9IGZyb20gXCIuL2NhbnZhcy1lbGVtZW50LWJpdG1hcC1zaXplLm1qc1wiO1xuZXhwb3J0IHsgQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQsIGNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJELCB0cnlDcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCwgfSBmcm9tIFwiLi9jYW52YXMtcmVuZGVyaW5nLXRhcmdldC5tanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fancy-canvas/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fancy-canvas/size.mjs":
/*!********************************************!*\
  !*** ./node_modules/fancy-canvas/size.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equalSizes: () => (/* binding */ equalSizes),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\nfunction size(_a) {\n    var width = _a.width, height = _a.height;\n    if (width < 0) {\n        throw new Error('Negative width is not allowed for Size');\n    }\n    if (height < 0) {\n        throw new Error('Negative height is not allowed for Size');\n    }\n    return {\n        width: width,\n        height: height,\n    };\n}\nfunction equalSizes(first, second) {\n    return (first.width === second.width) &&\n        (first.height === second.height);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW5jeS1jYW52YXMvc2l6ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcZmFuY3ktY2FudmFzXFxzaXplLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gc2l6ZShfYSkge1xuICAgIHZhciB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZ2F0aXZlIHdpZHRoIGlzIG5vdCBhbGxvd2VkIGZvciBTaXplJyk7XG4gICAgfVxuICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVnYXRpdmUgaGVpZ2h0IGlzIG5vdCBhbGxvd2VkIGZvciBTaXplJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbFNpemVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICByZXR1cm4gKGZpcnN0LndpZHRoID09PSBzZWNvbmQud2lkdGgpICYmXG4gICAgICAgIChmaXJzdC5oZWlnaHQgPT09IHNlY29uZC5oZWlnaHQpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fancy-canvas/size.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AreaSeries: () => (/* binding */ areaSeries),\n/* harmony export */   BarSeries: () => (/* binding */ barSeries),\n/* harmony export */   BaselineSeries: () => (/* binding */ baselineSeries),\n/* harmony export */   CandlestickSeries: () => (/* binding */ candlestickSeries),\n/* harmony export */   ColorType: () => (/* binding */ ColorType),\n/* harmony export */   CrosshairMode: () => (/* binding */ CrosshairMode),\n/* harmony export */   HistogramSeries: () => (/* binding */ histogramSeries),\n/* harmony export */   LastPriceAnimationMode: () => (/* binding */ LastPriceAnimationMode),\n/* harmony export */   LineSeries: () => (/* binding */ lineSeries),\n/* harmony export */   LineStyle: () => (/* binding */ LineStyle),\n/* harmony export */   LineType: () => (/* binding */ LineType),\n/* harmony export */   MismatchDirection: () => (/* binding */ MismatchDirection),\n/* harmony export */   PriceLineSource: () => (/* binding */ PriceLineSource),\n/* harmony export */   PriceScaleMode: () => (/* binding */ PriceScaleMode),\n/* harmony export */   TickMarkType: () => (/* binding */ TickMarkType),\n/* harmony export */   TrackingModeExitMode: () => (/* binding */ TrackingModeExitMode),\n/* harmony export */   createChart: () => (/* binding */ createChart),\n/* harmony export */   createChartEx: () => (/* binding */ createChartEx),\n/* harmony export */   createImageWatermark: () => (/* binding */ createImageWatermark),\n/* harmony export */   createOptionsChart: () => (/* binding */ createOptionsChart),\n/* harmony export */   createSeriesMarkers: () => (/* binding */ createSeriesMarkers),\n/* harmony export */   createTextWatermark: () => (/* binding */ createTextWatermark),\n/* harmony export */   createUpDownMarkers: () => (/* binding */ createUpDownMarkers),\n/* harmony export */   createYieldCurveChart: () => (/* binding */ createYieldCurveChart),\n/* harmony export */   customSeriesDefaultOptions: () => (/* binding */ customSeriesDefaultOptions),\n/* harmony export */   defaultHorzScaleBehavior: () => (/* binding */ defaultHorzScaleBehavior),\n/* harmony export */   isBusinessDay: () => (/* binding */ isBusinessDay),\n/* harmony export */   isUTCTimestamp: () => (/* binding */ isUTCTimestamp),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var fancy_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fancy-canvas */ \"(app-pages-browser)/./node_modules/fancy-canvas/index.mjs\");\n/*!\n * @license\n * TradingView Lightweight Charts v5.0.7\n * Copyright (c) 2025 TradingView, Inc.\n * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0\n */\n\n\nconst customStyleDefaults$1 = {\n    color: '#2196f3',\n};\nconst seriesOptionsDefaults = {\n    title: '',\n    visible: true,\n    lastValueVisible: true,\n    priceLineVisible: true,\n    priceLineSource: 0 /* PriceLineSource.LastBar */,\n    priceLineWidth: 1,\n    priceLineColor: '',\n    priceLineStyle: 2 /* LineStyle.Dashed */,\n    baseLineVisible: true,\n    baseLineWidth: 1,\n    baseLineColor: '#B2B5BE',\n    baseLineStyle: 0 /* LineStyle.Solid */,\n    priceFormat: {\n        type: 'price',\n        precision: 2,\n        minMove: 0.01,\n    },\n};\n\n/**\n * Represents the possible line types.\n */\nvar LineType;\n(function (LineType) {\n    /**\n     * A line.\n     */\n    LineType[LineType[\"Simple\"] = 0] = \"Simple\";\n    /**\n     * A stepped line.\n     */\n    LineType[LineType[\"WithSteps\"] = 1] = \"WithSteps\";\n    /**\n     * A curved line.\n     */\n    LineType[LineType[\"Curved\"] = 2] = \"Curved\";\n})(LineType || (LineType = {}));\n/**\n * Represents the possible line styles.\n */\nvar LineStyle;\n(function (LineStyle) {\n    /**\n     * A solid line.\n     */\n    LineStyle[LineStyle[\"Solid\"] = 0] = \"Solid\";\n    /**\n     * A dotted line.\n     */\n    LineStyle[LineStyle[\"Dotted\"] = 1] = \"Dotted\";\n    /**\n     * A dashed line.\n     */\n    LineStyle[LineStyle[\"Dashed\"] = 2] = \"Dashed\";\n    /**\n     * A dashed line with bigger dashes.\n     */\n    LineStyle[LineStyle[\"LargeDashed\"] = 3] = \"LargeDashed\";\n    /**\n     * A dotted line with more space between dots.\n     */\n    LineStyle[LineStyle[\"SparseDotted\"] = 4] = \"SparseDotted\";\n})(LineStyle || (LineStyle = {}));\nfunction setLineStyle(ctx, style) {\n    const dashPatterns = {\n        [0 /* LineStyle.Solid */]: [],\n        [1 /* LineStyle.Dotted */]: [ctx.lineWidth, ctx.lineWidth],\n        [2 /* LineStyle.Dashed */]: [2 * ctx.lineWidth, 2 * ctx.lineWidth],\n        [3 /* LineStyle.LargeDashed */]: [6 * ctx.lineWidth, 6 * ctx.lineWidth],\n        [4 /* LineStyle.SparseDotted */]: [ctx.lineWidth, 4 * ctx.lineWidth],\n    };\n    const dashPattern = dashPatterns[style];\n    ctx.setLineDash(dashPattern);\n}\nfunction drawHorizontalLine(ctx, y, left, right) {\n    ctx.beginPath();\n    const correction = (ctx.lineWidth % 2) ? 0.5 : 0;\n    ctx.moveTo(left, y + correction);\n    ctx.lineTo(right, y + correction);\n    ctx.stroke();\n}\nfunction drawVerticalLine(ctx, x, top, bottom) {\n    ctx.beginPath();\n    const correction = (ctx.lineWidth % 2) ? 0.5 : 0;\n    ctx.moveTo(x + correction, top);\n    ctx.lineTo(x + correction, bottom);\n    ctx.stroke();\n}\nfunction strokeInPixel(ctx, drawFunction) {\n    ctx.save();\n    if (ctx.lineWidth % 2) {\n        ctx.translate(0.5, 0.5);\n    }\n    drawFunction();\n    ctx.restore();\n}\n\n/**\n * Checks an assertion. Throws if the assertion is failed.\n *\n * @param condition - Result of the assertion evaluation\n * @param message - Text to include in the exception message\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error('Assertion failed' + (message ? ': ' + message : ''));\n    }\n}\nfunction ensureDefined(value) {\n    if (value === undefined) {\n        throw new Error('Value is undefined');\n    }\n    return value;\n}\nfunction ensureNotNull(value) {\n    if (value === null) {\n        throw new Error('Value is null');\n    }\n    return value;\n}\nfunction ensure(value) {\n    return ensureNotNull(ensureDefined(value));\n}\n/**\n * Compile time check for never\n */\nfunction ensureNever(value) { }\n\nclass Delegate {\n    constructor() {\n        this._private__listeners = [];\n    }\n    _internal_subscribe(callback, linkedObject, singleshot) {\n        const listener = {\n            _internal_callback: callback,\n            _internal_linkedObject: linkedObject,\n            _internal_singleshot: singleshot === true,\n        };\n        this._private__listeners.push(listener);\n    }\n    _internal_unsubscribe(callback) {\n        const index = this._private__listeners.findIndex((listener) => callback === listener._internal_callback);\n        if (index > -1) {\n            this._private__listeners.splice(index, 1);\n        }\n    }\n    _internal_unsubscribeAll(linkedObject) {\n        this._private__listeners = this._private__listeners.filter((listener) => listener._internal_linkedObject !== linkedObject);\n    }\n    _internal_fire(param1, param2, param3) {\n        const listenersSnapshot = [...this._private__listeners];\n        this._private__listeners = this._private__listeners.filter((listener) => !listener._internal_singleshot);\n        listenersSnapshot.forEach((listener) => listener._internal_callback(param1, param2, param3));\n    }\n    _internal_hasListeners() {\n        return this._private__listeners.length > 0;\n    }\n    _internal_destroy() {\n        this._private__listeners = [];\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction merge(dst, ...sources) {\n    for (const src of sources) {\n        // eslint-disable-next-line no-restricted-syntax\n        for (const i in src) {\n            if (src[i] === undefined ||\n                !Object.prototype.hasOwnProperty.call(src, i) ||\n                ['__proto__', 'constructor', 'prototype'].includes(i)) {\n                continue;\n            }\n            if ('object' !== typeof src[i] || dst[i] === undefined || Array.isArray(src[i])) {\n                dst[i] = src[i];\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                merge(dst[i], src[i]);\n            }\n        }\n    }\n    return dst;\n}\nfunction isNumber(value) {\n    return (typeof value === 'number') && (isFinite(value));\n}\nfunction isInteger(value) {\n    return (typeof value === 'number') && ((value % 1) === 0);\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\nfunction clone(object) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const o = object;\n    if (!o || 'object' !== typeof o) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return o;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let c;\n    if (Array.isArray(o)) {\n        c = [];\n    }\n    else {\n        c = {};\n    }\n    let p;\n    let v;\n    // eslint-disable-next-line no-restricted-syntax\n    for (p in o) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,no-prototype-builtins\n        if (o.hasOwnProperty(p)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            v = o[p];\n            if (v && 'object' === typeof v) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                c[p] = clone(v);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                c[p] = v;\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return c;\n}\nfunction notNull(t) {\n    return t !== null;\n}\nfunction undefinedIfNull(t) {\n    return (t === null) ? undefined : t;\n}\n\n/**\n * Default font family.\n * Must be used to generate font string when font is not specified.\n */\nconst defaultFontFamily = `-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif`;\n/**\n * Generates a font string, which can be used to set in canvas' font property.\n * If no family provided, {@link defaultFontFamily} will be used.\n *\n * @param size - Font size in pixels.\n * @param family - Optional font family.\n * @param style - Optional font style.\n * @returns The font string.\n */\nfunction makeFont(size, family, style) {\n    if (style !== undefined) {\n        style = `${style} `;\n    }\n    else {\n        style = '';\n    }\n    if (family === undefined) {\n        family = defaultFontFamily;\n    }\n    return `${style}${size}px ${family}`;\n}\n\nclass PriceAxisRendererOptionsProvider {\n    constructor(chartModel) {\n        this._private__rendererOptions = {\n            _internal_borderSize: 1 /* RendererConstants.BorderSize */,\n            _internal_tickLength: 5 /* RendererConstants.TickLength */,\n            _internal_fontSize: NaN,\n            _internal_font: '',\n            _internal_fontFamily: '',\n            _internal_color: '',\n            _internal_paneBackgroundColor: '',\n            _internal_paddingBottom: 0,\n            _internal_paddingInner: 0,\n            _internal_paddingOuter: 0,\n            _internal_paddingTop: 0,\n            _internal_baselineOffset: 0,\n        };\n        this._private__chartModel = chartModel;\n    }\n    _internal_options() {\n        const rendererOptions = this._private__rendererOptions;\n        const currentFontSize = this._private__fontSize();\n        const currentFontFamily = this._private__fontFamily();\n        if (rendererOptions._internal_fontSize !== currentFontSize || rendererOptions._internal_fontFamily !== currentFontFamily) {\n            rendererOptions._internal_fontSize = currentFontSize;\n            rendererOptions._internal_fontFamily = currentFontFamily;\n            rendererOptions._internal_font = makeFont(currentFontSize, currentFontFamily);\n            rendererOptions._internal_paddingTop = 2.5 / 12 * currentFontSize; // 2.5 px for 12px font\n            rendererOptions._internal_paddingBottom = rendererOptions._internal_paddingTop;\n            rendererOptions._internal_paddingInner = currentFontSize / 12 * rendererOptions._internal_tickLength;\n            rendererOptions._internal_paddingOuter = currentFontSize / 12 * rendererOptions._internal_tickLength;\n            rendererOptions._internal_baselineOffset = 0;\n        }\n        rendererOptions._internal_color = this._private__textColor();\n        rendererOptions._internal_paneBackgroundColor = this._private__paneBackgroundColor();\n        return this._private__rendererOptions;\n    }\n    _private__textColor() {\n        return this._private__chartModel._internal_options()['layout'].textColor;\n    }\n    _private__paneBackgroundColor() {\n        return this._private__chartModel._internal_backgroundTopColor();\n    }\n    _private__fontSize() {\n        return this._private__chartModel._internal_options()['layout'].fontSize;\n    }\n    _private__fontFamily() {\n        return this._private__chartModel._internal_options()['layout'].fontFamily;\n    }\n}\n\nfunction normalizeRgbComponent(component) {\n    if (component < 0) {\n        return 0;\n    }\n    if (component > 255) {\n        return 255;\n    }\n    // NaN values are treated as 0\n    return (Math.round(component) || 0);\n}\nfunction normalizeAlphaComponent(component) {\n    if (component <= 0 || component > 1) {\n        return Math.min(Math.max(component, 0), 1);\n    }\n    // limit the precision of all numbers to at most 4 digits in fractional part\n    return (Math.round(component * 10000) / 10000);\n}\nfunction rgbaToGrayscale(rgbValue) {\n    // Originally, the NTSC RGB to YUV formula\n    // perfected by @eugene-korobko's black magic\n    const redComponentGrayscaleWeight = 0.199;\n    const greenComponentGrayscaleWeight = 0.687;\n    const blueComponentGrayscaleWeight = 0.114;\n    return (redComponentGrayscaleWeight * rgbValue[0] +\n        greenComponentGrayscaleWeight * rgbValue[1] +\n        blueComponentGrayscaleWeight * rgbValue[2]);\n}\n/**\n * For colors which fall within the sRGB space, the browser can\n * be used to convert the color string into a rgb /rgba string.\n *\n * For other colors, it will be returned as specified (i.e. for\n * newer formats like display-p3)\n *\n * See: https://www.w3.org/TR/css-color-4/#serializing-sRGB-values\n */\nfunction getRgbStringViaBrowser(color) {\n    const element = document.createElement('div');\n    element.style.display = 'none';\n    // We append to the body as it is the most reliable way to get a color reading\n    // appending to the chart container or similar element can result in the following\n    // getComputedStyle returning empty strings on each check.\n    document.body.appendChild(element);\n    element.style.color = color;\n    const computed = window.getComputedStyle(element).color;\n    document.body.removeChild(element);\n    return computed;\n}\nclass ColorParser {\n    constructor(customParsers, initialCache) {\n        this._private__rgbaCache = new Map();\n        this._private__customParsers = customParsers;\n        if (initialCache) {\n            this._private__rgbaCache = initialCache;\n        }\n    }\n    /**\n     * We fallback to RGBA here since supporting alpha transformations\n     * on wider color gamuts would currently be a lot of extra code\n     * for very little benefit due to actual usage.\n     */\n    _internal_applyAlpha(color, alpha) {\n        // special case optimization\n        if (color === 'transparent') {\n            return color;\n        }\n        const originRgba = this._private__parseColor(color);\n        const originAlpha = originRgba[3];\n        return `rgba(${originRgba[0]}, ${originRgba[1]}, ${originRgba[2]}, ${alpha * originAlpha})`;\n    }\n    _internal_generateContrastColors(background) {\n        const rgba = this._private__parseColor(background);\n        return {\n            _internal_background: `rgb(${rgba[0]}, ${rgba[1]}, ${rgba[2]})`, // no alpha\n            _internal_foreground: rgbaToGrayscale(rgba) > 160 ? 'black' : 'white',\n        };\n    }\n    _internal_colorStringToGrayscale(background) {\n        return rgbaToGrayscale(this._private__parseColor(background));\n    }\n    _internal_gradientColorAtPercent(topColor, bottomColor, percent) {\n        const [topR, topG, topB, topA] = this._private__parseColor(topColor);\n        const [bottomR, bottomG, bottomB, bottomA] = this._private__parseColor(bottomColor);\n        const resultRgba = [\n            normalizeRgbComponent((topR + percent * (bottomR - topR))),\n            normalizeRgbComponent((topG + percent * (bottomG - topG))),\n            normalizeRgbComponent((topB + percent * (bottomB - topB))),\n            normalizeAlphaComponent((topA + percent * (bottomA - topA))),\n        ];\n        return `rgba(${resultRgba[0]}, ${resultRgba[1]}, ${resultRgba[2]}, ${resultRgba[3]})`;\n    }\n    _private__parseColor(color) {\n        const cached = this._private__rgbaCache.get(color);\n        if (cached) {\n            return cached;\n        }\n        const computed = getRgbStringViaBrowser(color);\n        const match = computed.match(/^rgba?\\s*\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d*\\.?\\d+))?\\)$/);\n        if (!match) {\n            if (this._private__customParsers.length) {\n                for (const parser of this._private__customParsers) {\n                    const result = parser(color);\n                    if (result) {\n                        this._private__rgbaCache.set(color, result);\n                        return result;\n                    }\n                }\n            }\n            throw new Error(`Failed to parse color: ${color}`);\n        }\n        const rgba = [\n            parseInt(match[1], 10),\n            parseInt(match[2], 10),\n            parseInt(match[3], 10),\n            (match[4] ? parseFloat(match[4]) : 1),\n        ];\n        this._private__rgbaCache.set(color, rgba);\n        return rgba;\n    }\n}\n\nclass CompositeRenderer {\n    constructor() {\n        this._private__renderers = [];\n    }\n    _internal_setRenderers(renderers) {\n        this._private__renderers = renderers;\n    }\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__renderers.forEach((r) => {\n            r._internal_draw(target, isHovered, hitTestData);\n        });\n    }\n}\n\nclass BitmapCoordinatesPaneRenderer {\n    _internal_draw(target, isHovered, hitTestData) {\n        target.useBitmapCoordinateSpace((scope) => this._internal__drawImpl(scope, isHovered, hitTestData));\n    }\n}\n\nclass PaneRendererMarks extends BitmapCoordinatesPaneRenderer {\n    constructor() {\n        super(...arguments);\n        this._internal__data = null;\n    }\n    _internal_setData(data) {\n        this._internal__data = data;\n    }\n    _internal__drawImpl({ context: ctx, horizontalPixelRatio, verticalPixelRatio }) {\n        if (this._internal__data === null || this._internal__data._internal_visibleRange === null) {\n            return;\n        }\n        const visibleRange = this._internal__data._internal_visibleRange;\n        const data = this._internal__data;\n        const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n        const correction = (tickWidth % 2) / 2;\n        const draw = (radiusMedia) => {\n            ctx.beginPath();\n            for (let i = visibleRange.to - 1; i >= visibleRange.from; --i) {\n                const point = data._internal_items[i];\n                const centerX = Math.round(point._internal_x * horizontalPixelRatio) + correction; // correct x coordinate only\n                const centerY = point._internal_y * verticalPixelRatio;\n                const radius = radiusMedia * verticalPixelRatio + correction;\n                ctx.moveTo(centerX, centerY);\n                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n            }\n            ctx.fill();\n        };\n        if (data._internal_lineWidth > 0) {\n            ctx.fillStyle = data._internal_backColor;\n            draw(data._internal_radius + data._internal_lineWidth);\n        }\n        ctx.fillStyle = data._internal_lineColor;\n        draw(data._internal_radius);\n    }\n}\n\nfunction createEmptyMarkerData() {\n    return {\n        _internal_items: [{\n                _internal_x: 0,\n                _internal_y: 0,\n                _internal_time: 0,\n                _internal_price: 0,\n            }],\n        _internal_lineColor: '',\n        _internal_backColor: '',\n        _internal_radius: 0,\n        _internal_lineWidth: 0,\n        _internal_visibleRange: null,\n    };\n}\nconst rangeForSinglePoint = { from: 0, to: 1 };\nclass CrosshairMarksPaneView {\n    constructor(chartModel, crosshair, pane) {\n        this._private__compositeRenderer = new CompositeRenderer();\n        this._private__markersRenderers = [];\n        this._private__markersData = [];\n        this._private__invalidated = true;\n        this._private__chartModel = chartModel;\n        this._private__crosshair = crosshair;\n        this._private__pane = pane;\n        this._private__compositeRenderer._internal_setRenderers(this._private__markersRenderers);\n    }\n    _internal_update(updateType) {\n        this._private__createMarkerRenderersIfNeeded();\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n        }\n        return this._private__compositeRenderer;\n    }\n    _private__createMarkerRenderersIfNeeded() {\n        const serieses = this._private__pane._internal_orderedSources();\n        if (serieses.length !== this._private__markersRenderers.length) {\n            this._private__markersData = serieses.map(createEmptyMarkerData);\n            this._private__markersRenderers = this._private__markersData.map((data) => {\n                const res = new PaneRendererMarks();\n                res._internal_setData(data);\n                return res;\n            });\n            this._private__compositeRenderer._internal_setRenderers(this._private__markersRenderers);\n        }\n    }\n    _private__updateImpl() {\n        const forceHidden = this._private__crosshair._internal_options().mode === 2 /* CrosshairMode.Hidden */ || !this._private__crosshair._internal_visible();\n        const serieses = this._private__pane._internal_orderedSeries();\n        const timePointIndex = this._private__crosshair._internal_appliedIndex();\n        const timeScale = this._private__chartModel._internal_timeScale();\n        this._private__createMarkerRenderersIfNeeded();\n        serieses.forEach((s, index) => {\n            const data = this._private__markersData[index];\n            const seriesData = s._internal_markerDataAtIndex(timePointIndex);\n            const firstValue = s._internal_firstValue();\n            if (forceHidden || seriesData === null || !s._internal_visible() || firstValue === null) {\n                data._internal_visibleRange = null;\n                return;\n            }\n            data._internal_lineColor = seriesData._internal_backgroundColor;\n            data._internal_radius = seriesData._internal_radius;\n            data._internal_lineWidth = seriesData._internal_borderWidth;\n            data._internal_items[0]._internal_price = seriesData._internal_price;\n            data._internal_items[0]._internal_y = s._internal_priceScale()._internal_priceToCoordinate(seriesData._internal_price, firstValue._internal_value);\n            data._internal_backColor = seriesData._internal_borderColor ?? this._private__chartModel._internal_backgroundColorAtYPercentFromTop(data._internal_items[0]._internal_y / s._internal_priceScale()._internal_height());\n            data._internal_items[0]._internal_time = timePointIndex;\n            data._internal_items[0]._internal_x = timeScale._internal_indexToCoordinate(timePointIndex);\n            data._internal_visibleRange = rangeForSinglePoint;\n        });\n    }\n}\n\nclass CrosshairRenderer extends BitmapCoordinatesPaneRenderer {\n    constructor(data) {\n        super();\n        this._private__data = data;\n    }\n    _internal__drawImpl({ context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio }) {\n        if (this._private__data === null) {\n            return;\n        }\n        const vertLinesVisible = this._private__data._internal_vertLine._internal_visible;\n        const horzLinesVisible = this._private__data._internal_horzLine._internal_visible;\n        if (!vertLinesVisible && !horzLinesVisible) {\n            return;\n        }\n        const x = Math.round(this._private__data._internal_x * horizontalPixelRatio);\n        const y = Math.round(this._private__data._internal_y * verticalPixelRatio);\n        ctx.lineCap = 'butt';\n        if (vertLinesVisible && x >= 0) {\n            ctx.lineWidth = Math.floor(this._private__data._internal_vertLine._internal_lineWidth * horizontalPixelRatio);\n            ctx.strokeStyle = this._private__data._internal_vertLine._internal_color;\n            ctx.fillStyle = this._private__data._internal_vertLine._internal_color;\n            setLineStyle(ctx, this._private__data._internal_vertLine._internal_lineStyle);\n            drawVerticalLine(ctx, x, 0, bitmapSize.height);\n        }\n        if (horzLinesVisible && y >= 0) {\n            ctx.lineWidth = Math.floor(this._private__data._internal_horzLine._internal_lineWidth * verticalPixelRatio);\n            ctx.strokeStyle = this._private__data._internal_horzLine._internal_color;\n            ctx.fillStyle = this._private__data._internal_horzLine._internal_color;\n            setLineStyle(ctx, this._private__data._internal_horzLine._internal_lineStyle);\n            drawHorizontalLine(ctx, y, 0, bitmapSize.width);\n        }\n    }\n}\n\nclass CrosshairPaneView {\n    constructor(source, pane) {\n        this._private__invalidated = true;\n        this._private__rendererData = {\n            _internal_vertLine: {\n                _internal_lineWidth: 1,\n                _internal_lineStyle: 0,\n                _internal_color: '',\n                _internal_visible: false,\n            },\n            _internal_horzLine: {\n                _internal_lineWidth: 1,\n                _internal_lineStyle: 0,\n                _internal_color: '',\n                _internal_visible: false,\n            },\n            _internal_x: 0,\n            _internal_y: 0,\n        };\n        this._private__renderer = new CrosshairRenderer(this._private__rendererData);\n        this._private__source = source;\n        this._private__pane = pane;\n    }\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer(pane) {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n        }\n        return this._private__renderer;\n    }\n    _private__updateImpl() {\n        const visible = this._private__source._internal_visible();\n        const crosshairOptions = this._private__pane._internal_model()._internal_options().crosshair;\n        const data = this._private__rendererData;\n        if (crosshairOptions.mode === 2 /* CrosshairMode.Hidden */) {\n            data._internal_horzLine._internal_visible = false;\n            data._internal_vertLine._internal_visible = false;\n            return;\n        }\n        data._internal_horzLine._internal_visible = visible && this._private__source._internal_horzLineVisible(this._private__pane);\n        data._internal_vertLine._internal_visible = visible && this._private__source._internal_vertLineVisible();\n        data._internal_horzLine._internal_lineWidth = crosshairOptions.horzLine.width;\n        data._internal_horzLine._internal_lineStyle = crosshairOptions.horzLine.style;\n        data._internal_horzLine._internal_color = crosshairOptions.horzLine.color;\n        data._internal_vertLine._internal_lineWidth = crosshairOptions.vertLine.width;\n        data._internal_vertLine._internal_lineStyle = crosshairOptions.vertLine.style;\n        data._internal_vertLine._internal_color = crosshairOptions.vertLine.color;\n        data._internal_x = this._private__source._internal_appliedX();\n        data._internal_y = this._private__source._internal_appliedY();\n    }\n}\n\n/**\n * Fills rectangle's inner border (so, all the filled area is limited by the [x, x + width]*[y, y + height] region)\n * ```\n * (x, y)\n * O***********************|*****\n * |        border         |  ^\n * |   *****************   |  |\n * |   |               |   |  |\n * | b |               | b |  h\n * | o |               | o |  e\n * | r |               | r |  i\n * | d |               | d |  g\n * | e |               | e |  h\n * | r |               | r |  t\n * |   |               |   |  |\n * |   *****************   |  |\n * |        border         |  v\n * |***********************|*****\n * |                       |\n * |<------- width ------->|\n * ```\n *\n * @param ctx - Context to draw on\n * @param x - Left side of the target rectangle\n * @param y - Top side of the target rectangle\n * @param width - Width of the target rectangle\n * @param height - Height of the target rectangle\n * @param borderWidth - Width of border to fill, must be less than width and height of the target rectangle\n */\nfunction fillRectInnerBorder(ctx, x, y, width, height, borderWidth) {\n    // horizontal (top and bottom) edges\n    ctx.fillRect(x + borderWidth, y, width - borderWidth * 2, borderWidth);\n    ctx.fillRect(x + borderWidth, y + height - borderWidth, width - borderWidth * 2, borderWidth);\n    // vertical (left and right) edges\n    ctx.fillRect(x, y, borderWidth, height);\n    ctx.fillRect(x + width - borderWidth, y, borderWidth, height);\n}\nfunction clearRect(ctx, x, y, w, h, clearColor) {\n    ctx.save();\n    ctx.globalCompositeOperation = 'copy';\n    ctx.fillStyle = clearColor;\n    ctx.fillRect(x, y, w, h);\n    ctx.restore();\n}\nfunction changeBorderRadius(borderRadius, offset) {\n    return borderRadius.map((x) => x === 0 ? x : x + offset);\n}\nfunction drawRoundRect(\n// eslint:disable-next-line:max-params\nctx, x, y, w, h, radii) {\n    /**\n     * As of May 2023, all of the major browsers now support ctx.roundRect() so we should\n     * be able to switch to the native version soon.\n     */\n    ctx.beginPath();\n    if (ctx.roundRect) {\n        ctx.roundRect(x, y, w, h, radii);\n        return;\n    }\n    /*\n     * Deprecate the rest in v5.\n     */\n    ctx.lineTo(x + w - radii[1], y);\n    if (radii[1] !== 0) {\n        ctx.arcTo(x + w, y, x + w, y + radii[1], radii[1]);\n    }\n    ctx.lineTo(x + w, y + h - radii[2]);\n    if (radii[2] !== 0) {\n        ctx.arcTo(x + w, y + h, x + w - radii[2], y + h, radii[2]);\n    }\n    ctx.lineTo(x + radii[3], y + h);\n    if (radii[3] !== 0) {\n        ctx.arcTo(x, y + h, x, y + h - radii[3], radii[3]);\n    }\n    ctx.lineTo(x, y + radii[0]);\n    if (radii[0] !== 0) {\n        ctx.arcTo(x, y, x + radii[0], y, radii[0]);\n    }\n}\n/**\n * Draws a rounded rect with a border.\n *\n * This function assumes that the colors will be solid, without\n * any alpha. (This allows us to fix a rendering artefact.)\n *\n * @param outerBorderRadius - The radius of the border (outer edge)\n */\n// eslint-disable-next-line max-params\nfunction drawRoundRectWithBorder(ctx, left, top, width, height, backgroundColor, borderWidth = 0, outerBorderRadius = [0, 0, 0, 0], borderColor = '') {\n    ctx.save();\n    if (!borderWidth || !borderColor || borderColor === backgroundColor) {\n        drawRoundRect(ctx, left, top, width, height, outerBorderRadius);\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n        return;\n    }\n    const halfBorderWidth = borderWidth / 2;\n    const radii = changeBorderRadius(outerBorderRadius, -halfBorderWidth);\n    drawRoundRect(ctx, left + halfBorderWidth, top + halfBorderWidth, width - borderWidth, height - borderWidth, radii);\n    if (backgroundColor !== 'transparent') {\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n    }\n    if (borderColor !== 'transparent') {\n        ctx.lineWidth = borderWidth;\n        ctx.strokeStyle = borderColor;\n        ctx.closePath();\n        ctx.stroke();\n    }\n    ctx.restore();\n}\n// eslint-disable-next-line max-params\nfunction clearRectWithGradient(ctx, x, y, w, h, topColor, bottomColor) {\n    ctx.save();\n    ctx.globalCompositeOperation = 'copy';\n    const gradient = ctx.createLinearGradient(0, 0, 0, h);\n    gradient.addColorStop(0, topColor);\n    gradient.addColorStop(1, bottomColor);\n    ctx.fillStyle = gradient;\n    ctx.fillRect(x, y, w, h);\n    ctx.restore();\n}\n\nclass PriceAxisViewRenderer {\n    constructor(data, commonData) {\n        this._internal_setData(data, commonData);\n    }\n    _internal_setData(data, commonData) {\n        this._private__data = data;\n        this._private__commonData = commonData;\n    }\n    _internal_height(rendererOptions, useSecondLine) {\n        if (!this._private__data._internal_visible) {\n            return 0;\n        }\n        return rendererOptions._internal_fontSize + rendererOptions._internal_paddingTop + rendererOptions._internal_paddingBottom;\n    }\n    _internal_draw(target, rendererOptions, textWidthCache, align) {\n        if (!this._private__data._internal_visible || this._private__data._internal_text.length === 0) {\n            return;\n        }\n        const textColor = this._private__data._internal_color;\n        const backgroundColor = this._private__commonData._internal_background;\n        const geometry = target.useBitmapCoordinateSpace((scope) => {\n            const ctx = scope.context;\n            ctx.font = rendererOptions._internal_font;\n            const geom = this._private__calculateGeometry(scope, rendererOptions, textWidthCache, align);\n            const gb = geom._internal_bitmap;\n            /*\n             draw label. backgroundColor will always be a solid color (no alpha) [see generateContrastColors in color.ts].\n             Therefore we can draw the rounded label using simplified code (drawRoundRectWithBorder) that doesn't need to ensure the background and the border don't overlap.\n            */\n            if (geom._internal_alignRight) {\n                drawRoundRectWithBorder(ctx, gb._internal_xOutside, gb._internal_yTop, gb._internal_totalWidth, gb._internal_totalHeight, backgroundColor, gb._internal_horzBorder, [gb._internal_radius, 0, 0, gb._internal_radius], backgroundColor);\n            }\n            else {\n                drawRoundRectWithBorder(ctx, gb._internal_xInside, gb._internal_yTop, gb._internal_totalWidth, gb._internal_totalHeight, backgroundColor, gb._internal_horzBorder, [0, gb._internal_radius, gb._internal_radius, 0], backgroundColor);\n            }\n            // draw tick\n            if (this._private__data._internal_tickVisible) {\n                ctx.fillStyle = textColor;\n                ctx.fillRect(gb._internal_xInside, gb._internal_yMid, gb._internal_xTick - gb._internal_xInside, gb._internal_tickHeight);\n            }\n            // draw separator\n            if (this._private__data._internal_borderVisible) {\n                ctx.fillStyle = rendererOptions._internal_paneBackgroundColor;\n                ctx.fillRect(geom._internal_alignRight ? gb._internal_right - gb._internal_horzBorder : 0, gb._internal_yTop, gb._internal_horzBorder, gb._internal_yBottom - gb._internal_yTop);\n            }\n            return geom;\n        });\n        target.useMediaCoordinateSpace(({ context: ctx }) => {\n            const gm = geometry._internal_media;\n            ctx.font = rendererOptions._internal_font;\n            ctx.textAlign = geometry._internal_alignRight ? 'right' : 'left';\n            ctx.textBaseline = 'middle';\n            ctx.fillStyle = textColor;\n            ctx.fillText(this._private__data._internal_text, gm._internal_xText, (gm._internal_yTop + gm._internal_yBottom) / 2 + gm._internal_textMidCorrection);\n        });\n    }\n    _private__calculateGeometry(scope, rendererOptions, textWidthCache, align) {\n        const { context: ctx, bitmapSize, mediaSize, horizontalPixelRatio, verticalPixelRatio } = scope;\n        const tickSize = (this._private__data._internal_tickVisible || !this._private__data._internal_moveTextToInvisibleTick) ? rendererOptions._internal_tickLength : 0;\n        const horzBorder = this._private__data._internal_separatorVisible ? rendererOptions._internal_borderSize : 0;\n        const paddingTop = rendererOptions._internal_paddingTop + this._private__commonData._internal_additionalPaddingTop;\n        const paddingBottom = rendererOptions._internal_paddingBottom + this._private__commonData._internal_additionalPaddingBottom;\n        const paddingInner = rendererOptions._internal_paddingInner;\n        const paddingOuter = rendererOptions._internal_paddingOuter;\n        const text = this._private__data._internal_text;\n        const actualTextHeight = rendererOptions._internal_fontSize;\n        const textMidCorrection = textWidthCache._internal_yMidCorrection(ctx, text);\n        const textWidth = Math.ceil(textWidthCache._internal_measureText(ctx, text));\n        const totalHeight = actualTextHeight + paddingTop + paddingBottom;\n        const totalWidth = rendererOptions._internal_borderSize + paddingInner + paddingOuter + textWidth + tickSize;\n        const tickHeightBitmap = Math.max(1, Math.floor(verticalPixelRatio));\n        let totalHeightBitmap = Math.round(totalHeight * verticalPixelRatio);\n        if (totalHeightBitmap % 2 !== tickHeightBitmap % 2) {\n            totalHeightBitmap += 1;\n        }\n        const horzBorderBitmap = horzBorder > 0 ? Math.max(1, Math.floor(horzBorder * horizontalPixelRatio)) : 0;\n        const totalWidthBitmap = Math.round(totalWidth * horizontalPixelRatio);\n        // tick overlaps scale border\n        const tickSizeBitmap = Math.round(tickSize * horizontalPixelRatio);\n        const yMid = this._private__commonData._internal_fixedCoordinate ?? this._private__commonData._internal_coordinate;\n        const yMidBitmap = Math.round(yMid * verticalPixelRatio) - Math.floor(verticalPixelRatio * 0.5);\n        const yTopBitmap = Math.floor(yMidBitmap + tickHeightBitmap / 2 - totalHeightBitmap / 2);\n        const yBottomBitmap = yTopBitmap + totalHeightBitmap;\n        const alignRight = align === 'right';\n        const xInside = alignRight ? mediaSize.width - horzBorder : horzBorder;\n        const xInsideBitmap = alignRight ? bitmapSize.width - horzBorderBitmap : horzBorderBitmap;\n        let xOutsideBitmap;\n        let xTickBitmap;\n        let xText;\n        if (alignRight) {\n            // 2               1\n            //\n            //              6  5\n            //\n            // 3               4\n            xOutsideBitmap = xInsideBitmap - totalWidthBitmap;\n            xTickBitmap = xInsideBitmap - tickSizeBitmap;\n            xText = xInside - tickSize - paddingInner - horzBorder;\n        }\n        else {\n            // 1               2\n            //\n            // 6  5\n            //\n            // 4               3\n            xOutsideBitmap = xInsideBitmap + totalWidthBitmap;\n            xTickBitmap = xInsideBitmap + tickSizeBitmap;\n            xText = xInside + tickSize + paddingInner;\n        }\n        return {\n            _internal_alignRight: alignRight,\n            _internal_bitmap: {\n                _internal_yTop: yTopBitmap,\n                _internal_yMid: yMidBitmap,\n                _internal_yBottom: yBottomBitmap,\n                _internal_totalWidth: totalWidthBitmap,\n                _internal_totalHeight: totalHeightBitmap,\n                // TODO: it is better to have different horizontal and vertical radii\n                _internal_radius: 2 * horizontalPixelRatio,\n                _internal_horzBorder: horzBorderBitmap,\n                _internal_xOutside: xOutsideBitmap,\n                _internal_xInside: xInsideBitmap,\n                _internal_xTick: xTickBitmap,\n                _internal_tickHeight: tickHeightBitmap,\n                _internal_right: bitmapSize.width,\n            },\n            _internal_media: {\n                _internal_yTop: yTopBitmap / verticalPixelRatio,\n                _internal_yBottom: yBottomBitmap / verticalPixelRatio,\n                _internal_xText: xText,\n                _internal_textMidCorrection: textMidCorrection,\n            },\n        };\n    }\n}\n\nclass PriceAxisView {\n    constructor(ctor) {\n        this._private__commonRendererData = {\n            _internal_coordinate: 0,\n            _internal_background: '#000',\n            _internal_additionalPaddingBottom: 0,\n            _internal_additionalPaddingTop: 0,\n        };\n        this._private__axisRendererData = {\n            _internal_text: '',\n            _internal_visible: false,\n            _internal_tickVisible: true,\n            _internal_moveTextToInvisibleTick: false,\n            _internal_borderColor: '',\n            _internal_color: '#FFF',\n            _internal_borderVisible: false,\n            _internal_separatorVisible: false,\n        };\n        this._private__paneRendererData = {\n            _internal_text: '',\n            _internal_visible: false,\n            _internal_tickVisible: false,\n            _internal_moveTextToInvisibleTick: true,\n            _internal_borderColor: '',\n            _internal_color: '#FFF',\n            _internal_borderVisible: true,\n            _internal_separatorVisible: true,\n        };\n        this._private__invalidated = true;\n        this._private__axisRenderer = new (ctor || PriceAxisViewRenderer)(this._private__axisRendererData, this._private__commonRendererData);\n        this._private__paneRenderer = new (ctor || PriceAxisViewRenderer)(this._private__paneRendererData, this._private__commonRendererData);\n    }\n    _internal_text() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__axisRendererData._internal_text;\n    }\n    _internal_coordinate() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__commonRendererData._internal_coordinate;\n    }\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_height(rendererOptions, useSecondLine = false) {\n        return Math.max(this._private__axisRenderer._internal_height(rendererOptions, useSecondLine), this._private__paneRenderer._internal_height(rendererOptions, useSecondLine));\n    }\n    _internal_getFixedCoordinate() {\n        return this._private__commonRendererData._internal_fixedCoordinate || 0;\n    }\n    _internal_setFixedCoordinate(value) {\n        this._private__commonRendererData._internal_fixedCoordinate = value;\n    }\n    _internal_isVisible() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__axisRendererData._internal_visible || this._private__paneRendererData._internal_visible;\n    }\n    _internal_isAxisLabelVisible() {\n        this._private__updateRendererDataIfNeeded();\n        return this._private__axisRendererData._internal_visible;\n    }\n    _internal_renderer(priceScale) {\n        this._private__updateRendererDataIfNeeded();\n        // force update tickVisible state from price scale options\n        // because we don't have and we can't have price axis in other methods\n        // (like paneRenderer or any other who call _updateRendererDataIfNeeded)\n        this._private__axisRendererData._internal_tickVisible = this._private__axisRendererData._internal_tickVisible && priceScale._internal_options().ticksVisible;\n        this._private__paneRendererData._internal_tickVisible = this._private__paneRendererData._internal_tickVisible && priceScale._internal_options().ticksVisible;\n        this._private__axisRenderer._internal_setData(this._private__axisRendererData, this._private__commonRendererData);\n        this._private__paneRenderer._internal_setData(this._private__paneRendererData, this._private__commonRendererData);\n        return this._private__axisRenderer;\n    }\n    _internal_paneRenderer() {\n        this._private__updateRendererDataIfNeeded();\n        this._private__axisRenderer._internal_setData(this._private__axisRendererData, this._private__commonRendererData);\n        this._private__paneRenderer._internal_setData(this._private__paneRendererData, this._private__commonRendererData);\n        return this._private__paneRenderer;\n    }\n    _private__updateRendererDataIfNeeded() {\n        if (this._private__invalidated) {\n            this._private__axisRendererData._internal_tickVisible = true;\n            this._private__paneRendererData._internal_tickVisible = false;\n            this._internal__updateRendererData(this._private__axisRendererData, this._private__paneRendererData, this._private__commonRendererData);\n        }\n    }\n}\n\nclass CrosshairPriceAxisView extends PriceAxisView {\n    constructor(source, priceScale, valueProvider) {\n        super();\n        this._private__source = source;\n        this._private__priceScale = priceScale;\n        this._private__valueProvider = valueProvider;\n    }\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonRendererData) {\n        axisRendererData._internal_visible = false;\n        if (this._private__source._internal_options().mode === 2 /* CrosshairMode.Hidden */) {\n            return;\n        }\n        const options = this._private__source._internal_options().horzLine;\n        if (!options.labelVisible) {\n            return;\n        }\n        const firstValue = this._private__priceScale._internal_firstValue();\n        if (!this._private__source._internal_visible() || this._private__priceScale._internal_isEmpty() || (firstValue === null)) {\n            return;\n        }\n        const colors = this._private__priceScale._internal_colorParser()._internal_generateContrastColors(options.labelBackgroundColor);\n        commonRendererData._internal_background = colors._internal_background;\n        axisRendererData._internal_color = colors._internal_foreground;\n        const additionalPadding = 2 / 12 * this._private__priceScale._internal_fontSize();\n        commonRendererData._internal_additionalPaddingTop = additionalPadding;\n        commonRendererData._internal_additionalPaddingBottom = additionalPadding;\n        const value = this._private__valueProvider(this._private__priceScale);\n        commonRendererData._internal_coordinate = value._internal_coordinate;\n        axisRendererData._internal_text = this._private__priceScale._internal_formatPrice(value._internal_price, firstValue);\n        axisRendererData._internal_visible = true;\n    }\n}\n\nconst optimizationReplacementRe = /[1-9]/g;\nconst radius$1 = 2;\nclass TimeAxisViewRenderer {\n    constructor() {\n        this._private__data = null;\n    }\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_draw(target, rendererOptions) {\n        if (this._private__data === null || this._private__data._internal_visible === false || this._private__data._internal_text.length === 0) {\n            return;\n        }\n        const textWidth = target.useMediaCoordinateSpace(({ context: ctx }) => {\n            ctx.font = rendererOptions._internal_font;\n            return Math.round(rendererOptions._internal_widthCache._internal_measureText(ctx, ensureNotNull(this._private__data)._internal_text, optimizationReplacementRe));\n        });\n        if (textWidth <= 0) {\n            return;\n        }\n        const horzMargin = rendererOptions._internal_paddingHorizontal;\n        const labelWidth = textWidth + 2 * horzMargin;\n        const labelWidthHalf = labelWidth / 2;\n        const timeScaleWidth = this._private__data._internal_width;\n        let coordinate = this._private__data._internal_coordinate;\n        let x1 = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        if (x1 < 0) {\n            coordinate = coordinate + Math.abs(0 - x1);\n            x1 = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        }\n        else if (x1 + labelWidth > timeScaleWidth) {\n            coordinate = coordinate - Math.abs(timeScaleWidth - (x1 + labelWidth));\n            x1 = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        }\n        const x2 = x1 + labelWidth;\n        const y1 = 0;\n        const y2 = Math.ceil(y1 +\n            rendererOptions._internal_borderSize +\n            rendererOptions._internal_tickLength +\n            rendererOptions._internal_paddingTop +\n            rendererOptions._internal_fontSize +\n            rendererOptions._internal_paddingBottom);\n        target.useBitmapCoordinateSpace(({ context: ctx, horizontalPixelRatio, verticalPixelRatio }) => {\n            const data = ensureNotNull(this._private__data);\n            ctx.fillStyle = data._internal_background;\n            const x1scaled = Math.round(x1 * horizontalPixelRatio);\n            const y1scaled = Math.round(y1 * verticalPixelRatio);\n            const x2scaled = Math.round(x2 * horizontalPixelRatio);\n            const y2scaled = Math.round(y2 * verticalPixelRatio);\n            const radiusScaled = Math.round(radius$1 * horizontalPixelRatio);\n            ctx.beginPath();\n            ctx.moveTo(x1scaled, y1scaled);\n            ctx.lineTo(x1scaled, y2scaled - radiusScaled);\n            ctx.arcTo(x1scaled, y2scaled, x1scaled + radiusScaled, y2scaled, radiusScaled);\n            ctx.lineTo(x2scaled - radiusScaled, y2scaled);\n            ctx.arcTo(x2scaled, y2scaled, x2scaled, y2scaled - radiusScaled, radiusScaled);\n            ctx.lineTo(x2scaled, y1scaled);\n            ctx.fill();\n            if (data._internal_tickVisible) {\n                const tickX = Math.round(data._internal_coordinate * horizontalPixelRatio);\n                const tickTop = y1scaled;\n                const tickBottom = Math.round((tickTop + rendererOptions._internal_tickLength) * verticalPixelRatio);\n                ctx.fillStyle = data._internal_color;\n                const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n                const tickOffset = Math.floor(horizontalPixelRatio * 0.5);\n                ctx.fillRect(tickX - tickOffset, tickTop, tickWidth, tickBottom - tickTop);\n            }\n        });\n        target.useMediaCoordinateSpace(({ context: ctx }) => {\n            const data = ensureNotNull(this._private__data);\n            const yText = y1 +\n                rendererOptions._internal_borderSize +\n                rendererOptions._internal_tickLength +\n                rendererOptions._internal_paddingTop +\n                rendererOptions._internal_fontSize / 2;\n            ctx.font = rendererOptions._internal_font;\n            ctx.textAlign = 'left';\n            ctx.textBaseline = 'middle';\n            ctx.fillStyle = data._internal_color;\n            const textYCorrection = rendererOptions._internal_widthCache._internal_yMidCorrection(ctx, 'Apr0');\n            ctx.translate(x1 + horzMargin, yText + textYCorrection);\n            ctx.fillText(data._internal_text, 0, 0);\n        });\n    }\n}\n\nclass CrosshairTimeAxisView {\n    constructor(crosshair, model, valueProvider) {\n        this._private__invalidated = true;\n        this._private__renderer = new TimeAxisViewRenderer();\n        this._private__rendererData = {\n            _internal_visible: false,\n            _internal_background: '#4c525e',\n            _internal_color: 'white',\n            _internal_text: '',\n            _internal_width: 0,\n            _internal_coordinate: NaN,\n            _internal_tickVisible: true,\n        };\n        this._private__crosshair = crosshair;\n        this._private__model = model;\n        this._private__valueProvider = valueProvider;\n    }\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n        }\n        this._private__renderer._internal_setData(this._private__rendererData);\n        return this._private__renderer;\n    }\n    _private__updateImpl() {\n        const data = this._private__rendererData;\n        data._internal_visible = false;\n        if (this._private__crosshair._internal_options().mode === 2 /* CrosshairMode.Hidden */) {\n            return;\n        }\n        const options = this._private__crosshair._internal_options().vertLine;\n        if (!options.labelVisible) {\n            return;\n        }\n        const timeScale = this._private__model._internal_timeScale();\n        if (timeScale._internal_isEmpty()) {\n            return;\n        }\n        data._internal_width = timeScale._internal_width();\n        const value = this._private__valueProvider();\n        if (value === null) {\n            return;\n        }\n        data._internal_coordinate = value._internal_coordinate;\n        const currentTime = timeScale._internal_indexToTimeScalePoint(this._private__crosshair._internal_appliedIndex());\n        data._internal_text = timeScale._internal_formatDateTime(ensureNotNull(currentTime));\n        data._internal_visible = true;\n        const colors = this._private__model._internal_colorParser()._internal_generateContrastColors(options.labelBackgroundColor);\n        data._internal_background = colors._internal_background;\n        data._internal_color = colors._internal_foreground;\n        data._internal_tickVisible = timeScale._internal_options().ticksVisible;\n    }\n}\n\nclass DataSource {\n    constructor() {\n        this._internal__priceScale = null;\n        this._private__zorder = 0;\n    }\n    _internal_zorder() {\n        return this._private__zorder;\n    }\n    _internal_setZorder(zorder) {\n        this._private__zorder = zorder;\n    }\n    _internal_priceScale() {\n        return this._internal__priceScale;\n    }\n    _internal_setPriceScale(priceScale) {\n        this._internal__priceScale = priceScale;\n    }\n    _internal_labelPaneViews(pane) {\n        return [];\n    }\n    _internal_timeAxisViews() {\n        return [];\n    }\n    _internal_visible() {\n        return true;\n    }\n}\n\n/**\n * Represents the crosshair mode.\n */\nvar CrosshairMode;\n(function (CrosshairMode) {\n    /**\n     * This mode allows crosshair to move freely on the chart.\n     */\n    CrosshairMode[CrosshairMode[\"Normal\"] = 0] = \"Normal\";\n    /**\n     * This mode sticks crosshair's horizontal line to the price value of a single-value series or to the close price of OHLC-based series.\n     */\n    CrosshairMode[CrosshairMode[\"Magnet\"] = 1] = \"Magnet\";\n    /**\n     * This mode disables rendering of the crosshair.\n     */\n    CrosshairMode[CrosshairMode[\"Hidden\"] = 2] = \"Hidden\";\n    /**\n     * This mode sticks crosshair's horizontal line to the price value of a single-value series or to the open/high/low/close price of OHLC-based series.\n     */\n    CrosshairMode[CrosshairMode[\"MagnetOHLC\"] = 3] = \"MagnetOHLC\";\n})(CrosshairMode || (CrosshairMode = {}));\nclass Crosshair extends DataSource {\n    constructor(model, options) {\n        super();\n        this._private__pane = null;\n        this._private__price = NaN;\n        this._private__index = 0;\n        this._private__visible = false; // initially the crosshair should not be visible, until the user interacts.\n        this._private__priceAxisViews = new Map();\n        this._private__subscribed = false;\n        this._private__crosshairPaneViewCache = new WeakMap();\n        this._private__markersPaneViewCache = new WeakMap();\n        this._private__x = NaN;\n        this._private__y = NaN;\n        this._private__originX = NaN;\n        this._private__originY = NaN;\n        this._private__model = model;\n        this._private__options = options;\n        const valuePriceProvider = (rawPriceProvider, rawCoordinateProvider) => {\n            return (priceScale) => {\n                const coordinate = rawCoordinateProvider();\n                const rawPrice = rawPriceProvider();\n                if (priceScale === ensureNotNull(this._private__pane)._internal_defaultPriceScale()) {\n                    // price must be defined\n                    return { _internal_price: rawPrice, _internal_coordinate: coordinate };\n                }\n                else {\n                    // always convert from coordinate\n                    const firstValue = ensureNotNull(priceScale._internal_firstValue());\n                    const price = priceScale._internal_coordinateToPrice(coordinate, firstValue);\n                    return { _internal_price: price, _internal_coordinate: coordinate };\n                }\n            };\n        };\n        const valueTimeProvider = (rawIndexProvider, rawCoordinateProvider) => {\n            return () => {\n                const time = this._private__model._internal_timeScale()._internal_indexToTime(rawIndexProvider());\n                const coordinate = rawCoordinateProvider();\n                if (!time || !Number.isFinite(coordinate)) {\n                    return null;\n                }\n                return {\n                    _internal_time: time,\n                    _internal_coordinate: coordinate,\n                };\n            };\n        };\n        // for current position always return both price and coordinate\n        this._private__currentPosPriceProvider = valuePriceProvider(() => this._private__price, () => this._private__y);\n        const currentPosTimeProvider = valueTimeProvider(() => this._private__index, () => this._internal_appliedX());\n        this._private__timeAxisView = new CrosshairTimeAxisView(this, model, currentPosTimeProvider);\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_saveOriginCoord(x, y) {\n        this._private__originX = x;\n        this._private__originY = y;\n    }\n    _internal_clearOriginCoord() {\n        this._private__originX = NaN;\n        this._private__originY = NaN;\n    }\n    _internal_originCoordX() {\n        return this._private__originX;\n    }\n    _internal_originCoordY() {\n        return this._private__originY;\n    }\n    _internal_setPosition(index, price, pane) {\n        if (!this._private__subscribed) {\n            this._private__subscribed = true;\n        }\n        this._private__visible = true;\n        this._private__tryToUpdateViews(index, price, pane);\n    }\n    _internal_appliedIndex() {\n        return this._private__index;\n    }\n    _internal_appliedX() {\n        return this._private__x;\n    }\n    _internal_appliedY() {\n        return this._private__y;\n    }\n    _internal_visible() {\n        return this._private__visible;\n    }\n    _internal_clearPosition() {\n        this._private__visible = false;\n        this._private__setIndexToLastSeriesBarIndex();\n        this._private__price = NaN;\n        this._private__x = NaN;\n        this._private__y = NaN;\n        this._private__pane = null;\n        this._internal_clearOriginCoord();\n        this._internal_updateAllViews();\n    }\n    _internal_paneViews(pane) {\n        let crosshairPaneView = this._private__crosshairPaneViewCache.get(pane);\n        if (!crosshairPaneView) {\n            crosshairPaneView = new CrosshairPaneView(this, pane);\n            this._private__crosshairPaneViewCache.set(pane, crosshairPaneView);\n        }\n        let markersPaneView = this._private__markersPaneViewCache.get(pane);\n        if (!markersPaneView) {\n            markersPaneView = new CrosshairMarksPaneView(this._private__model, this, pane);\n            this._private__markersPaneViewCache.set(pane, markersPaneView);\n        }\n        return [crosshairPaneView, markersPaneView];\n    }\n    _internal_horzLineVisible(pane) {\n        return pane === this._private__pane && this._private__options.horzLine.visible;\n    }\n    _internal_vertLineVisible() {\n        return this._private__options.vertLine.visible;\n    }\n    _internal_priceAxisViews(pane, priceScale) {\n        if (!this._private__visible || this._private__pane !== pane) {\n            this._private__priceAxisViews.clear();\n        }\n        const views = [];\n        if (this._private__pane === pane) {\n            views.push(this._private__createPriceAxisViewOnDemand(this._private__priceAxisViews, priceScale, this._private__currentPosPriceProvider));\n        }\n        return views;\n    }\n    _internal_timeAxisViews() {\n        return this._private__visible ? [this._private__timeAxisView] : [];\n    }\n    _internal_pane() {\n        return this._private__pane;\n    }\n    _internal_updateAllViews() {\n        this._private__model._internal_panes().forEach((pane) => {\n            this._private__crosshairPaneViewCache.get(pane)?._internal_update();\n            this._private__markersPaneViewCache.get(pane)?._internal_update();\n        });\n        this._private__priceAxisViews.forEach((value) => value._internal_update());\n        this._private__timeAxisView._internal_update();\n    }\n    _private__priceScaleByPane(pane) {\n        if (pane && !pane._internal_defaultPriceScale()._internal_isEmpty()) {\n            return pane._internal_defaultPriceScale();\n        }\n        return null;\n    }\n    _private__tryToUpdateViews(index, price, pane) {\n        if (this._private__tryToUpdateData(index, price, pane)) {\n            this._internal_updateAllViews();\n        }\n    }\n    _private__tryToUpdateData(newIndex, newPrice, newPane) {\n        const oldX = this._private__x;\n        const oldY = this._private__y;\n        const oldPrice = this._private__price;\n        const oldIndex = this._private__index;\n        const oldPane = this._private__pane;\n        const priceScale = this._private__priceScaleByPane(newPane);\n        this._private__index = newIndex;\n        this._private__x = isNaN(newIndex) ? NaN : this._private__model._internal_timeScale()._internal_indexToCoordinate(newIndex);\n        this._private__pane = newPane;\n        const firstValue = priceScale !== null ? priceScale._internal_firstValue() : null;\n        if (priceScale !== null && firstValue !== null) {\n            this._private__price = newPrice;\n            this._private__y = priceScale._internal_priceToCoordinate(newPrice, firstValue);\n        }\n        else {\n            this._private__price = NaN;\n            this._private__y = NaN;\n        }\n        return (oldX !== this._private__x || oldY !== this._private__y || oldIndex !== this._private__index ||\n            oldPrice !== this._private__price || oldPane !== this._private__pane);\n    }\n    _private__setIndexToLastSeriesBarIndex() {\n        const lastIndexes = this._private__model._internal_serieses()\n            .map((s) => s._internal_bars()._internal_lastIndex())\n            .filter(notNull);\n        const lastBarIndex = (lastIndexes.length === 0) ? null : Math.max(...lastIndexes);\n        this._private__index = lastBarIndex !== null ? lastBarIndex : NaN;\n    }\n    _private__createPriceAxisViewOnDemand(map, priceScale, valueProvider) {\n        let view = map.get(priceScale);\n        if (view === undefined) {\n            view = new CrosshairPriceAxisView(this, priceScale, valueProvider);\n            map.set(priceScale, view);\n        }\n        return view;\n    }\n}\n\nfunction isDefaultPriceScale(priceScaleId) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    return priceScaleId === \"left\" /* DefaultPriceScaleId.Left */ || priceScaleId === \"right\" /* DefaultPriceScaleId.Right */;\n}\n\nfunction mergePaneInvalidation(beforeValue, newValue) {\n    if (beforeValue === undefined) {\n        return newValue;\n    }\n    const level = Math.max(beforeValue._internal_level, newValue._internal_level);\n    const autoScale = beforeValue._internal_autoScale || newValue._internal_autoScale;\n    return { _internal_level: level, _internal_autoScale: autoScale };\n}\nclass InvalidateMask {\n    constructor(globalLevel) {\n        this._private__invalidatedPanes = new Map();\n        this._private__timeScaleInvalidations = [];\n        this._private__globalLevel = globalLevel;\n    }\n    _internal_invalidatePane(paneIndex, invalidation) {\n        const prevValue = this._private__invalidatedPanes.get(paneIndex);\n        const newValue = mergePaneInvalidation(prevValue, invalidation);\n        this._private__invalidatedPanes.set(paneIndex, newValue);\n    }\n    _internal_fullInvalidation() {\n        return this._private__globalLevel;\n    }\n    _internal_invalidateForPane(paneIndex) {\n        const paneInvalidation = this._private__invalidatedPanes.get(paneIndex);\n        if (paneInvalidation === undefined) {\n            return {\n                _internal_level: this._private__globalLevel,\n            };\n        }\n        return {\n            _internal_level: Math.max(this._private__globalLevel, paneInvalidation._internal_level),\n            _internal_autoScale: paneInvalidation._internal_autoScale,\n        };\n    }\n    _internal_setFitContent() {\n        this._internal_stopTimeScaleAnimation();\n        // modifies both bar spacing and right offset\n        this._private__timeScaleInvalidations = [{ _internal_type: 0 /* TimeScaleInvalidationType.FitContent */ }];\n    }\n    _internal_applyRange(range) {\n        this._internal_stopTimeScaleAnimation();\n        // modifies both bar spacing and right offset\n        this._private__timeScaleInvalidations = [{ _internal_type: 1 /* TimeScaleInvalidationType.ApplyRange */, _internal_value: range }];\n    }\n    _internal_setTimeScaleAnimation(animation) {\n        this._private__removeTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({ _internal_type: 5 /* TimeScaleInvalidationType.Animation */, _internal_value: animation });\n    }\n    _internal_stopTimeScaleAnimation() {\n        this._private__removeTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({ _internal_type: 6 /* TimeScaleInvalidationType.StopAnimation */ });\n    }\n    _internal_resetTimeScale() {\n        this._internal_stopTimeScaleAnimation();\n        // modifies both bar spacing and right offset\n        this._private__timeScaleInvalidations = [{ _internal_type: 4 /* TimeScaleInvalidationType.Reset */ }];\n    }\n    _internal_setBarSpacing(barSpacing) {\n        this._internal_stopTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({ _internal_type: 2 /* TimeScaleInvalidationType.ApplyBarSpacing */, _internal_value: barSpacing });\n    }\n    _internal_setRightOffset(offset) {\n        this._internal_stopTimeScaleAnimation();\n        this._private__timeScaleInvalidations.push({ _internal_type: 3 /* TimeScaleInvalidationType.ApplyRightOffset */, _internal_value: offset });\n    }\n    _internal_timeScaleInvalidations() {\n        return this._private__timeScaleInvalidations;\n    }\n    _internal_merge(other) {\n        for (const tsInvalidation of other._private__timeScaleInvalidations) {\n            this._private__applyTimeScaleInvalidation(tsInvalidation);\n        }\n        this._private__globalLevel = Math.max(this._private__globalLevel, other._private__globalLevel);\n        other._private__invalidatedPanes.forEach((invalidation, index) => {\n            this._internal_invalidatePane(index, invalidation);\n        });\n    }\n    static _internal_light() {\n        return new InvalidateMask(2 /* InvalidationLevel.Light */);\n    }\n    static _internal_full() {\n        return new InvalidateMask(3 /* InvalidationLevel.Full */);\n    }\n    _private__applyTimeScaleInvalidation(invalidation) {\n        switch (invalidation._internal_type) {\n            case 0 /* TimeScaleInvalidationType.FitContent */:\n                this._internal_setFitContent();\n                break;\n            case 1 /* TimeScaleInvalidationType.ApplyRange */:\n                this._internal_applyRange(invalidation._internal_value);\n                break;\n            case 2 /* TimeScaleInvalidationType.ApplyBarSpacing */:\n                this._internal_setBarSpacing(invalidation._internal_value);\n                break;\n            case 3 /* TimeScaleInvalidationType.ApplyRightOffset */:\n                this._internal_setRightOffset(invalidation._internal_value);\n                break;\n            case 4 /* TimeScaleInvalidationType.Reset */:\n                this._internal_resetTimeScale();\n                break;\n            case 5 /* TimeScaleInvalidationType.Animation */:\n                this._internal_setTimeScaleAnimation(invalidation._internal_value);\n                break;\n            case 6 /* TimeScaleInvalidationType.StopAnimation */:\n                this._private__removeTimeScaleAnimation();\n        }\n    }\n    _private__removeTimeScaleAnimation() {\n        const index = this._private__timeScaleInvalidations.findIndex((inv) => inv._internal_type === 5 /* TimeScaleInvalidationType.Animation */);\n        if (index !== -1) {\n            this._private__timeScaleInvalidations.splice(index, 1);\n        }\n    }\n}\n\nconst formatterOptions = {\n    _internal_decimalSign: '.'};\n/**\n * @param value - The number of convert.\n * @param length - The length. Must be between 0 and 16 inclusive.\n */\nfunction numberToStringWithLeadingZero(value, length) {\n    if (!isNumber(value)) {\n        return 'n/a';\n    }\n    if (!isInteger(length)) {\n        throw new TypeError('invalid length');\n    }\n    if (length < 0 || length > 16) {\n        throw new TypeError('invalid length');\n    }\n    if (length === 0) {\n        return value.toString();\n    }\n    const dummyString = '0000000000000000';\n    return (dummyString + value.toString()).slice(-length);\n}\nclass PriceFormatter {\n    constructor(priceScale, minMove) {\n        if (!minMove) {\n            minMove = 1;\n        }\n        if (!isNumber(priceScale) || !isInteger(priceScale)) {\n            priceScale = 100;\n        }\n        if (priceScale < 0) {\n            throw new TypeError('invalid base');\n        }\n        this._private__priceScale = priceScale;\n        this._private__minMove = minMove;\n        this._private__calculateDecimal();\n    }\n    format(price) {\n        // \\u2212 is unicode's minus sign https://www.fileformat.info/info/unicode/char/2212/index.htm\n        // we should use it because it has the same width as plus sign +\n        const sign = price < 0 ? '\\u2212' : '';\n        price = Math.abs(price);\n        return sign + this._private__formatAsDecimal(price);\n    }\n    _private__calculateDecimal() {\n        // check if this._base is power of 10\n        // for double fractional _fractionalLength if for the main fractional only\n        this._internal__fractionalLength = 0;\n        if (this._private__priceScale > 0 && this._private__minMove > 0) {\n            let base = this._private__priceScale;\n            while (base > 1) {\n                base /= 10;\n                this._internal__fractionalLength++;\n            }\n        }\n    }\n    _private__formatAsDecimal(price) {\n        const base = this._private__priceScale / this._private__minMove;\n        let intPart = Math.floor(price);\n        let fracString = '';\n        const fracLength = this._internal__fractionalLength !== undefined ? this._internal__fractionalLength : NaN;\n        if (base > 1) {\n            let fracPart = +(Math.round(price * base) - intPart * base).toFixed(this._internal__fractionalLength);\n            if (fracPart >= base) {\n                fracPart -= base;\n                intPart += 1;\n            }\n            fracString = formatterOptions._internal_decimalSign + numberToStringWithLeadingZero(+fracPart.toFixed(this._internal__fractionalLength) * this._private__minMove, fracLength);\n        }\n        else {\n            // should round int part to min move\n            intPart = Math.round(intPart * base) / base;\n            // if min move > 1, fractional part is always = 0\n            if (fracLength > 0) {\n                fracString = formatterOptions._internal_decimalSign + numberToStringWithLeadingZero(0, fracLength);\n            }\n        }\n        return intPart.toFixed(0) + fracString;\n    }\n}\n\nclass PercentageFormatter extends PriceFormatter {\n    constructor(priceScale = 100) {\n        super(priceScale);\n    }\n    format(price) {\n        return `${super.format(price)}%`;\n    }\n}\n\nclass VolumeFormatter {\n    constructor(precision) {\n        this._private__precision = precision;\n    }\n    format(vol) {\n        let sign = '';\n        if (vol < 0) {\n            sign = '-';\n            vol = -vol;\n        }\n        if (vol < 995) {\n            return sign + this._private__formatNumber(vol);\n        }\n        else if (vol < 999995) {\n            return sign + this._private__formatNumber(vol / 1000) + 'K';\n        }\n        else if (vol < 999999995) {\n            vol = 1000 * Math.round(vol / 1000);\n            return sign + this._private__formatNumber(vol / 1000000) + 'M';\n        }\n        else {\n            vol = 1000000 * Math.round(vol / 1000000);\n            return sign + this._private__formatNumber(vol / 1000000000) + 'B';\n        }\n    }\n    _private__formatNumber(value) {\n        let res;\n        const priceScale = Math.pow(10, this._private__precision);\n        value = Math.round(value * priceScale) / priceScale;\n        if (value >= 1e-15 && value < 1) {\n            res = value.toFixed(this._private__precision).replace(/\\.?0+$/, ''); // regex removes trailing zeroes\n        }\n        else {\n            res = String(value);\n        }\n        return res.replace(/(\\.[1-9]*)0+$/, (e, p1) => p1);\n    }\n}\n\nconst defaultReplacementRe = /[2-9]/g;\nclass TextWidthCache {\n    constructor(size = 50) {\n        this._private__actualSize = 0;\n        this._private__usageTick = 1;\n        this._private__oldestTick = 1;\n        this._private__tick2Labels = {};\n        this._private__cache = new Map();\n        this._private__maxSize = size;\n    }\n    _internal_reset() {\n        this._private__actualSize = 0;\n        this._private__cache.clear();\n        this._private__usageTick = 1;\n        this._private__oldestTick = 1;\n        this._private__tick2Labels = {};\n    }\n    _internal_measureText(ctx, text, optimizationReplacementRe) {\n        return this._private__getMetrics(ctx, text, optimizationReplacementRe).width;\n    }\n    _internal_yMidCorrection(ctx, text, optimizationReplacementRe) {\n        const metrics = this._private__getMetrics(ctx, text, optimizationReplacementRe);\n        // if actualBoundingBoxAscent/actualBoundingBoxDescent are not supported we use 0 as a fallback\n        return ((metrics.actualBoundingBoxAscent || 0) - (metrics.actualBoundingBoxDescent || 0)) / 2;\n    }\n    _private__getMetrics(ctx, text, optimizationReplacementRe) {\n        const re = optimizationReplacementRe || defaultReplacementRe;\n        const cacheString = String(text).replace(re, '0');\n        if (this._private__cache.has(cacheString)) {\n            return ensureDefined(this._private__cache.get(cacheString))._internal_metrics;\n        }\n        if (this._private__actualSize === this._private__maxSize) {\n            const oldestValue = this._private__tick2Labels[this._private__oldestTick];\n            delete this._private__tick2Labels[this._private__oldestTick];\n            this._private__cache.delete(oldestValue);\n            this._private__oldestTick++;\n            this._private__actualSize--;\n        }\n        ctx.save();\n        ctx.textBaseline = 'middle';\n        const metrics = ctx.measureText(cacheString);\n        ctx.restore();\n        if (metrics.width === 0 && !!text.length) {\n            // measureText can return 0 in FF depending on a canvas size, don't cache it\n            return metrics;\n        }\n        this._private__cache.set(cacheString, { _internal_metrics: metrics, _internal_tick: this._private__usageTick });\n        this._private__tick2Labels[this._private__usageTick] = cacheString;\n        this._private__actualSize++;\n        this._private__usageTick++;\n        return metrics;\n    }\n}\n\nclass PanePriceAxisViewRenderer {\n    constructor(textWidthCache) {\n        this._private__priceAxisViewRenderer = null;\n        this._private__rendererOptions = null;\n        this._private__align = 'right';\n        this._private__textWidthCache = textWidthCache;\n    }\n    _internal_setParams(priceAxisViewRenderer, rendererOptions, align) {\n        this._private__priceAxisViewRenderer = priceAxisViewRenderer;\n        this._private__rendererOptions = rendererOptions;\n        this._private__align = align;\n    }\n    _internal_draw(target) {\n        if (this._private__rendererOptions === null || this._private__priceAxisViewRenderer === null) {\n            return;\n        }\n        this._private__priceAxisViewRenderer._internal_draw(target, this._private__rendererOptions, this._private__textWidthCache, this._private__align);\n    }\n}\nclass PanePriceAxisView {\n    constructor(priceAxisView, dataSource, chartModel) {\n        this._private__priceAxisView = priceAxisView;\n        this._private__textWidthCache = new TextWidthCache(50); // when should we clear cache?\n        this._private__dataSource = dataSource;\n        this._private__chartModel = chartModel;\n        this._private__fontSize = -1;\n        this._private__renderer = new PanePriceAxisViewRenderer(this._private__textWidthCache);\n    }\n    _internal_renderer() {\n        const pane = this._private__chartModel._internal_paneForSource(this._private__dataSource);\n        if (pane === null) {\n            return null;\n        }\n        // this price scale will be used to find label placement only (left, right, none)\n        const priceScale = pane._internal_isOverlay(this._private__dataSource) ? pane._internal_defaultVisiblePriceScale() : this._private__dataSource._internal_priceScale();\n        if (priceScale === null) {\n            return null;\n        }\n        const position = pane._internal_priceScalePosition(priceScale);\n        if (position === 'overlay') {\n            return null;\n        }\n        const options = this._private__chartModel._internal_priceAxisRendererOptions();\n        if (options._internal_fontSize !== this._private__fontSize) {\n            this._private__fontSize = options._internal_fontSize;\n            this._private__textWidthCache._internal_reset();\n        }\n        this._private__renderer._internal_setParams(this._private__priceAxisView._internal_paneRenderer(), options, position);\n        return this._private__renderer;\n    }\n}\n\nclass HorizontalLineRenderer extends BitmapCoordinatesPaneRenderer {\n    constructor() {\n        super(...arguments);\n        this._private__data = null;\n    }\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_hitTest(x, y) {\n        if (!this._private__data?._internal_visible) {\n            return null;\n        }\n        const { _internal_y: itemY, _internal_lineWidth: lineWidth, _internal_externalId: externalId } = this._private__data;\n        // add a fixed area threshold around line (Y + width) for hit test\n        if (y >= itemY - lineWidth - 7 /* Constants.HitTestThreshold */ && y <= itemY + lineWidth + 7 /* Constants.HitTestThreshold */) {\n            return {\n                _internal_hitTestData: this._private__data,\n                _internal_externalId: externalId,\n            };\n        }\n        return null;\n    }\n    _internal__drawImpl({ context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio }) {\n        if (this._private__data === null) {\n            return;\n        }\n        if (this._private__data._internal_visible === false) {\n            return;\n        }\n        const y = Math.round(this._private__data._internal_y * verticalPixelRatio);\n        if (y < 0 || y > bitmapSize.height) {\n            return;\n        }\n        ctx.lineCap = 'butt';\n        ctx.strokeStyle = this._private__data._internal_color;\n        ctx.lineWidth = Math.floor(this._private__data._internal_lineWidth * horizontalPixelRatio);\n        setLineStyle(ctx, this._private__data._internal_lineStyle);\n        drawHorizontalLine(ctx, y, 0, bitmapSize.width);\n    }\n}\n\nclass SeriesHorizontalLinePaneView {\n    constructor(series) {\n        this._internal__lineRendererData = {\n            _internal_y: 0,\n            _internal_color: 'rgba(0, 0, 0, 0)',\n            _internal_lineWidth: 1,\n            _internal_lineStyle: 0 /* LineStyle.Solid */,\n            _internal_visible: false,\n        };\n        this._internal__lineRenderer = new HorizontalLineRenderer();\n        this._private__invalidated = true;\n        this._internal__series = series;\n        this._internal__model = series._internal_model();\n        this._internal__lineRenderer._internal_setData(this._internal__lineRendererData);\n    }\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (!this._internal__series._internal_visible()) {\n            return null;\n        }\n        if (this._private__invalidated) {\n            this._internal__updateImpl();\n            this._private__invalidated = false;\n        }\n        return this._internal__lineRenderer;\n    }\n}\n\nclass SeriesHorizontalBaseLinePaneView extends SeriesHorizontalLinePaneView {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(series) {\n        super(series);\n    }\n    _internal__updateImpl() {\n        this._internal__lineRendererData._internal_visible = false;\n        const priceScale = this._internal__series._internal_priceScale();\n        const mode = priceScale._internal_mode()._internal_mode;\n        if (mode !== 2 /* PriceScaleMode.Percentage */ && mode !== 3 /* PriceScaleMode.IndexedTo100 */) {\n            return;\n        }\n        const seriesOptions = this._internal__series._internal_options();\n        if (!seriesOptions.baseLineVisible || !this._internal__series._internal_visible()) {\n            return;\n        }\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return;\n        }\n        this._internal__lineRendererData._internal_visible = true;\n        this._internal__lineRendererData._internal_y = priceScale._internal_priceToCoordinate(firstValue._internal_value, firstValue._internal_value);\n        this._internal__lineRendererData._internal_color = seriesOptions.baseLineColor;\n        this._internal__lineRendererData._internal_lineWidth = seriesOptions.baseLineWidth;\n        this._internal__lineRendererData._internal_lineStyle = seriesOptions.baseLineStyle;\n    }\n}\n\nclass SeriesLastPriceAnimationRenderer extends BitmapCoordinatesPaneRenderer {\n    constructor() {\n        super(...arguments);\n        this._private__data = null;\n    }\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_data() {\n        return this._private__data;\n    }\n    _internal__drawImpl({ context: ctx, horizontalPixelRatio, verticalPixelRatio }) {\n        const data = this._private__data;\n        if (data === null) {\n            return;\n        }\n        const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n        const correction = (tickWidth % 2) / 2;\n        const centerX = Math.round(data._internal_center.x * horizontalPixelRatio) + correction; // correct x coordinate only\n        const centerY = data._internal_center.y * verticalPixelRatio;\n        ctx.fillStyle = data._internal_seriesLineColor;\n        ctx.beginPath();\n        // TODO: it is better to have different horizontal and vertical radii\n        const centerPointRadius = Math.max(2, data._internal_seriesLineWidth * 1.5) * horizontalPixelRatio;\n        ctx.arc(centerX, centerY, centerPointRadius, 0, 2 * Math.PI, false);\n        ctx.fill();\n        ctx.fillStyle = data._internal_fillColor;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, data._internal_radius * horizontalPixelRatio, 0, 2 * Math.PI, false);\n        ctx.fill();\n        ctx.lineWidth = tickWidth;\n        ctx.strokeStyle = data._internal_strokeColor;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, data._internal_radius * horizontalPixelRatio + tickWidth / 2, 0, 2 * Math.PI, false);\n        ctx.stroke();\n    }\n}\n\nconst animationStagesData = [\n    {\n        _internal_start: 0,\n        _internal_end: 0.25 /* Constants.Stage1Period */,\n        _internal_startRadius: 4 /* Constants.Stage1StartCircleRadius */,\n        _internal_endRadius: 10 /* Constants.Stage1EndCircleRadius */,\n        _internal_startFillAlpha: 0.25 /* Constants.Stage1StartFillAlpha */,\n        _internal_endFillAlpha: 0 /* Constants.Stage1EndFillAlpha */,\n        _internal_startStrokeAlpha: 0.4 /* Constants.Stage1StartStrokeAlpha */,\n        _internal_endStrokeAlpha: 0.8 /* Constants.Stage1EndStrokeAlpha */,\n    },\n    {\n        _internal_start: 0.25 /* Constants.Stage1Period */,\n        _internal_end: 0.25 /* Constants.Stage1Period */ + 0.275 /* Constants.Stage2Period */,\n        _internal_startRadius: 10 /* Constants.Stage2StartCircleRadius */,\n        _internal_endRadius: 14 /* Constants.Stage2EndCircleRadius */,\n        _internal_startFillAlpha: 0 /* Constants.Stage2StartFillAlpha */,\n        _internal_endFillAlpha: 0 /* Constants.Stage2EndFillAlpha */,\n        _internal_startStrokeAlpha: 0.8 /* Constants.Stage2StartStrokeAlpha */,\n        _internal_endStrokeAlpha: 0 /* Constants.Stage2EndStrokeAlpha */,\n    },\n    {\n        _internal_start: 0.25 /* Constants.Stage1Period */ + 0.275 /* Constants.Stage2Period */,\n        _internal_end: 0.25 /* Constants.Stage1Period */ + 0.275 /* Constants.Stage2Period */ + 0.475 /* Constants.Stage3Period */,\n        _internal_startRadius: 14 /* Constants.Stage3StartCircleRadius */,\n        _internal_endRadius: 14 /* Constants.Stage3EndCircleRadius */,\n        _internal_startFillAlpha: 0 /* Constants.Stage3StartFillAlpha */,\n        _internal_endFillAlpha: 0 /* Constants.Stage3EndFillAlpha */,\n        _internal_startStrokeAlpha: 0 /* Constants.Stage3StartStrokeAlpha */,\n        _internal_endStrokeAlpha: 0 /* Constants.Stage3EndStrokeAlpha */,\n    },\n];\nfunction radius(stage, startRadius, endRadius) {\n    return startRadius + (endRadius - startRadius) * stage;\n}\nclass SeriesLastPriceAnimationPaneView {\n    constructor(series) {\n        this._private__renderer = new SeriesLastPriceAnimationRenderer();\n        this._private__invalidated = true;\n        this._private__stageInvalidated = true;\n        this._private__startTime = performance.now();\n        this._private__endTime = this._private__startTime - 1;\n        this._private__series = series;\n    }\n    _internal_onDataCleared() {\n        this._private__endTime = this._private__startTime - 1;\n        this._internal_update();\n    }\n    _internal_onNewRealtimeDataReceived() {\n        this._internal_update();\n        if (this._private__series._internal_options().lastPriceAnimation === 2 /* LastPriceAnimationMode.OnDataUpdate */) {\n            const now = performance.now();\n            const timeToAnimationEnd = this._private__endTime - now;\n            if (timeToAnimationEnd > 0) {\n                if (timeToAnimationEnd < 2600 /* Constants.AnimationPeriod */ / 4) {\n                    this._private__endTime += 2600 /* Constants.AnimationPeriod */;\n                }\n                return;\n            }\n            this._private__startTime = now;\n            this._private__endTime = now + 2600 /* Constants.AnimationPeriod */;\n        }\n    }\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_invalidateStage() {\n        this._private__stageInvalidated = true;\n    }\n    _internal_visible() {\n        // center point is always visible if lastPriceAnimation is not LastPriceAnimationMode.Disabled\n        return this._private__series._internal_options().lastPriceAnimation !== 0 /* LastPriceAnimationMode.Disabled */;\n    }\n    _internal_animationActive() {\n        switch (this._private__series._internal_options().lastPriceAnimation) {\n            case 0 /* LastPriceAnimationMode.Disabled */:\n                return false;\n            case 1 /* LastPriceAnimationMode.Continuous */:\n                return true;\n            case 2 /* LastPriceAnimationMode.OnDataUpdate */:\n                return performance.now() <= this._private__endTime;\n        }\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            this._private__updateImpl();\n            this._private__invalidated = false;\n            this._private__stageInvalidated = false;\n        }\n        else if (this._private__stageInvalidated) {\n            this._private__updateRendererDataStage();\n            this._private__stageInvalidated = false;\n        }\n        return this._private__renderer;\n    }\n    _private__updateImpl() {\n        this._private__renderer._internal_setData(null);\n        const timeScale = this._private__series._internal_model()._internal_timeScale();\n        const visibleRange = timeScale._internal_visibleStrictRange();\n        const firstValue = this._private__series._internal_firstValue();\n        if (visibleRange === null || firstValue === null) {\n            return;\n        }\n        const lastValue = this._private__series._internal_lastValueData(true);\n        if (lastValue._internal_noData || !visibleRange._internal_contains(lastValue._internal_index)) {\n            return;\n        }\n        const lastValuePoint = {\n            x: timeScale._internal_indexToCoordinate(lastValue._internal_index),\n            y: this._private__series._internal_priceScale()._internal_priceToCoordinate(lastValue._internal_price, firstValue._internal_value),\n        };\n        const seriesLineColor = lastValue._internal_color;\n        const seriesLineWidth = this._private__series._internal_options().lineWidth;\n        const data = this._private__animationData(this._private__duration(), seriesLineColor);\n        this._private__renderer._internal_setData({\n            _internal_seriesLineColor: seriesLineColor,\n            _internal_seriesLineWidth: seriesLineWidth,\n            _internal_fillColor: data._internal_fillColor,\n            _internal_strokeColor: data._internal_strokeColor,\n            _internal_radius: data._internal_radius,\n            _internal_center: lastValuePoint,\n        });\n    }\n    _private__updateRendererDataStage() {\n        const rendererData = this._private__renderer._internal_data();\n        if (rendererData !== null) {\n            const data = this._private__animationData(this._private__duration(), rendererData._internal_seriesLineColor);\n            rendererData._internal_fillColor = data._internal_fillColor;\n            rendererData._internal_strokeColor = data._internal_strokeColor;\n            rendererData._internal_radius = data._internal_radius;\n        }\n    }\n    _private__duration() {\n        return this._internal_animationActive() ? performance.now() - this._private__startTime : 2600 /* Constants.AnimationPeriod */ - 1;\n    }\n    _private__color(seriesLineColor, stage, startAlpha, endAlpha) {\n        const alpha = startAlpha + (endAlpha - startAlpha) * stage;\n        return this._private__series._internal_model()._internal_colorParser()._internal_applyAlpha(seriesLineColor, alpha);\n    }\n    _private__animationData(durationSinceStart, lineColor) {\n        const globalStage = (durationSinceStart % 2600 /* Constants.AnimationPeriod */) / 2600 /* Constants.AnimationPeriod */;\n        let currentStageData;\n        for (const stageData of animationStagesData) {\n            if (globalStage >= stageData._internal_start && globalStage <= stageData._internal_end) {\n                currentStageData = stageData;\n                break;\n            }\n        }\n        assert(currentStageData !== undefined, 'Last price animation internal logic error');\n        const subStage = (globalStage - currentStageData._internal_start) / (currentStageData._internal_end - currentStageData._internal_start);\n        return {\n            _internal_fillColor: this._private__color(lineColor, subStage, currentStageData._internal_startFillAlpha, currentStageData._internal_endFillAlpha),\n            _internal_strokeColor: this._private__color(lineColor, subStage, currentStageData._internal_startStrokeAlpha, currentStageData._internal_endStrokeAlpha),\n            _internal_radius: radius(subStage, currentStageData._internal_startRadius, currentStageData._internal_endRadius),\n        };\n    }\n}\n\nclass SeriesPriceLinePaneView extends SeriesHorizontalLinePaneView {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(series) {\n        super(series);\n    }\n    _internal__updateImpl() {\n        const data = this._internal__lineRendererData;\n        data._internal_visible = false;\n        const seriesOptions = this._internal__series._internal_options();\n        if (!seriesOptions.priceLineVisible || !this._internal__series._internal_visible()) {\n            return;\n        }\n        const lastValueData = this._internal__series._internal_lastValueData(seriesOptions.priceLineSource === 0 /* PriceLineSource.LastBar */);\n        if (lastValueData._internal_noData) {\n            return;\n        }\n        data._internal_visible = true;\n        data._internal_y = lastValueData._internal_coordinate;\n        data._internal_color = this._internal__series._internal_priceLineColor(lastValueData._internal_color);\n        data._internal_lineWidth = seriesOptions.priceLineWidth;\n        data._internal_lineStyle = seriesOptions.priceLineStyle;\n    }\n}\n\nclass SeriesPriceAxisView extends PriceAxisView {\n    constructor(source) {\n        super();\n        this._private__source = source;\n    }\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonRendererData) {\n        axisRendererData._internal_visible = false;\n        paneRendererData._internal_visible = false;\n        const source = this._private__source;\n        if (!source._internal_visible()) {\n            return;\n        }\n        const seriesOptions = source._internal_options();\n        const showSeriesLastValue = seriesOptions.lastValueVisible;\n        const showSymbolLabel = source._internal_title() !== '';\n        const showPriceAndPercentage = seriesOptions.seriesLastValueMode === 0 /* PriceAxisLastValueMode.LastPriceAndPercentageValue */;\n        const lastValueData = source._internal_lastValueData(false);\n        if (lastValueData._internal_noData) {\n            return;\n        }\n        if (showSeriesLastValue) {\n            axisRendererData._internal_text = this._internal__axisText(lastValueData, showSeriesLastValue, showPriceAndPercentage);\n            axisRendererData._internal_visible = axisRendererData._internal_text.length !== 0;\n        }\n        if (showSymbolLabel || showPriceAndPercentage) {\n            paneRendererData._internal_text = this._internal__paneText(lastValueData, showSeriesLastValue, showSymbolLabel, showPriceAndPercentage);\n            paneRendererData._internal_visible = paneRendererData._internal_text.length > 0;\n        }\n        const lastValueColor = source._internal_priceLineColor(lastValueData._internal_color);\n        const colors = this._private__source._internal_model()._internal_colorParser()._internal_generateContrastColors(lastValueColor);\n        commonRendererData._internal_background = colors._internal_background;\n        commonRendererData._internal_coordinate = lastValueData._internal_coordinate;\n        paneRendererData._internal_borderColor = source._internal_model()._internal_backgroundColorAtYPercentFromTop(lastValueData._internal_coordinate / source._internal_priceScale()._internal_height());\n        axisRendererData._internal_borderColor = lastValueColor;\n        axisRendererData._internal_color = colors._internal_foreground;\n        paneRendererData._internal_color = colors._internal_foreground;\n    }\n    _internal__paneText(lastValue, showSeriesLastValue, showSymbolLabel, showPriceAndPercentage) {\n        let result = '';\n        const title = this._private__source._internal_title();\n        if (showSymbolLabel && title.length !== 0) {\n            result += `${title} `;\n        }\n        if (showSeriesLastValue && showPriceAndPercentage) {\n            result += this._private__source._internal_priceScale()._internal_isPercentage() ?\n                lastValue._internal_formattedPriceAbsolute : lastValue._internal_formattedPricePercentage;\n        }\n        return result.trim();\n    }\n    _internal__axisText(lastValueData, showSeriesLastValue, showPriceAndPercentage) {\n        if (!showSeriesLastValue) {\n            return '';\n        }\n        if (!showPriceAndPercentage) {\n            return lastValueData._internal_text;\n        }\n        return this._private__source._internal_priceScale()._internal_isPercentage() ?\n            lastValueData._internal_formattedPricePercentage : lastValueData._internal_formattedPriceAbsolute;\n    }\n}\n\nfunction computeFiniteResult(method, valueOne, valueTwo, fallback) {\n    const firstFinite = Number.isFinite(valueOne);\n    const secondFinite = Number.isFinite(valueTwo);\n    if (firstFinite && secondFinite) {\n        return method(valueOne, valueTwo);\n    }\n    return !firstFinite && !secondFinite ? fallback : (firstFinite ? valueOne : valueTwo);\n}\nclass PriceRangeImpl {\n    constructor(minValue, maxValue) {\n        this._private__minValue = minValue;\n        this._private__maxValue = maxValue;\n    }\n    _internal_equals(pr) {\n        if (pr === null) {\n            return false;\n        }\n        return this._private__minValue === pr._private__minValue && this._private__maxValue === pr._private__maxValue;\n    }\n    _internal_clone() {\n        return new PriceRangeImpl(this._private__minValue, this._private__maxValue);\n    }\n    _internal_minValue() {\n        return this._private__minValue;\n    }\n    _internal_maxValue() {\n        return this._private__maxValue;\n    }\n    _internal_length() {\n        return this._private__maxValue - this._private__minValue;\n    }\n    _internal_isEmpty() {\n        return this._private__maxValue === this._private__minValue || Number.isNaN(this._private__maxValue) || Number.isNaN(this._private__minValue);\n    }\n    _internal_merge(anotherRange) {\n        if (anotherRange === null) {\n            return this;\n        }\n        return new PriceRangeImpl(computeFiniteResult(Math.min, this._internal_minValue(), anotherRange._internal_minValue(), -Infinity), computeFiniteResult(Math.max, this._internal_maxValue(), anotherRange._internal_maxValue(), Infinity));\n    }\n    _internal_scaleAroundCenter(coeff) {\n        if (!isNumber(coeff)) {\n            return;\n        }\n        const delta = this._private__maxValue - this._private__minValue;\n        if (delta === 0) {\n            return;\n        }\n        const center = (this._private__maxValue + this._private__minValue) * 0.5;\n        let maxDelta = this._private__maxValue - center;\n        let minDelta = this._private__minValue - center;\n        maxDelta *= coeff;\n        minDelta *= coeff;\n        this._private__maxValue = center + maxDelta;\n        this._private__minValue = center + minDelta;\n    }\n    _internal_shift(delta) {\n        if (!isNumber(delta)) {\n            return;\n        }\n        this._private__maxValue += delta;\n        this._private__minValue += delta;\n    }\n    _internal_toRaw() {\n        return {\n            minValue: this._private__minValue,\n            maxValue: this._private__maxValue,\n        };\n    }\n    static _internal_fromRaw(raw) {\n        return (raw === null) ? null : new PriceRangeImpl(raw.minValue, raw.maxValue);\n    }\n}\n\nclass AutoscaleInfoImpl {\n    constructor(priceRange, margins) {\n        this._private__priceRange = priceRange;\n        this._private__margins = margins || null;\n    }\n    _internal_priceRange() {\n        return this._private__priceRange;\n    }\n    _internal_margins() {\n        return this._private__margins;\n    }\n    _internal_toRaw() {\n        return {\n            priceRange: this._private__priceRange === null ? null : this._private__priceRange._internal_toRaw(),\n            margins: this._private__margins || undefined,\n        };\n    }\n    static _internal_fromRaw(raw) {\n        return (raw === null) ? null : new AutoscaleInfoImpl(PriceRangeImpl._internal_fromRaw(raw.priceRange), raw.margins);\n    }\n}\n\nclass CustomPriceLinePaneView extends SeriesHorizontalLinePaneView {\n    constructor(series, priceLine) {\n        super(series);\n        this._private__priceLine = priceLine;\n    }\n    _internal__updateImpl() {\n        const data = this._internal__lineRendererData;\n        data._internal_visible = false;\n        const lineOptions = this._private__priceLine._internal_options();\n        if (!this._internal__series._internal_visible() || !lineOptions.lineVisible) {\n            return;\n        }\n        const y = this._private__priceLine._internal_yCoord();\n        if (y === null) {\n            return;\n        }\n        data._internal_visible = true;\n        data._internal_y = y;\n        data._internal_color = lineOptions.color;\n        data._internal_lineWidth = lineOptions.lineWidth;\n        data._internal_lineStyle = lineOptions.lineStyle;\n        data._internal_externalId = this._private__priceLine._internal_options().id;\n    }\n}\n\nclass CustomPriceLinePriceAxisView extends PriceAxisView {\n    constructor(series, priceLine) {\n        super();\n        this._private__series = series;\n        this._private__priceLine = priceLine;\n    }\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonData) {\n        axisRendererData._internal_visible = false;\n        paneRendererData._internal_visible = false;\n        const options = this._private__priceLine._internal_options();\n        const labelVisible = options.axisLabelVisible;\n        const showPaneLabel = options.title !== '';\n        const series = this._private__series;\n        if (!labelVisible || !series._internal_visible()) {\n            return;\n        }\n        const y = this._private__priceLine._internal_yCoord();\n        if (y === null) {\n            return;\n        }\n        if (showPaneLabel) {\n            paneRendererData._internal_text = options.title;\n            paneRendererData._internal_visible = true;\n        }\n        paneRendererData._internal_borderColor = series._internal_model()._internal_backgroundColorAtYPercentFromTop(y / series._internal_priceScale()._internal_height());\n        axisRendererData._internal_text = this._private__formatPrice(options.price);\n        axisRendererData._internal_visible = true;\n        const colors = this._private__series._internal_model()._internal_colorParser()._internal_generateContrastColors(options.axisLabelColor || options.color);\n        commonData._internal_background = colors._internal_background;\n        const textColor = options.axisLabelTextColor || colors._internal_foreground;\n        axisRendererData._internal_color = textColor; // price text\n        paneRendererData._internal_color = textColor; // title text\n        commonData._internal_coordinate = y;\n    }\n    _private__formatPrice(price) {\n        const firstValue = this._private__series._internal_firstValue();\n        if (firstValue === null) {\n            return '';\n        }\n        return this._private__series._internal_priceScale()._internal_formatPrice(price, firstValue._internal_value);\n    }\n}\n\nclass CustomPriceLine {\n    constructor(series, options) {\n        this._private__series = series;\n        this._private__options = options;\n        this._private__priceLineView = new CustomPriceLinePaneView(series, this);\n        this._private__priceAxisView = new CustomPriceLinePriceAxisView(series, this);\n        this._private__panePriceAxisView = new PanePriceAxisView(this._private__priceAxisView, series, series._internal_model());\n    }\n    _internal_applyOptions(options) {\n        merge(this._private__options, options);\n        this._internal_update();\n        this._private__series._internal_model()._internal_lightUpdate();\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_paneView() {\n        return this._private__priceLineView;\n    }\n    _internal_labelPaneView() {\n        return this._private__panePriceAxisView;\n    }\n    _internal_priceAxisView() {\n        return this._private__priceAxisView;\n    }\n    _internal_update() {\n        this._private__priceLineView._internal_update();\n        this._private__priceAxisView._internal_update();\n    }\n    _internal_yCoord() {\n        const series = this._private__series;\n        const priceScale = series._internal_priceScale();\n        const timeScale = series._internal_model()._internal_timeScale();\n        if (timeScale._internal_isEmpty() || priceScale._internal_isEmpty()) {\n            return null;\n        }\n        const firstValue = series._internal_firstValue();\n        if (firstValue === null) {\n            return null;\n        }\n        return priceScale._internal_priceToCoordinate(this._private__options.price, firstValue._internal_value);\n    }\n}\n\nclass PriceDataSource extends DataSource {\n    constructor(model) {\n        super();\n        this._private__model = model;\n    }\n    _internal_model() {\n        return this._private__model;\n    }\n}\n\nconst barStyleFnMap = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Bar: (findBar, barStyle, barIndex, precomputedBars) => {\n        const upColor = barStyle.upColor;\n        const downColor = barStyle.downColor;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        const isUp = ensure(currentBar._internal_value[0 /* PlotRowValueIndex.Open */]) <= ensure(currentBar._internal_value[3 /* PlotRowValueIndex.Close */]);\n        return {\n            _internal_barColor: currentBar._internal_color ?? (isUp ? upColor : downColor),\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Candlestick: (findBar, candlestickStyle, barIndex, precomputedBars) => {\n        const upColor = candlestickStyle.upColor;\n        const downColor = candlestickStyle.downColor;\n        const borderUpColor = candlestickStyle.borderUpColor;\n        const borderDownColor = candlestickStyle.borderDownColor;\n        const wickUpColor = candlestickStyle.wickUpColor;\n        const wickDownColor = candlestickStyle.wickDownColor;\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        const isUp = ensure(currentBar._internal_value[0 /* PlotRowValueIndex.Open */]) <= ensure(currentBar._internal_value[3 /* PlotRowValueIndex.Close */]);\n        return {\n            _internal_barColor: currentBar._internal_color ?? (isUp ? upColor : downColor),\n            _internal_barBorderColor: currentBar._internal_borderColor ?? (isUp ? borderUpColor : borderDownColor),\n            _internal_barWickColor: currentBar._internal_wickColor ?? (isUp ? wickUpColor : wickDownColor),\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Custom: (findBar, customStyle, barIndex, precomputedBars) => {\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        return {\n            _internal_barColor: currentBar._internal_color ?? customStyle.color,\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Area: (findBar, areaStyle, barIndex, precomputedBars) => {\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        return {\n            _internal_barColor: currentBar._internal_lineColor ?? areaStyle.lineColor,\n            _internal_lineColor: currentBar._internal_lineColor ?? areaStyle.lineColor,\n            _internal_topColor: currentBar._internal_topColor ?? areaStyle.topColor,\n            _internal_bottomColor: currentBar._internal_bottomColor ?? areaStyle.bottomColor,\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Baseline: (findBar, baselineStyle, barIndex, precomputedBars) => {\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        const isAboveBaseline = currentBar._internal_value[3 /* PlotRowValueIndex.Close */] >= baselineStyle.baseValue.price;\n        return {\n            _internal_barColor: isAboveBaseline ? baselineStyle.topLineColor : baselineStyle.bottomLineColor,\n            _internal_topLineColor: currentBar._internal_topLineColor ?? baselineStyle.topLineColor,\n            _internal_bottomLineColor: currentBar._internal_bottomLineColor ?? baselineStyle.bottomLineColor,\n            _internal_topFillColor1: currentBar._internal_topFillColor1 ?? baselineStyle.topFillColor1,\n            _internal_topFillColor2: currentBar._internal_topFillColor2 ?? baselineStyle.topFillColor2,\n            _internal_bottomFillColor1: currentBar._internal_bottomFillColor1 ?? baselineStyle.bottomFillColor1,\n            _internal_bottomFillColor2: currentBar._internal_bottomFillColor2 ?? baselineStyle.bottomFillColor2,\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Line: (findBar, lineStyle, barIndex, precomputedBars) => {\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        return {\n            _internal_barColor: currentBar._internal_color ?? lineStyle.color,\n            _internal_lineColor: currentBar._internal_color ?? lineStyle.color,\n        };\n    },\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Histogram: (findBar, histogramStyle, barIndex, precomputedBars) => {\n        const currentBar = ensureNotNull(findBar(barIndex, precomputedBars));\n        return {\n            _internal_barColor: currentBar._internal_color ?? histogramStyle.color,\n        };\n    },\n};\nclass SeriesBarColorer {\n    constructor(series) {\n        this._private__findBar = (barIndex, precomputedBars) => {\n            if (precomputedBars !== undefined) {\n                return precomputedBars._internal_value;\n            }\n            return this._private__series._internal_bars()._internal_valueAt(barIndex);\n        };\n        this._private__series = series;\n        this._private__styleGetter = barStyleFnMap[series._internal_seriesType()];\n    }\n    _internal_barStyle(barIndex, precomputedBars) {\n        // precomputedBars: {value: [Array BarValues], previousValue: [Array BarValues] | undefined}\n        // Used to avoid binary search if bars are already known\n        return this._private__styleGetter(this._private__findBar, this._private__series._internal_options(), barIndex, precomputedBars);\n    }\n}\n\n/**\n * Binary function that accepts two arguments (the first of the type of array elements, and the second is always val), and returns a value convertible to bool.\n * The value returned indicates whether the first argument is considered to go before the second.\n * The function shall not modify any of its arguments.\n */\nfunction boundCompare(lower, arr, value, compare, start = 0, to = arr.length) {\n    let count = to - start;\n    while (0 < count) {\n        const count2 = (count >> 1);\n        const mid = start + count2;\n        if (compare(arr[mid], value) === lower) {\n            start = mid + 1;\n            count -= count2 + 1;\n        }\n        else {\n            count = count2;\n        }\n    }\n    return start;\n}\nconst lowerBound = boundCompare.bind(null, true);\nconst upperBound = boundCompare.bind(null, false);\n\n/**\n * Search direction if no data found at provided index\n */\nvar MismatchDirection;\n(function (MismatchDirection) {\n    /**\n     * Search the nearest left item\n     */\n    MismatchDirection[MismatchDirection[\"NearestLeft\"] = -1] = \"NearestLeft\";\n    /**\n     * Do not search\n     */\n    MismatchDirection[MismatchDirection[\"None\"] = 0] = \"None\";\n    /**\n     * Search the nearest right item\n     */\n    MismatchDirection[MismatchDirection[\"NearestRight\"] = 1] = \"NearestRight\";\n})(MismatchDirection || (MismatchDirection = {}));\n// TODO: think about changing it dynamically\nconst CHUNK_SIZE = 30;\n/**\n * PlotList is an array of plot rows\n * each plot row consists of key (index in timescale) and plot value map\n */\nclass PlotList {\n    constructor() {\n        this._private__items = [];\n        this._private__minMaxCache = new Map();\n        this._private__rowSearchCache = new Map();\n        this._private__indices = [];\n    }\n    // @returns Last row\n    _internal_last() {\n        return this._internal_size() > 0 ? this._private__items[this._private__items.length - 1] : null;\n    }\n    _internal_firstIndex() {\n        return this._internal_size() > 0 ? this._private__indexAt(0) : null;\n    }\n    _internal_lastIndex() {\n        return this._internal_size() > 0 ? this._private__indexAt((this._private__items.length - 1)) : null;\n    }\n    _internal_size() {\n        return this._private__items.length;\n    }\n    _internal_isEmpty() {\n        return this._internal_size() === 0;\n    }\n    _internal_contains(index) {\n        return this._private__search(index, 0 /* MismatchDirection.None */) !== null;\n    }\n    _internal_valueAt(index) {\n        return this._internal_search(index);\n    }\n    _internal_search(index, searchMode = 0 /* MismatchDirection.None */) {\n        const pos = this._private__search(index, searchMode);\n        if (pos === null) {\n            return null;\n        }\n        return {\n            ...this._private__valueAt(pos),\n            _internal_index: this._private__indexAt(pos),\n        };\n    }\n    _internal_rows() {\n        return this._private__items;\n    }\n    _internal_minMaxOnRangeCached(start, end, plots) {\n        // this code works for single series only\n        // could fail after whitespaces implementation\n        if (this._internal_isEmpty()) {\n            return null;\n        }\n        let result = null;\n        for (const plot of plots) {\n            const plotMinMax = this._private__minMaxOnRangeCachedImpl(start, end, plot);\n            result = mergeMinMax(result, plotMinMax);\n        }\n        return result;\n    }\n    _internal_setData(plotRows) {\n        this._private__rowSearchCache.clear();\n        this._private__minMaxCache.clear();\n        this._private__items = plotRows;\n        this._private__indices = plotRows.map((plotRow) => plotRow._internal_index);\n    }\n    // TimePointIndex values for fulfilled data points\n    _internal_indices() {\n        return this._private__indices;\n    }\n    _private__indexAt(offset) {\n        return this._private__items[offset]._internal_index;\n    }\n    _private__valueAt(offset) {\n        return this._private__items[offset];\n    }\n    _private__search(index, searchMode) {\n        const exactPos = this._private__bsearch(index);\n        if (exactPos === null && searchMode !== 0 /* MismatchDirection.None */) {\n            switch (searchMode) {\n                case -1 /* MismatchDirection.NearestLeft */:\n                    return this._private__searchNearestLeft(index);\n                case 1 /* MismatchDirection.NearestRight */:\n                    return this._private__searchNearestRight(index);\n                default:\n                    throw new TypeError('Unknown search mode');\n            }\n        }\n        return exactPos;\n    }\n    _private__searchNearestLeft(index) {\n        let nearestLeftPos = this._private__lowerbound(index);\n        if (nearestLeftPos > 0) {\n            nearestLeftPos = nearestLeftPos - 1;\n        }\n        return (nearestLeftPos !== this._private__items.length && this._private__indexAt(nearestLeftPos) < index) ? nearestLeftPos : null;\n    }\n    _private__searchNearestRight(index) {\n        const nearestRightPos = this._private__upperbound(index);\n        return (nearestRightPos !== this._private__items.length && index < this._private__indexAt(nearestRightPos)) ? nearestRightPos : null;\n    }\n    _private__bsearch(index) {\n        const start = this._private__lowerbound(index);\n        if (start !== this._private__items.length && !(index < this._private__items[start]._internal_index)) {\n            return start;\n        }\n        return null;\n    }\n    _private__lowerbound(index) {\n        return lowerBound(this._private__items, index, (a, b) => a._internal_index < b);\n    }\n    _private__upperbound(index) {\n        return upperBound(this._private__items, index, (a, b) => a._internal_index > b);\n    }\n    _private__plotMinMax(startIndex, endIndexExclusive, plotIndex) {\n        let result = null;\n        for (let i = startIndex; i < endIndexExclusive; i++) {\n            const values = this._private__items[i]._internal_value;\n            const v = values[plotIndex];\n            if (Number.isNaN(v)) {\n                continue;\n            }\n            if (result === null) {\n                result = { _internal_min: v, _internal_max: v };\n            }\n            else {\n                if (v < result._internal_min) {\n                    result._internal_min = v;\n                }\n                if (v > result._internal_max) {\n                    result._internal_max = v;\n                }\n            }\n        }\n        return result;\n    }\n    _private__minMaxOnRangeCachedImpl(start, end, plotIndex) {\n        // this code works for single series only\n        // could fail after whitespaces implementation\n        if (this._internal_isEmpty()) {\n            return null;\n        }\n        let result = null;\n        // assume that bar indexes only increase\n        const firstIndex = ensureNotNull(this._internal_firstIndex());\n        const lastIndex = ensureNotNull(this._internal_lastIndex());\n        const s = Math.max(start, firstIndex);\n        const e = Math.min(end, lastIndex);\n        const cachedLow = Math.ceil(s / CHUNK_SIZE) * CHUNK_SIZE;\n        const cachedHigh = Math.max(cachedLow, Math.floor(e / CHUNK_SIZE) * CHUNK_SIZE);\n        {\n            const startIndex = this._private__lowerbound(s);\n            const endIndex = this._private__upperbound(Math.min(e, cachedLow, end)); // non-inclusive end\n            const plotMinMax = this._private__plotMinMax(startIndex, endIndex, plotIndex);\n            result = mergeMinMax(result, plotMinMax);\n        }\n        let minMaxCache = this._private__minMaxCache.get(plotIndex);\n        if (minMaxCache === undefined) {\n            minMaxCache = new Map();\n            this._private__minMaxCache.set(plotIndex, minMaxCache);\n        }\n        // now go cached\n        for (let c = Math.max(cachedLow + 1, s); c < cachedHigh; c += CHUNK_SIZE) {\n            const chunkIndex = Math.floor(c / CHUNK_SIZE);\n            let chunkMinMax = minMaxCache.get(chunkIndex);\n            if (chunkMinMax === undefined) {\n                const chunkStart = this._private__lowerbound(chunkIndex * CHUNK_SIZE);\n                const chunkEnd = this._private__upperbound((chunkIndex + 1) * CHUNK_SIZE - 1);\n                chunkMinMax = this._private__plotMinMax(chunkStart, chunkEnd, plotIndex);\n                minMaxCache.set(chunkIndex, chunkMinMax);\n            }\n            result = mergeMinMax(result, chunkMinMax);\n        }\n        // tail\n        {\n            const startIndex = this._private__lowerbound(cachedHigh);\n            const endIndex = this._private__upperbound(e); // non-inclusive end\n            const plotMinMax = this._private__plotMinMax(startIndex, endIndex, plotIndex);\n            result = mergeMinMax(result, plotMinMax);\n        }\n        return result;\n    }\n}\nfunction mergeMinMax(first, second) {\n    if (first === null) {\n        return second;\n    }\n    else {\n        if (second === null) {\n            return first;\n        }\n        else {\n            // merge MinMax values\n            const min = Math.min(first._internal_min, second._internal_min);\n            const max = Math.max(first._internal_max, second._internal_max);\n            return { _internal_min: min, _internal_max: max };\n        }\n    }\n}\n\nfunction createSeriesPlotList() {\n    return new PlotList();\n}\n\nclass PrimitiveRendererWrapper {\n    constructor(baseRenderer) {\n        this._private__baseRenderer = baseRenderer;\n    }\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__baseRenderer.draw(target);\n    }\n    _internal_drawBackground(target, isHovered, hitTestData) {\n        this._private__baseRenderer.drawBackground?.(target);\n    }\n}\nclass PrimitivePaneViewWrapper {\n    constructor(paneView) {\n        this._private__cache = null;\n        this._private__paneView = paneView;\n    }\n    _internal_renderer() {\n        const baseRenderer = this._private__paneView.renderer();\n        if (baseRenderer === null) {\n            return null;\n        }\n        if (this._private__cache?._internal_base === baseRenderer) {\n            return this._private__cache._internal_wrapper;\n        }\n        const wrapper = new PrimitiveRendererWrapper(baseRenderer);\n        this._private__cache = {\n            _internal_base: baseRenderer,\n            _internal_wrapper: wrapper,\n        };\n        return wrapper;\n    }\n    _internal_zOrder() {\n        return this._private__paneView.zOrder?.() ?? 'normal';\n    }\n}\nclass PrimitiveWrapper {\n    constructor(primitive) {\n        this._private__paneViewsCache = null;\n        this._internal__primitive = primitive;\n    }\n    _internal_primitive() {\n        return this._internal__primitive;\n    }\n    _internal_updateAllViews() {\n        this._internal__primitive.updateAllViews?.();\n    }\n    _internal_paneViews() {\n        const base = this._internal__primitive.paneViews?.() ?? [];\n        if (this._private__paneViewsCache?._internal_base === base) {\n            return this._private__paneViewsCache._internal_wrapper;\n        }\n        const wrapper = base.map((pw) => new PrimitivePaneViewWrapper(pw));\n        this._private__paneViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper,\n        };\n        return wrapper;\n    }\n    _internal_hitTest(x, y) {\n        return this._internal__primitive.hitTest?.(x, y) ?? null;\n    }\n}\nlet PanePrimitiveWrapper$1 = class PanePrimitiveWrapper extends PrimitiveWrapper {\n    _internal_labelPaneViews() {\n        return [];\n    }\n};\n\nclass SeriesPrimitiveRendererWrapper {\n    constructor(baseRenderer) {\n        this._private__baseRenderer = baseRenderer;\n    }\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__baseRenderer.draw(target);\n    }\n    _internal_drawBackground(target, isHovered, hitTestData) {\n        this._private__baseRenderer.drawBackground?.(target);\n    }\n}\nclass SeriesPrimitivePaneViewWrapper {\n    constructor(paneView) {\n        this._private__cache = null;\n        this._private__paneView = paneView;\n    }\n    _internal_renderer() {\n        const baseRenderer = this._private__paneView.renderer();\n        if (baseRenderer === null) {\n            return null;\n        }\n        if (this._private__cache?._internal_base === baseRenderer) {\n            return this._private__cache._internal_wrapper;\n        }\n        const wrapper = new SeriesPrimitiveRendererWrapper(baseRenderer);\n        this._private__cache = {\n            _internal_base: baseRenderer,\n            _internal_wrapper: wrapper,\n        };\n        return wrapper;\n    }\n    _internal_zOrder() {\n        return this._private__paneView.zOrder?.() ?? 'normal';\n    }\n}\nfunction getAxisViewData(baseView) {\n    return {\n        _internal_text: baseView.text(),\n        _internal_coordinate: baseView.coordinate(),\n        _internal_fixedCoordinate: baseView.fixedCoordinate?.(),\n        _internal_color: baseView.textColor(),\n        _internal_background: baseView.backColor(),\n        _internal_visible: baseView.visible?.() ?? true,\n        _internal_tickVisible: baseView.tickVisible?.() ?? true,\n    };\n}\nclass SeriesPrimitiveTimeAxisViewWrapper {\n    constructor(baseView, timeScale) {\n        this._private__renderer = new TimeAxisViewRenderer();\n        this._private__baseView = baseView;\n        this._private__timeScale = timeScale;\n    }\n    _internal_renderer() {\n        this._private__renderer._internal_setData({\n            _internal_width: this._private__timeScale._internal_width(),\n            ...getAxisViewData(this._private__baseView),\n        });\n        return this._private__renderer;\n    }\n}\nclass SeriesPrimitivePriceAxisViewWrapper extends PriceAxisView {\n    constructor(baseView, priceScale) {\n        super();\n        this._private__baseView = baseView;\n        this._private__priceScale = priceScale;\n    }\n    _internal__updateRendererData(axisRendererData, paneRendererData, commonRendererData) {\n        const data = getAxisViewData(this._private__baseView);\n        commonRendererData._internal_background = data._internal_background;\n        axisRendererData._internal_color = data._internal_color;\n        const additionalPadding = 2 / 12 * this._private__priceScale._internal_fontSize();\n        commonRendererData._internal_additionalPaddingTop = additionalPadding;\n        commonRendererData._internal_additionalPaddingBottom = additionalPadding;\n        commonRendererData._internal_coordinate = data._internal_coordinate;\n        commonRendererData._internal_fixedCoordinate = data._internal_fixedCoordinate;\n        axisRendererData._internal_text = data._internal_text;\n        axisRendererData._internal_visible = data._internal_visible;\n        axisRendererData._internal_tickVisible = data._internal_tickVisible;\n    }\n}\nclass SeriesPrimitiveWrapper extends PrimitiveWrapper {\n    constructor(primitive, series) {\n        super(primitive);\n        this._private__timeAxisViewsCache = null;\n        this._private__priceAxisViewsCache = null;\n        this._private__priceAxisPaneViewsCache = null;\n        this._private__timeAxisPaneViewsCache = null;\n        this._private__series = series;\n    }\n    _internal_timeAxisViews() {\n        const base = this._internal__primitive.timeAxisViews?.() ?? [];\n        if (this._private__timeAxisViewsCache?._internal_base === base) {\n            return this._private__timeAxisViewsCache._internal_wrapper;\n        }\n        const timeScale = this._private__series._internal_model()._internal_timeScale();\n        const wrapper = base.map((aw) => new SeriesPrimitiveTimeAxisViewWrapper(aw, timeScale));\n        this._private__timeAxisViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper,\n        };\n        return wrapper;\n    }\n    _internal_priceAxisViews() {\n        const base = this._internal__primitive.priceAxisViews?.() ?? [];\n        if (this._private__priceAxisViewsCache?._internal_base === base) {\n            return this._private__priceAxisViewsCache._internal_wrapper;\n        }\n        const priceScale = this._private__series._internal_priceScale();\n        const wrapper = base.map((aw) => new SeriesPrimitivePriceAxisViewWrapper(aw, priceScale));\n        this._private__priceAxisViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper,\n        };\n        return wrapper;\n    }\n    _internal_priceAxisPaneViews() {\n        const base = this._internal__primitive.priceAxisPaneViews?.() ?? [];\n        if (this._private__priceAxisPaneViewsCache?._internal_base === base) {\n            return this._private__priceAxisPaneViewsCache._internal_wrapper;\n        }\n        const wrapper = base.map((pw) => new SeriesPrimitivePaneViewWrapper(pw));\n        this._private__priceAxisPaneViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper,\n        };\n        return wrapper;\n    }\n    _internal_timeAxisPaneViews() {\n        const base = this._internal__primitive.timeAxisPaneViews?.() ?? [];\n        if (this._private__timeAxisPaneViewsCache?._internal_base === base) {\n            return this._private__timeAxisPaneViewsCache._internal_wrapper;\n        }\n        const wrapper = base.map((pw) => new SeriesPrimitivePaneViewWrapper(pw));\n        this._private__timeAxisPaneViewsCache = {\n            _internal_base: base,\n            _internal_wrapper: wrapper,\n        };\n        return wrapper;\n    }\n    _internal_autoscaleInfo(startTimePoint, endTimePoint) {\n        return (this._internal__primitive.autoscaleInfo?.(startTimePoint, endTimePoint) ?? null);\n    }\n}\n\nfunction extractPrimitivePaneViews(primitives, extractor, zOrder, destination) {\n    primitives.forEach((wrapper) => {\n        extractor(wrapper).forEach((paneView) => {\n            if (paneView._internal_zOrder() !== zOrder) {\n                return;\n            }\n            destination.push(paneView);\n        });\n    });\n}\nfunction primitivePaneViewsExtractor(wrapper) {\n    return wrapper._internal_paneViews();\n}\nfunction primitivePricePaneViewsExtractor(wrapper) {\n    return wrapper._internal_priceAxisPaneViews();\n}\nfunction primitiveTimePaneViewsExtractor(wrapper) {\n    return wrapper._internal_timeAxisPaneViews();\n}\nconst lineBasedSeries = ['Area', 'Line', 'Baseline'];\nclass Series extends PriceDataSource {\n    constructor(model, seriesType, options, createPaneView, customPaneView) {\n        super(model);\n        this._private__data = createSeriesPlotList();\n        this._private__priceLineView = new SeriesPriceLinePaneView(this);\n        this._private__customPriceLines = [];\n        this._private__baseHorizontalLineView = new SeriesHorizontalBaseLinePaneView(this);\n        this._private__lastPriceAnimationPaneView = null;\n        this._private__barColorerCache = null;\n        this._private__animationTimeoutId = null;\n        this._private__primitives = [];\n        this._private__options = options;\n        this._private__seriesType = seriesType;\n        const priceAxisView = new SeriesPriceAxisView(this);\n        this._private__priceAxisViews = [priceAxisView];\n        this._private__panePriceAxisView = new PanePriceAxisView(priceAxisView, this, model);\n        if (lineBasedSeries.includes(this._private__seriesType)) {\n            this._private__lastPriceAnimationPaneView = new SeriesLastPriceAnimationPaneView(this);\n        }\n        this._private__recreateFormatter();\n        this._private__paneView = createPaneView(this, this._internal_model(), customPaneView);\n    }\n    _internal_destroy() {\n        if (this._private__animationTimeoutId !== null) {\n            clearTimeout(this._private__animationTimeoutId);\n        }\n    }\n    _internal_priceLineColor(lastBarColor) {\n        return this._private__options.priceLineColor || lastBarColor;\n    }\n    _internal_lastValueData(globalLast) {\n        const noDataRes = { _internal_noData: true };\n        const priceScale = this._internal_priceScale();\n        if (this._internal_model()._internal_timeScale()._internal_isEmpty() || priceScale._internal_isEmpty() || this._private__data._internal_isEmpty()) {\n            return noDataRes;\n        }\n        const visibleBars = this._internal_model()._internal_timeScale()._internal_visibleStrictRange();\n        const firstValue = this._internal_firstValue();\n        if (visibleBars === null || firstValue === null) {\n            return noDataRes;\n        }\n        // find range of bars inside range\n        // TODO: make it more optimal\n        let bar;\n        let lastIndex;\n        if (globalLast) {\n            const lastBar = this._private__data._internal_last();\n            if (lastBar === null) {\n                return noDataRes;\n            }\n            bar = lastBar;\n            lastIndex = lastBar._internal_index;\n        }\n        else {\n            const endBar = this._private__data._internal_search(visibleBars._internal_right(), -1 /* MismatchDirection.NearestLeft */);\n            if (endBar === null) {\n                return noDataRes;\n            }\n            bar = this._private__data._internal_valueAt(endBar._internal_index);\n            if (bar === null) {\n                return noDataRes;\n            }\n            lastIndex = endBar._internal_index;\n        }\n        const price = bar._internal_value[3 /* PlotRowValueIndex.Close */];\n        const barColorer = this._internal_barColorer();\n        const style = barColorer._internal_barStyle(lastIndex, { _internal_value: bar });\n        const coordinate = priceScale._internal_priceToCoordinate(price, firstValue._internal_value);\n        return {\n            _internal_noData: false,\n            _internal_price: price,\n            _internal_text: priceScale._internal_formatPrice(price, firstValue._internal_value),\n            _internal_formattedPriceAbsolute: priceScale._internal_formatPriceAbsolute(price),\n            _internal_formattedPricePercentage: priceScale._internal_formatPricePercentage(price, firstValue._internal_value),\n            _internal_color: style._internal_barColor,\n            _internal_coordinate: coordinate,\n            _internal_index: lastIndex,\n        };\n    }\n    _internal_barColorer() {\n        if (this._private__barColorerCache !== null) {\n            return this._private__barColorerCache;\n        }\n        this._private__barColorerCache = new SeriesBarColorer(this);\n        return this._private__barColorerCache;\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyOptions(options) {\n        const targetPriceScaleId = options.priceScaleId;\n        if (targetPriceScaleId !== undefined && targetPriceScaleId !== this._private__options.priceScaleId) {\n            // series cannot do it itself, ask model\n            this._internal_model()._internal_moveSeriesToScale(this, targetPriceScaleId);\n        }\n        merge(this._private__options, options);\n        if (options.priceFormat !== undefined) {\n            this._private__recreateFormatter();\n            // updated formatter might affect rendering  and as a consequence of this the width of price axis might be changed\n            // thus we need to force the chart to do a full update to apply changes correctly\n            // full update is quite heavy operation in terms of performance\n            // but updating formatter looks like quite rare so forcing a full update here shouldn't affect the performance a lot\n            this._internal_model()._internal_fullUpdate();\n        }\n        this._internal_model()._internal_updateSource(this);\n        // a series might affect crosshair by some options (like crosshair markers)\n        // that's why we need to update crosshair as well\n        this._internal_model()._internal_updateCrosshair();\n        this._private__paneView._internal_update('options');\n    }\n    _internal_setData(data, updateInfo) {\n        this._private__data._internal_setData(data);\n        this._private__paneView._internal_update('data');\n        if (this._private__lastPriceAnimationPaneView !== null) {\n            if (updateInfo && updateInfo._internal_lastBarUpdatedOrNewBarsAddedToTheRight) {\n                this._private__lastPriceAnimationPaneView._internal_onNewRealtimeDataReceived();\n            }\n            else if (data.length === 0) {\n                this._private__lastPriceAnimationPaneView._internal_onDataCleared();\n            }\n        }\n        const sourcePane = this._internal_model()._internal_paneForSource(this);\n        this._internal_model()._internal_recalculatePane(sourcePane);\n        this._internal_model()._internal_updateSource(this);\n        this._internal_model()._internal_updateCrosshair();\n        this._internal_model()._internal_lightUpdate();\n    }\n    _internal_createPriceLine(options) {\n        const result = new CustomPriceLine(this, options);\n        this._private__customPriceLines.push(result);\n        this._internal_model()._internal_updateSource(this);\n        return result;\n    }\n    _internal_removePriceLine(line) {\n        const index = this._private__customPriceLines.indexOf(line);\n        if (index !== -1) {\n            this._private__customPriceLines.splice(index, 1);\n        }\n        this._internal_model()._internal_updateSource(this);\n    }\n    _internal_priceLines() {\n        return this._private__customPriceLines;\n    }\n    _internal_seriesType() {\n        return this._private__seriesType;\n    }\n    _internal_firstValue() {\n        const bar = this._internal_firstBar();\n        if (bar === null) {\n            return null;\n        }\n        return {\n            _internal_value: bar._internal_value[3 /* PlotRowValueIndex.Close */],\n            _internal_timePoint: bar._internal_time,\n        };\n    }\n    _internal_firstBar() {\n        const visibleBars = this._internal_model()._internal_timeScale()._internal_visibleStrictRange();\n        if (visibleBars === null) {\n            return null;\n        }\n        const startTimePoint = visibleBars._internal_left();\n        return this._private__data._internal_search(startTimePoint, 1 /* MismatchDirection.NearestRight */);\n    }\n    _internal_bars() {\n        return this._private__data;\n    }\n    _internal_dataAt(time) {\n        const prices = this._private__data._internal_valueAt(time);\n        if (prices === null) {\n            return null;\n        }\n        if (this._private__seriesType === 'Bar' || this._private__seriesType === 'Candlestick' || this._private__seriesType === 'Custom') {\n            return {\n                _internal_open: prices._internal_value[0 /* PlotRowValueIndex.Open */],\n                _internal_high: prices._internal_value[1 /* PlotRowValueIndex.High */],\n                _internal_low: prices._internal_value[2 /* PlotRowValueIndex.Low */],\n                _internal_close: prices._internal_value[3 /* PlotRowValueIndex.Close */],\n            };\n        }\n        else {\n            return prices._internal_value[3 /* PlotRowValueIndex.Close */];\n        }\n    }\n    _internal_topPaneViews(pane) {\n        const res = [];\n        extractPrimitivePaneViews(this._private__primitives, primitivePaneViewsExtractor, 'top', res);\n        const animationPaneView = this._private__lastPriceAnimationPaneView;\n        if (animationPaneView === null || !animationPaneView._internal_visible()) {\n            return res;\n        }\n        if (this._private__animationTimeoutId === null && animationPaneView._internal_animationActive()) {\n            this._private__animationTimeoutId = setTimeout(() => {\n                this._private__animationTimeoutId = null;\n                this._internal_model()._internal_cursorUpdate();\n            }, 0);\n        }\n        animationPaneView._internal_invalidateStage();\n        res.unshift(animationPaneView);\n        return res;\n    }\n    _internal_paneViews() {\n        const res = [];\n        if (!this._private__isOverlay()) {\n            res.push(this._private__baseHorizontalLineView);\n        }\n        res.push(this._private__paneView, this._private__priceLineView);\n        const priceLineViews = this._private__customPriceLines.map((line) => line._internal_paneView());\n        res.push(...priceLineViews);\n        extractPrimitivePaneViews(this._private__primitives, primitivePaneViewsExtractor, 'normal', res);\n        return res;\n    }\n    _internal_bottomPaneViews() {\n        return this._private__extractPaneViews(primitivePaneViewsExtractor, 'bottom');\n    }\n    _internal_pricePaneViews(zOrder) {\n        return this._private__extractPaneViews(primitivePricePaneViewsExtractor, zOrder);\n    }\n    _internal_timePaneViews(zOrder) {\n        return this._private__extractPaneViews(primitiveTimePaneViewsExtractor, zOrder);\n    }\n    _internal_primitiveHitTest(x, y) {\n        return this._private__primitives\n            .map((primitive) => primitive._internal_hitTest(x, y))\n            .filter((result) => result !== null);\n    }\n    _internal_labelPaneViews() {\n        return [\n            this._private__panePriceAxisView,\n            ...this._private__customPriceLines.map((line) => line._internal_labelPaneView()),\n        ];\n    }\n    _internal_priceAxisViews(pane, priceScale) {\n        if (priceScale !== this._internal__priceScale && !this._private__isOverlay()) {\n            return [];\n        }\n        const result = [...this._private__priceAxisViews];\n        for (const customPriceLine of this._private__customPriceLines) {\n            result.push(customPriceLine._internal_priceAxisView());\n        }\n        this._private__primitives.forEach((wrapper) => {\n            result.push(...wrapper._internal_priceAxisViews());\n        });\n        return result;\n    }\n    _internal_timeAxisViews() {\n        const res = [];\n        this._private__primitives.forEach((wrapper) => {\n            res.push(...wrapper._internal_timeAxisViews());\n        });\n        return res;\n    }\n    _internal_autoscaleInfo(startTimePoint, endTimePoint) {\n        if (this._private__options.autoscaleInfoProvider !== undefined) {\n            const autoscaleInfo = this._private__options.autoscaleInfoProvider(() => {\n                const res = this._private__autoscaleInfoImpl(startTimePoint, endTimePoint);\n                return (res === null) ? null : res._internal_toRaw();\n            });\n            return AutoscaleInfoImpl._internal_fromRaw(autoscaleInfo);\n        }\n        return this._private__autoscaleInfoImpl(startTimePoint, endTimePoint);\n    }\n    _internal_minMove() {\n        return this._private__options.priceFormat.minMove;\n    }\n    _internal_formatter() {\n        return this._private__formatter;\n    }\n    _internal_updateAllViews() {\n        this._private__paneView._internal_update();\n        for (const priceAxisView of this._private__priceAxisViews) {\n            priceAxisView._internal_update();\n        }\n        for (const customPriceLine of this._private__customPriceLines) {\n            customPriceLine._internal_update();\n        }\n        this._private__priceLineView._internal_update();\n        this._private__baseHorizontalLineView._internal_update();\n        this._private__lastPriceAnimationPaneView?._internal_update();\n        this._private__primitives.forEach((wrapper) => wrapper._internal_updateAllViews());\n    }\n    _internal_priceScale() {\n        return ensureNotNull(super._internal_priceScale());\n    }\n    _internal_markerDataAtIndex(index) {\n        const getValue = (this._private__seriesType === 'Line' || this._private__seriesType === 'Area' || this._private__seriesType === 'Baseline') &&\n            this._private__options.crosshairMarkerVisible;\n        if (!getValue) {\n            return null;\n        }\n        const bar = this._private__data._internal_valueAt(index);\n        if (bar === null) {\n            return null;\n        }\n        const price = bar._internal_value[3 /* PlotRowValueIndex.Close */];\n        const radius = this._private__markerRadius();\n        const borderColor = this._private__markerBorderColor();\n        const borderWidth = this._private__markerBorderWidth();\n        const backgroundColor = this._private__markerBackgroundColor(index);\n        return { _internal_price: price, _internal_radius: radius, _internal_borderColor: borderColor, _internal_borderWidth: borderWidth, _internal_backgroundColor: backgroundColor };\n    }\n    _internal_title() {\n        return this._private__options.title;\n    }\n    _internal_visible() {\n        return this._private__options.visible;\n    }\n    _internal_attachPrimitive(primitive) {\n        this._private__primitives.push(new SeriesPrimitiveWrapper(primitive, this));\n    }\n    _internal_detachPrimitive(source) {\n        this._private__primitives = this._private__primitives.filter((wrapper) => wrapper._internal_primitive() !== source);\n    }\n    _internal_customSeriesPlotValuesBuilder() {\n        if (this._private__seriesType !== 'Custom') {\n            return undefined;\n        }\n        return (data) => {\n            return this._private__paneView._internal_priceValueBuilder(data);\n        };\n    }\n    _internal_customSeriesWhitespaceCheck() {\n        if (this._private__seriesType !== 'Custom') {\n            return undefined;\n        }\n        return (data) => {\n            return this._private__paneView._internal_isWhitespace(data);\n        };\n    }\n    _internal_fulfilledIndices() {\n        return this._private__data._internal_indices();\n    }\n    _private__isOverlay() {\n        const priceScale = this._internal_priceScale();\n        return !isDefaultPriceScale(priceScale._internal_id());\n    }\n    _private__autoscaleInfoImpl(startTimePoint, endTimePoint) {\n        if (!isInteger(startTimePoint) || !isInteger(endTimePoint) || this._private__data._internal_isEmpty()) {\n            return null;\n        }\n        // TODO: refactor this\n        // series data is strongly hardcoded to keep bars\n        const plots = this._private__seriesType === 'Line' || this._private__seriesType === 'Area' || this._private__seriesType === 'Baseline' || this._private__seriesType === 'Histogram'\n            ? [3 /* PlotRowValueIndex.Close */]\n            : [2 /* PlotRowValueIndex.Low */, 1 /* PlotRowValueIndex.High */];\n        const barsMinMax = this._private__data._internal_minMaxOnRangeCached(startTimePoint, endTimePoint, plots);\n        let range = barsMinMax !== null ? new PriceRangeImpl(barsMinMax._internal_min, barsMinMax._internal_max) : null;\n        let margins = null;\n        if (this._internal_seriesType() === 'Histogram') {\n            const base = this._private__options.base;\n            const rangeWithBase = new PriceRangeImpl(base, base);\n            range = range !== null ? range._internal_merge(rangeWithBase) : rangeWithBase;\n        }\n        this._private__primitives.forEach((primitive) => {\n            const primitiveAutoscale = primitive._internal_autoscaleInfo(startTimePoint, endTimePoint);\n            if (primitiveAutoscale?.priceRange) {\n                const primitiveRange = new PriceRangeImpl(primitiveAutoscale.priceRange.minValue, primitiveAutoscale.priceRange.maxValue);\n                range = range !== null ? range._internal_merge(primitiveRange) : primitiveRange;\n            }\n            if (primitiveAutoscale?.margins) {\n                margins = primitiveAutoscale.margins;\n            }\n        });\n        return new AutoscaleInfoImpl(range, margins);\n    }\n    _private__markerRadius() {\n        switch (this._private__seriesType) {\n            case 'Line':\n            case 'Area':\n            case 'Baseline':\n                return this._private__options.crosshairMarkerRadius;\n        }\n        return 0;\n    }\n    _private__markerBorderColor() {\n        switch (this._private__seriesType) {\n            case 'Line':\n            case 'Area':\n            case 'Baseline': {\n                const crosshairMarkerBorderColor = this._private__options.crosshairMarkerBorderColor;\n                if (crosshairMarkerBorderColor.length !== 0) {\n                    return crosshairMarkerBorderColor;\n                }\n            }\n        }\n        return null;\n    }\n    _private__markerBorderWidth() {\n        switch (this._private__seriesType) {\n            case 'Line':\n            case 'Area':\n            case 'Baseline':\n                return this._private__options.crosshairMarkerBorderWidth;\n        }\n        return 0;\n    }\n    _private__markerBackgroundColor(index) {\n        switch (this._private__seriesType) {\n            case 'Line':\n            case 'Area':\n            case 'Baseline': {\n                const crosshairMarkerBackgroundColor = this._private__options.crosshairMarkerBackgroundColor;\n                if (crosshairMarkerBackgroundColor.length !== 0) {\n                    return crosshairMarkerBackgroundColor;\n                }\n            }\n        }\n        return this._internal_barColorer()._internal_barStyle(index)._internal_barColor;\n    }\n    _private__recreateFormatter() {\n        switch (this._private__options.priceFormat.type) {\n            case 'custom': {\n                this._private__formatter = { format: this._private__options.priceFormat.formatter };\n                break;\n            }\n            case 'volume': {\n                this._private__formatter = new VolumeFormatter(this._private__options.priceFormat.precision);\n                break;\n            }\n            case 'percent': {\n                this._private__formatter = new PercentageFormatter(this._private__options.priceFormat.precision);\n                break;\n            }\n            default: {\n                const priceScale = Math.pow(10, this._private__options.priceFormat.precision);\n                this._private__formatter = new PriceFormatter(priceScale, this._private__options.priceFormat.minMove * priceScale);\n            }\n        }\n        if (this._internal__priceScale !== null) {\n            this._internal__priceScale._internal_updateFormatter();\n        }\n    }\n    _private__extractPaneViews(extractor, zOrder) {\n        const res = [];\n        extractPrimitivePaneViews(this._private__primitives, extractor, zOrder, res);\n        return res;\n    }\n}\n\nconst magnetPlotRowKeys = [\n    3 /* PlotRowValueIndex.Close */,\n];\nconst magnetOHLCPlotRowKeys = [\n    0 /* PlotRowValueIndex.Open */,\n    1 /* PlotRowValueIndex.High */,\n    2 /* PlotRowValueIndex.Low */,\n    3 /* PlotRowValueIndex.Close */,\n];\nclass Magnet {\n    constructor(options) {\n        this._private__options = options;\n    }\n    _internal_align(price, index, pane) {\n        let res = price;\n        if (this._private__options.mode === 0 /* CrosshairMode.Normal */) {\n            return res;\n        }\n        const defaultPriceScale = pane._internal_defaultPriceScale();\n        const firstValue = defaultPriceScale._internal_firstValue();\n        if (firstValue === null) {\n            return res;\n        }\n        const y = defaultPriceScale._internal_priceToCoordinate(price, firstValue);\n        // get all serieses from the pane\n        const serieses = pane._internal_dataSources().filter(((ds) => (ds instanceof Series)));\n        const candidates = serieses.reduce((acc, series) => {\n            if (pane._internal_isOverlay(series) || !series._internal_visible()) {\n                return acc;\n            }\n            const ps = series._internal_priceScale();\n            const bars = series._internal_bars();\n            if (ps._internal_isEmpty() || !bars._internal_contains(index)) {\n                return acc;\n            }\n            const bar = bars._internal_valueAt(index);\n            if (bar === null) {\n                return acc;\n            }\n            // convert bar to pixels\n            const firstPrice = ensure(series._internal_firstValue());\n            const plotRowKeys = this._private__options.mode === 3 /* CrosshairMode.MagnetOHLC */\n                ? magnetOHLCPlotRowKeys\n                : magnetPlotRowKeys;\n            return acc.concat(plotRowKeys.map((key) => ps._internal_priceToCoordinate(bar._internal_value[key], firstPrice._internal_value)));\n        }, []);\n        if (candidates.length === 0) {\n            return res;\n        }\n        candidates.sort((y1, y2) => Math.abs(y1 - y) - Math.abs(y2 - y));\n        const nearest = candidates[0];\n        res = defaultPriceScale._internal_coordinateToPrice(nearest, firstValue);\n        return res;\n    }\n}\n\nfunction clamp(value, minVal, maxVal) {\n    return Math.min(Math.max(value, minVal), maxVal);\n}\nfunction isBaseDecimal(value) {\n    if (value < 0) {\n        return false;\n    }\n    for (let current = value; current > 1; current /= 10) {\n        if ((current % 10) !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction greaterOrEqual(x1, x2, epsilon) {\n    return (x2 - x1) <= epsilon;\n}\nfunction equal(x1, x2, epsilon) {\n    return Math.abs(x1 - x2) < epsilon;\n}\n// We can't use Math.min(...arr) because that would only support arrays shorter than 65536 items.\nfunction min(arr) {\n    if (arr.length < 1) {\n        throw Error('array is empty');\n    }\n    let minVal = arr[0];\n    for (let i = 1; i < arr.length; ++i) {\n        if (arr[i] < minVal) {\n            minVal = arr[i];\n        }\n    }\n    return minVal;\n}\nfunction ceiledEven(x) {\n    const ceiled = Math.ceil(x);\n    return (ceiled % 2 !== 0) ? ceiled - 1 : ceiled;\n}\nfunction ceiledOdd(x) {\n    const ceiled = Math.ceil(x);\n    return (ceiled % 2 === 0) ? ceiled - 1 : ceiled;\n}\n\nclass GridRenderer extends BitmapCoordinatesPaneRenderer {\n    constructor() {\n        super(...arguments);\n        this._private__data = null;\n    }\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal__drawImpl({ context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio }) {\n        if (this._private__data === null) {\n            return;\n        }\n        const lineWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n        ctx.lineWidth = lineWidth;\n        strokeInPixel(ctx, () => {\n            const data = ensureNotNull(this._private__data);\n            if (data._internal_vertLinesVisible) {\n                ctx.strokeStyle = data._internal_vertLinesColor;\n                setLineStyle(ctx, data._internal_vertLineStyle);\n                ctx.beginPath();\n                for (const timeMark of data._internal_timeMarks) {\n                    const x = Math.round(timeMark._internal_coord * horizontalPixelRatio);\n                    ctx.moveTo(x, -lineWidth);\n                    ctx.lineTo(x, bitmapSize.height + lineWidth);\n                }\n                ctx.stroke();\n            }\n            if (data._internal_horzLinesVisible) {\n                ctx.strokeStyle = data._internal_horzLinesColor;\n                setLineStyle(ctx, data._internal_horzLineStyle);\n                ctx.beginPath();\n                for (const priceMark of data._internal_priceMarks) {\n                    const y = Math.round(priceMark._internal_coord * verticalPixelRatio);\n                    ctx.moveTo(-lineWidth, y);\n                    ctx.lineTo(bitmapSize.width + lineWidth, y);\n                }\n                ctx.stroke();\n            }\n        });\n    }\n}\n\nclass GridPaneView {\n    constructor(pane) {\n        this._private__renderer = new GridRenderer();\n        this._private__invalidated = true;\n        this._private__pane = pane;\n    }\n    _internal_update() {\n        this._private__invalidated = true;\n    }\n    _internal_renderer() {\n        if (this._private__invalidated) {\n            const gridOptions = this._private__pane._internal_model()._internal_options().grid;\n            const data = {\n                _internal_horzLinesVisible: gridOptions.horzLines.visible,\n                _internal_vertLinesVisible: gridOptions.vertLines.visible,\n                _internal_horzLinesColor: gridOptions.horzLines.color,\n                _internal_vertLinesColor: gridOptions.vertLines.color,\n                _internal_horzLineStyle: gridOptions.horzLines.style,\n                _internal_vertLineStyle: gridOptions.vertLines.style,\n                _internal_priceMarks: this._private__pane._internal_defaultPriceScale()._internal_marks(),\n                // need this conversiom because TimeMark is a part of external interface\n                // and fields inside TimeMark are not minified\n                _internal_timeMarks: (this._private__pane._internal_model()._internal_timeScale()._internal_marks() || []).map((tm) => {\n                    return { _internal_coord: tm.coord };\n                }),\n            };\n            this._private__renderer._internal_setData(data);\n            this._private__invalidated = false;\n        }\n        return this._private__renderer;\n    }\n}\n\nclass Grid {\n    constructor(pane) {\n        this._private__paneView = new GridPaneView(pane);\n    }\n    _internal_paneView() {\n        return this._private__paneView;\n    }\n}\n\nconst defLogFormula = {\n    _internal_logicalOffset: 4,\n    _internal_coordOffset: 0.0001,\n};\nfunction fromPercent(value, baseValue) {\n    if (baseValue < 0) {\n        value = -value;\n    }\n    return (value / 100) * baseValue + baseValue;\n}\nfunction toPercent(value, baseValue) {\n    const result = 100 * (value - baseValue) / baseValue;\n    return (baseValue < 0 ? -result : result);\n}\nfunction toPercentRange(priceRange, baseValue) {\n    const minPercent = toPercent(priceRange._internal_minValue(), baseValue);\n    const maxPercent = toPercent(priceRange._internal_maxValue(), baseValue);\n    return new PriceRangeImpl(minPercent, maxPercent);\n}\nfunction fromIndexedTo100(value, baseValue) {\n    value -= 100;\n    if (baseValue < 0) {\n        value = -value;\n    }\n    return (value / 100) * baseValue + baseValue;\n}\nfunction toIndexedTo100(value, baseValue) {\n    const result = 100 * (value - baseValue) / baseValue + 100;\n    return (baseValue < 0 ? -result : result);\n}\nfunction toIndexedTo100Range(priceRange, baseValue) {\n    const minPercent = toIndexedTo100(priceRange._internal_minValue(), baseValue);\n    const maxPercent = toIndexedTo100(priceRange._internal_maxValue(), baseValue);\n    return new PriceRangeImpl(minPercent, maxPercent);\n}\nfunction toLog(price, logFormula) {\n    const m = Math.abs(price);\n    if (m < 1e-15) {\n        return 0;\n    }\n    const res = Math.log10(m + logFormula._internal_coordOffset) + logFormula._internal_logicalOffset;\n    return ((price < 0) ? -res : res);\n}\nfunction fromLog(logical, logFormula) {\n    const m = Math.abs(logical);\n    if (m < 1e-15) {\n        return 0;\n    }\n    const res = Math.pow(10, m - logFormula._internal_logicalOffset) - logFormula._internal_coordOffset;\n    return (logical < 0) ? -res : res;\n}\nfunction convertPriceRangeToLog(priceRange, logFormula) {\n    if (priceRange === null) {\n        return null;\n    }\n    const min = toLog(priceRange._internal_minValue(), logFormula);\n    const max = toLog(priceRange._internal_maxValue(), logFormula);\n    return new PriceRangeImpl(min, max);\n}\nfunction canConvertPriceRangeFromLog(priceRange, logFormula) {\n    if (priceRange === null) {\n        return false;\n    }\n    const min = fromLog(priceRange._internal_minValue(), logFormula);\n    const max = fromLog(priceRange._internal_maxValue(), logFormula);\n    return isFinite(min) && isFinite(max);\n}\nfunction convertPriceRangeFromLog(priceRange, logFormula) {\n    if (priceRange === null) {\n        return null;\n    }\n    const min = fromLog(priceRange._internal_minValue(), logFormula);\n    const max = fromLog(priceRange._internal_maxValue(), logFormula);\n    return new PriceRangeImpl(min, max);\n}\nfunction logFormulaForPriceRange(range) {\n    if (range === null) {\n        return defLogFormula;\n    }\n    const diff = Math.abs(range._internal_maxValue() - range._internal_minValue());\n    if (diff >= 1 || diff < 1e-15) {\n        return defLogFormula;\n    }\n    const digits = Math.ceil(Math.abs(Math.log10(diff)));\n    const logicalOffset = defLogFormula._internal_logicalOffset + digits;\n    const coordOffset = 1 / Math.pow(10, logicalOffset);\n    return {\n        _internal_logicalOffset: logicalOffset,\n        _internal_coordOffset: coordOffset,\n    };\n}\nfunction logFormulasAreSame(f1, f2) {\n    return f1._internal_logicalOffset === f2._internal_logicalOffset && f1._internal_coordOffset === f2._internal_coordOffset;\n}\n\nclass PriceTickSpanCalculator {\n    constructor(base, integralDividers) {\n        this._private__base = base;\n        this._private__integralDividers = integralDividers;\n        if (isBaseDecimal(this._private__base)) {\n            this._private__fractionalDividers = [2, 2.5, 2];\n        }\n        else {\n            this._private__fractionalDividers = [];\n            for (let baseRest = this._private__base; baseRest !== 1;) {\n                if ((baseRest % 2) === 0) {\n                    this._private__fractionalDividers.push(2);\n                    baseRest /= 2;\n                }\n                else if ((baseRest % 5) === 0) {\n                    this._private__fractionalDividers.push(2, 2.5);\n                    baseRest /= 5;\n                }\n                else {\n                    throw new Error('unexpected base');\n                }\n                if (this._private__fractionalDividers.length > 100) {\n                    throw new Error('something wrong with base');\n                }\n            }\n        }\n    }\n    _internal_tickSpan(high, low, maxTickSpan) {\n        const minMovement = (this._private__base === 0) ? (0) : (1 / this._private__base);\n        let resultTickSpan = Math.pow(10, Math.max(0, Math.ceil(Math.log10(high - low))));\n        let index = 0;\n        let c = this._private__integralDividers[0];\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // the second part is actual for small with very small values like 1e-10\n            // greaterOrEqual fails for such values\n            const resultTickSpanLargerMinMovement = greaterOrEqual(resultTickSpan, minMovement, 1e-14 /* Constants.TickSpanEpsilon */) && resultTickSpan > (minMovement + 1e-14 /* Constants.TickSpanEpsilon */);\n            const resultTickSpanLargerMaxTickSpan = greaterOrEqual(resultTickSpan, maxTickSpan * c, 1e-14 /* Constants.TickSpanEpsilon */);\n            const resultTickSpanLarger1 = greaterOrEqual(resultTickSpan, 1, 1e-14 /* Constants.TickSpanEpsilon */);\n            const haveToContinue = resultTickSpanLargerMinMovement && resultTickSpanLargerMaxTickSpan && resultTickSpanLarger1;\n            if (!haveToContinue) {\n                break;\n            }\n            resultTickSpan /= c;\n            c = this._private__integralDividers[++index % this._private__integralDividers.length];\n        }\n        if (resultTickSpan <= (minMovement + 1e-14 /* Constants.TickSpanEpsilon */)) {\n            resultTickSpan = minMovement;\n        }\n        resultTickSpan = Math.max(1, resultTickSpan);\n        if ((this._private__fractionalDividers.length > 0) && equal(resultTickSpan, 1, 1e-14 /* Constants.TickSpanEpsilon */)) {\n            index = 0;\n            c = this._private__fractionalDividers[0];\n            while (greaterOrEqual(resultTickSpan, maxTickSpan * c, 1e-14 /* Constants.TickSpanEpsilon */) && resultTickSpan > (minMovement + 1e-14 /* Constants.TickSpanEpsilon */)) {\n                resultTickSpan /= c;\n                c = this._private__fractionalDividers[++index % this._private__fractionalDividers.length];\n            }\n        }\n        return resultTickSpan;\n    }\n}\n\nconst TICK_DENSITY = 2.5;\nclass PriceTickMarkBuilder {\n    constructor(priceScale, base, coordinateToLogicalFunc, logicalToCoordinateFunc) {\n        this._private__marks = [];\n        this._private__priceScale = priceScale;\n        this._private__base = base;\n        this._private__coordinateToLogicalFunc = coordinateToLogicalFunc;\n        this._private__logicalToCoordinateFunc = logicalToCoordinateFunc;\n    }\n    _internal_tickSpan(high, low) {\n        if (high < low) {\n            throw new Error('high < low');\n        }\n        const scaleHeight = this._private__priceScale._internal_height();\n        const markHeight = this._private__tickMarkHeight();\n        const maxTickSpan = (high - low) * markHeight / scaleHeight;\n        const spanCalculator1 = new PriceTickSpanCalculator(this._private__base, [2, 2.5, 2]);\n        const spanCalculator2 = new PriceTickSpanCalculator(this._private__base, [2, 2, 2.5]);\n        const spanCalculator3 = new PriceTickSpanCalculator(this._private__base, [2.5, 2, 2]);\n        const spans = [];\n        spans.push(spanCalculator1._internal_tickSpan(high, low, maxTickSpan), spanCalculator2._internal_tickSpan(high, low, maxTickSpan), spanCalculator3._internal_tickSpan(high, low, maxTickSpan));\n        return min(spans);\n    }\n    _internal_rebuildTickMarks() {\n        const priceScale = this._private__priceScale;\n        const firstValue = priceScale._internal_firstValue();\n        if (firstValue === null) {\n            this._private__marks = [];\n            return;\n        }\n        const scaleHeight = priceScale._internal_height();\n        const bottom = this._private__coordinateToLogicalFunc(scaleHeight - 1, firstValue);\n        const top = this._private__coordinateToLogicalFunc(0, firstValue);\n        const extraTopBottomMargin = this._private__priceScale._internal_options().entireTextOnly ? this._private__fontHeight() / 2 : 0;\n        const minCoord = extraTopBottomMargin;\n        const maxCoord = scaleHeight - 1 - extraTopBottomMargin;\n        const high = Math.max(bottom, top);\n        const low = Math.min(bottom, top);\n        if (high === low) {\n            this._private__marks = [];\n            return;\n        }\n        const span = this._internal_tickSpan(high, low);\n        this._private__updateMarks(firstValue, span, high, low, minCoord, maxCoord);\n        if (priceScale._internal_hasVisibleEdgeMarks() && this._private__shouldApplyEdgeMarks(span, low, high)) {\n            const padding = this._private__priceScale._internal_getEdgeMarksPadding();\n            this._private__applyEdgeMarks(firstValue, span, minCoord, maxCoord, padding, padding * 2);\n        }\n    }\n    _internal_marks() {\n        return this._private__marks;\n    }\n    _private__fontHeight() {\n        return this._private__priceScale._internal_fontSize();\n    }\n    _private__tickMarkHeight() {\n        return Math.ceil(this._private__fontHeight() * TICK_DENSITY);\n    }\n    _private__updateMarks(firstValue, span, high, low, minCoord, maxCoord) {\n        const marks = this._private__marks;\n        const priceScale = this._private__priceScale;\n        let mod = high % span;\n        mod += mod < 0 ? span : 0;\n        const sign = (high >= low) ? 1 : -1;\n        let prevCoord = null;\n        let targetIndex = 0;\n        for (let logical = high - mod; logical > low; logical -= span) {\n            const coord = this._private__logicalToCoordinateFunc(logical, firstValue, true);\n            // check if there is place for it\n            // this is required for log scale\n            if (prevCoord !== null && Math.abs(coord - prevCoord) < this._private__tickMarkHeight()) {\n                continue;\n            }\n            // check if a tick mark is partially visible and skip it if entireTextOnly is true\n            if (coord < minCoord || coord > maxCoord) {\n                continue;\n            }\n            if (targetIndex < marks.length) {\n                marks[targetIndex]._internal_coord = coord;\n                marks[targetIndex]._internal_label = priceScale._internal_formatLogical(logical);\n            }\n            else {\n                marks.push({\n                    _internal_coord: coord,\n                    _internal_label: priceScale._internal_formatLogical(logical),\n                });\n            }\n            targetIndex++;\n            prevCoord = coord;\n            if (priceScale._internal_isLog()) {\n                // recalc span\n                span = this._internal_tickSpan(logical * sign, low);\n            }\n        }\n        marks.length = targetIndex;\n    }\n    _private__applyEdgeMarks(firstValue, span, minCoord, maxCoord, minPadding, maxPadding) {\n        const marks = this._private__marks;\n        // top boundary\n        const topMark = this._private__computeBoundaryPriceMark(firstValue, minCoord, minPadding, maxPadding);\n        // bottom boundary\n        const bottomMark = this._private__computeBoundaryPriceMark(firstValue, maxCoord, -maxPadding, -minPadding);\n        const spanPx = this._private__logicalToCoordinateFunc(0, firstValue, true)\n            - this._private__logicalToCoordinateFunc(span, firstValue, true);\n        if (marks.length > 0 && marks[0]._internal_coord - topMark._internal_coord < spanPx / 2) {\n            marks.shift();\n        }\n        if (marks.length > 0 && bottomMark._internal_coord - marks[marks.length - 1]._internal_coord < spanPx / 2) {\n            marks.pop();\n        }\n        marks.unshift(topMark);\n        marks.push(bottomMark);\n    }\n    _private__computeBoundaryPriceMark(firstValue, coord, minPadding, maxPadding) {\n        const avgPadding = (minPadding + maxPadding) / 2;\n        const value1 = this._private__coordinateToLogicalFunc(coord + minPadding, firstValue);\n        const value2 = this._private__coordinateToLogicalFunc(coord + maxPadding, firstValue);\n        const minValue = Math.min(value1, value2);\n        const maxValue = Math.max(value1, value2);\n        const valueSpan = Math.max(0.1, this._internal_tickSpan(maxValue, minValue));\n        const value = this._private__coordinateToLogicalFunc(coord + avgPadding, firstValue);\n        const roundedValue = value - (value % valueSpan);\n        const roundedCoord = this._private__logicalToCoordinateFunc(roundedValue, firstValue, true);\n        return { _internal_label: this._private__priceScale._internal_formatLogical(roundedValue), _internal_coord: roundedCoord };\n    }\n    _private__shouldApplyEdgeMarks(span, low, high) {\n        let range = ensure(this._private__priceScale._internal_priceRange());\n        if (this._private__priceScale._internal_isLog()) {\n            range = convertPriceRangeFromLog(range, this._private__priceScale._internal_getLogFormula());\n        }\n        return (range._internal_minValue() - low < span) && (high - range._internal_maxValue() < span);\n    }\n}\n\nfunction sortSources(sources) {\n    return sources.slice().sort((s1, s2) => {\n        return (ensureNotNull(s1._internal_zorder()) - ensureNotNull(s2._internal_zorder()));\n    });\n}\n\n/**\n * Represents the price scale mode.\n */\nvar PriceScaleMode;\n(function (PriceScaleMode) {\n    /**\n     * Price scale shows prices. Price range changes linearly.\n     */\n    PriceScaleMode[PriceScaleMode[\"Normal\"] = 0] = \"Normal\";\n    /**\n     * Price scale shows prices. Price range changes logarithmically.\n     */\n    PriceScaleMode[PriceScaleMode[\"Logarithmic\"] = 1] = \"Logarithmic\";\n    /**\n     * Price scale shows percentage values according the first visible value of the price scale.\n     * The first visible value is 0% in this mode.\n     */\n    PriceScaleMode[PriceScaleMode[\"Percentage\"] = 2] = \"Percentage\";\n    /**\n     * The same as percentage mode, but the first value is moved to 100.\n     */\n    PriceScaleMode[PriceScaleMode[\"IndexedTo100\"] = 3] = \"IndexedTo100\";\n})(PriceScaleMode || (PriceScaleMode = {}));\nconst percentageFormatter = new PercentageFormatter();\nconst defaultPriceFormatter = new PriceFormatter(100, 1);\nclass PriceScale {\n    constructor(id, options, layoutOptions, localizationOptions, colorParser) {\n        this._private__height = 0;\n        this._private__internalHeightCache = null;\n        this._private__priceRange = null;\n        this._private__priceRangeSnapshot = null;\n        this._private__invalidatedForRange = { _internal_isValid: false, _internal_visibleBars: null };\n        this._private__isCustomPriceRange = false;\n        this._private__marginAbove = 0;\n        this._private__marginBelow = 0;\n        this._private__onMarksChanged = new Delegate();\n        this._private__modeChanged = new Delegate();\n        this._private__dataSources = [];\n        this._private__formatterSource = null;\n        this._private__cachedOrderedSources = null;\n        this._private__marksCache = null;\n        this._private__scaleStartPoint = null;\n        this._private__scrollStartPoint = null;\n        this._private__formatter = defaultPriceFormatter;\n        this._private__logFormula = logFormulaForPriceRange(null);\n        this._private__id = id;\n        this._private__options = options;\n        this._private__layoutOptions = layoutOptions;\n        this._private__localizationOptions = localizationOptions;\n        this._private__colorParser = colorParser;\n        this._private__markBuilder = new PriceTickMarkBuilder(this, 100, this._private__coordinateToLogical.bind(this), this._private__logicalToCoordinate.bind(this));\n    }\n    _internal_id() {\n        return this._private__id;\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyOptions(options) {\n        merge(this._private__options, options);\n        this._internal_updateFormatter();\n        if (options.mode !== undefined) {\n            this._internal_setMode({ _internal_mode: options.mode });\n        }\n        if (options.scaleMargins !== undefined) {\n            const top = ensureDefined(options.scaleMargins.top);\n            const bottom = ensureDefined(options.scaleMargins.bottom);\n            if (top < 0 || top > 1) {\n                throw new Error(`Invalid top margin - expect value between 0 and 1, given=${top}`);\n            }\n            if (bottom < 0 || bottom > 1) {\n                throw new Error(`Invalid bottom margin - expect value between 0 and 1, given=${bottom}`);\n            }\n            if (top + bottom > 1) {\n                throw new Error(`Invalid margins - sum of margins must be less than 1, given=${top + bottom}`);\n            }\n            this._private__invalidateInternalHeightCache();\n            this._private__marksCache = null;\n        }\n    }\n    _internal_isAutoScale() {\n        return this._private__options.autoScale;\n    }\n    _internal_isCustomPriceRange() {\n        return this._private__isCustomPriceRange;\n    }\n    _internal_isLog() {\n        return this._private__options.mode === 1 /* PriceScaleMode.Logarithmic */;\n    }\n    _internal_isPercentage() {\n        return this._private__options.mode === 2 /* PriceScaleMode.Percentage */;\n    }\n    _internal_isIndexedTo100() {\n        return this._private__options.mode === 3 /* PriceScaleMode.IndexedTo100 */;\n    }\n    _internal_getLogFormula() {\n        return this._private__logFormula;\n    }\n    _internal_mode() {\n        return {\n            _internal_autoScale: this._private__options.autoScale,\n            _internal_isInverted: this._private__options.invertScale,\n            _internal_mode: this._private__options.mode,\n        };\n    }\n    // eslint-disable-next-line complexity\n    _internal_setMode(newMode) {\n        const oldMode = this._internal_mode();\n        let priceRange = null;\n        if (newMode._internal_autoScale !== undefined) {\n            this._private__options.autoScale = newMode._internal_autoScale;\n        }\n        if (newMode._internal_mode !== undefined) {\n            this._private__options.mode = newMode._internal_mode;\n            if (newMode._internal_mode === 2 /* PriceScaleMode.Percentage */ || newMode._internal_mode === 3 /* PriceScaleMode.IndexedTo100 */) {\n                this._private__options.autoScale = true;\n            }\n            // TODO: Remove after making rebuildTickMarks lazy\n            this._private__invalidatedForRange._internal_isValid = false;\n        }\n        // define which scale converted from\n        if (oldMode._internal_mode === 1 /* PriceScaleMode.Logarithmic */ && newMode._internal_mode !== oldMode._internal_mode) {\n            if (canConvertPriceRangeFromLog(this._private__priceRange, this._private__logFormula)) {\n                priceRange = convertPriceRangeFromLog(this._private__priceRange, this._private__logFormula);\n                if (priceRange !== null) {\n                    this._internal_setPriceRange(priceRange);\n                }\n            }\n            else {\n                this._private__options.autoScale = true;\n            }\n        }\n        // define which scale converted to\n        if (newMode._internal_mode === 1 /* PriceScaleMode.Logarithmic */ && newMode._internal_mode !== oldMode._internal_mode) {\n            priceRange = convertPriceRangeToLog(this._private__priceRange, this._private__logFormula);\n            if (priceRange !== null) {\n                this._internal_setPriceRange(priceRange);\n            }\n        }\n        const modeChanged = oldMode._internal_mode !== this._private__options.mode;\n        if (modeChanged && (oldMode._internal_mode === 2 /* PriceScaleMode.Percentage */ || this._internal_isPercentage())) {\n            this._internal_updateFormatter();\n        }\n        if (modeChanged && (oldMode._internal_mode === 3 /* PriceScaleMode.IndexedTo100 */ || this._internal_isIndexedTo100())) {\n            this._internal_updateFormatter();\n        }\n        if (newMode._internal_isInverted !== undefined && oldMode._internal_isInverted !== newMode._internal_isInverted) {\n            this._private__options.invertScale = newMode._internal_isInverted;\n            this._private__onIsInvertedChanged();\n        }\n        this._private__modeChanged._internal_fire(oldMode, this._internal_mode());\n    }\n    _internal_modeChanged() {\n        return this._private__modeChanged;\n    }\n    _internal_fontSize() {\n        return this._private__layoutOptions.fontSize;\n    }\n    _internal_height() {\n        return this._private__height;\n    }\n    _internal_setHeight(value) {\n        if (this._private__height === value) {\n            return;\n        }\n        this._private__height = value;\n        this._private__invalidateInternalHeightCache();\n        this._private__marksCache = null;\n    }\n    _internal_internalHeight() {\n        if (this._private__internalHeightCache) {\n            return this._private__internalHeightCache;\n        }\n        const res = this._internal_height() - this._private__topMarginPx() - this._private__bottomMarginPx();\n        this._private__internalHeightCache = res;\n        return res;\n    }\n    _internal_priceRange() {\n        this._private__makeSureItIsValid();\n        return this._private__priceRange;\n    }\n    _internal_setPriceRange(newPriceRange, isForceSetValue) {\n        const oldPriceRange = this._private__priceRange;\n        if (!isForceSetValue &&\n            !(oldPriceRange === null && newPriceRange !== null) &&\n            (oldPriceRange === null || oldPriceRange._internal_equals(newPriceRange))) {\n            return;\n        }\n        this._private__marksCache = null;\n        this._private__priceRange = newPriceRange;\n    }\n    _internal_setCustomPriceRange(newPriceRange) {\n        this._internal_setPriceRange(newPriceRange);\n        this._private__toggleCustomPriceRange(newPriceRange !== null);\n    }\n    _internal_isEmpty() {\n        this._private__makeSureItIsValid();\n        return this._private__height === 0 || !this._private__priceRange || this._private__priceRange._internal_isEmpty();\n    }\n    _internal_invertedCoordinate(coordinate) {\n        return this._internal_isInverted() ? coordinate : this._internal_height() - 1 - coordinate;\n    }\n    _internal_priceToCoordinate(price, baseValue) {\n        if (this._internal_isPercentage()) {\n            price = toPercent(price, baseValue);\n        }\n        else if (this._internal_isIndexedTo100()) {\n            price = toIndexedTo100(price, baseValue);\n        }\n        return this._private__logicalToCoordinate(price, baseValue);\n    }\n    _internal_pointsArrayToCoordinates(points, baseValue, visibleRange) {\n        this._private__makeSureItIsValid();\n        const bh = this._private__bottomMarginPx();\n        const range = ensureNotNull(this._internal_priceRange());\n        const min = range._internal_minValue();\n        const max = range._internal_maxValue();\n        const ih = (this._internal_internalHeight() - 1);\n        const isInverted = this._internal_isInverted();\n        const hmm = ih / (max - min);\n        const fromIndex = (visibleRange === undefined) ? 0 : visibleRange.from;\n        const toIndex = (visibleRange === undefined) ? points.length : visibleRange.to;\n        const transformFn = this._private__getCoordinateTransformer();\n        for (let i = fromIndex; i < toIndex; i++) {\n            const point = points[i];\n            const price = point._internal_price;\n            if (isNaN(price)) {\n                continue;\n            }\n            let logical = price;\n            if (transformFn !== null) {\n                logical = transformFn(point._internal_price, baseValue);\n            }\n            const invCoordinate = bh + hmm * (logical - min);\n            const coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            point._internal_y = coordinate;\n        }\n    }\n    _internal_barPricesToCoordinates(pricesList, baseValue, visibleRange) {\n        this._private__makeSureItIsValid();\n        const bh = this._private__bottomMarginPx();\n        const range = ensureNotNull(this._internal_priceRange());\n        const min = range._internal_minValue();\n        const max = range._internal_maxValue();\n        const ih = (this._internal_internalHeight() - 1);\n        const isInverted = this._internal_isInverted();\n        const hmm = ih / (max - min);\n        const fromIndex = (visibleRange === undefined) ? 0 : visibleRange.from;\n        const toIndex = (visibleRange === undefined) ? pricesList.length : visibleRange.to;\n        const transformFn = this._private__getCoordinateTransformer();\n        for (let i = fromIndex; i < toIndex; i++) {\n            const bar = pricesList[i];\n            let openLogical = bar._internal_open;\n            let highLogical = bar._internal_high;\n            let lowLogical = bar._internal_low;\n            let closeLogical = bar._internal_close;\n            if (transformFn !== null) {\n                openLogical = transformFn(bar._internal_open, baseValue);\n                highLogical = transformFn(bar._internal_high, baseValue);\n                lowLogical = transformFn(bar._internal_low, baseValue);\n                closeLogical = transformFn(bar._internal_close, baseValue);\n            }\n            let invCoordinate = bh + hmm * (openLogical - min);\n            let coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_openY = coordinate;\n            invCoordinate = bh + hmm * (highLogical - min);\n            coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_highY = coordinate;\n            invCoordinate = bh + hmm * (lowLogical - min);\n            coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_lowY = coordinate;\n            invCoordinate = bh + hmm * (closeLogical - min);\n            coordinate = isInverted ? invCoordinate : this._private__height - 1 - invCoordinate;\n            bar._internal_closeY = coordinate;\n        }\n    }\n    _internal_coordinateToPrice(coordinate, baseValue) {\n        const logical = this._private__coordinateToLogical(coordinate, baseValue);\n        return this._internal_logicalToPrice(logical, baseValue);\n    }\n    _internal_logicalToPrice(logical, baseValue) {\n        let value = logical;\n        if (this._internal_isPercentage()) {\n            value = fromPercent(value, baseValue);\n        }\n        else if (this._internal_isIndexedTo100()) {\n            value = fromIndexedTo100(value, baseValue);\n        }\n        return value;\n    }\n    _internal_dataSources() {\n        return this._private__dataSources;\n    }\n    _internal_orderedSources() {\n        if (!this._private__cachedOrderedSources) {\n            this._private__cachedOrderedSources = sortSources(this._private__dataSources);\n        }\n        return this._private__cachedOrderedSources;\n    }\n    _internal_addDataSource(source) {\n        if (this._private__dataSources.indexOf(source) !== -1) {\n            return;\n        }\n        this._private__dataSources.push(source);\n        this._internal_updateFormatter();\n        this._internal_invalidateSourcesCache();\n    }\n    _internal_removeDataSource(source) {\n        const index = this._private__dataSources.indexOf(source);\n        if (index === -1) {\n            throw new Error('source is not attached to scale');\n        }\n        this._private__dataSources.splice(index, 1);\n        if (this._private__dataSources.length === 0) {\n            this._internal_setMode({\n                _internal_autoScale: true,\n            });\n            // if no sources on price scale let's clear price range cache as well as enabling auto scale\n            this._internal_setPriceRange(null);\n        }\n        this._internal_updateFormatter();\n        this._internal_invalidateSourcesCache();\n    }\n    _internal_firstValue() {\n        // TODO: cache the result\n        let result = null;\n        for (const source of this._private__dataSources) {\n            const firstValue = source._internal_firstValue();\n            if (firstValue === null) {\n                continue;\n            }\n            if (result === null || firstValue._internal_timePoint < result._internal_timePoint) {\n                result = firstValue;\n            }\n        }\n        return result === null ? null : result._internal_value;\n    }\n    _internal_isInverted() {\n        return this._private__options.invertScale;\n    }\n    _internal_marks() {\n        const firstValueIsNull = this._internal_firstValue() === null;\n        // do not recalculate marks if firstValueIsNull is true because in this case we'll always get empty result\n        // this could happen in case when a series had some data and then you set empty data to it (in a simplified case)\n        // we could display an empty price scale, but this is not good from UX\n        // so in this case we need to keep an previous marks to display them on the scale\n        // as one of possible examples for this situation could be the following:\n        // let's say you have a study/indicator attached to a price scale and then you decide to stop it, i.e. remove its data because of its visibility\n        // a user will see the previous marks on the scale until you turn on your study back or remove it from the chart completely\n        if (this._private__marksCache !== null && (firstValueIsNull || this._private__marksCache._internal_firstValueIsNull === firstValueIsNull)) {\n            return this._private__marksCache._internal_marks;\n        }\n        this._private__markBuilder._internal_rebuildTickMarks();\n        const marks = this._private__markBuilder._internal_marks();\n        this._private__marksCache = { _internal_marks: marks, _internal_firstValueIsNull: firstValueIsNull };\n        this._private__onMarksChanged._internal_fire();\n        return marks;\n    }\n    _internal_onMarksChanged() {\n        return this._private__onMarksChanged;\n    }\n    _internal_startScale(x) {\n        if (this._internal_isPercentage() || this._internal_isIndexedTo100()) {\n            return;\n        }\n        if (this._private__scaleStartPoint !== null || this._private__priceRangeSnapshot !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        // invert x\n        this._private__scaleStartPoint = this._private__height - x;\n        this._private__priceRangeSnapshot = ensureNotNull(this._internal_priceRange())._internal_clone();\n    }\n    _internal_scaleTo(x) {\n        if (this._internal_isPercentage() || this._internal_isIndexedTo100()) {\n            return;\n        }\n        if (this._private__scaleStartPoint === null) {\n            return;\n        }\n        this._internal_setMode({\n            _internal_autoScale: false,\n        });\n        // invert x\n        x = this._private__height - x;\n        if (x < 0) {\n            x = 0;\n        }\n        let scaleCoeff = (this._private__scaleStartPoint + (this._private__height - 1) * 0.2) / (x + (this._private__height - 1) * 0.2);\n        const newPriceRange = ensureNotNull(this._private__priceRangeSnapshot)._internal_clone();\n        scaleCoeff = Math.max(scaleCoeff, 0.1);\n        newPriceRange._internal_scaleAroundCenter(scaleCoeff);\n        this._internal_setPriceRange(newPriceRange);\n    }\n    _internal_endScale() {\n        if (this._internal_isPercentage() || this._internal_isIndexedTo100()) {\n            return;\n        }\n        this._private__scaleStartPoint = null;\n        this._private__priceRangeSnapshot = null;\n    }\n    _internal_startScroll(x) {\n        if (this._internal_isAutoScale()) {\n            return;\n        }\n        if (this._private__scrollStartPoint !== null || this._private__priceRangeSnapshot !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        this._private__scrollStartPoint = x;\n        this._private__priceRangeSnapshot = ensureNotNull(this._internal_priceRange())._internal_clone();\n    }\n    _internal_scrollTo(x) {\n        if (this._internal_isAutoScale()) {\n            return;\n        }\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        const priceUnitsPerPixel = ensureNotNull(this._internal_priceRange())._internal_length() / (this._internal_internalHeight() - 1);\n        let pixelDelta = x - this._private__scrollStartPoint;\n        if (this._internal_isInverted()) {\n            pixelDelta *= -1;\n        }\n        const priceDelta = pixelDelta * priceUnitsPerPixel;\n        const newPriceRange = ensureNotNull(this._private__priceRangeSnapshot)._internal_clone();\n        newPriceRange._internal_shift(priceDelta);\n        this._internal_setPriceRange(newPriceRange, true);\n        this._private__marksCache = null;\n    }\n    _internal_endScroll() {\n        if (this._internal_isAutoScale()) {\n            return;\n        }\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        this._private__scrollStartPoint = null;\n        this._private__priceRangeSnapshot = null;\n    }\n    _internal_formatter() {\n        if (!this._private__formatter) {\n            this._internal_updateFormatter();\n        }\n        return this._private__formatter;\n    }\n    _internal_formatPrice(price, firstValue) {\n        switch (this._private__options.mode) {\n            case 2 /* PriceScaleMode.Percentage */:\n                return this._private__formatPercentage(toPercent(price, firstValue));\n            case 3 /* PriceScaleMode.IndexedTo100 */:\n                return this._internal_formatter().format(toIndexedTo100(price, firstValue));\n            default:\n                return this._private__formatPrice(price);\n        }\n    }\n    _internal_formatLogical(logical) {\n        switch (this._private__options.mode) {\n            case 2 /* PriceScaleMode.Percentage */:\n                return this._private__formatPercentage(logical);\n            case 3 /* PriceScaleMode.IndexedTo100 */:\n                return this._internal_formatter().format(logical);\n            default:\n                return this._private__formatPrice(logical);\n        }\n    }\n    _internal_formatPriceAbsolute(price) {\n        return this._private__formatPrice(price, ensureNotNull(this._private__formatterSource)._internal_formatter());\n    }\n    _internal_formatPricePercentage(price, baseValue) {\n        price = toPercent(price, baseValue);\n        return this._private__formatPercentage(price, percentageFormatter);\n    }\n    _internal_sourcesForAutoScale() {\n        return this._private__dataSources;\n    }\n    _internal_recalculatePriceRange(visibleBars) {\n        this._private__invalidatedForRange = {\n            _internal_visibleBars: visibleBars,\n            _internal_isValid: false,\n        };\n    }\n    _internal_updateAllViews() {\n        this._private__dataSources.forEach((s) => s._internal_updateAllViews());\n    }\n    _internal_hasVisibleEdgeMarks() {\n        return this._private__options.ensureEdgeTickMarksVisible && this._internal_isAutoScale();\n    }\n    _internal_getEdgeMarksPadding() {\n        return this._internal_fontSize() / 2;\n    }\n    _internal_updateFormatter() {\n        this._private__marksCache = null;\n        let zOrder = Infinity;\n        this._private__formatterSource = null;\n        // choose source with the lowest zorder\n        for (const source of this._private__dataSources) {\n            if (source._internal_zorder() < zOrder) {\n                zOrder = source._internal_zorder();\n                this._private__formatterSource = source;\n            }\n        }\n        let base = 100;\n        if (this._private__formatterSource !== null) {\n            base = Math.round(1 / this._private__formatterSource._internal_minMove());\n        }\n        this._private__formatter = defaultPriceFormatter;\n        if (this._internal_isPercentage()) {\n            this._private__formatter = percentageFormatter;\n            base = 100;\n        }\n        else if (this._internal_isIndexedTo100()) {\n            this._private__formatter = new PriceFormatter(100, 1);\n            base = 100;\n        }\n        else {\n            if (this._private__formatterSource !== null) {\n                // user\n                this._private__formatter = this._private__formatterSource._internal_formatter();\n            }\n        }\n        this._private__markBuilder = new PriceTickMarkBuilder(this, base, this._private__coordinateToLogical.bind(this), this._private__logicalToCoordinate.bind(this));\n        this._private__markBuilder._internal_rebuildTickMarks();\n    }\n    _internal_invalidateSourcesCache() {\n        this._private__cachedOrderedSources = null;\n    }\n    _internal_colorParser() {\n        return this._private__colorParser;\n    }\n    _private__toggleCustomPriceRange(v) {\n        this._private__isCustomPriceRange = v;\n    }\n    _private__topMarginPx() {\n        return this._internal_isInverted()\n            ? this._private__options.scaleMargins.bottom * this._internal_height() + this._private__marginBelow\n            : this._private__options.scaleMargins.top * this._internal_height() + this._private__marginAbove;\n    }\n    _private__bottomMarginPx() {\n        return this._internal_isInverted()\n            ? this._private__options.scaleMargins.top * this._internal_height() + this._private__marginAbove\n            : this._private__options.scaleMargins.bottom * this._internal_height() + this._private__marginBelow;\n    }\n    _private__makeSureItIsValid() {\n        if (!this._private__invalidatedForRange._internal_isValid) {\n            this._private__invalidatedForRange._internal_isValid = true;\n            this._private__recalculatePriceRangeImpl();\n        }\n    }\n    _private__invalidateInternalHeightCache() {\n        this._private__internalHeightCache = null;\n    }\n    _private__logicalToCoordinate(logical, baseValue) {\n        this._private__makeSureItIsValid();\n        if (this._internal_isEmpty()) {\n            return 0;\n        }\n        logical = this._internal_isLog() && logical ? toLog(logical, this._private__logFormula) : logical;\n        const range = ensureNotNull(this._internal_priceRange());\n        const invCoordinate = this._private__bottomMarginPx() +\n            (this._internal_internalHeight() - 1) * (logical - range._internal_minValue()) / range._internal_length();\n        const coordinate = this._internal_invertedCoordinate(invCoordinate);\n        return coordinate;\n    }\n    _private__coordinateToLogical(coordinate, baseValue) {\n        this._private__makeSureItIsValid();\n        if (this._internal_isEmpty()) {\n            return 0;\n        }\n        const invCoordinate = this._internal_invertedCoordinate(coordinate);\n        const range = ensureNotNull(this._internal_priceRange());\n        const logical = range._internal_minValue() + range._internal_length() *\n            ((invCoordinate - this._private__bottomMarginPx()) / (this._internal_internalHeight() - 1));\n        return this._internal_isLog() ? fromLog(logical, this._private__logFormula) : logical;\n    }\n    _private__onIsInvertedChanged() {\n        this._private__marksCache = null;\n        this._private__markBuilder._internal_rebuildTickMarks();\n    }\n    // eslint-disable-next-line complexity\n    _private__recalculatePriceRangeImpl() {\n        if (this._internal_isCustomPriceRange() && !this._internal_isAutoScale()) {\n            return;\n        }\n        const visibleBars = this._private__invalidatedForRange._internal_visibleBars;\n        if (visibleBars === null) {\n            return;\n        }\n        let priceRange = null;\n        const sources = this._internal_sourcesForAutoScale();\n        let marginAbove = 0;\n        let marginBelow = 0;\n        for (const source of sources) {\n            if (!source._internal_visible()) {\n                continue;\n            }\n            const firstValue = source._internal_firstValue();\n            if (firstValue === null) {\n                continue;\n            }\n            const autoScaleInfo = source._internal_autoscaleInfo(visibleBars._internal_left(), visibleBars._internal_right());\n            let sourceRange = autoScaleInfo && autoScaleInfo._internal_priceRange();\n            if (sourceRange !== null) {\n                switch (this._private__options.mode) {\n                    case 1 /* PriceScaleMode.Logarithmic */:\n                        sourceRange = convertPriceRangeToLog(sourceRange, this._private__logFormula);\n                        break;\n                    case 2 /* PriceScaleMode.Percentage */:\n                        sourceRange = toPercentRange(sourceRange, firstValue._internal_value);\n                        break;\n                    case 3 /* PriceScaleMode.IndexedTo100 */:\n                        sourceRange = toIndexedTo100Range(sourceRange, firstValue._internal_value);\n                        break;\n                }\n                if (priceRange === null) {\n                    priceRange = sourceRange;\n                }\n                else {\n                    priceRange = priceRange._internal_merge(ensureNotNull(sourceRange));\n                }\n                if (autoScaleInfo !== null) {\n                    const margins = autoScaleInfo._internal_margins();\n                    if (margins !== null) {\n                        marginAbove = Math.max(marginAbove, margins.above);\n                        marginBelow = Math.max(marginBelow, margins.below);\n                    }\n                }\n            }\n        }\n        if (this._internal_hasVisibleEdgeMarks()) {\n            marginAbove = Math.max(marginAbove, this._internal_getEdgeMarksPadding());\n            marginBelow = Math.max(marginBelow, this._internal_getEdgeMarksPadding());\n        }\n        if (marginAbove !== this._private__marginAbove || marginBelow !== this._private__marginBelow) {\n            this._private__marginAbove = marginAbove;\n            this._private__marginBelow = marginBelow;\n            this._private__marksCache = null;\n            this._private__invalidateInternalHeightCache();\n        }\n        if (priceRange !== null) {\n            // keep current range is new is empty\n            if (priceRange._internal_minValue() === priceRange._internal_maxValue()) {\n                const formatterSource = this._private__formatterSource;\n                const minMove = formatterSource === null || this._internal_isPercentage() || this._internal_isIndexedTo100() ? 1 : formatterSource._internal_minMove();\n                // if price range is degenerated to 1 point let's extend it by 10 min move values\n                // to avoid incorrect range and empty (blank) scale (in case of min tick much greater than 1)\n                const extendValue = 5 * minMove;\n                if (this._internal_isLog()) {\n                    priceRange = convertPriceRangeFromLog(priceRange, this._private__logFormula);\n                }\n                priceRange = new PriceRangeImpl(priceRange._internal_minValue() - extendValue, priceRange._internal_maxValue() + extendValue);\n                if (this._internal_isLog()) {\n                    priceRange = convertPriceRangeToLog(priceRange, this._private__logFormula);\n                }\n            }\n            if (this._internal_isLog()) {\n                const rawRange = convertPriceRangeFromLog(priceRange, this._private__logFormula);\n                const newLogFormula = logFormulaForPriceRange(rawRange);\n                if (!logFormulasAreSame(newLogFormula, this._private__logFormula)) {\n                    const rawSnapshot = this._private__priceRangeSnapshot !== null ? convertPriceRangeFromLog(this._private__priceRangeSnapshot, this._private__logFormula) : null;\n                    this._private__logFormula = newLogFormula;\n                    priceRange = convertPriceRangeToLog(rawRange, newLogFormula);\n                    if (rawSnapshot !== null) {\n                        this._private__priceRangeSnapshot = convertPriceRangeToLog(rawSnapshot, newLogFormula);\n                    }\n                }\n            }\n            this._internal_setPriceRange(priceRange);\n        }\n        else {\n            // reset empty to default\n            if (this._private__priceRange === null) {\n                this._internal_setPriceRange(new PriceRangeImpl(-0.5, 0.5));\n                this._private__logFormula = logFormulaForPriceRange(null);\n            }\n        }\n    }\n    _private__getCoordinateTransformer() {\n        if (this._internal_isPercentage()) {\n            return toPercent;\n        }\n        else if (this._internal_isIndexedTo100()) {\n            return toIndexedTo100;\n        }\n        else if (this._internal_isLog()) {\n            return (price) => toLog(price, this._private__logFormula);\n        }\n        return null;\n    }\n    _private__formatValue(value, formatter, fallbackFormatter) {\n        if (formatter === undefined) {\n            if (fallbackFormatter === undefined) {\n                fallbackFormatter = this._internal_formatter();\n            }\n            return fallbackFormatter.format(value);\n        }\n        return formatter(value);\n    }\n    _private__formatPrice(price, fallbackFormatter) {\n        return this._private__formatValue(price, this._private__localizationOptions.priceFormatter, fallbackFormatter);\n    }\n    _private__formatPercentage(percentage, fallbackFormatter) {\n        return this._private__formatValue(percentage, this._private__localizationOptions.percentageFormatter, fallbackFormatter);\n    }\n}\n\nfunction isSeries(source) {\n    return source instanceof Series;\n}\nconst DEFAULT_STRETCH_FACTOR = 1000;\nconst MIN_PANE_HEIGHT = 30;\nclass Pane {\n    constructor(timeScale, model) {\n        this._private__dataSources = [];\n        this._private__overlaySourcesByScaleId = new Map();\n        this._private__height = 0;\n        this._private__width = 0;\n        this._private__stretchFactor = DEFAULT_STRETCH_FACTOR;\n        this._private__cachedOrderedSources = null;\n        this._private__destroyed = new Delegate();\n        this._private__primitives = [];\n        this._private__timeScale = timeScale;\n        this._private__model = model;\n        this._private__grid = new Grid(this);\n        const options = model._internal_options();\n        this._private__leftPriceScale = this._private__createPriceScale(\"left\" /* DefaultPriceScaleId.Left */, options.leftPriceScale);\n        this._private__rightPriceScale = this._private__createPriceScale(\"right\" /* DefaultPriceScaleId.Right */, options.rightPriceScale);\n        this._private__leftPriceScale._internal_modeChanged()._internal_subscribe(this._private__onPriceScaleModeChanged.bind(this, this._private__leftPriceScale), this);\n        this._private__rightPriceScale._internal_modeChanged()._internal_subscribe(this._private__onPriceScaleModeChanged.bind(this, this._private__rightPriceScale), this);\n        this._internal_applyScaleOptions(options);\n    }\n    _internal_applyScaleOptions(options) {\n        if (options.leftPriceScale) {\n            this._private__leftPriceScale._internal_applyOptions(options.leftPriceScale);\n        }\n        if (options.rightPriceScale) {\n            this._private__rightPriceScale._internal_applyOptions(options.rightPriceScale);\n        }\n        if (options.localization) {\n            this._private__leftPriceScale._internal_updateFormatter();\n            this._private__rightPriceScale._internal_updateFormatter();\n        }\n        if (options.overlayPriceScales) {\n            const sourceArrays = Array.from(this._private__overlaySourcesByScaleId.values());\n            for (const arr of sourceArrays) {\n                const priceScale = ensureNotNull(arr[0]._internal_priceScale());\n                priceScale._internal_applyOptions(options.overlayPriceScales);\n                if (options.localization) {\n                    priceScale._internal_updateFormatter();\n                }\n            }\n        }\n    }\n    _internal_priceScaleById(id) {\n        switch (id) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n            case \"left\" /* DefaultPriceScaleId.Left */: {\n                return this._private__leftPriceScale;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n            case \"right\" /* DefaultPriceScaleId.Right */: {\n                return this._private__rightPriceScale;\n            }\n        }\n        if (this._private__overlaySourcesByScaleId.has(id)) {\n            return ensureDefined(this._private__overlaySourcesByScaleId.get(id))[0]._internal_priceScale();\n        }\n        return null;\n    }\n    _internal_destroy() {\n        this._internal_model()._internal_priceScalesOptionsChanged()._internal_unsubscribeAll(this);\n        this._private__leftPriceScale._internal_modeChanged()._internal_unsubscribeAll(this);\n        this._private__rightPriceScale._internal_modeChanged()._internal_unsubscribeAll(this);\n        this._private__dataSources.forEach((source) => {\n            if (source._internal_destroy) {\n                source._internal_destroy();\n            }\n        });\n        this._private__primitives = this._private__primitives.filter((primitive) => {\n            const p = primitive._internal_primitive();\n            if (p.detached) {\n                p.detached();\n            }\n            return false;\n        });\n        this._private__destroyed._internal_fire();\n    }\n    _internal_stretchFactor() {\n        return this._private__stretchFactor;\n    }\n    _internal_setStretchFactor(factor) {\n        this._private__stretchFactor = factor;\n    }\n    _internal_model() {\n        return this._private__model;\n    }\n    _internal_width() {\n        return this._private__width;\n    }\n    _internal_height() {\n        return this._private__height;\n    }\n    _internal_setWidth(width) {\n        this._private__width = width;\n        this._internal_updateAllSources();\n    }\n    _internal_setHeight(height) {\n        this._private__height = height;\n        this._private__leftPriceScale._internal_setHeight(height);\n        this._private__rightPriceScale._internal_setHeight(height);\n        // process overlays\n        this._private__dataSources.forEach((ds) => {\n            if (this._internal_isOverlay(ds)) {\n                const priceScale = ds._internal_priceScale();\n                if (priceScale !== null) {\n                    priceScale._internal_setHeight(height);\n                }\n            }\n        });\n        this._internal_updateAllSources();\n    }\n    _internal_series() {\n        return this._private__dataSources.filter(isSeries);\n    }\n    _internal_dataSources() {\n        return this._private__dataSources;\n    }\n    _internal_isOverlay(source) {\n        const priceScale = source._internal_priceScale();\n        if (priceScale === null) {\n            return true;\n        }\n        return this._private__leftPriceScale !== priceScale && this._private__rightPriceScale !== priceScale;\n    }\n    _internal_addDataSource(source, targetScaleId, keepSourcesOrder) {\n        this._private__insertDataSource(source, targetScaleId, keepSourcesOrder ? source._internal_zorder() : this._private__dataSources.length);\n    }\n    _internal_removeDataSource(source, keepSourceOrder) {\n        const index = this._private__dataSources.indexOf(source);\n        assert(index !== -1, 'removeDataSource: invalid data source');\n        this._private__dataSources.splice(index, 1);\n        if (!keepSourceOrder) {\n            this._private__dataSources.forEach((ds, i) => ds._internal_setZorder(i));\n        }\n        const priceScaleId = ensureNotNull(source._internal_priceScale())._internal_id();\n        if (this._private__overlaySourcesByScaleId.has(priceScaleId)) {\n            const overlaySources = ensureDefined(this._private__overlaySourcesByScaleId.get(priceScaleId));\n            const overlayIndex = overlaySources.indexOf(source);\n            if (overlayIndex !== -1) {\n                overlaySources.splice(overlayIndex, 1);\n                if (overlaySources.length === 0) {\n                    this._private__overlaySourcesByScaleId.delete(priceScaleId);\n                }\n            }\n        }\n        const priceScale = source._internal_priceScale();\n        // if source has owner, it returns owner's price scale\n        // and it does not have source in their list\n        if (priceScale && priceScale._internal_dataSources().indexOf(source) >= 0) {\n            priceScale._internal_removeDataSource(source);\n            this._internal_recalculatePriceScale(priceScale);\n        }\n        this._private__cachedOrderedSources = null;\n    }\n    _internal_priceScalePosition(priceScale) {\n        if (priceScale === this._private__leftPriceScale) {\n            return 'left';\n        }\n        if (priceScale === this._private__rightPriceScale) {\n            return 'right';\n        }\n        return 'overlay';\n    }\n    _internal_leftPriceScale() {\n        return this._private__leftPriceScale;\n    }\n    _internal_rightPriceScale() {\n        return this._private__rightPriceScale;\n    }\n    _internal_startScalePrice(priceScale, x) {\n        priceScale._internal_startScale(x);\n    }\n    _internal_scalePriceTo(priceScale, x) {\n        priceScale._internal_scaleTo(x);\n        // TODO: be more smart and update only affected views\n        this._internal_updateAllSources();\n    }\n    _internal_endScalePrice(priceScale) {\n        priceScale._internal_endScale();\n    }\n    _internal_startScrollPrice(priceScale, x) {\n        priceScale._internal_startScroll(x);\n    }\n    _internal_scrollPriceTo(priceScale, x) {\n        priceScale._internal_scrollTo(x);\n        this._internal_updateAllSources();\n    }\n    _internal_endScrollPrice(priceScale) {\n        priceScale._internal_endScroll();\n    }\n    _internal_updateAllSources() {\n        this._private__dataSources.forEach((source) => {\n            source._internal_updateAllViews();\n        });\n    }\n    _internal_defaultPriceScale() {\n        let priceScale = null;\n        if (this._private__model._internal_options().rightPriceScale.visible && this._private__rightPriceScale._internal_dataSources().length !== 0) {\n            priceScale = this._private__rightPriceScale;\n        }\n        else if (this._private__model._internal_options().leftPriceScale.visible && this._private__leftPriceScale._internal_dataSources().length !== 0) {\n            priceScale = this._private__leftPriceScale;\n        }\n        else if (this._private__dataSources.length !== 0) {\n            priceScale = this._private__dataSources[0]._internal_priceScale();\n        }\n        if (priceScale === null) {\n            priceScale = this._private__rightPriceScale;\n        }\n        return priceScale;\n    }\n    _internal_defaultVisiblePriceScale() {\n        let priceScale = null;\n        if (this._private__model._internal_options().rightPriceScale.visible) {\n            priceScale = this._private__rightPriceScale;\n        }\n        else if (this._private__model._internal_options().leftPriceScale.visible) {\n            priceScale = this._private__leftPriceScale;\n        }\n        return priceScale;\n    }\n    _internal_recalculatePriceScale(priceScale) {\n        if (priceScale === null || !priceScale._internal_isAutoScale()) {\n            return;\n        }\n        this._private__recalculatePriceScaleImpl(priceScale);\n    }\n    _internal_resetPriceScale(priceScale) {\n        const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n        priceScale._internal_setMode({ _internal_autoScale: true });\n        if (visibleBars !== null) {\n            priceScale._internal_recalculatePriceRange(visibleBars);\n        }\n        this._internal_updateAllSources();\n    }\n    _internal_momentaryAutoScale() {\n        this._private__recalculatePriceScaleImpl(this._private__leftPriceScale);\n        this._private__recalculatePriceScaleImpl(this._private__rightPriceScale);\n    }\n    _internal_recalculate() {\n        this._internal_recalculatePriceScale(this._private__leftPriceScale);\n        this._internal_recalculatePriceScale(this._private__rightPriceScale);\n        this._private__dataSources.forEach((ds) => {\n            if (this._internal_isOverlay(ds)) {\n                this._internal_recalculatePriceScale(ds._internal_priceScale());\n            }\n        });\n        this._internal_updateAllSources();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_orderedSources() {\n        if (this._private__cachedOrderedSources === null) {\n            this._private__cachedOrderedSources = sortSources(this._private__dataSources);\n        }\n        return this._private__cachedOrderedSources;\n    }\n    _internal_setSeriesOrder(series, order) {\n        order = clamp(order, 0, this._private__dataSources.length - 1);\n        const index = this._private__dataSources.indexOf(series);\n        assert(index !== -1, 'setSeriesOrder: invalid data source');\n        this._private__dataSources.splice(index, 1);\n        this._private__dataSources.splice(order, 0, series);\n        this._private__dataSources.forEach((ps, i) => ps._internal_setZorder(i));\n        this._private__cachedOrderedSources = null;\n        for (const ps of [this._private__leftPriceScale, this._private__rightPriceScale]) {\n            ps._internal_invalidateSourcesCache();\n            ps._internal_updateFormatter();\n        }\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_orderedSeries() {\n        return this._internal_orderedSources().filter(isSeries);\n    }\n    _internal_onDestroyed() {\n        return this._private__destroyed;\n    }\n    _internal_grid() {\n        return this._private__grid;\n    }\n    _internal_attachPrimitive(primitive) {\n        this._private__primitives.push(new PanePrimitiveWrapper$1(primitive));\n    }\n    _internal_detachPrimitive(source) {\n        this._private__primitives = this._private__primitives.filter((wrapper) => wrapper._internal_primitive() !== source);\n        if (source.detached) {\n            source.detached();\n        }\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_primitives() {\n        return this._private__primitives;\n    }\n    _internal_primitiveHitTest(x, y) {\n        return this._private__primitives\n            .map((primitive) => primitive._internal_hitTest(x, y))\n            .filter((result) => result !== null);\n    }\n    _private__recalculatePriceScaleImpl(priceScale) {\n        // TODO: can use this checks\n        const sourceForAutoScale = priceScale._internal_sourcesForAutoScale();\n        if (sourceForAutoScale && sourceForAutoScale.length > 0 && !this._private__timeScale._internal_isEmpty()) {\n            const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n            if (visibleBars !== null) {\n                priceScale._internal_recalculatePriceRange(visibleBars);\n            }\n        }\n        priceScale._internal_updateAllViews();\n    }\n    _private__insertDataSource(source, priceScaleId, order) {\n        let priceScale = this._internal_priceScaleById(priceScaleId);\n        if (priceScale === null) {\n            priceScale = this._private__createPriceScale(priceScaleId, this._private__model._internal_options().overlayPriceScales);\n        }\n        this._private__dataSources.splice(order, 0, source);\n        if (!isDefaultPriceScale(priceScaleId)) {\n            const overlaySources = this._private__overlaySourcesByScaleId.get(priceScaleId) || [];\n            overlaySources.push(source);\n            this._private__overlaySourcesByScaleId.set(priceScaleId, overlaySources);\n        }\n        source._internal_setZorder(order);\n        priceScale._internal_addDataSource(source);\n        source._internal_setPriceScale(priceScale);\n        this._internal_recalculatePriceScale(priceScale);\n        this._private__cachedOrderedSources = null;\n    }\n    _private__onPriceScaleModeChanged(priceScale, oldMode, newMode) {\n        if (oldMode._internal_mode === newMode._internal_mode) {\n            return;\n        }\n        // momentary auto scale if we toggle percentage/indexedTo100 mode\n        this._private__recalculatePriceScaleImpl(priceScale);\n    }\n    _private__createPriceScale(id, options) {\n        const actualOptions = { visible: true, autoScale: true, ...clone(options) };\n        const priceScale = new PriceScale(id, actualOptions, this._private__model._internal_options()['layout'], this._private__model._internal_options().localization, this._private__model._internal_colorParser());\n        priceScale._internal_setHeight(this._internal_height());\n        return priceScale;\n    }\n}\n\n// returns true if item is above reference\nfunction comparePrimitiveZOrder(item, reference) {\n    return (!reference ||\n        (item === 'top' && reference !== 'top') ||\n        (item === 'normal' && reference === 'bottom'));\n}\nfunction findBestPrimitiveHitTest(sources, x, y) {\n    let bestPrimitiveHit;\n    let bestHitSource;\n    for (const source of sources) {\n        const primitiveHitResults = source._internal_primitiveHitTest?.(x, y) ?? [];\n        for (const hitResult of primitiveHitResults) {\n            if (comparePrimitiveZOrder(hitResult.zOrder, bestPrimitiveHit?.zOrder)) {\n                bestPrimitiveHit = hitResult;\n                bestHitSource = source;\n            }\n        }\n    }\n    if (!bestPrimitiveHit || !bestHitSource) {\n        return null;\n    }\n    return {\n        _internal_hit: bestPrimitiveHit,\n        _internal_source: bestHitSource,\n    };\n}\nfunction convertPrimitiveHitResult(primitiveHit) {\n    return {\n        _internal_source: primitiveHit._internal_source,\n        _internal_object: {\n            _internal_externalId: primitiveHit._internal_hit.externalId,\n        },\n        _internal_cursorStyle: primitiveHit._internal_hit.cursorStyle,\n    };\n}\n/**\n * Performs a hit test on a collection of pane views to determine which view and object\n * is located at a given coordinate (x, y) and returns the matching pane view and\n * hit-tested result object, or null if no match is found.\n */\nfunction hitTestPaneView(paneViews, x, y, pane) {\n    for (const paneView of paneViews) {\n        const renderer = paneView._internal_renderer(pane);\n        if (renderer !== null && renderer._internal_hitTest) {\n            const result = renderer._internal_hitTest(x, y);\n            if (result !== null) {\n                return {\n                    _internal_view: paneView,\n                    _internal_object: result,\n                };\n            }\n        }\n    }\n    return null;\n}\nfunction isDataSource(source) {\n    return source._internal_paneViews !== undefined;\n}\n// eslint-disable-next-line complexity\nfunction hitTestPane(pane, x, y) {\n    const sources = [pane, ...pane._internal_orderedSources()];\n    const bestPrimitiveHit = findBestPrimitiveHitTest(sources, x, y);\n    if (bestPrimitiveHit?._internal_hit.zOrder === 'top') {\n        // a primitive hit on the 'top' layer will always beat the built-in hit tests\n        // (on normal layer) so we can return early here.\n        return convertPrimitiveHitResult(bestPrimitiveHit);\n    }\n    for (const source of sources) {\n        if (bestPrimitiveHit && bestPrimitiveHit._internal_source === source && bestPrimitiveHit._internal_hit.zOrder !== 'bottom' && !bestPrimitiveHit._internal_hit.isBackground) {\n            // a primitive will be drawn above a built-in item like a series marker\n            // therefore it takes precedence here.\n            return convertPrimitiveHitResult(bestPrimitiveHit);\n        }\n        if (isDataSource(source)) {\n            const sourceResult = hitTestPaneView(source._internal_paneViews(pane), x, y, pane);\n            if (sourceResult !== null) {\n                return {\n                    _internal_source: source,\n                    _internal_view: sourceResult._internal_view,\n                    _internal_object: sourceResult._internal_object,\n                };\n            }\n        }\n        if (bestPrimitiveHit && bestPrimitiveHit._internal_source === source && bestPrimitiveHit._internal_hit.zOrder !== 'bottom' && bestPrimitiveHit._internal_hit.isBackground) {\n            return convertPrimitiveHitResult(bestPrimitiveHit);\n        }\n    }\n    if (bestPrimitiveHit?._internal_hit) {\n        // return primitive hits for the 'bottom' layer\n        return convertPrimitiveHitResult(bestPrimitiveHit);\n    }\n    return null;\n}\n\nclass FormattedLabelsCache {\n    constructor(format, horzScaleBehavior, size = 50) {\n        this._private__actualSize = 0;\n        this._private__usageTick = 1;\n        this._private__oldestTick = 1;\n        this._private__cache = new Map();\n        this._private__tick2Labels = new Map();\n        this._private__format = format;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__maxSize = size;\n    }\n    _internal_format(tickMark) {\n        const time = tickMark.time;\n        const cacheKey = this._private__horzScaleBehavior.cacheKey(time);\n        const tick = this._private__cache.get(cacheKey);\n        if (tick !== undefined) {\n            return tick._internal_string;\n        }\n        if (this._private__actualSize === this._private__maxSize) {\n            const oldestValue = this._private__tick2Labels.get(this._private__oldestTick);\n            this._private__tick2Labels.delete(this._private__oldestTick);\n            this._private__cache.delete(ensureDefined(oldestValue));\n            this._private__oldestTick++;\n            this._private__actualSize--;\n        }\n        const str = this._private__format(tickMark);\n        this._private__cache.set(cacheKey, { _internal_string: str, _internal_tick: this._private__usageTick });\n        this._private__tick2Labels.set(this._private__usageTick, cacheKey);\n        this._private__actualSize++;\n        this._private__usageTick++;\n        return str;\n    }\n}\n\nclass RangeImpl {\n    constructor(left, right) {\n        assert(left <= right, 'right should be >= left');\n        this._private__left = left;\n        this._private__right = right;\n    }\n    _internal_left() {\n        return this._private__left;\n    }\n    _internal_right() {\n        return this._private__right;\n    }\n    _internal_count() {\n        return this._private__right - this._private__left + 1;\n    }\n    _internal_contains(index) {\n        return this._private__left <= index && index <= this._private__right;\n    }\n    _internal_equals(other) {\n        return this._private__left === other._internal_left() && this._private__right === other._internal_right();\n    }\n}\nfunction areRangesEqual(first, second) {\n    if (first === null || second === null) {\n        return first === second;\n    }\n    return first._internal_equals(second);\n}\n\nclass TickMarks {\n    constructor() {\n        this._private__marksByWeight = new Map();\n        this._private__cache = null;\n        this._private__uniformDistribution = false;\n    }\n    _internal_setUniformDistribution(val) {\n        this._private__uniformDistribution = val;\n        this._private__cache = null;\n    }\n    _internal_setTimeScalePoints(newPoints, firstChangedPointIndex) {\n        this._private__removeMarksSinceIndex(firstChangedPointIndex);\n        this._private__cache = null;\n        for (let index = firstChangedPointIndex; index < newPoints.length; ++index) {\n            const point = newPoints[index];\n            let marksForWeight = this._private__marksByWeight.get(point.timeWeight);\n            if (marksForWeight === undefined) {\n                marksForWeight = [];\n                this._private__marksByWeight.set(point.timeWeight, marksForWeight);\n            }\n            marksForWeight.push({\n                index: index,\n                time: point.time,\n                weight: point.timeWeight,\n                originalTime: point.originalTime,\n            });\n        }\n    }\n    _internal_build(spacing, maxWidth, checkIndicesForData, indicesWithDataMap, indicesWithDataId) {\n        const maxIndexesPerMark = Math.ceil(maxWidth / spacing);\n        if (this._private__cache === null ||\n            this._private__cache._internal_maxIndexesPerMark !== maxIndexesPerMark ||\n            indicesWithDataId !== this._private__cache._internal_indicesWithDataId ||\n            checkIndicesForData !== this._private__cache._internal_checkIndicesForData) {\n            this._private__cache = {\n                _internal_indicesWithDataId: indicesWithDataId,\n                _internal_checkIndicesForData: checkIndicesForData,\n                _internal_marks: this._private__buildMarksImpl(maxIndexesPerMark, checkIndicesForData, indicesWithDataMap),\n                _internal_maxIndexesPerMark: maxIndexesPerMark,\n            };\n        }\n        return this._private__cache._internal_marks;\n    }\n    _private__removeMarksSinceIndex(sinceIndex) {\n        if (sinceIndex === 0) {\n            this._private__marksByWeight.clear();\n            return;\n        }\n        const weightsToClear = [];\n        this._private__marksByWeight.forEach((marks, timeWeight) => {\n            if (sinceIndex <= marks[0].index) {\n                weightsToClear.push(timeWeight);\n            }\n            else {\n                marks.splice(lowerBound(marks, sinceIndex, (tm) => tm.index < sinceIndex), Infinity);\n            }\n        });\n        for (const weight of weightsToClear) {\n            this._private__marksByWeight.delete(weight);\n        }\n    }\n    _private__buildMarksImpl(maxIndexesPerMark, checkIndicesForData, indicesWithDataMap) {\n        let marks = [];\n        const canBeIncluded = (mark) => !checkIndicesForData || indicesWithDataMap.has(mark.index);\n        for (const weight of Array.from(this._private__marksByWeight.keys()).sort((a, b) => b - a)) {\n            if (!this._private__marksByWeight.get(weight)) {\n                continue;\n            }\n            // Built tickMarks are now prevMarks, and marks it as new array\n            const prevMarks = marks;\n            marks = [];\n            const prevMarksLength = prevMarks.length;\n            let prevMarksPointer = 0;\n            const currentWeight = ensureDefined(this._private__marksByWeight.get(weight));\n            const currentWeightLength = currentWeight.length;\n            let rightIndex = Infinity;\n            let leftIndex = -Infinity;\n            for (let i = 0; i < currentWeightLength; i++) {\n                const mark = currentWeight[i];\n                const currentIndex = mark.index;\n                // Determine indexes with which current index will be compared\n                // All marks to the right is moved to new array\n                while (prevMarksPointer < prevMarksLength) {\n                    const lastMark = prevMarks[prevMarksPointer];\n                    const lastIndex = lastMark.index;\n                    if (lastIndex < currentIndex && canBeIncluded(lastMark)) {\n                        prevMarksPointer++;\n                        marks.push(lastMark);\n                        leftIndex = lastIndex;\n                        rightIndex = Infinity;\n                    }\n                    else {\n                        rightIndex = lastIndex;\n                        break;\n                    }\n                }\n                if (rightIndex - currentIndex >= maxIndexesPerMark &&\n                    currentIndex - leftIndex >= maxIndexesPerMark &&\n                    canBeIncluded(mark)) {\n                    // TickMark fits. Place it into new array\n                    marks.push(mark);\n                    leftIndex = currentIndex;\n                }\n                else {\n                    if (this._private__uniformDistribution) {\n                        return prevMarks;\n                    }\n                }\n            }\n            // Place all unused tickMarks into new array;\n            for (; prevMarksPointer < prevMarksLength; prevMarksPointer++) {\n                if (canBeIncluded(prevMarks[prevMarksPointer])) {\n                    marks.push(prevMarks[prevMarksPointer]);\n                }\n            }\n        }\n        return marks;\n    }\n}\n\nclass TimeScaleVisibleRange {\n    constructor(logicalRange) {\n        this._private__logicalRange = logicalRange;\n    }\n    _internal_strictRange() {\n        if (this._private__logicalRange === null) {\n            return null;\n        }\n        return new RangeImpl(Math.floor(this._private__logicalRange._internal_left()), Math.ceil(this._private__logicalRange._internal_right()));\n    }\n    _internal_logicalRange() {\n        return this._private__logicalRange;\n    }\n    static _internal_invalid() {\n        return new TimeScaleVisibleRange(null);\n    }\n}\n\nconst defaultTickMarkMaxCharacterLength = 8;\nfunction markWithGreaterWeight$2(a, b) {\n    return a.weight > b.weight ? a : b;\n}\nclass TimeScale {\n    constructor(model, options, localizationOptions, horzScaleBehavior) {\n        this._private__width = 0;\n        this._private__baseIndexOrNull = null;\n        this._private__points = [];\n        this._private__scrollStartPoint = null;\n        this._private__scaleStartPoint = null;\n        this._private__tickMarks = new TickMarks();\n        this._private__formattedByWeight = new Map();\n        this._private__visibleRange = TimeScaleVisibleRange._internal_invalid();\n        this._private__visibleRangeInvalidated = true;\n        this._private__visibleBarsChanged = new Delegate();\n        this._private__logicalRangeChanged = new Delegate();\n        this._private__optionsApplied = new Delegate();\n        this._private__commonTransitionStartState = null;\n        this._private__timeMarksCache = null;\n        this._private__indicesWithData = new Map();\n        this._private__indicesWithDataUpdateId = -1;\n        this._private__labels = [];\n        this._private__options = options;\n        this._private__localizationOptions = localizationOptions;\n        this._private__rightOffset = options.rightOffset;\n        this._private__barSpacing = options.barSpacing;\n        this._private__model = model;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__updateDateTimeFormatter();\n        this._private__tickMarks._internal_setUniformDistribution(options.uniformDistribution);\n        this._internal_recalculateIndicesWithData();\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyLocalizationOptions(localizationOptions) {\n        merge(this._private__localizationOptions, localizationOptions);\n        this._private__invalidateTickMarks();\n        this._private__updateDateTimeFormatter();\n    }\n    _internal_applyOptions(options, localizationOptions) {\n        merge(this._private__options, options);\n        if (this._private__options.fixLeftEdge) {\n            this._private__doFixLeftEdge();\n        }\n        if (this._private__options.fixRightEdge) {\n            this._private__doFixRightEdge();\n        }\n        // note that bar spacing should be applied before right offset\n        // because right offset depends on bar spacing\n        if (options.barSpacing !== undefined) {\n            this._private__model._internal_setBarSpacing(options.barSpacing);\n        }\n        if (options.rightOffset !== undefined) {\n            this._private__model._internal_setRightOffset(options.rightOffset);\n        }\n        if (options.minBarSpacing !== undefined || options.maxBarSpacing !== undefined) {\n            // yes, if we apply bar spacing constrains then we need to correct bar spacing\n            // the easiest way is to apply it once again\n            this._private__model._internal_setBarSpacing(options.barSpacing ?? this._private__barSpacing);\n        }\n        if (options.ignoreWhitespaceIndices !== undefined && options.ignoreWhitespaceIndices !== this._private__options.ignoreWhitespaceIndices) {\n            this._internal_recalculateIndicesWithData();\n        }\n        this._private__invalidateTickMarks();\n        this._private__updateDateTimeFormatter();\n        this._private__optionsApplied._internal_fire();\n    }\n    _internal_indexToTime(index) {\n        return this._private__points[index]?.time ?? null;\n    }\n    _internal_indexToTimeScalePoint(index) {\n        return this._private__points[index] ?? null;\n    }\n    _internal_timeToIndex(time, findNearest) {\n        if (this._private__points.length < 1) {\n            // no time points available\n            return null;\n        }\n        if (this._private__horzScaleBehavior.key(time) > this._private__horzScaleBehavior.key(this._private__points[this._private__points.length - 1].time)) {\n            // special case\n            return findNearest ? this._private__points.length - 1 : null;\n        }\n        const index = lowerBound(this._private__points, this._private__horzScaleBehavior.key(time), (a, b) => this._private__horzScaleBehavior.key(a.time) < b);\n        if (this._private__horzScaleBehavior.key(time) < this._private__horzScaleBehavior.key(this._private__points[index].time)) {\n            return findNearest ? index : null;\n        }\n        return index;\n    }\n    _internal_isEmpty() {\n        return this._private__width === 0 || this._private__points.length === 0 || this._private__baseIndexOrNull === null;\n    }\n    _internal_hasPoints() {\n        return this._private__points.length > 0;\n    }\n    // strict range: integer indices of the bars in the visible range rounded in more wide direction\n    _internal_visibleStrictRange() {\n        this._private__updateVisibleRange();\n        return this._private__visibleRange._internal_strictRange();\n    }\n    _internal_visibleLogicalRange() {\n        this._private__updateVisibleRange();\n        return this._private__visibleRange._internal_logicalRange();\n    }\n    _internal_visibleTimeRange() {\n        const visibleBars = this._internal_visibleStrictRange();\n        if (visibleBars === null) {\n            return null;\n        }\n        const range = {\n            from: visibleBars._internal_left(),\n            to: visibleBars._internal_right(),\n        };\n        return this._internal_timeRangeForLogicalRange(range);\n    }\n    _internal_timeRangeForLogicalRange(range) {\n        const from = Math.round(range.from);\n        const to = Math.round(range.to);\n        const firstIndex = ensureNotNull(this._private__firstIndex());\n        const lastIndex = ensureNotNull(this._private__lastIndex());\n        return {\n            from: ensureNotNull(this._internal_indexToTimeScalePoint(Math.max(firstIndex, from))),\n            to: ensureNotNull(this._internal_indexToTimeScalePoint(Math.min(lastIndex, to))),\n        };\n    }\n    _internal_logicalRangeForTimeRange(range) {\n        return {\n            from: ensureNotNull(this._internal_timeToIndex(range.from, true)),\n            to: ensureNotNull(this._internal_timeToIndex(range.to, true)),\n        };\n    }\n    _internal_width() {\n        return this._private__width;\n    }\n    _internal_setWidth(newWidth) {\n        if (!isFinite(newWidth) || newWidth <= 0) {\n            return;\n        }\n        if (this._private__width === newWidth) {\n            return;\n        }\n        // when we change the width and we need to correct visible range because of fixing left edge\n        // we need to check the previous visible range rather than the new one\n        // because it might be updated by changing width, bar spacing, etc\n        // but we need to try to keep the same range\n        const previousVisibleRange = this._internal_visibleLogicalRange();\n        const oldWidth = this._private__width;\n        this._private__width = newWidth;\n        this._private__visibleRangeInvalidated = true;\n        if (this._private__options.lockVisibleTimeRangeOnResize && oldWidth !== 0) {\n            // recalculate bar spacing\n            const newBarSpacing = this._private__barSpacing * newWidth / oldWidth;\n            this._private__barSpacing = newBarSpacing;\n        }\n        // if time scale is scrolled to the end of data and we have fixed right edge\n        // keep left edge instead of right\n        // we need it to avoid \"shaking\" if the last bar visibility affects time scale width\n        if (this._private__options.fixLeftEdge) {\n            // note that logical left range means not the middle of a bar (it's the left border)\n            if (previousVisibleRange !== null && previousVisibleRange._internal_left() <= 0) {\n                const delta = oldWidth - newWidth;\n                // reduce  _rightOffset means move right\n                // we could move more than required - this will be fixed by _correctOffset()\n                this._private__rightOffset -= Math.round(delta / this._private__barSpacing) + 1;\n                this._private__visibleRangeInvalidated = true;\n            }\n        }\n        // updating bar spacing should be first because right offset depends on it\n        this._private__correctBarSpacing();\n        this._private__correctOffset();\n    }\n    _internal_indexToCoordinate(index) {\n        if (this._internal_isEmpty() || !isInteger(index)) {\n            return 0;\n        }\n        const baseIndex = this._internal_baseIndex();\n        const deltaFromRight = baseIndex + this._private__rightOffset - index;\n        const coordinate = this._private__width - (deltaFromRight + 0.5) * this._private__barSpacing - 1;\n        return coordinate;\n    }\n    _internal_indexesToCoordinates(points, visibleRange) {\n        const baseIndex = this._internal_baseIndex();\n        const indexFrom = (visibleRange === undefined) ? 0 : visibleRange.from;\n        const indexTo = (visibleRange === undefined) ? points.length : visibleRange.to;\n        for (let i = indexFrom; i < indexTo; i++) {\n            const index = points[i]._internal_time;\n            const deltaFromRight = baseIndex + this._private__rightOffset - index;\n            const coordinate = this._private__width - (deltaFromRight + 0.5) * this._private__barSpacing - 1;\n            points[i]._internal_x = coordinate;\n        }\n    }\n    _internal_coordinateToIndex(x, considerIgnoreWhitespace) {\n        const index = Math.ceil(this._private__coordinateToFloatIndex(x));\n        if (!considerIgnoreWhitespace ||\n            !this._private__options.ignoreWhitespaceIndices ||\n            this._private__shouldConsiderIndex(index)) {\n            return index;\n        }\n        return this._private__findNearestIndexWithData(index);\n    }\n    _internal_setRightOffset(offset) {\n        this._private__visibleRangeInvalidated = true;\n        this._private__rightOffset = offset;\n        this._private__correctOffset();\n        this._private__model._internal_recalculateAllPanes();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_barSpacing() {\n        return this._private__barSpacing;\n    }\n    _internal_setBarSpacing(newBarSpacing) {\n        this._private__setBarSpacing(newBarSpacing);\n        // do not allow scroll out of visible bars\n        this._private__correctOffset();\n        this._private__model._internal_recalculateAllPanes();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_rightOffset() {\n        return this._private__rightOffset;\n    }\n    // eslint-disable-next-line complexity\n    _internal_marks() {\n        if (this._internal_isEmpty()) {\n            return null;\n        }\n        if (this._private__timeMarksCache !== null) {\n            return this._private__timeMarksCache;\n        }\n        const spacing = this._private__barSpacing;\n        const fontSize = this._private__model._internal_options()['layout'].fontSize;\n        const pixelsPer8Characters = (fontSize + 4) * 5;\n        const pixelsPerCharacter = pixelsPer8Characters / defaultTickMarkMaxCharacterLength;\n        const maxLabelWidth = pixelsPerCharacter * (this._private__options.tickMarkMaxCharacterLength || defaultTickMarkMaxCharacterLength);\n        const indexPerLabel = Math.round(maxLabelWidth / spacing);\n        const visibleBars = ensureNotNull(this._internal_visibleStrictRange());\n        const firstBar = Math.max(visibleBars._internal_left(), visibleBars._internal_left() - indexPerLabel);\n        const lastBar = Math.max(visibleBars._internal_right(), visibleBars._internal_right() - indexPerLabel);\n        const items = this._private__tickMarks._internal_build(spacing, maxLabelWidth, this._private__options.ignoreWhitespaceIndices, this._private__indicesWithData, this._private__indicesWithDataUpdateId);\n        // according to indexPerLabel value this value means \"earliest index which _might be_ used as the second label on time scale\"\n        const earliestIndexOfSecondLabel = this._private__firstIndex() + indexPerLabel;\n        // according to indexPerLabel value this value means \"earliest index which _might be_ used as the second last label on time scale\"\n        const indexOfSecondLastLabel = this._private__lastIndex() - indexPerLabel;\n        const isAllScalingAndScrollingDisabled = this._private__isAllScalingAndScrollingDisabled();\n        const isLeftEdgeFixed = this._private__options.fixLeftEdge || isAllScalingAndScrollingDisabled;\n        const isRightEdgeFixed = this._private__options.fixRightEdge || isAllScalingAndScrollingDisabled;\n        let targetIndex = 0;\n        for (const tm of items) {\n            if (!(firstBar <= tm.index && tm.index <= lastBar)) {\n                continue;\n            }\n            let label;\n            if (targetIndex < this._private__labels.length) {\n                label = this._private__labels[targetIndex];\n                label.coord = this._internal_indexToCoordinate(tm.index);\n                label.label = this._private__formatLabel(tm);\n                label.weight = tm.weight;\n            }\n            else {\n                label = {\n                    needAlignCoordinate: false,\n                    coord: this._internal_indexToCoordinate(tm.index),\n                    label: this._private__formatLabel(tm),\n                    weight: tm.weight,\n                };\n                this._private__labels.push(label);\n            }\n            if (this._private__barSpacing > (maxLabelWidth / 2) && !isAllScalingAndScrollingDisabled) {\n                // if there is enough space then let's show all tick marks as usual\n                label.needAlignCoordinate = false;\n            }\n            else {\n                // if a user is able to scroll after a tick mark then show it as usual, otherwise the coordinate might be aligned\n                // if the index is for the second (last) label or later (earlier) then most likely this label might be displayed without correcting the coordinate\n                label.needAlignCoordinate = (isLeftEdgeFixed && tm.index <= earliestIndexOfSecondLabel) || (isRightEdgeFixed && tm.index >= indexOfSecondLastLabel);\n            }\n            targetIndex++;\n        }\n        this._private__labels.length = targetIndex;\n        this._private__timeMarksCache = this._private__labels;\n        return this._private__labels;\n    }\n    _internal_restoreDefault() {\n        this._private__visibleRangeInvalidated = true;\n        this._internal_setBarSpacing(this._private__options.barSpacing);\n        this._internal_setRightOffset(this._private__options.rightOffset);\n    }\n    _internal_setBaseIndex(baseIndex) {\n        this._private__visibleRangeInvalidated = true;\n        this._private__baseIndexOrNull = baseIndex;\n        this._private__correctOffset();\n        this._private__doFixLeftEdge();\n    }\n    /**\n     * Zoom in/out the scale around a `zoomPoint` on `scale` value.\n     *\n     * @param zoomPoint - X coordinate of the point to apply the zoom.\n     * If `rightBarStaysOnScroll` option is disabled, then will be used to restore right offset.\n     * @param scale - Zoom value (in 1/10 parts of current bar spacing).\n     * Negative value means zoom out, positive - zoom in.\n     */\n    _internal_zoom(zoomPoint, scale) {\n        const floatIndexAtZoomPoint = this._private__coordinateToFloatIndex(zoomPoint);\n        const barSpacing = this._internal_barSpacing();\n        const newBarSpacing = barSpacing + scale * (barSpacing / 10);\n        // zoom in/out bar spacing\n        this._internal_setBarSpacing(newBarSpacing);\n        if (!this._private__options.rightBarStaysOnScroll) {\n            // and then correct right offset to move index under zoomPoint back to its coordinate\n            this._internal_setRightOffset(this._internal_rightOffset() + (floatIndexAtZoomPoint - this._private__coordinateToFloatIndex(zoomPoint)));\n        }\n    }\n    _internal_startScale(x) {\n        if (this._private__scrollStartPoint) {\n            this._internal_endScroll();\n        }\n        if (this._private__scaleStartPoint !== null || this._private__commonTransitionStartState !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        this._private__scaleStartPoint = x;\n        this._private__saveCommonTransitionsStartState();\n    }\n    _internal_scaleTo(x) {\n        if (this._private__commonTransitionStartState === null) {\n            return;\n        }\n        const startLengthFromRight = clamp(this._private__width - x, 0, this._private__width);\n        const currentLengthFromRight = clamp(this._private__width - ensureNotNull(this._private__scaleStartPoint), 0, this._private__width);\n        if (startLengthFromRight === 0 || currentLengthFromRight === 0) {\n            return;\n        }\n        this._internal_setBarSpacing(this._private__commonTransitionStartState._internal_barSpacing * startLengthFromRight / currentLengthFromRight);\n    }\n    _internal_endScale() {\n        if (this._private__scaleStartPoint === null) {\n            return;\n        }\n        this._private__scaleStartPoint = null;\n        this._private__clearCommonTransitionsStartState();\n    }\n    _internal_startScroll(x) {\n        if (this._private__scrollStartPoint !== null || this._private__commonTransitionStartState !== null) {\n            return;\n        }\n        if (this._internal_isEmpty()) {\n            return;\n        }\n        this._private__scrollStartPoint = x;\n        this._private__saveCommonTransitionsStartState();\n    }\n    _internal_scrollTo(x) {\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        const shiftInLogical = (this._private__scrollStartPoint - x) / this._internal_barSpacing();\n        this._private__rightOffset = ensureNotNull(this._private__commonTransitionStartState)._internal_rightOffset + shiftInLogical;\n        this._private__visibleRangeInvalidated = true;\n        // do not allow scroll out of visible bars\n        this._private__correctOffset();\n    }\n    _internal_endScroll() {\n        if (this._private__scrollStartPoint === null) {\n            return;\n        }\n        this._private__scrollStartPoint = null;\n        this._private__clearCommonTransitionsStartState();\n    }\n    _internal_scrollToRealTime() {\n        this._internal_scrollToOffsetAnimated(this._private__options.rightOffset);\n    }\n    _internal_scrollToOffsetAnimated(offset, animationDuration = 400 /* Constants.DefaultAnimationDuration */) {\n        if (!isFinite(offset)) {\n            throw new RangeError('offset is required and must be finite number');\n        }\n        if (!isFinite(animationDuration) || animationDuration <= 0) {\n            throw new RangeError('animationDuration (optional) must be finite positive number');\n        }\n        const source = this._private__rightOffset;\n        const animationStart = performance.now();\n        this._private__model._internal_setTimeScaleAnimation({\n            _internal_finished: (time) => (time - animationStart) / animationDuration >= 1,\n            _internal_getPosition: (time) => {\n                const animationProgress = (time - animationStart) / animationDuration;\n                const finishAnimation = animationProgress >= 1;\n                return finishAnimation ? offset : source + (offset - source) * animationProgress;\n            },\n        });\n    }\n    _internal_update(newPoints, firstChangedPointIndex) {\n        this._private__visibleRangeInvalidated = true;\n        this._private__points = newPoints;\n        this._private__tickMarks._internal_setTimeScalePoints(newPoints, firstChangedPointIndex);\n        this._private__correctOffset();\n    }\n    _internal_visibleBarsChanged() {\n        return this._private__visibleBarsChanged;\n    }\n    _internal_logicalRangeChanged() {\n        return this._private__logicalRangeChanged;\n    }\n    _internal_optionsApplied() {\n        return this._private__optionsApplied;\n    }\n    _internal_baseIndex() {\n        // null is used to known that baseIndex is not set yet\n        // so in methods which should known whether it is set or not\n        // we should check field `_baseIndexOrNull` instead of getter `baseIndex()`\n        // see minRightOffset for example\n        return this._private__baseIndexOrNull || 0;\n    }\n    _internal_setVisibleRange(range) {\n        const length = range._internal_count();\n        this._private__setBarSpacing(this._private__width / length);\n        this._private__rightOffset = range._internal_right() - this._internal_baseIndex();\n        this._private__correctOffset();\n        this._private__visibleRangeInvalidated = true;\n        this._private__model._internal_recalculateAllPanes();\n        this._private__model._internal_lightUpdate();\n    }\n    _internal_fitContent() {\n        const first = this._private__firstIndex();\n        const last = this._private__lastIndex();\n        if (first === null || last === null) {\n            return;\n        }\n        this._internal_setVisibleRange(new RangeImpl(first, last + this._private__options.rightOffset));\n    }\n    _internal_setLogicalRange(range) {\n        const barRange = new RangeImpl(range.from, range.to);\n        this._internal_setVisibleRange(barRange);\n    }\n    _internal_formatDateTime(timeScalePoint) {\n        if (this._private__localizationOptions.timeFormatter !== undefined) {\n            return this._private__localizationOptions.timeFormatter(timeScalePoint.originalTime);\n        }\n        return this._private__horzScaleBehavior.formatHorzItem(timeScalePoint.time);\n    }\n    _internal_recalculateIndicesWithData() {\n        if (!this._private__options.ignoreWhitespaceIndices) {\n            return;\n        }\n        this._private__indicesWithData.clear();\n        const series = this._private__model._internal_serieses();\n        for (const s of series) {\n            for (const index of s._internal_fulfilledIndices()) {\n                this._private__indicesWithData.set(index, true);\n            }\n        }\n        this._private__indicesWithDataUpdateId++;\n    }\n    _private__isAllScalingAndScrollingDisabled() {\n        const handleScroll = this._private__model._internal_options()['handleScroll'];\n        const handleScale = this._private__model._internal_options()['handleScale'];\n        return !handleScroll.horzTouchDrag\n            && !handleScroll.mouseWheel\n            && !handleScroll.pressedMouseMove\n            && !handleScroll.vertTouchDrag\n            && !handleScale.axisDoubleClickReset.time\n            && !handleScale.axisPressedMouseMove.time\n            && !handleScale.mouseWheel\n            && !handleScale.pinch;\n    }\n    _private__firstIndex() {\n        return this._private__points.length === 0 ? null : 0;\n    }\n    _private__lastIndex() {\n        return this._private__points.length === 0 ? null : (this._private__points.length - 1);\n    }\n    _private__rightOffsetForCoordinate(x) {\n        return (this._private__width - 1 - x) / this._private__barSpacing;\n    }\n    _private__coordinateToFloatIndex(x) {\n        const deltaFromRight = this._private__rightOffsetForCoordinate(x);\n        const baseIndex = this._internal_baseIndex();\n        const index = baseIndex + this._private__rightOffset - deltaFromRight;\n        // JavaScript uses very strange rounding\n        // we need rounding to avoid problems with calculation errors\n        return Math.round(index * 1000000) / 1000000;\n    }\n    _private__setBarSpacing(newBarSpacing) {\n        const oldBarSpacing = this._private__barSpacing;\n        this._private__barSpacing = newBarSpacing;\n        this._private__correctBarSpacing();\n        // this._barSpacing might be changed in _correctBarSpacing\n        if (oldBarSpacing !== this._private__barSpacing) {\n            this._private__visibleRangeInvalidated = true;\n            this._private__resetTimeMarksCache();\n        }\n    }\n    _private__updateVisibleRange() {\n        if (!this._private__visibleRangeInvalidated) {\n            return;\n        }\n        this._private__visibleRangeInvalidated = false;\n        if (this._internal_isEmpty()) {\n            this._private__setVisibleRange(TimeScaleVisibleRange._internal_invalid());\n            return;\n        }\n        const baseIndex = this._internal_baseIndex();\n        const newBarsLength = this._private__width / this._private__barSpacing;\n        const rightBorder = this._private__rightOffset + baseIndex;\n        const leftBorder = rightBorder - newBarsLength + 1;\n        const logicalRange = new RangeImpl(leftBorder, rightBorder);\n        this._private__setVisibleRange(new TimeScaleVisibleRange(logicalRange));\n    }\n    _private__correctBarSpacing() {\n        const barSpacing = clamp(this._private__barSpacing, this._private__minBarSpacing(), this._private__maxBarSpacing());\n        if (this._private__barSpacing !== barSpacing) {\n            this._private__barSpacing = barSpacing;\n            this._private__visibleRangeInvalidated = true;\n        }\n    }\n    _private__maxBarSpacing() {\n        if (this._private__options.maxBarSpacing > 0) {\n            // option takes precedance\n            return this._private__options.maxBarSpacing;\n        }\n        else {\n            // half of the width is default value for maximum bar spacing\n            return this._private__width * 0.5;\n        }\n    }\n    _private__minBarSpacing() {\n        // if both options are enabled then limit bar spacing so that zooming-out is not possible\n        // if it would cause either the first or last points to move too far from an edge\n        if (this._private__options.fixLeftEdge && this._private__options.fixRightEdge && this._private__points.length !== 0) {\n            return this._private__width / this._private__points.length;\n        }\n        return this._private__options.minBarSpacing;\n    }\n    _private__correctOffset() {\n        // block scrolling of to past\n        const minRightOffset = this._private__minRightOffset();\n        if (minRightOffset !== null && this._private__rightOffset < minRightOffset) {\n            this._private__rightOffset = minRightOffset;\n            this._private__visibleRangeInvalidated = true;\n        }\n        // block scrolling of to future\n        const maxRightOffset = this._private__maxRightOffset();\n        if (this._private__rightOffset > maxRightOffset) {\n            this._private__rightOffset = maxRightOffset;\n            this._private__visibleRangeInvalidated = true;\n        }\n    }\n    _private__minRightOffset() {\n        const firstIndex = this._private__firstIndex();\n        const baseIndex = this._private__baseIndexOrNull;\n        if (firstIndex === null || baseIndex === null) {\n            return null;\n        }\n        const barsEstimation = this._private__options.fixLeftEdge\n            ? this._private__width / this._private__barSpacing\n            : Math.min(2 /* Constants.MinVisibleBarsCount */, this._private__points.length);\n        return firstIndex - baseIndex - 1 + barsEstimation;\n    }\n    _private__maxRightOffset() {\n        return this._private__options.fixRightEdge\n            ? 0\n            : (this._private__width / this._private__barSpacing) - Math.min(2 /* Constants.MinVisibleBarsCount */, this._private__points.length);\n    }\n    _private__saveCommonTransitionsStartState() {\n        this._private__commonTransitionStartState = {\n            _internal_barSpacing: this._internal_barSpacing(),\n            _internal_rightOffset: this._internal_rightOffset(),\n        };\n    }\n    _private__clearCommonTransitionsStartState() {\n        this._private__commonTransitionStartState = null;\n    }\n    _private__formatLabel(tickMark) {\n        let formatter = this._private__formattedByWeight.get(tickMark.weight);\n        if (formatter === undefined) {\n            formatter = new FormattedLabelsCache((mark) => {\n                return this._private__formatLabelImpl(mark);\n            }, this._private__horzScaleBehavior);\n            this._private__formattedByWeight.set(tickMark.weight, formatter);\n        }\n        return formatter._internal_format(tickMark);\n    }\n    _private__formatLabelImpl(tickMark) {\n        return this._private__horzScaleBehavior.formatTickmark(tickMark, this._private__localizationOptions);\n    }\n    _private__setVisibleRange(newVisibleRange) {\n        const oldVisibleRange = this._private__visibleRange;\n        this._private__visibleRange = newVisibleRange;\n        if (!areRangesEqual(oldVisibleRange._internal_strictRange(), this._private__visibleRange._internal_strictRange())) {\n            this._private__visibleBarsChanged._internal_fire();\n        }\n        if (!areRangesEqual(oldVisibleRange._internal_logicalRange(), this._private__visibleRange._internal_logicalRange())) {\n            this._private__logicalRangeChanged._internal_fire();\n        }\n        // TODO: reset only coords in case when this._visibleBars has not been changed\n        this._private__resetTimeMarksCache();\n    }\n    _private__resetTimeMarksCache() {\n        this._private__timeMarksCache = null;\n    }\n    _private__invalidateTickMarks() {\n        this._private__resetTimeMarksCache();\n        this._private__formattedByWeight.clear();\n    }\n    _private__updateDateTimeFormatter() {\n        this._private__horzScaleBehavior.updateFormatter(this._private__localizationOptions);\n    }\n    _private__doFixLeftEdge() {\n        if (!this._private__options.fixLeftEdge) {\n            return;\n        }\n        const firstIndex = this._private__firstIndex();\n        if (firstIndex === null) {\n            return;\n        }\n        const visibleRange = this._internal_visibleStrictRange();\n        if (visibleRange === null) {\n            return;\n        }\n        const delta = visibleRange._internal_left() - firstIndex;\n        if (delta < 0) {\n            const leftEdgeOffset = this._private__rightOffset - delta - 1;\n            this._internal_setRightOffset(leftEdgeOffset);\n        }\n        this._private__correctBarSpacing();\n    }\n    _private__doFixRightEdge() {\n        this._private__correctOffset();\n        this._private__correctBarSpacing();\n    }\n    _private__shouldConsiderIndex(index) {\n        if (!this._private__options.ignoreWhitespaceIndices) {\n            return true;\n        }\n        return this._private__indicesWithData.get(index) || false;\n    }\n    _private__findNearestIndexWithData(x) {\n        const gen = testNearestIntegers(x);\n        const maxIndex = this._private__lastIndex();\n        while (maxIndex) {\n            const index = gen.next().value;\n            if (this._private__indicesWithData.get(index)) {\n                return index;\n            }\n            if (index < 0 || index > maxIndex) {\n                break;\n            }\n        }\n        return x; // fallback to original index\n    }\n}\nfunction* testNearestIntegers(num) {\n    const rounded = Math.round(num);\n    const isRoundedDown = rounded < num;\n    let offset = 1;\n    while (true) {\n        if (isRoundedDown) {\n            yield rounded + offset;\n            yield rounded - offset;\n        }\n        else {\n            yield rounded - offset;\n            yield rounded + offset;\n        }\n        offset++;\n    }\n}\n\n/// <reference types=\"_build-time-constants\" />\n/**\n * Determine how to exit the tracking mode.\n *\n * By default, mobile users will long press to deactivate the scroll and have the ability to check values and dates.\n * Another press is required to activate the scroll, be able to move left/right, zoom, etc.\n */\nvar TrackingModeExitMode;\n(function (TrackingModeExitMode) {\n    /**\n     * Tracking Mode will be deactivated on touch end event.\n     */\n    TrackingModeExitMode[TrackingModeExitMode[\"OnTouchEnd\"] = 0] = \"OnTouchEnd\";\n    /**\n     * Tracking Mode will be deactivated on the next tap event.\n     */\n    TrackingModeExitMode[TrackingModeExitMode[\"OnNextTap\"] = 1] = \"OnNextTap\";\n})(TrackingModeExitMode || (TrackingModeExitMode = {}));\nfunction isPanePrimitive(source) {\n    return source instanceof Pane;\n}\nclass ChartModel {\n    constructor(invalidateHandler, options, horzScaleBehavior) {\n        this._private__panes = [];\n        this._private__serieses = [];\n        this._private__width = 0;\n        this._private__hoveredSource = null;\n        this._private__priceScalesOptionsChanged = new Delegate();\n        this._private__crosshairMoved = new Delegate();\n        this._private__gradientColorsCache = null;\n        this._private__invalidateHandler = invalidateHandler;\n        this._private__options = options;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__colorParser = new ColorParser(this._private__options.layout.colorParsers);\n        this._private__rendererOptionsProvider = new PriceAxisRendererOptionsProvider(this);\n        this._private__timeScale = new TimeScale(this, options.timeScale, this._private__options.localization, horzScaleBehavior);\n        this._private__crosshair = new Crosshair(this, options.crosshair);\n        this._private__magnet = new Magnet(options.crosshair);\n        this._private__getOrCreatePane(0);\n        this._private__panes[0]._internal_setStretchFactor(DEFAULT_STRETCH_FACTOR * 2);\n        this._private__backgroundTopColor = this._private__getBackgroundColor(0 /* BackgroundColorSide.Top */);\n        this._private__backgroundBottomColor = this._private__getBackgroundColor(1 /* BackgroundColorSide.Bottom */);\n    }\n    _internal_fullUpdate() {\n        this._private__invalidate(InvalidateMask._internal_full());\n    }\n    _internal_lightUpdate() {\n        this._private__invalidate(InvalidateMask._internal_light());\n    }\n    _internal_cursorUpdate() {\n        this._private__invalidate(new InvalidateMask(1 /* InvalidationLevel.Cursor */));\n    }\n    _internal_updateSource(source) {\n        const inv = this._private__invalidationMaskForSource(source);\n        this._private__invalidate(inv);\n    }\n    _internal_hoveredSource() {\n        return this._private__hoveredSource;\n    }\n    _internal_setHoveredSource(source) {\n        if (this._private__hoveredSource?._internal_source === source?._internal_source && this._private__hoveredSource?._internal_object?._internal_externalId === source?._internal_object?._internal_externalId) {\n            return;\n        }\n        const prevSource = this._private__hoveredSource;\n        this._private__hoveredSource = source;\n        if (prevSource !== null) {\n            this._internal_updateSource(prevSource._internal_source);\n        }\n        // additional check to prevent unnecessary updates of same source\n        if (source !== null && source._internal_source !== prevSource?._internal_source) {\n            this._internal_updateSource(source._internal_source);\n        }\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_applyOptions(options) {\n        merge(this._private__options, options);\n        this._private__panes.forEach((p) => p._internal_applyScaleOptions(options));\n        if (options.timeScale !== undefined) {\n            this._private__timeScale._internal_applyOptions(options.timeScale);\n        }\n        if (options.localization !== undefined) {\n            this._private__timeScale._internal_applyLocalizationOptions(options.localization);\n        }\n        if (options.leftPriceScale || options.rightPriceScale) {\n            this._private__priceScalesOptionsChanged._internal_fire();\n        }\n        this._private__backgroundTopColor = this._private__getBackgroundColor(0 /* BackgroundColorSide.Top */);\n        this._private__backgroundBottomColor = this._private__getBackgroundColor(1 /* BackgroundColorSide.Bottom */);\n        this._internal_fullUpdate();\n    }\n    _internal_applyPriceScaleOptions(priceScaleId, options, paneIndex = 0) {\n        const pane = this._private__panes[paneIndex];\n        if (pane === undefined) {\n            {\n                throw new Error(`Trying to apply price scale options with incorrect pane index: ${paneIndex}`);\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (priceScaleId === \"left\" /* DefaultPriceScaleId.Left */) {\n            merge(this._private__options, {\n                leftPriceScale: options,\n            });\n            pane._internal_applyScaleOptions({\n                leftPriceScale: options,\n            });\n            this._private__priceScalesOptionsChanged._internal_fire();\n            this._internal_fullUpdate();\n            return;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        }\n        else if (priceScaleId === \"right\" /* DefaultPriceScaleId.Right */) {\n            merge(this._private__options, {\n                rightPriceScale: options,\n            });\n            pane._internal_applyScaleOptions({\n                rightPriceScale: options,\n            });\n            this._private__priceScalesOptionsChanged._internal_fire();\n            this._internal_fullUpdate();\n            return;\n        }\n        const res = this._internal_findPriceScale(priceScaleId, paneIndex);\n        if (res === null) {\n            {\n                throw new Error(`Trying to apply price scale options with incorrect ID: ${priceScaleId}`);\n            }\n        }\n        res._internal_priceScale._internal_applyOptions(options);\n        this._private__priceScalesOptionsChanged._internal_fire();\n    }\n    _internal_findPriceScale(priceScaleId, paneIndex) {\n        const pane = this._private__panes[paneIndex];\n        if (pane === undefined) {\n            return null;\n        }\n        const priceScale = pane._internal_priceScaleById(priceScaleId);\n        if (priceScale !== null) {\n            return {\n                _internal_pane: pane,\n                _internal_priceScale: priceScale,\n            };\n        }\n        return null;\n    }\n    _internal_timeScale() {\n        return this._private__timeScale;\n    }\n    _internal_panes() {\n        return this._private__panes;\n    }\n    _internal_crosshairSource() {\n        return this._private__crosshair;\n    }\n    _internal_crosshairMoved() {\n        return this._private__crosshairMoved;\n    }\n    _internal_setPaneHeight(pane, height) {\n        pane._internal_setHeight(height);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_setWidth(width) {\n        this._private__width = width;\n        this._private__timeScale._internal_setWidth(this._private__width);\n        this._private__panes.forEach((pane) => pane._internal_setWidth(width));\n        this._internal_recalculateAllPanes();\n    }\n    _internal_removePane(index) {\n        if (this._private__panes.length === 1) {\n            return;\n        }\n        assert(index >= 0 && index < this._private__panes.length, 'Invalid pane index');\n        this._private__panes.splice(index, 1);\n        this._internal_fullUpdate();\n    }\n    _internal_changePanesHeight(paneIndex, height) {\n        if (this._private__panes.length < 2) {\n            return;\n        }\n        assert(paneIndex >= 0 && paneIndex < this._private__panes.length, 'Invalid pane index');\n        const targetPane = this._private__panes[paneIndex];\n        const totalStretch = this._private__panes.reduce((prevValue, pane) => prevValue + pane._internal_stretchFactor(), 0);\n        const totalHeight = this._private__panes.reduce((prevValue, pane) => prevValue + pane._internal_height(), 0);\n        const maxPaneHeight = totalHeight - MIN_PANE_HEIGHT * (this._private__panes.length - 1);\n        height = Math.min(maxPaneHeight, Math.max(MIN_PANE_HEIGHT, height));\n        const pixelStretchFactor = totalStretch / totalHeight;\n        const oldHeight = targetPane._internal_height();\n        targetPane._internal_setStretchFactor(height * pixelStretchFactor);\n        let otherPanesChange = height - oldHeight;\n        let panesCount = this._private__panes.length - 1;\n        for (const pane of this._private__panes) {\n            if (pane !== targetPane) {\n                const newPaneHeight = Math.min(maxPaneHeight, Math.max(30, pane._internal_height() - otherPanesChange / panesCount));\n                otherPanesChange -= (pane._internal_height() - newPaneHeight);\n                panesCount -= 1;\n                const newStretchFactor = newPaneHeight * pixelStretchFactor;\n                pane._internal_setStretchFactor(newStretchFactor);\n            }\n        }\n        this._internal_fullUpdate();\n    }\n    _internal_swapPanes(first, second) {\n        assert(first >= 0 && first < this._private__panes.length && second >= 0 && second < this._private__panes.length, 'Invalid pane index');\n        const firstPane = this._private__panes[first];\n        const secondPane = this._private__panes[second];\n        this._private__panes[first] = secondPane;\n        this._private__panes[second] = firstPane;\n        this._internal_fullUpdate();\n    }\n    _internal_startScalePrice(pane, priceScale, x) {\n        pane._internal_startScalePrice(priceScale, x);\n    }\n    _internal_scalePriceTo(pane, priceScale, x) {\n        pane._internal_scalePriceTo(priceScale, x);\n        this._internal_updateCrosshair();\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */));\n    }\n    _internal_endScalePrice(pane, priceScale) {\n        pane._internal_endScalePrice(priceScale);\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */));\n    }\n    _internal_startScrollPrice(pane, priceScale, x) {\n        if (priceScale._internal_isAutoScale()) {\n            return;\n        }\n        pane._internal_startScrollPrice(priceScale, x);\n    }\n    _internal_scrollPriceTo(pane, priceScale, x) {\n        if (priceScale._internal_isAutoScale()) {\n            return;\n        }\n        pane._internal_scrollPriceTo(priceScale, x);\n        this._internal_updateCrosshair();\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */));\n    }\n    _internal_endScrollPrice(pane, priceScale) {\n        if (priceScale._internal_isAutoScale()) {\n            return;\n        }\n        pane._internal_endScrollPrice(priceScale);\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */));\n    }\n    _internal_resetPriceScale(pane, priceScale) {\n        pane._internal_resetPriceScale(priceScale);\n        this._private__invalidate(this._private__paneInvalidationMask(pane, 2 /* InvalidationLevel.Light */));\n    }\n    _internal_startScaleTime(position) {\n        this._private__timeScale._internal_startScale(position);\n    }\n    /**\n     * Zoom in/out the chart (depends on scale value).\n     *\n     * @param pointX - X coordinate of the point to apply the zoom (the point which should stay on its place)\n     * @param scale - Zoom value. Negative value means zoom out, positive - zoom in.\n     */\n    _internal_zoomTime(pointX, scale) {\n        const timeScale = this._internal_timeScale();\n        if (timeScale._internal_isEmpty() || scale === 0) {\n            return;\n        }\n        const timeScaleWidth = timeScale._internal_width();\n        pointX = Math.max(1, Math.min(pointX, timeScaleWidth));\n        timeScale._internal_zoom(pointX, scale);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_scrollChart(x) {\n        this._internal_startScrollTime(0);\n        this._internal_scrollTimeTo(x);\n        this._internal_endScrollTime();\n    }\n    _internal_scaleTimeTo(x) {\n        this._private__timeScale._internal_scaleTo(x);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_endScaleTime() {\n        this._private__timeScale._internal_endScale();\n        this._internal_lightUpdate();\n    }\n    _internal_startScrollTime(x) {\n        this._private__timeScale._internal_startScroll(x);\n    }\n    _internal_scrollTimeTo(x) {\n        this._private__timeScale._internal_scrollTo(x);\n        this._internal_recalculateAllPanes();\n    }\n    _internal_endScrollTime() {\n        this._private__timeScale._internal_endScroll();\n        this._internal_lightUpdate();\n    }\n    _internal_serieses() {\n        return this._private__serieses;\n    }\n    _internal_setAndSaveCurrentPosition(x, y, event, pane, skipEvent) {\n        this._private__crosshair._internal_saveOriginCoord(x, y);\n        let price = NaN;\n        let index = this._private__timeScale._internal_coordinateToIndex(x, true);\n        const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n        if (visibleBars !== null) {\n            index = Math.min(Math.max(visibleBars._internal_left(), index), visibleBars._internal_right());\n        }\n        const priceScale = pane._internal_defaultPriceScale();\n        const firstValue = priceScale._internal_firstValue();\n        if (firstValue !== null) {\n            price = priceScale._internal_coordinateToPrice(y, firstValue);\n        }\n        price = this._private__magnet._internal_align(price, index, pane);\n        this._private__crosshair._internal_setPosition(index, price, pane);\n        this._internal_cursorUpdate();\n        if (!skipEvent) {\n            const hitTest = hitTestPane(pane, x, y);\n            this._internal_setHoveredSource(hitTest && { _internal_source: hitTest._internal_source, _internal_object: hitTest._internal_object, _internal_cursorStyle: hitTest._internal_cursorStyle || null });\n            this._private__crosshairMoved._internal_fire(this._private__crosshair._internal_appliedIndex(), { x, y }, event);\n        }\n    }\n    // A position provided external (not from an internal event listener)\n    _internal_setAndSaveSyntheticPosition(price, horizontalPosition, pane) {\n        const priceScale = pane._internal_defaultPriceScale();\n        const firstValue = priceScale._internal_firstValue();\n        const y = priceScale._internal_priceToCoordinate(price, ensureNotNull(firstValue));\n        const index = this._private__timeScale._internal_timeToIndex(horizontalPosition, true);\n        const x = this._private__timeScale._internal_indexToCoordinate(ensureNotNull(index));\n        this._internal_setAndSaveCurrentPosition(x, y, null, pane, true);\n    }\n    _internal_clearCurrentPosition(skipEvent) {\n        const crosshair = this._internal_crosshairSource();\n        crosshair._internal_clearPosition();\n        this._internal_cursorUpdate();\n        if (!skipEvent) {\n            this._private__crosshairMoved._internal_fire(null, null, null);\n        }\n    }\n    _internal_updateCrosshair() {\n        // apply magnet\n        const pane = this._private__crosshair._internal_pane();\n        if (pane !== null) {\n            const x = this._private__crosshair._internal_originCoordX();\n            const y = this._private__crosshair._internal_originCoordY();\n            this._internal_setAndSaveCurrentPosition(x, y, null, pane);\n        }\n        this._private__crosshair._internal_updateAllViews();\n    }\n    _internal_updateTimeScale(newBaseIndex, newPoints, firstChangedPointIndex) {\n        const oldFirstTime = this._private__timeScale._internal_indexToTime(0);\n        if (newPoints !== undefined && firstChangedPointIndex !== undefined) {\n            this._private__timeScale._internal_update(newPoints, firstChangedPointIndex);\n        }\n        const newFirstTime = this._private__timeScale._internal_indexToTime(0);\n        const currentBaseIndex = this._private__timeScale._internal_baseIndex();\n        const visibleBars = this._private__timeScale._internal_visibleStrictRange();\n        // if time scale cannot return current visible bars range (e.g. time scale has zero-width)\n        // then we do not need to update right offset to shift visible bars range to have the same right offset as we have before new bar\n        // (and actually we cannot)\n        if (visibleBars !== null && oldFirstTime !== null && newFirstTime !== null) {\n            const isLastSeriesBarVisible = visibleBars._internal_contains(currentBaseIndex);\n            const isLeftBarShiftToLeft = this._private__horzScaleBehavior.key(oldFirstTime) > this._private__horzScaleBehavior.key(newFirstTime);\n            const isSeriesPointsAdded = newBaseIndex !== null && newBaseIndex > currentBaseIndex;\n            const isSeriesPointsAddedToRight = isSeriesPointsAdded && !isLeftBarShiftToLeft;\n            const allowShiftWhenReplacingWhitespace = this._private__timeScale._internal_options().allowShiftVisibleRangeOnWhitespaceReplacement;\n            const replacedExistingWhitespace = firstChangedPointIndex === undefined;\n            const needShiftVisibleRangeOnNewBar = isLastSeriesBarVisible && (!replacedExistingWhitespace || allowShiftWhenReplacingWhitespace) && this._private__timeScale._internal_options().shiftVisibleRangeOnNewBar;\n            if (isSeriesPointsAddedToRight && !needShiftVisibleRangeOnNewBar) {\n                const compensationShift = newBaseIndex - currentBaseIndex;\n                this._private__timeScale._internal_setRightOffset(this._private__timeScale._internal_rightOffset() - compensationShift);\n            }\n        }\n        this._private__timeScale._internal_setBaseIndex(newBaseIndex);\n    }\n    _internal_recalculatePane(pane) {\n        if (pane !== null) {\n            pane._internal_recalculate();\n        }\n    }\n    _internal_paneForSource(source) {\n        if (isPanePrimitive(source)) {\n            return source;\n        }\n        const pane = this._private__panes.find((p) => p._internal_orderedSources().includes(source));\n        return pane === undefined ? null : pane;\n    }\n    _internal_recalculateAllPanes() {\n        this._private__panes.forEach((p) => p._internal_recalculate());\n        this._internal_updateCrosshair();\n    }\n    _internal_destroy() {\n        this._private__panes.forEach((p) => p._internal_destroy());\n        this._private__panes.length = 0;\n        // to avoid memleaks\n        this._private__options.localization.priceFormatter = undefined;\n        this._private__options.localization.percentageFormatter = undefined;\n        this._private__options.localization.timeFormatter = undefined;\n    }\n    _internal_rendererOptionsProvider() {\n        return this._private__rendererOptionsProvider;\n    }\n    _internal_priceAxisRendererOptions() {\n        return this._private__rendererOptionsProvider._internal_options();\n    }\n    _internal_priceScalesOptionsChanged() {\n        return this._private__priceScalesOptionsChanged;\n    }\n    _internal_addSeriesToPane(series, paneIndex) {\n        const pane = this._private__getOrCreatePane(paneIndex);\n        this._private__addSeriesToPane(series, pane);\n        this._private__serieses.push(series);\n        if (this._private__serieses.length === 1) {\n            // call fullUpdate to recalculate chart's parts geometry\n            this._internal_fullUpdate();\n        }\n        else {\n            this._internal_lightUpdate();\n        }\n    }\n    _internal_removeSeries(series) {\n        const pane = this._internal_paneForSource(series);\n        const seriesIndex = this._private__serieses.indexOf(series);\n        assert(seriesIndex !== -1, 'Series not found');\n        const paneImpl = ensureNotNull(pane);\n        this._private__serieses.splice(seriesIndex, 1);\n        paneImpl._internal_removeDataSource(series);\n        if (series._internal_destroy) {\n            series._internal_destroy();\n        }\n        this._private__timeScale._internal_recalculateIndicesWithData();\n        this._private__cleanupIfPaneIsEmpty(paneImpl);\n    }\n    _internal_moveSeriesToScale(series, targetScaleId) {\n        const pane = ensureNotNull(this._internal_paneForSource(series));\n        pane._internal_removeDataSource(series, true);\n        pane._internal_addDataSource(series, targetScaleId, true);\n    }\n    _internal_fitContent() {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setFitContent();\n        this._private__invalidate(mask);\n    }\n    _internal_setTargetLogicalRange(range) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_applyRange(range);\n        this._private__invalidate(mask);\n    }\n    _internal_resetTimeScale() {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_resetTimeScale();\n        this._private__invalidate(mask);\n    }\n    _internal_setBarSpacing(spacing) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setBarSpacing(spacing);\n        this._private__invalidate(mask);\n    }\n    _internal_setRightOffset(offset) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setRightOffset(offset);\n        this._private__invalidate(mask);\n    }\n    _internal_setTimeScaleAnimation(animation) {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_setTimeScaleAnimation(animation);\n        this._private__invalidate(mask);\n    }\n    _internal_stopTimeScaleAnimation() {\n        const mask = InvalidateMask._internal_light();\n        mask._internal_stopTimeScaleAnimation();\n        this._private__invalidate(mask);\n    }\n    _internal_defaultVisiblePriceScaleId() {\n        return this._private__options.rightPriceScale.visible ? \"right\" /* DefaultPriceScaleId.Right */ : \"left\" /* DefaultPriceScaleId.Left */;\n    }\n    _internal_moveSeriesToPane(series, newPaneIndex) {\n        assert(newPaneIndex >= 0, 'Index should be greater or equal to 0');\n        const fromPaneIndex = this._private__seriesPaneIndex(series);\n        if (newPaneIndex === fromPaneIndex) {\n            return;\n        }\n        const previousPane = ensureNotNull(this._internal_paneForSource(series));\n        previousPane._internal_removeDataSource(series);\n        const newPane = this._private__getOrCreatePane(newPaneIndex);\n        this._private__addSeriesToPane(series, newPane);\n        if (previousPane._internal_dataSources().length === 0) {\n            this._private__cleanupIfPaneIsEmpty(previousPane);\n        }\n    }\n    _internal_backgroundBottomColor() {\n        return this._private__backgroundBottomColor;\n    }\n    _internal_backgroundTopColor() {\n        return this._private__backgroundTopColor;\n    }\n    _internal_backgroundColorAtYPercentFromTop(percent) {\n        const bottomColor = this._private__backgroundBottomColor;\n        const topColor = this._private__backgroundTopColor;\n        if (bottomColor === topColor) {\n            // solid background\n            return bottomColor;\n        }\n        // gradient background\n        // percent should be from 0 to 100 (we're using only integer values to make cache more efficient)\n        percent = Math.max(0, Math.min(100, Math.round(percent * 100)));\n        if (this._private__gradientColorsCache === null ||\n            this._private__gradientColorsCache._internal_topColor !== topColor || this._private__gradientColorsCache._internal_bottomColor !== bottomColor) {\n            this._private__gradientColorsCache = {\n                _internal_topColor: topColor,\n                _internal_bottomColor: bottomColor,\n                _internal_colors: new Map(),\n            };\n        }\n        else {\n            const cachedValue = this._private__gradientColorsCache._internal_colors.get(percent);\n            if (cachedValue !== undefined) {\n                return cachedValue;\n            }\n        }\n        const result = this._private__colorParser._internal_gradientColorAtPercent(topColor, bottomColor, percent / 100);\n        this._private__gradientColorsCache._internal_colors.set(percent, result);\n        return result;\n    }\n    _internal_getPaneIndex(pane) {\n        return this._private__panes.indexOf(pane);\n    }\n    _internal_colorParser() {\n        return this._private__colorParser;\n    }\n    _private__getOrCreatePane(index) {\n        assert(index >= 0, 'Index should be greater or equal to 0');\n        index = Math.min(this._private__panes.length, index);\n        if (index < this._private__panes.length) {\n            return this._private__panes[index];\n        }\n        const pane = new Pane(this._private__timeScale, this);\n        this._private__panes.push(pane);\n        // we always do autoscaling on the creation\n        // if autoscale option is true, it is ok, just recalculate by invalidation mask\n        // if autoscale option is false, autoscale anyway on the first draw\n        // also there is a scenario when autoscale is true in constructor and false later on applyOptions\n        const mask = InvalidateMask._internal_full();\n        mask._internal_invalidatePane(index, {\n            _internal_level: 0 /* InvalidationLevel.None */,\n            _internal_autoScale: true,\n        });\n        this._private__invalidate(mask);\n        return pane;\n    }\n    _private__seriesPaneIndex(series) {\n        return this._private__panes.findIndex((pane) => pane._internal_series().includes(series));\n    }\n    _private__paneInvalidationMask(pane, level) {\n        const inv = new InvalidateMask(level);\n        if (pane !== null) {\n            const index = this._private__panes.indexOf(pane);\n            inv._internal_invalidatePane(index, {\n                _internal_level: level,\n            });\n        }\n        return inv;\n    }\n    _private__invalidationMaskForSource(source, invalidateType) {\n        if (invalidateType === undefined) {\n            invalidateType = 2 /* InvalidationLevel.Light */;\n        }\n        return this._private__paneInvalidationMask(this._internal_paneForSource(source), invalidateType);\n    }\n    _private__invalidate(mask) {\n        if (this._private__invalidateHandler) {\n            this._private__invalidateHandler(mask);\n        }\n        this._private__panes.forEach((pane) => pane._internal_grid()._internal_paneView()._internal_update());\n    }\n    _private__addSeriesToPane(series, pane) {\n        const priceScaleId = series._internal_options().priceScaleId;\n        const targetScaleId = priceScaleId !== undefined ? priceScaleId : this._internal_defaultVisiblePriceScaleId();\n        pane._internal_addDataSource(series, targetScaleId);\n        if (!isDefaultPriceScale(targetScaleId)) {\n            // let's apply that options again to apply margins\n            series._internal_applyOptions(series._internal_options());\n        }\n    }\n    _private__getBackgroundColor(side) {\n        const layoutOptions = this._private__options['layout'];\n        if (layoutOptions.background.type === \"gradient\" /* ColorType.VerticalGradient */) {\n            return side === 0 /* BackgroundColorSide.Top */ ?\n                layoutOptions.background.topColor :\n                layoutOptions.background.bottomColor;\n        }\n        return layoutOptions.background.color;\n    }\n    _private__cleanupIfPaneIsEmpty(pane) {\n        if (pane._internal_dataSources().length === 0 && this._private__panes.length > 1) {\n            this._private__panes.splice(this._internal_getPaneIndex(pane), 1);\n            this._internal_fullUpdate();\n        }\n    }\n}\n\nfunction fillUpDownCandlesticksColors(options) {\n    if (options.borderColor !== undefined) {\n        options.borderUpColor = options.borderColor;\n        options.borderDownColor = options.borderColor;\n    }\n    if (options.wickColor !== undefined) {\n        options.wickUpColor = options.wickColor;\n        options.wickDownColor = options.wickColor;\n    }\n}\n/**\n * Represents the type of the last price animation for series such as area or line.\n */\nvar LastPriceAnimationMode;\n(function (LastPriceAnimationMode) {\n    /**\n     * Animation is always disabled\n     */\n    LastPriceAnimationMode[LastPriceAnimationMode[\"Disabled\"] = 0] = \"Disabled\";\n    /**\n     * Animation is always enabled.\n     */\n    LastPriceAnimationMode[LastPriceAnimationMode[\"Continuous\"] = 1] = \"Continuous\";\n    /**\n     * Animation is active after new data.\n     */\n    LastPriceAnimationMode[LastPriceAnimationMode[\"OnDataUpdate\"] = 2] = \"OnDataUpdate\";\n})(LastPriceAnimationMode || (LastPriceAnimationMode = {}));\nfunction precisionByMinMove(minMove) {\n    if (minMove >= 1) {\n        return 0;\n    }\n    let i = 0;\n    for (; i < 8; i++) {\n        const intPart = Math.round(minMove);\n        const fractPart = Math.abs(intPart - minMove);\n        if (fractPart < 1e-8) {\n            return i;\n        }\n        minMove = minMove * 10;\n    }\n    return i;\n}\n/**\n * Represents the source of data to be used for the horizontal price line.\n */\nvar PriceLineSource;\n(function (PriceLineSource) {\n    /**\n     * Use the last bar data.\n     */\n    PriceLineSource[PriceLineSource[\"LastBar\"] = 0] = \"LastBar\";\n    /**\n     * Use the last visible data of the chart viewport.\n     */\n    PriceLineSource[PriceLineSource[\"LastVisible\"] = 1] = \"LastVisible\";\n})(PriceLineSource || (PriceLineSource = {}));\n\n/**\n * Represents a type of color.\n */\nvar ColorType;\n(function (ColorType) {\n    /** Solid color */\n    ColorType[\"Solid\"] = \"solid\";\n    /** Vertical gradient color */\n    ColorType[\"VerticalGradient\"] = \"gradient\";\n})(ColorType || (ColorType = {}));\n\n/**\n * Check if a time value is a business day object.\n *\n * @param time - The time to check.\n * @returns `true` if `time` is a {@link BusinessDay} object, false otherwise.\n */\nfunction isBusinessDay(time) {\n    return !isNumber(time) && !isString(time);\n}\n/**\n * Check if a time value is a UTC timestamp number.\n *\n * @param time - The time to check.\n * @returns `true` if `time` is a {@link UTCTimestamp} number, false otherwise.\n */\nfunction isUTCTimestamp(time) {\n    return isNumber(time);\n}\n/**\n * Represents the type of a tick mark on the time axis.\n */\nvar TickMarkType;\n(function (TickMarkType) {\n    /**\n     * The start of the year (e.g. it's the first tick mark in a year).\n     */\n    TickMarkType[TickMarkType[\"Year\"] = 0] = \"Year\";\n    /**\n     * The start of the month (e.g. it's the first tick mark in a month).\n     */\n    TickMarkType[TickMarkType[\"Month\"] = 1] = \"Month\";\n    /**\n     * A day of the month.\n     */\n    TickMarkType[TickMarkType[\"DayOfMonth\"] = 2] = \"DayOfMonth\";\n    /**\n     * A time without seconds.\n     */\n    TickMarkType[TickMarkType[\"Time\"] = 3] = \"Time\";\n    /**\n     * A time with seconds.\n     */\n    TickMarkType[TickMarkType[\"TimeWithSeconds\"] = 4] = \"TimeWithSeconds\";\n})(TickMarkType || (TickMarkType = {}));\n\nconst getMonth = (date) => date.getUTCMonth() + 1;\nconst getDay = (date) => date.getUTCDate();\nconst getYear = (date) => date.getUTCFullYear();\nconst dd = (date) => numberToStringWithLeadingZero(getDay(date), 2);\nconst MMMM = (date, locale) => new Date(date.getUTCFullYear(), date.getUTCMonth(), 1)\n    .toLocaleString(locale, { month: 'long' });\nconst MMM = (date, locale) => new Date(date.getUTCFullYear(), date.getUTCMonth(), 1)\n    .toLocaleString(locale, { month: 'short' });\nconst MM = (date) => numberToStringWithLeadingZero(getMonth(date), 2);\nconst yy = (date) => numberToStringWithLeadingZero(getYear(date) % 100, 2);\nconst yyyy = (date) => numberToStringWithLeadingZero(getYear(date), 4);\nfunction formatDate(date, format, locale) {\n    return format\n        .replace(/yyyy/g, yyyy(date))\n        .replace(/yy/g, yy(date))\n        .replace(/MMMM/g, MMMM(date, locale))\n        .replace(/MMM/g, MMM(date, locale))\n        .replace(/MM/g, MM(date))\n        .replace(/dd/g, dd(date));\n}\n\nclass DateFormatter {\n    constructor(dateFormat = 'yyyy-MM-dd', locale = 'default') {\n        this._private__dateFormat = dateFormat;\n        this._private__locale = locale;\n    }\n    _internal_format(date) {\n        return formatDate(date, this._private__dateFormat, this._private__locale);\n    }\n}\n\nclass TimeFormatter {\n    constructor(format) {\n        this._private__formatStr = format || '%h:%m:%s';\n    }\n    _internal_format(date) {\n        return this._private__formatStr.replace('%h', numberToStringWithLeadingZero(date.getUTCHours(), 2)).\n            replace('%m', numberToStringWithLeadingZero(date.getUTCMinutes(), 2)).\n            replace('%s', numberToStringWithLeadingZero(date.getUTCSeconds(), 2));\n    }\n}\n\nconst defaultParams = {\n    _internal_dateFormat: 'yyyy-MM-dd',\n    _internal_timeFormat: '%h:%m:%s',\n    _internal_dateTimeSeparator: ' ',\n    _internal_locale: 'default',\n};\nclass DateTimeFormatter {\n    constructor(params = {}) {\n        const formatterParams = { ...defaultParams, ...params };\n        this._private__dateFormatter = new DateFormatter(formatterParams._internal_dateFormat, formatterParams._internal_locale);\n        this._private__timeFormatter = new TimeFormatter(formatterParams._internal_timeFormat);\n        this._private__separator = formatterParams._internal_dateTimeSeparator;\n    }\n    _internal_format(dateTime) {\n        return `${this._private__dateFormatter._internal_format(dateTime)}${this._private__separator}${this._private__timeFormatter._internal_format(dateTime)}`;\n    }\n}\n\nfunction defaultTickMarkFormatter(timePoint, tickMarkType, locale) {\n    const formatOptions = {};\n    switch (tickMarkType) {\n        case 0 /* TickMarkType.Year */:\n            formatOptions.year = 'numeric';\n            break;\n        case 1 /* TickMarkType.Month */:\n            formatOptions.month = 'short';\n            break;\n        case 2 /* TickMarkType.DayOfMonth */:\n            formatOptions.day = 'numeric';\n            break;\n        case 3 /* TickMarkType.Time */:\n            formatOptions.hour12 = false;\n            formatOptions.hour = '2-digit';\n            formatOptions.minute = '2-digit';\n            break;\n        case 4 /* TickMarkType.TimeWithSeconds */:\n            formatOptions.hour12 = false;\n            formatOptions.hour = '2-digit';\n            formatOptions.minute = '2-digit';\n            formatOptions.second = '2-digit';\n            break;\n    }\n    const date = timePoint._internal_businessDay === undefined\n        ? new Date(timePoint._internal_timestamp * 1000)\n        : new Date(Date.UTC(timePoint._internal_businessDay.year, timePoint._internal_businessDay.month - 1, timePoint._internal_businessDay.day));\n    // from given date we should use only as UTC date or timestamp\n    // but to format as locale date we can convert UTC date to local date\n    const localDateFromUtc = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());\n    return localDateFromUtc.toLocaleString(locale, formatOptions);\n}\n\nfunction hours(count) {\n    return count * 60 * 60 * 1000;\n}\nfunction minutes(count) {\n    return count * 60 * 1000;\n}\nfunction seconds(count) {\n    return count * 1000;\n}\nconst intradayWeightDivisors = [\n    { _internal_divisor: seconds(1), _internal_weight: 10 /* TickMarkWeight.Second */ },\n    { _internal_divisor: minutes(1), _internal_weight: 20 /* TickMarkWeight.Minute1 */ },\n    { _internal_divisor: minutes(5), _internal_weight: 21 /* TickMarkWeight.Minute5 */ },\n    { _internal_divisor: minutes(30), _internal_weight: 22 /* TickMarkWeight.Minute30 */ },\n    { _internal_divisor: hours(1), _internal_weight: 30 /* TickMarkWeight.Hour1 */ },\n    { _internal_divisor: hours(3), _internal_weight: 31 /* TickMarkWeight.Hour3 */ },\n    { _internal_divisor: hours(6), _internal_weight: 32 /* TickMarkWeight.Hour6 */ },\n    { _internal_divisor: hours(12), _internal_weight: 33 /* TickMarkWeight.Hour12 */ },\n];\nfunction weightByTime(currentDate, prevDate) {\n    if (currentDate.getUTCFullYear() !== prevDate.getUTCFullYear()) {\n        return 70 /* TickMarkWeight.Year */;\n    }\n    else if (currentDate.getUTCMonth() !== prevDate.getUTCMonth()) {\n        return 60 /* TickMarkWeight.Month */;\n    }\n    else if (currentDate.getUTCDate() !== prevDate.getUTCDate()) {\n        return 50 /* TickMarkWeight.Day */;\n    }\n    for (let i = intradayWeightDivisors.length - 1; i >= 0; --i) {\n        if (Math.floor(prevDate.getTime() / intradayWeightDivisors[i]._internal_divisor) !== Math.floor(currentDate.getTime() / intradayWeightDivisors[i]._internal_divisor)) {\n            return intradayWeightDivisors[i]._internal_weight;\n        }\n    }\n    return 0 /* TickMarkWeight.LessThanSecond */;\n}\nfunction cast(t) {\n    return t;\n}\nfunction fillWeightsForPoints(sortedTimePoints, startIndex = 0) {\n    if (sortedTimePoints.length === 0) {\n        return;\n    }\n    let prevTime = startIndex === 0 ? null : cast(sortedTimePoints[startIndex - 1].time)._internal_timestamp;\n    let prevDate = prevTime !== null ? new Date(prevTime * 1000) : null;\n    let totalTimeDiff = 0;\n    for (let index = startIndex; index < sortedTimePoints.length; ++index) {\n        const currentPoint = sortedTimePoints[index];\n        const currentDate = new Date(cast(currentPoint.time)._internal_timestamp * 1000);\n        if (prevDate !== null) {\n            currentPoint.timeWeight = weightByTime(currentDate, prevDate);\n        }\n        totalTimeDiff += cast(currentPoint.time)._internal_timestamp - (prevTime || cast(currentPoint.time)._internal_timestamp);\n        prevTime = cast(currentPoint.time)._internal_timestamp;\n        prevDate = currentDate;\n    }\n    if (startIndex === 0 && sortedTimePoints.length > 1) {\n        // let's guess a weight for the first point\n        // let's say the previous point was average time back in the history\n        const averageTimeDiff = Math.ceil(totalTimeDiff / (sortedTimePoints.length - 1));\n        const approxPrevDate = new Date((cast(sortedTimePoints[0].time)._internal_timestamp - averageTimeDiff) * 1000);\n        sortedTimePoints[0].timeWeight = weightByTime(new Date(cast(sortedTimePoints[0].time)._internal_timestamp * 1000), approxPrevDate);\n    }\n}\n\nfunction businessDayConverter(time) {\n    let businessDay = time;\n    if (isString(time)) {\n        businessDay = stringToBusinessDay(time);\n    }\n    if (!isBusinessDay(businessDay)) {\n        throw new Error('time must be of type BusinessDay');\n    }\n    const date = new Date(Date.UTC(businessDay.year, businessDay.month - 1, businessDay.day, 0, 0, 0, 0));\n    return {\n        _internal_timestamp: Math.round(date.getTime() / 1000),\n        _internal_businessDay: businessDay,\n    };\n}\nfunction timestampConverter(time) {\n    if (!isUTCTimestamp(time)) {\n        throw new Error('time must be of type isUTCTimestamp');\n    }\n    return {\n        _internal_timestamp: time,\n    };\n}\nfunction selectTimeConverter(data) {\n    if (data.length === 0) {\n        return null;\n    }\n    if (isBusinessDay(data[0].time) || isString(data[0].time)) {\n        return businessDayConverter;\n    }\n    return timestampConverter;\n}\nconst validDateRegex = /^\\d\\d\\d\\d-\\d\\d-\\d\\d$/;\nfunction convertTime(time) {\n    if (isUTCTimestamp(time)) {\n        return timestampConverter(time);\n    }\n    if (!isBusinessDay(time)) {\n        return businessDayConverter(stringToBusinessDay(time));\n    }\n    return businessDayConverter(time);\n}\nfunction stringToBusinessDay(value) {\n    {\n        // in some browsers (I look at your Chrome) the Date constructor may accept invalid date string\n        // but parses them in 'implementation specific' way\n        // for example 2019-1-1 isn't the same as 2019-01-01 (for Chrome both are 'valid' date strings)\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=968939\n        // so, we need to be sure that date has valid format to avoid strange behavior and hours of debugging\n        // but let's do this in development build only because of perf\n        if (!validDateRegex.test(value)) {\n            throw new Error(`Invalid date string=${value}, expected format=yyyy-mm-dd`);\n        }\n    }\n    const d = new Date(value);\n    if (isNaN(d.getTime())) {\n        throw new Error(`Invalid date string=${value}, expected format=yyyy-mm-dd`);\n    }\n    return {\n        day: d.getUTCDate(),\n        month: d.getUTCMonth() + 1,\n        year: d.getUTCFullYear(),\n    };\n}\nfunction convertStringToBusinessDay(value) {\n    if (isString(value.time)) {\n        value.time = stringToBusinessDay(value.time);\n    }\n}\nfunction convertStringsToBusinessDays(data) {\n    return data.forEach(convertStringToBusinessDay);\n}\n\n// eslint-disable-next-line complexity\nfunction weightToTickMarkType(weight, timeVisible, secondsVisible) {\n    switch (weight) {\n        case 0 /* TickMarkWeight.LessThanSecond */:\n        case 10 /* TickMarkWeight.Second */:\n            return timeVisible\n                ? (secondsVisible ? 4 /* TickMarkType.TimeWithSeconds */ : 3 /* TickMarkType.Time */)\n                : 2 /* TickMarkType.DayOfMonth */;\n        case 20 /* TickMarkWeight.Minute1 */:\n        case 21 /* TickMarkWeight.Minute5 */:\n        case 22 /* TickMarkWeight.Minute30 */:\n        case 30 /* TickMarkWeight.Hour1 */:\n        case 31 /* TickMarkWeight.Hour3 */:\n        case 32 /* TickMarkWeight.Hour6 */:\n        case 33 /* TickMarkWeight.Hour12 */:\n            return timeVisible ? 3 /* TickMarkType.Time */ : 2 /* TickMarkType.DayOfMonth */;\n        case 50 /* TickMarkWeight.Day */:\n            return 2 /* TickMarkType.DayOfMonth */;\n        case 60 /* TickMarkWeight.Month */:\n            return 1 /* TickMarkType.Month */;\n        case 70 /* TickMarkWeight.Year */:\n            return 0 /* TickMarkType.Year */;\n    }\n}\nclass HorzScaleBehaviorTime {\n    options() {\n        return this._private__options;\n    }\n    setOptions(options) {\n        this._private__options = options;\n        this.updateFormatter(options.localization);\n    }\n    preprocessData(data) {\n        if (Array.isArray(data)) {\n            convertStringsToBusinessDays(data);\n        }\n        else {\n            convertStringToBusinessDay(data);\n        }\n    }\n    createConverterToInternalObj(data) {\n        return ensureNotNull(selectTimeConverter(data));\n    }\n    key(item) {\n        // eslint-disable-next-line no-restricted-syntax\n        if (typeof item === 'object' && \"_internal_timestamp\" in item) {\n            return item._internal_timestamp;\n        }\n        else {\n            return this.key(this.convertHorzItemToInternal(item));\n        }\n    }\n    cacheKey(item) {\n        const time = item;\n        return time._internal_businessDay === undefined\n            ? new Date(time._internal_timestamp * 1000).getTime()\n            : new Date(Date.UTC(time._internal_businessDay.year, time._internal_businessDay.month - 1, time._internal_businessDay.day)).getTime();\n    }\n    convertHorzItemToInternal(item) {\n        return convertTime(item);\n    }\n    updateFormatter(options) {\n        if (!this._private__options) {\n            return;\n        }\n        const dateFormat = options.dateFormat;\n        if (this._private__options.timeScale.timeVisible) {\n            this._private__dateTimeFormatter = new DateTimeFormatter({\n                _internal_dateFormat: dateFormat,\n                _internal_timeFormat: this._private__options.timeScale.secondsVisible ? '%h:%m:%s' : '%h:%m',\n                _internal_dateTimeSeparator: '   ',\n                _internal_locale: options.locale,\n            });\n        }\n        else {\n            this._private__dateTimeFormatter = new DateFormatter(dateFormat, options.locale);\n        }\n    }\n    formatHorzItem(item) {\n        const tp = item;\n        return this._private__dateTimeFormatter._internal_format(new Date(tp._internal_timestamp * 1000));\n    }\n    formatTickmark(tickMark, localizationOptions) {\n        const tickMarkType = weightToTickMarkType(tickMark.weight, this._private__options.timeScale.timeVisible, this._private__options.timeScale.secondsVisible);\n        const options = this._private__options.timeScale;\n        if (options.tickMarkFormatter !== undefined) {\n            const tickMarkString = options.tickMarkFormatter(tickMark.originalTime, tickMarkType, localizationOptions.locale);\n            if (tickMarkString !== null) {\n                return tickMarkString;\n            }\n        }\n        return defaultTickMarkFormatter(tickMark.time, tickMarkType, localizationOptions.locale);\n    }\n    maxTickMarkWeight(tickMarks) {\n        let maxWeight = tickMarks.reduce(markWithGreaterWeight$2, tickMarks[0]).weight;\n        // special case: it looks strange if 15:00 is bold but 14:00 is not\n        // so if maxWeight > TickMarkWeight.Hour1 and < TickMarkWeight.Day reduce it to TickMarkWeight.Hour1\n        if (maxWeight > 30 /* TickMarkWeight.Hour1 */ && maxWeight < 50 /* TickMarkWeight.Day */) {\n            maxWeight = 30 /* TickMarkWeight.Hour1 */;\n        }\n        return maxWeight;\n    }\n    fillWeightsForPoints(sortedTimePoints, startIndex) {\n        fillWeightsForPoints(sortedTimePoints, startIndex);\n    }\n    static _internal_applyDefaults(options) {\n        return merge({ localization: { dateFormat: 'dd MMM \\'yy' } }, options ?? {});\n    }\n}\n\n/**\n * When you're trying to use the library in server-side context (for instance in SSR)\n * you don't have some browser-specific variables like navigator or window\n * and if the library will use them on the top level of the library\n * the import will fail due ReferenceError\n * thus, this allows use the navigator on the top level and being imported in server-side context as well\n * See issue #446\n */\n// eslint-disable-next-line @typescript-eslint/tslint/config\nconst isRunningOnClientSide = typeof window !== 'undefined';\n\nfunction isFF() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    return window.navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n}\nfunction isIOS() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    return /iPhone|iPad|iPod/.test(window.navigator.platform);\n}\nfunction isChrome() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    return window.chrome !== undefined;\n}\n// Determine whether the browser is running on windows.\nfunction isWindows() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    // more accurate if available\n    if (navigator?.userAgentData?.platform) {\n        return navigator.userAgentData.platform === 'Windows';\n    }\n    return navigator.userAgent.toLowerCase().indexOf('win') >= 0;\n}\n// Determine whether the browser is Chromium based.\nfunction isChromiumBased() {\n    if (!isRunningOnClientSide) {\n        return false;\n    }\n    if (!navigator.userAgentData) {\n        return false;\n    }\n    return navigator.userAgentData.brands.some((brand) => {\n        return brand.brand.includes('Chromium');\n    });\n}\n\n/// <reference types=\"_build-time-constants\" />\nfunction warn(msg) {\n    {\n        // eslint-disable-next-line no-console\n        console.warn(msg);\n    }\n}\n\n// on Hi-DPI CSS size * Device Pixel Ratio should be integer to avoid smoothing\n// For chart widget we decrease the size because we must be inside container.\n// For time axis this is not important, since it just affects space for pane widgets\nfunction suggestChartSize(originalSize) {\n    const integerWidth = Math.floor(originalSize.width);\n    const integerHeight = Math.floor(originalSize.height);\n    const width = integerWidth - (integerWidth % 2);\n    const height = integerHeight - (integerHeight % 2);\n    return (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width, height });\n}\nfunction suggestTimeScaleHeight(originalHeight) {\n    return originalHeight + (originalHeight % 2);\n}\nfunction suggestPriceScaleWidth(originalWidth) {\n    return originalWidth + (originalWidth % 2);\n}\n\nfunction preventScrollByWheelClick(el) {\n    if (!isChrome()) {\n        return;\n    }\n    el.addEventListener('mousedown', (e) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (e.button === 1 /* MouseEventButton.Middle */) {\n            // prevent incorrect scrolling event\n            e.preventDefault();\n            return false;\n        }\n        return undefined;\n    });\n}\n\n// TODO: get rid of a lot of boolean flags, probably we should replace it with some enum\nclass MouseEventHandler {\n    constructor(target, handler, options) {\n        this._private__clickCount = 0;\n        this._private__clickTimeoutId = null;\n        this._private__clickPosition = { _internal_x: Number.NEGATIVE_INFINITY, _internal_y: Number.POSITIVE_INFINITY };\n        this._private__tapCount = 0;\n        this._private__tapTimeoutId = null;\n        this._private__tapPosition = { _internal_x: Number.NEGATIVE_INFINITY, _internal_y: Number.POSITIVE_INFINITY };\n        this._private__longTapTimeoutId = null;\n        this._private__longTapActive = false;\n        this._private__mouseMoveStartPosition = null;\n        this._private__touchMoveStartPosition = null;\n        this._private__touchMoveExceededManhattanDistance = false;\n        this._private__cancelClick = false;\n        this._private__cancelTap = false;\n        this._private__unsubscribeOutsideMouseEvents = null;\n        this._private__unsubscribeOutsideTouchEvents = null;\n        this._private__unsubscribeMobileSafariEvents = null;\n        this._private__unsubscribeMousemove = null;\n        this._private__unsubscribeRootMouseEvents = null;\n        this._private__unsubscribeRootTouchEvents = null;\n        this._private__startPinchMiddlePoint = null;\n        this._private__startPinchDistance = 0;\n        this._private__pinchPrevented = false;\n        this._private__preventTouchDragProcess = false;\n        this._private__mousePressed = false;\n        this._private__lastTouchEventTimeStamp = 0;\n        // for touchstart/touchmove/touchend events we handle only first touch\n        // i.e. we don't support several active touches at the same time (except pinch event)\n        this._private__activeTouchId = null;\n        // accept all mouse leave events if it's not an iOS device\n        // see _mouseEnterHandler, _mouseMoveHandler, _mouseLeaveHandler\n        this._private__acceptMouseLeave = !isIOS();\n        /**\n         * In Firefox mouse events dont't fire if the mouse position is outside of the browser's border.\n         * To prevent the mouse from hanging while pressed we're subscribing on the mouseleave event of the document element.\n         * We're subscribing on mouseleave, but this event is actually fired on mouseup outside of the browser's border.\n         */\n        this._private__onFirefoxOutsideMouseUp = (mouseUpEvent) => {\n            this._private__mouseUpHandler(mouseUpEvent);\n        };\n        /**\n         * Safari doesn't fire touchstart/mousedown events on double tap since iOS 13.\n         * There are two possible solutions:\n         * 1) Call preventDefault in touchEnd handler. But it also prevents click event from firing.\n         * 2) Add listener on dblclick event that fires with the preceding mousedown/mouseup.\n         * https://developer.apple.com/forums/thread/125073\n         */\n        this._private__onMobileSafariDoubleClick = (dblClickEvent) => {\n            if (this._private__firesTouchEvents(dblClickEvent)) {\n                const compatEvent = this._private__makeCompatEvent(dblClickEvent);\n                ++this._private__tapCount;\n                if (this._private__tapTimeoutId && this._private__tapCount > 1) {\n                    const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(dblClickEvent), this._private__tapPosition);\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n                    if (manhattanDistance < 30 /* Constants.DoubleTapManhattanDistance */ && !this._private__cancelTap) {\n                        this._private__processTouchEvent(compatEvent, this._private__handler._internal_doubleTapEvent);\n                    }\n                    this._private__resetTapTimeout();\n                }\n            }\n            else {\n                const compatEvent = this._private__makeCompatEvent(dblClickEvent);\n                ++this._private__clickCount;\n                if (this._private__clickTimeoutId && this._private__clickCount > 1) {\n                    const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(dblClickEvent), this._private__clickPosition);\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n                    if (manhattanDistance < 5 /* Constants.DoubleClickManhattanDistance */ && !this._private__cancelClick) {\n                        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseDoubleClickEvent);\n                    }\n                    this._private__resetClickTimeout();\n                }\n            }\n        };\n        this._private__target = target;\n        this._private__handler = handler;\n        this._private__options = options;\n        this._private__init();\n    }\n    _internal_destroy() {\n        if (this._private__unsubscribeOutsideMouseEvents !== null) {\n            this._private__unsubscribeOutsideMouseEvents();\n            this._private__unsubscribeOutsideMouseEvents = null;\n        }\n        if (this._private__unsubscribeOutsideTouchEvents !== null) {\n            this._private__unsubscribeOutsideTouchEvents();\n            this._private__unsubscribeOutsideTouchEvents = null;\n        }\n        if (this._private__unsubscribeMousemove !== null) {\n            this._private__unsubscribeMousemove();\n            this._private__unsubscribeMousemove = null;\n        }\n        if (this._private__unsubscribeRootMouseEvents !== null) {\n            this._private__unsubscribeRootMouseEvents();\n            this._private__unsubscribeRootMouseEvents = null;\n        }\n        if (this._private__unsubscribeRootTouchEvents !== null) {\n            this._private__unsubscribeRootTouchEvents();\n            this._private__unsubscribeRootTouchEvents = null;\n        }\n        if (this._private__unsubscribeMobileSafariEvents !== null) {\n            this._private__unsubscribeMobileSafariEvents();\n            this._private__unsubscribeMobileSafariEvents = null;\n        }\n        this._private__clearLongTapTimeout();\n        this._private__resetClickTimeout();\n    }\n    _private__mouseEnterHandler(enterEvent) {\n        if (this._private__unsubscribeMousemove) {\n            this._private__unsubscribeMousemove();\n        }\n        const boundMouseMoveHandler = this._private__mouseMoveHandler.bind(this);\n        this._private__unsubscribeMousemove = () => {\n            this._private__target.removeEventListener('mousemove', boundMouseMoveHandler);\n        };\n        this._private__target.addEventListener('mousemove', boundMouseMoveHandler);\n        if (this._private__firesTouchEvents(enterEvent)) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(enterEvent);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseEnterEvent);\n        this._private__acceptMouseLeave = true;\n    }\n    _private__resetClickTimeout() {\n        if (this._private__clickTimeoutId !== null) {\n            clearTimeout(this._private__clickTimeoutId);\n        }\n        this._private__clickCount = 0;\n        this._private__clickTimeoutId = null;\n        this._private__clickPosition = { _internal_x: Number.NEGATIVE_INFINITY, _internal_y: Number.POSITIVE_INFINITY };\n    }\n    _private__resetTapTimeout() {\n        if (this._private__tapTimeoutId !== null) {\n            clearTimeout(this._private__tapTimeoutId);\n        }\n        this._private__tapCount = 0;\n        this._private__tapTimeoutId = null;\n        this._private__tapPosition = { _internal_x: Number.NEGATIVE_INFINITY, _internal_y: Number.POSITIVE_INFINITY };\n    }\n    _private__mouseMoveHandler(moveEvent) {\n        if (this._private__mousePressed || this._private__touchMoveStartPosition !== null) {\n            return;\n        }\n        if (this._private__firesTouchEvents(moveEvent)) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(moveEvent);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseMoveEvent);\n        this._private__acceptMouseLeave = true;\n    }\n    _private__touchMoveHandler(moveEvent) {\n        const touch = touchWithId(moveEvent.changedTouches, ensureNotNull(this._private__activeTouchId));\n        if (touch === null) {\n            return;\n        }\n        this._private__lastTouchEventTimeStamp = eventTimeStamp(moveEvent);\n        if (this._private__startPinchMiddlePoint !== null) {\n            return;\n        }\n        if (this._private__preventTouchDragProcess) {\n            return;\n        }\n        // prevent pinch if move event comes faster than the second touch\n        this._private__pinchPrevented = true;\n        const moveInfo = this._private__touchMouseMoveWithDownInfo(getPosition(touch), ensureNotNull(this._private__touchMoveStartPosition));\n        const { _internal_xOffset: xOffset, _internal_yOffset: yOffset, _internal_manhattanDistance: manhattanDistance } = moveInfo;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (!this._private__touchMoveExceededManhattanDistance && manhattanDistance < 5 /* Constants.CancelTapManhattanDistance */) {\n            return;\n        }\n        if (!this._private__touchMoveExceededManhattanDistance) {\n            // first time when current position exceeded manhattan distance\n            // vertical drag is more important than horizontal drag\n            // because we scroll the page vertically often than horizontally\n            const correctedXOffset = xOffset * 0.5;\n            // a drag can be only if touch page scroll isn't allowed\n            const isVertDrag = yOffset >= correctedXOffset && !this._private__options._internal_treatVertTouchDragAsPageScroll();\n            const isHorzDrag = correctedXOffset > yOffset && !this._private__options._internal_treatHorzTouchDragAsPageScroll();\n            // if drag event happened then we should revert preventDefault state to original one\n            // and try to process the drag event\n            // else we shouldn't prevent default of the event and ignore processing the drag event\n            if (!isVertDrag && !isHorzDrag) {\n                this._private__preventTouchDragProcess = true;\n            }\n            this._private__touchMoveExceededManhattanDistance = true;\n            // if manhattan distance is more that 5 - we should cancel tap event\n            this._private__cancelTap = true;\n            this._private__clearLongTapTimeout();\n            this._private__resetTapTimeout();\n        }\n        if (!this._private__preventTouchDragProcess) {\n            const compatEvent = this._private__makeCompatEvent(moveEvent, touch);\n            this._private__processTouchEvent(compatEvent, this._private__handler._internal_touchMoveEvent);\n            // we should prevent default in case of touch only\n            // to prevent scroll of the page\n            preventDefault(moveEvent);\n        }\n    }\n    _private__mouseMoveWithDownHandler(moveEvent) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (moveEvent.button !== 0 /* MouseEventButton.Left */) {\n            return;\n        }\n        const moveInfo = this._private__touchMouseMoveWithDownInfo(getPosition(moveEvent), ensureNotNull(this._private__mouseMoveStartPosition));\n        const { _internal_manhattanDistance: manhattanDistance } = moveInfo;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (manhattanDistance >= 5 /* Constants.CancelClickManhattanDistance */) {\n            // if manhattan distance is more that 5 - we should cancel click event\n            this._private__cancelClick = true;\n            this._private__resetClickTimeout();\n        }\n        if (this._private__cancelClick) {\n            // if this._cancelClick is true, that means that minimum manhattan distance is already exceeded\n            const compatEvent = this._private__makeCompatEvent(moveEvent);\n            this._private__processMouseEvent(compatEvent, this._private__handler._internal_pressedMouseMoveEvent);\n        }\n    }\n    _private__touchMouseMoveWithDownInfo(currentPosition, startPosition) {\n        const xOffset = Math.abs(startPosition._internal_x - currentPosition._internal_x);\n        const yOffset = Math.abs(startPosition._internal_y - currentPosition._internal_y);\n        const manhattanDistance = xOffset + yOffset;\n        return {\n            _internal_xOffset: xOffset,\n            _internal_yOffset: yOffset,\n            _internal_manhattanDistance: manhattanDistance,\n        };\n    }\n    // eslint-disable-next-line complexity\n    _private__touchEndHandler(touchEndEvent) {\n        let touch = touchWithId(touchEndEvent.changedTouches, ensureNotNull(this._private__activeTouchId));\n        if (touch === null && touchEndEvent.touches.length === 0) {\n            // something went wrong, somehow we missed the required touchend event\n            // probably the browser has not sent this event\n            touch = touchEndEvent.changedTouches[0];\n        }\n        if (touch === null) {\n            return;\n        }\n        this._private__activeTouchId = null;\n        this._private__lastTouchEventTimeStamp = eventTimeStamp(touchEndEvent);\n        this._private__clearLongTapTimeout();\n        this._private__touchMoveStartPosition = null;\n        if (this._private__unsubscribeRootTouchEvents) {\n            this._private__unsubscribeRootTouchEvents();\n            this._private__unsubscribeRootTouchEvents = null;\n        }\n        const compatEvent = this._private__makeCompatEvent(touchEndEvent, touch);\n        this._private__processTouchEvent(compatEvent, this._private__handler._internal_touchEndEvent);\n        ++this._private__tapCount;\n        if (this._private__tapTimeoutId && this._private__tapCount > 1) {\n            // check that both clicks are near enough\n            const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(touch), this._private__tapPosition);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n            if (manhattanDistance < 30 /* Constants.DoubleTapManhattanDistance */ && !this._private__cancelTap) {\n                this._private__processTouchEvent(compatEvent, this._private__handler._internal_doubleTapEvent);\n            }\n            this._private__resetTapTimeout();\n        }\n        else {\n            if (!this._private__cancelTap) {\n                this._private__processTouchEvent(compatEvent, this._private__handler._internal_tapEvent);\n                // do not fire mouse events if tap handler was executed\n                // prevent click event on new dom element (who appeared after tap)\n                if (this._private__handler._internal_tapEvent) {\n                    preventDefault(touchEndEvent);\n                }\n            }\n        }\n        // prevent, for example, safari's dblclick-to-zoom or fast-click after long-tap\n        // we handle mouseDoubleClickEvent here ourselves\n        if (this._private__tapCount === 0) {\n            preventDefault(touchEndEvent);\n        }\n        if (touchEndEvent.touches.length === 0) {\n            if (this._private__longTapActive) {\n                this._private__longTapActive = false;\n                // prevent native click event\n                preventDefault(touchEndEvent);\n            }\n        }\n    }\n    _private__mouseUpHandler(mouseUpEvent) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (mouseUpEvent.button !== 0 /* MouseEventButton.Left */) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(mouseUpEvent);\n        this._private__mouseMoveStartPosition = null;\n        this._private__mousePressed = false;\n        if (this._private__unsubscribeRootMouseEvents) {\n            this._private__unsubscribeRootMouseEvents();\n            this._private__unsubscribeRootMouseEvents = null;\n        }\n        if (isFF()) {\n            const rootElement = this._private__target.ownerDocument.documentElement;\n            rootElement.removeEventListener('mouseleave', this._private__onFirefoxOutsideMouseUp);\n        }\n        if (this._private__firesTouchEvents(mouseUpEvent)) {\n            return;\n        }\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseUpEvent);\n        ++this._private__clickCount;\n        if (this._private__clickTimeoutId && this._private__clickCount > 1) {\n            // check that both clicks are near enough\n            const { _internal_manhattanDistance: manhattanDistance } = this._private__touchMouseMoveWithDownInfo(getPosition(mouseUpEvent), this._private__clickPosition);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n            if (manhattanDistance < 5 /* Constants.DoubleClickManhattanDistance */ && !this._private__cancelClick) {\n                this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseDoubleClickEvent);\n            }\n            this._private__resetClickTimeout();\n        }\n        else {\n            if (!this._private__cancelClick) {\n                this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseClickEvent);\n            }\n        }\n    }\n    _private__clearLongTapTimeout() {\n        if (this._private__longTapTimeoutId === null) {\n            return;\n        }\n        clearTimeout(this._private__longTapTimeoutId);\n        this._private__longTapTimeoutId = null;\n    }\n    _private__touchStartHandler(downEvent) {\n        if (this._private__activeTouchId !== null) {\n            return;\n        }\n        const touch = downEvent.changedTouches[0];\n        this._private__activeTouchId = touch.identifier;\n        this._private__lastTouchEventTimeStamp = eventTimeStamp(downEvent);\n        const rootElement = this._private__target.ownerDocument.documentElement;\n        this._private__cancelTap = false;\n        this._private__touchMoveExceededManhattanDistance = false;\n        this._private__preventTouchDragProcess = false;\n        this._private__touchMoveStartPosition = getPosition(touch);\n        if (this._private__unsubscribeRootTouchEvents) {\n            this._private__unsubscribeRootTouchEvents();\n            this._private__unsubscribeRootTouchEvents = null;\n        }\n        {\n            const boundTouchMoveWithDownHandler = this._private__touchMoveHandler.bind(this);\n            const boundTouchEndHandler = this._private__touchEndHandler.bind(this);\n            this._private__unsubscribeRootTouchEvents = () => {\n                rootElement.removeEventListener('touchmove', boundTouchMoveWithDownHandler);\n                rootElement.removeEventListener('touchend', boundTouchEndHandler);\n            };\n            rootElement.addEventListener('touchmove', boundTouchMoveWithDownHandler, { passive: false });\n            rootElement.addEventListener('touchend', boundTouchEndHandler, { passive: false });\n            this._private__clearLongTapTimeout();\n            this._private__longTapTimeoutId = setTimeout(this._private__longTapHandler.bind(this, downEvent), 240 /* Delay.LongTap */);\n        }\n        const compatEvent = this._private__makeCompatEvent(downEvent, touch);\n        this._private__processTouchEvent(compatEvent, this._private__handler._internal_touchStartEvent);\n        if (!this._private__tapTimeoutId) {\n            this._private__tapCount = 0;\n            this._private__tapTimeoutId = setTimeout(this._private__resetTapTimeout.bind(this), 500 /* Delay.ResetClick */);\n            this._private__tapPosition = getPosition(touch);\n        }\n    }\n    _private__mouseDownHandler(downEvent) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (downEvent.button !== 0 /* MouseEventButton.Left */) {\n            return;\n        }\n        const rootElement = this._private__target.ownerDocument.documentElement;\n        if (isFF()) {\n            rootElement.addEventListener('mouseleave', this._private__onFirefoxOutsideMouseUp);\n        }\n        this._private__cancelClick = false;\n        this._private__mouseMoveStartPosition = getPosition(downEvent);\n        if (this._private__unsubscribeRootMouseEvents) {\n            this._private__unsubscribeRootMouseEvents();\n            this._private__unsubscribeRootMouseEvents = null;\n        }\n        {\n            const boundMouseMoveWithDownHandler = this._private__mouseMoveWithDownHandler.bind(this);\n            const boundMouseUpHandler = this._private__mouseUpHandler.bind(this);\n            this._private__unsubscribeRootMouseEvents = () => {\n                rootElement.removeEventListener('mousemove', boundMouseMoveWithDownHandler);\n                rootElement.removeEventListener('mouseup', boundMouseUpHandler);\n            };\n            rootElement.addEventListener('mousemove', boundMouseMoveWithDownHandler);\n            rootElement.addEventListener('mouseup', boundMouseUpHandler);\n        }\n        this._private__mousePressed = true;\n        if (this._private__firesTouchEvents(downEvent)) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(downEvent);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseDownEvent);\n        if (!this._private__clickTimeoutId) {\n            this._private__clickCount = 0;\n            this._private__clickTimeoutId = setTimeout(this._private__resetClickTimeout.bind(this), 500 /* Delay.ResetClick */);\n            this._private__clickPosition = getPosition(downEvent);\n        }\n    }\n    _private__init() {\n        this._private__target.addEventListener('mouseenter', this._private__mouseEnterHandler.bind(this));\n        // Do not show context menu when something went wrong\n        this._private__target.addEventListener('touchcancel', this._private__clearLongTapTimeout.bind(this));\n        {\n            const doc = this._private__target.ownerDocument;\n            const outsideHandler = (event) => {\n                if (!this._private__handler._internal_mouseDownOutsideEvent) {\n                    return;\n                }\n                if (event.composed && this._private__target.contains(event.composedPath()[0])) {\n                    return;\n                }\n                if (event.target && this._private__target.contains(event.target)) {\n                    return;\n                }\n                this._private__handler._internal_mouseDownOutsideEvent();\n            };\n            this._private__unsubscribeOutsideTouchEvents = () => {\n                doc.removeEventListener('touchstart', outsideHandler);\n            };\n            this._private__unsubscribeOutsideMouseEvents = () => {\n                doc.removeEventListener('mousedown', outsideHandler);\n            };\n            doc.addEventListener('mousedown', outsideHandler);\n            doc.addEventListener('touchstart', outsideHandler, { passive: true });\n        }\n        if (isIOS()) {\n            this._private__unsubscribeMobileSafariEvents = () => {\n                this._private__target.removeEventListener('dblclick', this._private__onMobileSafariDoubleClick);\n            };\n            this._private__target.addEventListener('dblclick', this._private__onMobileSafariDoubleClick);\n        }\n        this._private__target.addEventListener('mouseleave', this._private__mouseLeaveHandler.bind(this));\n        this._private__target.addEventListener('touchstart', this._private__touchStartHandler.bind(this), { passive: true });\n        preventScrollByWheelClick(this._private__target);\n        this._private__target.addEventListener('mousedown', this._private__mouseDownHandler.bind(this));\n        this._private__initPinch();\n        // Hey mobile Safari, what's up?\n        // If mobile Safari doesn't have any touchmove handler with passive=false\n        // it treats a touchstart and the following touchmove events as cancelable=false,\n        // so we can't prevent them (as soon we subscribe on touchmove inside touchstart's handler).\n        // And we'll get scroll of the page along with chart's one instead of only chart's scroll.\n        this._private__target.addEventListener('touchmove', () => { }, { passive: false });\n    }\n    _private__initPinch() {\n        if (this._private__handler._internal_pinchStartEvent === undefined &&\n            this._private__handler._internal_pinchEvent === undefined &&\n            this._private__handler._internal_pinchEndEvent === undefined) {\n            return;\n        }\n        this._private__target.addEventListener('touchstart', (event) => this._private__checkPinchState(event.touches), { passive: true });\n        this._private__target.addEventListener('touchmove', (event) => {\n            if (event.touches.length !== 2 || this._private__startPinchMiddlePoint === null) {\n                return;\n            }\n            if (this._private__handler._internal_pinchEvent !== undefined) {\n                const currentDistance = getDistance(event.touches[0], event.touches[1]);\n                const scale = currentDistance / this._private__startPinchDistance;\n                this._private__handler._internal_pinchEvent(this._private__startPinchMiddlePoint, scale);\n                preventDefault(event);\n            }\n        }, { passive: false });\n        this._private__target.addEventListener('touchend', (event) => {\n            this._private__checkPinchState(event.touches);\n        });\n    }\n    _private__checkPinchState(touches) {\n        if (touches.length === 1) {\n            this._private__pinchPrevented = false;\n        }\n        if (touches.length !== 2 || this._private__pinchPrevented || this._private__longTapActive) {\n            this._private__stopPinch();\n        }\n        else {\n            this._private__startPinch(touches);\n        }\n    }\n    _private__startPinch(touches) {\n        const box = getBoundingClientRect(this._private__target);\n        this._private__startPinchMiddlePoint = {\n            _internal_x: ((touches[0].clientX - box.left) + (touches[1].clientX - box.left)) / 2,\n            _internal_y: ((touches[0].clientY - box.top) + (touches[1].clientY - box.top)) / 2,\n        };\n        this._private__startPinchDistance = getDistance(touches[0], touches[1]);\n        if (this._private__handler._internal_pinchStartEvent !== undefined) {\n            this._private__handler._internal_pinchStartEvent();\n        }\n        this._private__clearLongTapTimeout();\n    }\n    _private__stopPinch() {\n        if (this._private__startPinchMiddlePoint === null) {\n            return;\n        }\n        this._private__startPinchMiddlePoint = null;\n        if (this._private__handler._internal_pinchEndEvent !== undefined) {\n            this._private__handler._internal_pinchEndEvent();\n        }\n    }\n    _private__mouseLeaveHandler(event) {\n        if (this._private__unsubscribeMousemove) {\n            this._private__unsubscribeMousemove();\n        }\n        if (this._private__firesTouchEvents(event)) {\n            return;\n        }\n        if (!this._private__acceptMouseLeave) {\n            // mobile Safari sometimes emits mouse leave event for no reason, there is no way to handle it in other way\n            // just ignore this event if there was no mouse move or mouse enter events\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(event);\n        this._private__processMouseEvent(compatEvent, this._private__handler._internal_mouseLeaveEvent);\n        // accept all mouse leave events if it's not an iOS device\n        this._private__acceptMouseLeave = !isIOS();\n    }\n    _private__longTapHandler(event) {\n        const touch = touchWithId(event.touches, ensureNotNull(this._private__activeTouchId));\n        if (touch === null) {\n            return;\n        }\n        const compatEvent = this._private__makeCompatEvent(event, touch);\n        this._private__processTouchEvent(compatEvent, this._private__handler._internal_longTapEvent);\n        this._private__cancelTap = true;\n        // long tap is active until touchend event with 0 touches occurred\n        this._private__longTapActive = true;\n    }\n    _private__firesTouchEvents(e) {\n        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents !== undefined) {\n            return e.sourceCapabilities.firesTouchEvents;\n        }\n        return eventTimeStamp(e) < this._private__lastTouchEventTimeStamp + 500 /* Delay.PreventFiresTouchEvents */;\n    }\n    _private__processTouchEvent(event, callback) {\n        if (callback) {\n            callback.call(this._private__handler, event);\n        }\n    }\n    _private__processMouseEvent(event, callback) {\n        if (!callback) {\n            return;\n        }\n        callback.call(this._private__handler, event);\n    }\n    _private__makeCompatEvent(event, touch) {\n        // TouchEvent has no clientX/Y coordinates:\n        // We have to use the last Touch instead\n        const eventLike = touch || event;\n        const box = this._private__target.getBoundingClientRect() || { left: 0, top: 0 };\n        return {\n            clientX: eventLike.clientX,\n            clientY: eventLike.clientY,\n            pageX: eventLike.pageX,\n            pageY: eventLike.pageY,\n            screenX: eventLike.screenX,\n            screenY: eventLike.screenY,\n            localX: (eventLike.clientX - box.left),\n            localY: (eventLike.clientY - box.top),\n            ctrlKey: event.ctrlKey,\n            altKey: event.altKey,\n            shiftKey: event.shiftKey,\n            metaKey: event.metaKey,\n            _internal_isTouch: !event.type.startsWith('mouse') && event.type !== 'contextmenu' && event.type !== 'click',\n            _internal_srcType: event.type,\n            _internal_target: eventLike.target,\n            _internal_view: event.view,\n            _internal_preventDefault: () => {\n                if (event.type !== 'touchstart') {\n                    // touchstart is passive and cannot be prevented\n                    preventDefault(event);\n                }\n            },\n        };\n    }\n}\nfunction getBoundingClientRect(element) {\n    return element.getBoundingClientRect() || { left: 0, top: 0 };\n}\nfunction getDistance(p1, p2) {\n    const xDiff = p1.clientX - p2.clientX;\n    const yDiff = p1.clientY - p2.clientY;\n    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n}\nfunction preventDefault(event) {\n    if (event.cancelable) {\n        event.preventDefault();\n    }\n}\nfunction getPosition(eventLike) {\n    return {\n        _internal_x: eventLike.pageX,\n        _internal_y: eventLike.pageY,\n    };\n}\nfunction eventTimeStamp(e) {\n    // for some reason e.timestamp is always 0 on iPad with magic mouse, so we use performance.now() as a fallback\n    return e.timeStamp || performance.now();\n}\nfunction touchWithId(touches, id) {\n    for (let i = 0; i < touches.length; ++i) {\n        if (touches[i].identifier === id) {\n            return touches[i];\n        }\n    }\n    return null;\n}\n\nclass PaneSeparator {\n    constructor(chartWidget, topPaneIndex, bottomPaneIndex) {\n        this._private__handle = null;\n        this._private__mouseEventHandler = null;\n        this._private__resizeEnabled = true;\n        this._private__resizeInfo = null;\n        this._private__chartWidget = chartWidget;\n        this._private__topPane = chartWidget._internal_paneWidgets()[topPaneIndex];\n        this._private__bottomPane = chartWidget._internal_paneWidgets()[bottomPaneIndex];\n        this._private__rowElement = document.createElement('tr');\n        this._private__rowElement.style.height = 1 /* SeparatorConstants.SeparatorHeight */ + 'px';\n        this._private__cell = document.createElement('td');\n        this._private__cell.style.position = 'relative';\n        this._private__cell.style.padding = '0';\n        this._private__cell.style.margin = '0';\n        this._private__cell.setAttribute('colspan', '3');\n        this._private__updateBorderColor();\n        this._private__rowElement.appendChild(this._private__cell);\n        this._private__resizeEnabled = this._private__chartWidget._internal_options()['layout'].panes.enableResize;\n        if (!this._private__resizeEnabled) {\n            this._private__handle = null;\n            this._private__mouseEventHandler = null;\n        }\n        else {\n            this._private__addResizableHandle();\n        }\n    }\n    _internal_destroy() {\n        if (this._private__mouseEventHandler !== null) {\n            this._private__mouseEventHandler._internal_destroy();\n        }\n    }\n    _internal_getElement() {\n        return this._private__rowElement;\n    }\n    _internal_getSize() {\n        return (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: this._private__topPane._internal_getSize().width,\n            height: 1 /* SeparatorConstants.SeparatorHeight */,\n        });\n    }\n    _internal_getBitmapSize() {\n        return (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: this._private__topPane._internal_getBitmapSize().width,\n            height: 1 /* SeparatorConstants.SeparatorHeight */ * window.devicePixelRatio,\n        });\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        ctx.fillStyle = this._private__chartWidget._internal_options()['layout'].panes.separatorColor;\n        ctx.fillRect(x, y, bitmapSize.width, bitmapSize.height);\n    }\n    _internal_update() {\n        this._private__updateBorderColor();\n        if (this._private__chartWidget._internal_options()['layout'].panes.enableResize !== this._private__resizeEnabled) {\n            this._private__resizeEnabled = this._private__chartWidget._internal_options()['layout'].panes.enableResize;\n            if (this._private__resizeEnabled) {\n                this._private__addResizableHandle();\n            }\n            else {\n                if (this._private__handle !== null) {\n                    this._private__cell.removeChild(this._private__handle._internal_backgroundElement);\n                    this._private__cell.removeChild(this._private__handle._internal_element);\n                    this._private__handle = null;\n                }\n                if (this._private__mouseEventHandler !== null) {\n                    this._private__mouseEventHandler._internal_destroy();\n                    this._private__mouseEventHandler = null;\n                }\n            }\n        }\n    }\n    _private__addResizableHandle() {\n        const backgroundElement = document.createElement('div');\n        const bgStyle = backgroundElement.style;\n        bgStyle.position = 'fixed';\n        bgStyle.display = 'none';\n        bgStyle.zIndex = '49';\n        bgStyle.top = '0';\n        bgStyle.left = '0';\n        bgStyle.width = '100%';\n        bgStyle.height = '100%';\n        bgStyle.cursor = 'row-resize';\n        this._private__cell.appendChild(backgroundElement);\n        const element = document.createElement('div');\n        const style = element.style;\n        style.position = 'absolute';\n        style.zIndex = '50';\n        style.top = '-4px';\n        style.height = '9px';\n        style.width = '100%';\n        style.backgroundColor = '';\n        style.cursor = 'row-resize';\n        this._private__cell.appendChild(element);\n        const handlers = {\n            _internal_mouseEnterEvent: this._private__mouseOverEvent.bind(this),\n            _internal_mouseLeaveEvent: this._private__mouseLeaveEvent.bind(this),\n            _internal_mouseDownEvent: this._private__mouseDownEvent.bind(this),\n            _internal_touchStartEvent: this._private__mouseDownEvent.bind(this),\n            _internal_pressedMouseMoveEvent: this._private__pressedMouseMoveEvent.bind(this),\n            _internal_touchMoveEvent: this._private__pressedMouseMoveEvent.bind(this),\n            _internal_mouseUpEvent: this._private__mouseUpEvent.bind(this),\n            _internal_touchEndEvent: this._private__mouseUpEvent.bind(this),\n        };\n        this._private__mouseEventHandler = new MouseEventHandler(element, handlers, {\n            _internal_treatVertTouchDragAsPageScroll: () => false,\n            _internal_treatHorzTouchDragAsPageScroll: () => true,\n        });\n        this._private__handle = { _internal_element: element, _internal_backgroundElement: backgroundElement };\n    }\n    _private__updateBorderColor() {\n        this._private__cell.style.background = this._private__chartWidget._internal_options()['layout'].panes.separatorColor;\n    }\n    _private__mouseOverEvent(event) {\n        if (this._private__handle !== null) {\n            this._private__handle._internal_element.style.backgroundColor = this._private__chartWidget._internal_options()['layout'].panes.separatorHoverColor;\n        }\n    }\n    _private__mouseLeaveEvent(event) {\n        if (this._private__handle !== null && this._private__resizeInfo === null) {\n            this._private__handle._internal_element.style.backgroundColor = '';\n        }\n    }\n    _private__mouseDownEvent(event) {\n        if (this._private__handle === null) {\n            return;\n        }\n        const totalStretch = this._private__topPane._internal_state()._internal_stretchFactor() + this._private__bottomPane._internal_state()._internal_stretchFactor();\n        const totalHeight = this._private__topPane._internal_getSize().height + this._private__bottomPane._internal_getSize().height;\n        const pixelStretchFactor = totalStretch / totalHeight;\n        const minPaneStretch = 30 /* SeparatorConstants.MinPaneHeight */ * pixelStretchFactor;\n        if (totalStretch <= minPaneStretch * 2) {\n            // cannot resize panes that already have less than minimal height\n            // that's possible if there are many panes on the chart\n            return;\n        }\n        this._private__resizeInfo = {\n            _internal_startY: event.pageY,\n            _internal_prevStretchTopPane: this._private__topPane._internal_state()._internal_stretchFactor(),\n            _internal_maxPaneStretch: totalStretch - minPaneStretch,\n            _internal_totalStretch: totalStretch,\n            _internal_pixelStretchFactor: pixelStretchFactor,\n            _internal_minPaneStretch: minPaneStretch,\n        };\n        this._private__handle._internal_backgroundElement.style.display = 'block';\n    }\n    _private__pressedMouseMoveEvent(event) {\n        const resizeInfo = this._private__resizeInfo;\n        if (resizeInfo === null) {\n            return;\n        }\n        const deltaY = event.pageY - resizeInfo._internal_startY;\n        const deltaStretchFactor = deltaY * resizeInfo._internal_pixelStretchFactor;\n        const upperPaneNewStretch = clamp(resizeInfo._internal_prevStretchTopPane + deltaStretchFactor, resizeInfo._internal_minPaneStretch, resizeInfo._internal_maxPaneStretch);\n        this._private__topPane._internal_state()._internal_setStretchFactor(upperPaneNewStretch);\n        this._private__bottomPane._internal_state()._internal_setStretchFactor(resizeInfo._internal_totalStretch - upperPaneNewStretch);\n        this._private__chartWidget._internal_model()._internal_fullUpdate();\n    }\n    _private__mouseUpEvent(event) {\n        if (this._private__resizeInfo === null || this._private__handle === null) {\n            return;\n        }\n        this._private__resizeInfo = null;\n        this._private__handle._internal_backgroundElement.style.display = 'none';\n    }\n}\n\nfunction distanceBetweenPoints(pos1, pos2) {\n    return pos1._internal_position - pos2._internal_position;\n}\nfunction speedPxPerMSec(pos1, pos2, maxSpeed) {\n    const speed = (pos1._internal_position - pos2._internal_position) / (pos1._internal_time - pos2._internal_time);\n    return Math.sign(speed) * Math.min(Math.abs(speed), maxSpeed);\n}\nfunction durationMSec(speed, dumpingCoeff) {\n    const lnDumpingCoeff = Math.log(dumpingCoeff);\n    return Math.log((1 /* Constants.EpsilonDistance */ * lnDumpingCoeff) / -speed) / (lnDumpingCoeff);\n}\nclass KineticAnimation {\n    constructor(minSpeed, maxSpeed, dumpingCoeff, minMove) {\n        this._private__position1 = null;\n        this._private__position2 = null;\n        this._private__position3 = null;\n        this._private__position4 = null;\n        this._private__animationStartPosition = null;\n        this._private__durationMsecs = 0;\n        this._private__speedPxPerMsec = 0;\n        this._private__minSpeed = minSpeed;\n        this._private__maxSpeed = maxSpeed;\n        this._private__dumpingCoeff = dumpingCoeff;\n        this._private__minMove = minMove;\n    }\n    _internal_addPosition(position, time) {\n        if (this._private__position1 !== null) {\n            if (this._private__position1._internal_time === time) {\n                this._private__position1._internal_position = position;\n                return;\n            }\n            if (Math.abs(this._private__position1._internal_position - position) < this._private__minMove) {\n                return;\n            }\n        }\n        this._private__position4 = this._private__position3;\n        this._private__position3 = this._private__position2;\n        this._private__position2 = this._private__position1;\n        this._private__position1 = { _internal_time: time, _internal_position: position };\n    }\n    _internal_start(position, time) {\n        if (this._private__position1 === null || this._private__position2 === null) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (time - this._private__position1._internal_time > 50 /* Constants.MaxStartDelay */) {\n            return;\n        }\n        // To calculate all the rest parameters we should calculate the speed af first\n        let totalDistance = 0;\n        const speed1 = speedPxPerMSec(this._private__position1, this._private__position2, this._private__maxSpeed);\n        const distance1 = distanceBetweenPoints(this._private__position1, this._private__position2);\n        // We're calculating weighted average speed\n        // Than more distance for a segment, than more its weight\n        const speedItems = [speed1];\n        const distanceItems = [distance1];\n        totalDistance += distance1;\n        if (this._private__position3 !== null) {\n            const speed2 = speedPxPerMSec(this._private__position2, this._private__position3, this._private__maxSpeed);\n            // stop at this moment if direction of the segment is opposite\n            if (Math.sign(speed2) === Math.sign(speed1)) {\n                const distance2 = distanceBetweenPoints(this._private__position2, this._private__position3);\n                speedItems.push(speed2);\n                distanceItems.push(distance2);\n                totalDistance += distance2;\n                if (this._private__position4 !== null) {\n                    const speed3 = speedPxPerMSec(this._private__position3, this._private__position4, this._private__maxSpeed);\n                    if (Math.sign(speed3) === Math.sign(speed1)) {\n                        const distance3 = distanceBetweenPoints(this._private__position3, this._private__position4);\n                        speedItems.push(speed3);\n                        distanceItems.push(distance3);\n                        totalDistance += distance3;\n                    }\n                }\n            }\n        }\n        let resultSpeed = 0;\n        for (let i = 0; i < speedItems.length; ++i) {\n            resultSpeed += distanceItems[i] / totalDistance * speedItems[i];\n        }\n        if (Math.abs(resultSpeed) < this._private__minSpeed) {\n            return;\n        }\n        this._private__animationStartPosition = { _internal_position: position, _internal_time: time };\n        this._private__speedPxPerMsec = resultSpeed;\n        this._private__durationMsecs = durationMSec(Math.abs(resultSpeed), this._private__dumpingCoeff);\n    }\n    _internal_getPosition(time) {\n        const startPosition = ensureNotNull(this._private__animationStartPosition);\n        const durationMsecs = time - startPosition._internal_time;\n        return startPosition._internal_position + this._private__speedPxPerMsec * (Math.pow(this._private__dumpingCoeff, durationMsecs) - 1) / (Math.log(this._private__dumpingCoeff));\n    }\n    _internal_finished(time) {\n        return this._private__animationStartPosition === null || this._private__progressDuration(time) === this._private__durationMsecs;\n    }\n    _private__progressDuration(time) {\n        const startPosition = ensureNotNull(this._private__animationStartPosition);\n        const progress = time - startPosition._internal_time;\n        return Math.min(progress, this._private__durationMsecs);\n    }\n}\n\nconst svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"35\" height=\"19\" fill=\"none\"><g fill-rule=\"evenodd\" clip-path=\"url(#a)\" clip-rule=\"evenodd\"><path fill=\"var(--stroke)\" d=\"M2 0H0v10h6v9h21.4l.5-1.3 6-15 1-2.7H23.7l-.5 1.3-.2.6a5 5 0 0 0-7-.9V0H2Zm20 17h4l5.2-13 .8-2h-7l-1 2.5-.2.5-1.5 3.8-.3.7V17Zm-.8-10a3 3 0 0 0 .7-2.7A3 3 0 1 0 16.8 7h4.4ZM14 7V2H2v6h6v9h4V7h2Z\"/><path fill=\"var(--fill)\" d=\"M14 2H2v6h6v9h6V2Zm12 15h-7l6-15h7l-6 15Zm-7-9a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z\"/></g><defs><clipPath id=\"a\"><path fill=\"var(--stroke)\" d=\"M0 0h35v19H0z\"/></clipPath></defs></svg>`;\nconst css = `a#tv-attr-logo{--fill:#131722;--stroke:#fff;position:absolute;left:10px;bottom:10px;height:19px;width:35px;margin:0;padding:0;border:0;z-index:3;}a#tv-attr-logo[data-dark]{--fill:#D1D4DC;--stroke:#131722;}`;\n// This widget doesn't support dynamically responding to options changes\n// because it is expected that the `attributionLogo` option won't be changed\n// and this saves some bundle size.\nclass AttributionLogoWidget {\n    constructor(container, chart) {\n        this._private__element = undefined;\n        this._private__cssElement = undefined;\n        this._private__theme = undefined;\n        this._private__visible = false;\n        this._private__container = container;\n        this._private__chart = chart;\n        this._private__render();\n    }\n    _internal_update() {\n        this._private__render();\n    }\n    _internal_removeElement() {\n        if (this._private__element) {\n            this._private__container.removeChild(this._private__element);\n        }\n        if (this._private__cssElement) {\n            this._private__container.removeChild(this._private__cssElement);\n        }\n        this._private__element = undefined;\n        this._private__cssElement = undefined;\n    }\n    _private__shouldUpdate() {\n        return this._private__visible !== this._private__shouldBeVisible() || this._private__theme !== this._private__themeToUse();\n    }\n    _private__themeToUse() {\n        return this._private__chart._internal_model()._internal_colorParser()._internal_colorStringToGrayscale(this._private__chart._internal_options()['layout'].textColor) > 160\n            ? 'dark'\n            : 'light';\n    }\n    _private__shouldBeVisible() {\n        return this._private__chart._internal_options()['layout'].attributionLogo;\n    }\n    _private__getUTMSource() {\n        const url = new URL(location.href);\n        if (!url.hostname) {\n            // ignore local testing\n            return '';\n        }\n        return '&utm_source=' + url.hostname + url.pathname;\n    }\n    _private__render() {\n        if (!this._private__shouldUpdate()) {\n            return;\n        }\n        this._internal_removeElement();\n        this._private__visible = this._private__shouldBeVisible();\n        if (this._private__visible) {\n            this._private__theme = this._private__themeToUse();\n            this._private__cssElement = document.createElement('style');\n            this._private__cssElement.innerText = css;\n            this._private__element = document.createElement('a');\n            this._private__element.href = `https://www.tradingview.com/?utm_medium=lwc-link&utm_campaign=lwc-chart${this._private__getUTMSource()}`;\n            this._private__element.title = 'Charting by TradingView';\n            this._private__element.id = 'tv-attr-logo';\n            this._private__element.target = '_blank';\n            this._private__element.innerHTML = svg;\n            this._private__element.toggleAttribute('data-dark', this._private__theme === 'dark');\n            this._private__container.appendChild(this._private__cssElement);\n            this._private__container.appendChild(this._private__element);\n        }\n    }\n}\n\nfunction createBoundCanvas(parentElement, size) {\n    const doc = ensureNotNull(parentElement.ownerDocument);\n    const canvas = doc.createElement('canvas');\n    parentElement.appendChild(canvas);\n    const binding = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.bindCanvasElementBitmapSizeTo)(canvas, {\n        type: 'device-pixel-content-box',\n        options: {\n            allowResizeObserver: true,\n        },\n        transform: (bitmapSize, canvasElementClientSize) => ({\n            width: Math.max(bitmapSize.width, canvasElementClientSize.width),\n            height: Math.max(bitmapSize.height, canvasElementClientSize.height),\n        }),\n    });\n    binding.resizeCanvasElement(size);\n    return binding;\n}\nfunction releaseCanvas(canvas) {\n    // This function fixes the iOS Safari error \"Total canvas memory use exceeds the maximum limit\".\n    // Seems that iOS Safari stores canvas elements for some additional time internally.\n    // So if we create/destroy a lot of canvas elements in a short period of time we can get this error.\n    // We resize the canvas to 1x1 pixels to force it to release memmory resources.\n    canvas.width = 1;\n    canvas.height = 1;\n    canvas.getContext('2d')?.clearRect(0, 0, 1, 1);\n}\n\nfunction drawBackground(renderer, target, isHovered, hitTestData) {\n    if (renderer._internal_drawBackground) {\n        renderer._internal_drawBackground(target, isHovered, hitTestData);\n    }\n}\nfunction drawForeground(renderer, target, isHovered, hitTestData) {\n    renderer._internal_draw(target, isHovered, hitTestData);\n}\nfunction drawSourceViews(paneViewsGetter, drawRendererFn, source, pane) {\n    const views = paneViewsGetter(source, pane);\n    for (const view of views) {\n        const renderer = view._internal_renderer(pane);\n        if (renderer !== null) {\n            drawRendererFn(renderer);\n        }\n    }\n}\n\nfunction hasPriceScale(source) {\n    return source._internal_priceScale !== undefined;\n}\nfunction buildPriceAxisViewsGetter(zOrder, priceScaleId) {\n    return (source) => {\n        if (!hasPriceScale(source)) {\n            return [];\n        }\n        const psId = source._internal_priceScale()?._internal_id() ?? '';\n        if (psId !== priceScaleId) {\n            // exclude if source is using a different price scale.\n            return [];\n        }\n        return source._internal_pricePaneViews?.(zOrder) ?? [];\n    };\n}\nfunction recalculateOverlapping(views, direction, scaleHeight, rendererOptions) {\n    if (!views.length) {\n        return;\n    }\n    let currentGroupStart = 0;\n    const initLabelHeight = views[0]._internal_height(rendererOptions, true);\n    let spaceBeforeCurrentGroup = direction === 1\n        ? scaleHeight / 2 - (views[0]._internal_getFixedCoordinate() - initLabelHeight / 2)\n        : views[0]._internal_getFixedCoordinate() - initLabelHeight / 2 - scaleHeight / 2;\n    spaceBeforeCurrentGroup = Math.max(0, spaceBeforeCurrentGroup);\n    for (let i = 1; i < views.length; i++) {\n        const view = views[i];\n        const prev = views[i - 1];\n        const height = prev._internal_height(rendererOptions, false);\n        const coordinate = view._internal_getFixedCoordinate();\n        const prevFixedCoordinate = prev._internal_getFixedCoordinate();\n        const overlap = direction === 1\n            ? coordinate > prevFixedCoordinate - height\n            : coordinate < prevFixedCoordinate + height;\n        if (overlap) {\n            const fixedCoordinate = prevFixedCoordinate - height * direction;\n            view._internal_setFixedCoordinate(fixedCoordinate);\n            const edgePoint = fixedCoordinate - direction * height / 2;\n            const outOfViewport = direction === 1 ? edgePoint < 0 : edgePoint > scaleHeight;\n            if (outOfViewport && spaceBeforeCurrentGroup > 0) {\n                // shift the whole group up or down\n                const desiredGroupShift = direction === 1 ? -1 - edgePoint : edgePoint - scaleHeight;\n                const possibleShift = Math.min(desiredGroupShift, spaceBeforeCurrentGroup);\n                for (let k = currentGroupStart; k < views.length; k++) {\n                    views[k]._internal_setFixedCoordinate(views[k]._internal_getFixedCoordinate() + direction * possibleShift);\n                }\n                spaceBeforeCurrentGroup -= possibleShift;\n            }\n        }\n        else {\n            currentGroupStart = i;\n            spaceBeforeCurrentGroup = direction === 1\n                ? prevFixedCoordinate - height - coordinate\n                : coordinate - (prevFixedCoordinate + height);\n        }\n    }\n}\nfunction priceScaleCrosshairLabelVisible(crosshair) {\n    return crosshair.mode !== 2 /* CrosshairMode.Hidden */ && crosshair.horzLine.visible && crosshair.horzLine.labelVisible;\n}\nclass PriceAxisWidget {\n    constructor(pane, options, rendererOptionsProvider, side) {\n        this._private__priceScale = null;\n        this._private__size = null;\n        this._private__mousedown = false;\n        this._private__widthCache = new TextWidthCache(200);\n        this._private__font = null;\n        this._private__prevOptimalWidth = 0;\n        this._private__isSettingSize = false;\n        this._private__canvasSuggestedBitmapSizeChangedHandler = () => {\n            if (this._private__isSettingSize) {\n                return;\n            }\n            this._private__pane._internal_chart()._internal_model()._internal_lightUpdate();\n        };\n        this._private__topCanvasSuggestedBitmapSizeChangedHandler = () => {\n            if (this._private__isSettingSize) {\n                return;\n            }\n            this._private__pane._internal_chart()._internal_model()._internal_lightUpdate();\n        };\n        this._private__pane = pane;\n        this._private__options = options;\n        this._private__layoutOptions = options['layout'];\n        this._private__rendererOptionsProvider = rendererOptionsProvider;\n        this._private__isLeft = side === 'left';\n        this._private__sourcePaneViews = buildPriceAxisViewsGetter('normal', side);\n        this._private__sourceTopPaneViews = buildPriceAxisViewsGetter('top', side);\n        this._private__sourceBottomPaneViews = buildPriceAxisViewsGetter('bottom', side);\n        this._private__cell = document.createElement('div');\n        this._private__cell.style.height = '100%';\n        this._private__cell.style.overflow = 'hidden';\n        this._private__cell.style.width = '25px';\n        this._private__cell.style.left = '0';\n        this._private__cell.style.position = 'relative';\n        this._private__canvasBinding = createBoundCanvas(this._private__cell, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: 16, height: 16 }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        const canvas = this._private__canvasBinding.canvasElement;\n        canvas.style.position = 'absolute';\n        canvas.style.zIndex = '1';\n        canvas.style.left = '0';\n        canvas.style.top = '0';\n        this._private__topCanvasBinding = createBoundCanvas(this._private__cell, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: 16, height: 16 }));\n        this._private__topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        const topCanvas = this._private__topCanvasBinding.canvasElement;\n        topCanvas.style.position = 'absolute';\n        topCanvas.style.zIndex = '2';\n        topCanvas.style.left = '0';\n        topCanvas.style.top = '0';\n        const handler = {\n            _internal_mouseDownEvent: this._private__mouseDownEvent.bind(this),\n            _internal_touchStartEvent: this._private__mouseDownEvent.bind(this),\n            _internal_pressedMouseMoveEvent: this._private__pressedMouseMoveEvent.bind(this),\n            _internal_touchMoveEvent: this._private__pressedMouseMoveEvent.bind(this),\n            _internal_mouseDownOutsideEvent: this._private__mouseDownOutsideEvent.bind(this),\n            _internal_mouseUpEvent: this._private__mouseUpEvent.bind(this),\n            _internal_touchEndEvent: this._private__mouseUpEvent.bind(this),\n            _internal_mouseDoubleClickEvent: this._private__mouseDoubleClickEvent.bind(this),\n            _internal_doubleTapEvent: this._private__mouseDoubleClickEvent.bind(this),\n            _internal_mouseEnterEvent: this._private__mouseEnterEvent.bind(this),\n            _internal_mouseLeaveEvent: this._private__mouseLeaveEvent.bind(this),\n        };\n        this._private__mouseEventHandler = new MouseEventHandler(this._private__topCanvasBinding.canvasElement, handler, {\n            _internal_treatVertTouchDragAsPageScroll: () => !this._private__options['handleScroll'].vertTouchDrag,\n            _internal_treatHorzTouchDragAsPageScroll: () => true,\n        });\n    }\n    _internal_destroy() {\n        this._private__mouseEventHandler._internal_destroy();\n        this._private__topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__topCanvasBinding.canvasElement);\n        this._private__topCanvasBinding.dispose();\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n        if (this._private__priceScale !== null) {\n            this._private__priceScale._internal_onMarksChanged()._internal_unsubscribeAll(this);\n        }\n        this._private__priceScale = null;\n    }\n    _internal_getElement() {\n        return this._private__cell;\n    }\n    _internal_fontSize() {\n        return this._private__layoutOptions.fontSize;\n    }\n    _internal_rendererOptions() {\n        const options = this._private__rendererOptionsProvider._internal_options();\n        const isFontChanged = this._private__font !== options._internal_font;\n        if (isFontChanged) {\n            this._private__widthCache._internal_reset();\n            this._private__font = options._internal_font;\n        }\n        return options;\n    }\n    _internal_optimalWidth() {\n        if (this._private__priceScale === null) {\n            return 0;\n        }\n        let tickMarkMaxWidth = 0;\n        const rendererOptions = this._internal_rendererOptions();\n        const ctx = ensureNotNull(this._private__canvasBinding.canvasElement.getContext('2d', {\n            colorSpace: this._private__pane._internal_chart()._internal_options().layout.colorSpace,\n        }));\n        ctx.save();\n        const tickMarks = this._private__priceScale._internal_marks();\n        ctx.font = this._private__baseFont();\n        if (tickMarks.length > 0) {\n            tickMarkMaxWidth = Math.max(this._private__widthCache._internal_measureText(ctx, tickMarks[0]._internal_label), this._private__widthCache._internal_measureText(ctx, tickMarks[tickMarks.length - 1]._internal_label));\n        }\n        const views = this._private__backLabels();\n        for (let j = views.length; j--;) {\n            const width = this._private__widthCache._internal_measureText(ctx, views[j]._internal_text());\n            if (width > tickMarkMaxWidth) {\n                tickMarkMaxWidth = width;\n            }\n        }\n        const firstValue = this._private__priceScale._internal_firstValue();\n        if (firstValue !== null &&\n            this._private__size !== null &&\n            priceScaleCrosshairLabelVisible(this._private__options.crosshair)) {\n            const topValue = this._private__priceScale._internal_coordinateToPrice(1, firstValue);\n            const bottomValue = this._private__priceScale._internal_coordinateToPrice(this._private__size.height - 2, firstValue);\n            tickMarkMaxWidth = Math.max(tickMarkMaxWidth, this._private__widthCache._internal_measureText(ctx, this._private__priceScale._internal_formatPrice(Math.floor(Math.min(topValue, bottomValue)) + 0.11111111111111, firstValue)), this._private__widthCache._internal_measureText(ctx, this._private__priceScale._internal_formatPrice(Math.ceil(Math.max(topValue, bottomValue)) - 0.11111111111111, firstValue)));\n        }\n        ctx.restore();\n        const resultTickMarksMaxWidth = tickMarkMaxWidth || 34 /* Constants.DefaultOptimalWidth */;\n        const res = Math.ceil(rendererOptions._internal_borderSize +\n            rendererOptions._internal_tickLength +\n            rendererOptions._internal_paddingInner +\n            rendererOptions._internal_paddingOuter +\n            5 /* Constants.LabelOffset */ +\n            resultTickMarksMaxWidth);\n        // make it even, remove this after migration to perfect fancy canvas\n        return suggestPriceScaleWidth(res);\n    }\n    _internal_setSize(newSize) {\n        if (this._private__size === null || !(0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, newSize)) {\n            this._private__size = newSize;\n            this._private__isSettingSize = true;\n            this._private__canvasBinding.resizeCanvasElement(newSize);\n            this._private__topCanvasBinding.resizeCanvasElement(newSize);\n            this._private__isSettingSize = false;\n            this._private__cell.style.width = `${newSize.width}px`;\n            this._private__cell.style.height = `${newSize.height}px`;\n        }\n    }\n    _internal_getWidth() {\n        return ensureNotNull(this._private__size).width;\n    }\n    _internal_setPriceScale(priceScale) {\n        if (this._private__priceScale === priceScale) {\n            return;\n        }\n        if (this._private__priceScale !== null) {\n            this._private__priceScale._internal_onMarksChanged()._internal_unsubscribeAll(this);\n        }\n        this._private__priceScale = priceScale;\n        priceScale._internal_onMarksChanged()._internal_subscribe(this._private__onMarksChanged.bind(this), this);\n    }\n    _internal_priceScale() {\n        return this._private__priceScale;\n    }\n    _internal_reset() {\n        const pane = this._private__pane._internal_state();\n        const model = this._private__pane._internal_chart()._internal_model();\n        model._internal_resetPriceScale(pane, ensureNotNull(this._internal_priceScale()));\n    }\n    _internal_paint(type) {\n        if (this._private__size === null) {\n            return;\n        }\n        const canvasOptions = {\n            colorSpace: this._private__pane._internal_chart()._internal_options().layout.colorSpace,\n        };\n        if (type !== 1 /* InvalidationLevel.Cursor */) {\n            this._private__alignLabels();\n            this._private__canvasBinding.applySuggestedBitmapSize();\n            const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding, canvasOptions);\n            if (target !== null) {\n                target.useBitmapCoordinateSpace((scope) => {\n                    this._private__drawBackground(scope);\n                    this._private__drawBorder(scope);\n                });\n                this._private__pane._internal_drawAdditionalSources(target, this._private__sourceBottomPaneViews);\n                this._private__drawTickMarks(target);\n                this._private__pane._internal_drawAdditionalSources(target, this._private__sourcePaneViews);\n                this._private__drawBackLabels(target);\n            }\n        }\n        this._private__topCanvasBinding.applySuggestedBitmapSize();\n        const topTarget = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__topCanvasBinding, canvasOptions);\n        if (topTarget !== null) {\n            topTarget.useBitmapCoordinateSpace(({ context: ctx, bitmapSize }) => {\n                ctx.clearRect(0, 0, bitmapSize.width, bitmapSize.height);\n            });\n            this._private__drawCrosshairLabel(topTarget);\n            this._private__pane._internal_drawAdditionalSources(topTarget, this._private__sourceTopPaneViews);\n        }\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _internal_update() {\n        // this call has side-effect - it regenerates marks on the price scale\n        this._private__priceScale?._internal_marks();\n    }\n    _private__mouseDownEvent(e) {\n        if (this._private__priceScale === null || this._private__priceScale._internal_isEmpty() || !this._private__options['handleScale'].axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        this._private__mousedown = true;\n        model._internal_startScalePrice(pane, this._private__priceScale, e.localY);\n    }\n    _private__pressedMouseMoveEvent(e) {\n        if (this._private__priceScale === null || !this._private__options['handleScale'].axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        const priceScale = this._private__priceScale;\n        model._internal_scalePriceTo(pane, priceScale, e.localY);\n    }\n    _private__mouseDownOutsideEvent() {\n        if (this._private__priceScale === null || !this._private__options['handleScale'].axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        const priceScale = this._private__priceScale;\n        if (this._private__mousedown) {\n            this._private__mousedown = false;\n            model._internal_endScalePrice(pane, priceScale);\n        }\n    }\n    _private__mouseUpEvent(e) {\n        if (this._private__priceScale === null || !this._private__options['handleScale'].axisPressedMouseMove.price) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const pane = this._private__pane._internal_state();\n        this._private__mousedown = false;\n        model._internal_endScalePrice(pane, this._private__priceScale);\n    }\n    _private__mouseDoubleClickEvent(e) {\n        if (this._private__options['handleScale'].axisDoubleClickReset.price) {\n            this._internal_reset();\n        }\n    }\n    _private__mouseEnterEvent(e) {\n        if (this._private__priceScale === null) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        if (model._internal_options()['handleScale'].axisPressedMouseMove.price && !this._private__priceScale._internal_isPercentage() && !this._private__priceScale._internal_isIndexedTo100()) {\n            this._private__setCursor(1 /* CursorType.NsResize */);\n        }\n    }\n    _private__mouseLeaveEvent(e) {\n        this._private__setCursor(0 /* CursorType.Default */);\n    }\n    _private__backLabels() {\n        const res = [];\n        const priceScale = (this._private__priceScale === null) ? undefined : this._private__priceScale;\n        const addViewsForSources = (sources) => {\n            for (let i = 0; i < sources.length; ++i) {\n                const source = sources[i];\n                const views = source._internal_priceAxisViews(this._private__pane._internal_state(), priceScale);\n                for (let j = 0; j < views.length; j++) {\n                    res.push(views[j]);\n                }\n            }\n        };\n        // calculate max and min coordinates for views on selection\n        // crosshair individually\n        addViewsForSources(this._private__pane._internal_state()._internal_orderedSources());\n        return res;\n    }\n    _private__drawBackground({ context: ctx, bitmapSize }) {\n        const { width, height } = bitmapSize;\n        const model = this._private__pane._internal_state()._internal_model();\n        const topColor = model._internal_backgroundTopColor();\n        const bottomColor = model._internal_backgroundBottomColor();\n        if (topColor === bottomColor) {\n            clearRect(ctx, 0, 0, width, height, topColor);\n        }\n        else {\n            clearRectWithGradient(ctx, 0, 0, width, height, topColor, bottomColor);\n        }\n    }\n    _private__drawBorder({ context: ctx, bitmapSize, horizontalPixelRatio }) {\n        if (this._private__size === null || this._private__priceScale === null || !this._private__priceScale._internal_options().borderVisible) {\n            return;\n        }\n        ctx.fillStyle = this._private__priceScale._internal_options().borderColor;\n        const borderSize = Math.max(1, Math.floor(this._internal_rendererOptions()._internal_borderSize * horizontalPixelRatio));\n        let left;\n        if (this._private__isLeft) {\n            left = bitmapSize.width - borderSize;\n        }\n        else {\n            left = 0;\n        }\n        ctx.fillRect(left, 0, borderSize, bitmapSize.height);\n    }\n    _private__drawTickMarks(target) {\n        if (this._private__size === null || this._private__priceScale === null) {\n            return;\n        }\n        const tickMarks = this._private__priceScale._internal_marks();\n        const priceScaleOptions = this._private__priceScale._internal_options();\n        const rendererOptions = this._internal_rendererOptions();\n        const tickMarkLeftX = this._private__isLeft ?\n            (this._private__size.width - rendererOptions._internal_tickLength) :\n            0;\n        if (priceScaleOptions.borderVisible && priceScaleOptions.ticksVisible) {\n            target.useBitmapCoordinateSpace(({ context: ctx, horizontalPixelRatio, verticalPixelRatio }) => {\n                ctx.fillStyle = priceScaleOptions.borderColor;\n                const tickHeight = Math.max(1, Math.floor(verticalPixelRatio));\n                const tickOffset = Math.floor(verticalPixelRatio * 0.5);\n                const tickLength = Math.round(rendererOptions._internal_tickLength * horizontalPixelRatio);\n                ctx.beginPath();\n                for (const tickMark of tickMarks) {\n                    ctx.rect(Math.floor(tickMarkLeftX * horizontalPixelRatio), Math.round(tickMark._internal_coord * verticalPixelRatio) - tickOffset, tickLength, tickHeight);\n                }\n                ctx.fill();\n            });\n        }\n        target.useMediaCoordinateSpace(({ context: ctx }) => {\n            ctx.font = this._private__baseFont();\n            ctx.fillStyle = priceScaleOptions.textColor ?? this._private__layoutOptions.textColor;\n            ctx.textAlign = this._private__isLeft ? 'right' : 'left';\n            ctx.textBaseline = 'middle';\n            const textLeftX = this._private__isLeft ?\n                Math.round(tickMarkLeftX - rendererOptions._internal_paddingInner) :\n                Math.round(tickMarkLeftX + rendererOptions._internal_tickLength + rendererOptions._internal_paddingInner);\n            const yMidCorrections = tickMarks.map((mark) => this._private__widthCache._internal_yMidCorrection(ctx, mark._internal_label));\n            for (let i = tickMarks.length; i--;) {\n                const tickMark = tickMarks[i];\n                ctx.fillText(tickMark._internal_label, textLeftX, tickMark._internal_coord + yMidCorrections[i]);\n            }\n        });\n    }\n    _private__alignLabels() {\n        if (this._private__size === null || this._private__priceScale === null) {\n            return;\n        }\n        let center = this._private__size.height / 2;\n        const views = [];\n        const orderedSources = this._private__priceScale._internal_orderedSources().slice(); // Copy of array\n        const pane = this._private__pane;\n        const paneState = pane._internal_state();\n        const rendererOptions = this._internal_rendererOptions();\n        // if we are default price scale, append labels from no-scale\n        const isDefault = this._private__priceScale === paneState._internal_defaultVisiblePriceScale();\n        if (isDefault) {\n            this._private__pane._internal_state()._internal_orderedSources().forEach((source) => {\n                if (paneState._internal_isOverlay(source)) {\n                    orderedSources.push(source);\n                }\n            });\n        }\n        // we can use any, but let's use the first source as \"center\" one\n        const centerSource = this._private__priceScale._internal_dataSources()[0];\n        const priceScale = this._private__priceScale;\n        const updateForSources = (sources) => {\n            sources.forEach((source) => {\n                const sourceViews = source._internal_priceAxisViews(paneState, priceScale);\n                // never align selected sources\n                sourceViews.forEach((view) => {\n                    view._internal_setFixedCoordinate(null);\n                    if (view._internal_isVisible()) {\n                        views.push(view);\n                    }\n                });\n                if (centerSource === source && sourceViews.length > 0) {\n                    center = sourceViews[0]._internal_coordinate();\n                }\n            });\n        };\n        // crosshair individually\n        updateForSources(orderedSources);\n        views.forEach((view) => view._internal_setFixedCoordinate(view._internal_coordinate()));\n        const options = this._private__priceScale._internal_options();\n        if (!options.alignLabels) {\n            return;\n        }\n        this._private__fixLabelOverlap(views, rendererOptions, center);\n    }\n    _private__fixLabelOverlap(views, rendererOptions, center) {\n        if (this._private__size === null) {\n            return;\n        }\n        // split into two parts\n        const top = views.filter((view) => view._internal_coordinate() <= center);\n        const bottom = views.filter((view) => view._internal_coordinate() > center);\n        // sort top from center to top\n        top.sort((l, r) => r._internal_coordinate() - l._internal_coordinate());\n        // share center label\n        if (top.length && bottom.length) {\n            bottom.push(top[0]);\n        }\n        bottom.sort((l, r) => l._internal_coordinate() - r._internal_coordinate());\n        for (const view of views) {\n            const halfHeight = Math.floor(view._internal_height(rendererOptions) / 2);\n            const coordinate = view._internal_coordinate();\n            if (coordinate > -halfHeight && coordinate < halfHeight) {\n                view._internal_setFixedCoordinate(halfHeight);\n            }\n            if (coordinate > (this._private__size.height - halfHeight) && coordinate < this._private__size.height + halfHeight) {\n                view._internal_setFixedCoordinate(this._private__size.height - halfHeight);\n            }\n        }\n        recalculateOverlapping(top, 1, this._private__size.height, rendererOptions);\n        recalculateOverlapping(bottom, -1, this._private__size.height, rendererOptions);\n    }\n    _private__drawBackLabels(target) {\n        if (this._private__size === null) {\n            return;\n        }\n        const views = this._private__backLabels();\n        const rendererOptions = this._internal_rendererOptions();\n        const align = this._private__isLeft ? 'right' : 'left';\n        views.forEach((view) => {\n            if (view._internal_isAxisLabelVisible()) {\n                const renderer = view._internal_renderer(ensureNotNull(this._private__priceScale));\n                renderer._internal_draw(target, rendererOptions, this._private__widthCache, align);\n            }\n        });\n    }\n    _private__drawCrosshairLabel(target) {\n        if (this._private__size === null || this._private__priceScale === null) {\n            return;\n        }\n        const model = this._private__pane._internal_chart()._internal_model();\n        const views = []; // array of arrays\n        const pane = this._private__pane._internal_state();\n        const v = model._internal_crosshairSource()._internal_priceAxisViews(pane, this._private__priceScale);\n        if (v.length) {\n            views.push(v);\n        }\n        const ro = this._internal_rendererOptions();\n        const align = this._private__isLeft ? 'right' : 'left';\n        views.forEach((arr) => {\n            arr.forEach((view) => {\n                view._internal_renderer(ensureNotNull(this._private__priceScale))._internal_draw(target, ro, this._private__widthCache, align);\n            });\n        });\n    }\n    _private__setCursor(type) {\n        this._private__cell.style.cursor = type === 1 /* CursorType.NsResize */ ? 'ns-resize' : 'default';\n    }\n    _private__onMarksChanged() {\n        const width = this._internal_optimalWidth();\n        // avoid price scale is shrunk\n        // using < instead !== to avoid infinite changes\n        if (this._private__prevOptimalWidth < width) {\n            this._private__pane._internal_chart()._internal_model()._internal_fullUpdate();\n        }\n        this._private__prevOptimalWidth = width;\n    }\n    _private__baseFont() {\n        return makeFont(this._private__layoutOptions.fontSize, this._private__layoutOptions.fontFamily);\n    }\n}\n\nfunction sourceBottomPaneViews$1(source, pane) {\n    return source._internal_bottomPaneViews?.(pane) ?? [];\n}\nfunction sourcePaneViews$1(source, pane) {\n    return source._internal_paneViews?.(pane) ?? [];\n}\nfunction sourceLabelPaneViews(source, pane) {\n    return source._internal_labelPaneViews?.(pane) ?? [];\n}\nfunction sourceTopPaneViews$1(source, pane) {\n    return source._internal_topPaneViews?.(pane) ?? [];\n}\nclass PaneWidget {\n    constructor(chart, state) {\n        this._private__size = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: 0, height: 0 });\n        this._private__leftPriceAxisWidget = null;\n        this._private__rightPriceAxisWidget = null;\n        this._private__attributionLogoWidget = null;\n        this._private__startScrollingPos = null;\n        this._private__isScrolling = false;\n        this._private__clicked = new Delegate();\n        this._private__dblClicked = new Delegate();\n        this._private__prevPinchScale = 0;\n        this._private__longTap = false;\n        this._private__startTrackPoint = null;\n        this._private__exitTrackingModeOnNextTry = false;\n        this._private__initCrosshairPosition = null;\n        this._private__scrollXAnimation = null;\n        this._private__isSettingSize = false;\n        this._private__canvasSuggestedBitmapSizeChangedHandler = () => {\n            if (this._private__isSettingSize || this._private__state === null) {\n                return;\n            }\n            this._private__model()._internal_lightUpdate();\n        };\n        this._private__topCanvasSuggestedBitmapSizeChangedHandler = () => {\n            if (this._private__isSettingSize || this._private__state === null) {\n                return;\n            }\n            this._private__model()._internal_lightUpdate();\n        };\n        this._private__chart = chart;\n        this._private__state = state;\n        this._private__state._internal_onDestroyed()._internal_subscribe(this._private__onStateDestroyed.bind(this), this, true);\n        this._private__paneCell = document.createElement('td');\n        this._private__paneCell.style.padding = '0';\n        this._private__paneCell.style.position = 'relative';\n        const paneWrapper = document.createElement('div');\n        paneWrapper.style.width = '100%';\n        paneWrapper.style.height = '100%';\n        paneWrapper.style.position = 'relative';\n        paneWrapper.style.overflow = 'hidden';\n        this._private__leftAxisCell = document.createElement('td');\n        this._private__leftAxisCell.style.padding = '0';\n        this._private__rightAxisCell = document.createElement('td');\n        this._private__rightAxisCell.style.padding = '0';\n        this._private__paneCell.appendChild(paneWrapper);\n        this._private__canvasBinding = createBoundCanvas(paneWrapper, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: 16, height: 16 }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        const canvas = this._private__canvasBinding.canvasElement;\n        canvas.style.position = 'absolute';\n        canvas.style.zIndex = '1';\n        canvas.style.left = '0';\n        canvas.style.top = '0';\n        this._private__topCanvasBinding = createBoundCanvas(paneWrapper, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: 16, height: 16 }));\n        this._private__topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        const topCanvas = this._private__topCanvasBinding.canvasElement;\n        topCanvas.style.position = 'absolute';\n        topCanvas.style.zIndex = '2';\n        topCanvas.style.left = '0';\n        topCanvas.style.top = '0';\n        this._private__rowElement = document.createElement('tr');\n        this._private__rowElement.appendChild(this._private__leftAxisCell);\n        this._private__rowElement.appendChild(this._private__paneCell);\n        this._private__rowElement.appendChild(this._private__rightAxisCell);\n        this._internal_updatePriceAxisWidgetsStates();\n        this._private__mouseEventHandler = new MouseEventHandler(this._private__topCanvasBinding.canvasElement, this, {\n            _internal_treatVertTouchDragAsPageScroll: () => this._private__startTrackPoint === null && !this._private__chart._internal_options()['handleScroll'].vertTouchDrag,\n            _internal_treatHorzTouchDragAsPageScroll: () => this._private__startTrackPoint === null && !this._private__chart._internal_options()['handleScroll'].horzTouchDrag,\n        });\n    }\n    _internal_destroy() {\n        if (this._private__leftPriceAxisWidget !== null) {\n            this._private__leftPriceAxisWidget._internal_destroy();\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            this._private__rightPriceAxisWidget._internal_destroy();\n        }\n        this._private__attributionLogoWidget = null;\n        this._private__topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__topCanvasBinding.canvasElement);\n        this._private__topCanvasBinding.dispose();\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_unsubscribeAll(this);\n            this._private__state._internal_destroy();\n        }\n        this._private__mouseEventHandler._internal_destroy();\n    }\n    _internal_state() {\n        return ensureNotNull(this._private__state);\n    }\n    _internal_setState(pane) {\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_unsubscribeAll(this);\n        }\n        this._private__state = pane;\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_subscribe(PaneWidget.prototype._private__onStateDestroyed.bind(this), this, true);\n        }\n        this._internal_updatePriceAxisWidgetsStates();\n        if (this._private__chart._internal_paneWidgets().indexOf(this) === this._private__chart._internal_paneWidgets().length - 1) {\n            this._private__attributionLogoWidget = this._private__attributionLogoWidget ?? new AttributionLogoWidget(this._private__paneCell, this._private__chart);\n            this._private__attributionLogoWidget._internal_update();\n        }\n        else {\n            this._private__attributionLogoWidget?._internal_removeElement();\n            this._private__attributionLogoWidget = null;\n        }\n    }\n    _internal_chart() {\n        return this._private__chart;\n    }\n    _internal_getElement() {\n        return this._private__rowElement;\n    }\n    _internal_updatePriceAxisWidgetsStates() {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__recreatePriceAxisWidgets();\n        if (this._private__model()._internal_serieses().length === 0) {\n            return;\n        }\n        if (this._private__leftPriceAxisWidget !== null) {\n            const leftPriceScale = this._private__state._internal_leftPriceScale();\n            this._private__leftPriceAxisWidget._internal_setPriceScale(ensureNotNull(leftPriceScale));\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            const rightPriceScale = this._private__state._internal_rightPriceScale();\n            this._private__rightPriceAxisWidget._internal_setPriceScale(ensureNotNull(rightPriceScale));\n        }\n    }\n    _internal_updatePriceAxisWidgets() {\n        if (this._private__leftPriceAxisWidget !== null) {\n            this._private__leftPriceAxisWidget._internal_update();\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            this._private__rightPriceAxisWidget._internal_update();\n        }\n    }\n    _internal_stretchFactor() {\n        return this._private__state !== null ? this._private__state._internal_stretchFactor() : 0;\n    }\n    _internal_setStretchFactor(stretchFactor) {\n        if (this._private__state) {\n            this._private__state._internal_setStretchFactor(stretchFactor);\n        }\n    }\n    _internal_mouseEnterEvent(event) {\n        if (!this._private__state) {\n            return;\n        }\n        this._private__onMouseEvent();\n        const x = event.localX;\n        const y = event.localY;\n        this._private__setCrosshairPosition(x, y, event);\n    }\n    _internal_mouseDownEvent(event) {\n        this._private__onMouseEvent();\n        this._private__mouseTouchDownEvent();\n        this._private__setCrosshairPosition(event.localX, event.localY, event);\n    }\n    _internal_mouseMoveEvent(event) {\n        if (!this._private__state) {\n            return;\n        }\n        this._private__onMouseEvent();\n        const x = event.localX;\n        const y = event.localY;\n        this._private__setCrosshairPosition(x, y, event);\n    }\n    _internal_mouseClickEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__onMouseEvent();\n        this._private__fireClickedDelegate(event);\n    }\n    _internal_mouseDoubleClickEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__fireMouseClickDelegate(this._private__dblClicked, event);\n    }\n    _internal_doubleTapEvent(event) {\n        this._internal_mouseDoubleClickEvent(event);\n    }\n    _internal_pressedMouseMoveEvent(event) {\n        this._private__onMouseEvent();\n        this._private__pressedMouseTouchMoveEvent(event);\n        this._private__setCrosshairPosition(event.localX, event.localY, event);\n    }\n    _internal_mouseUpEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__onMouseEvent();\n        this._private__longTap = false;\n        this._private__endScroll(event);\n    }\n    _internal_tapEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__fireClickedDelegate(event);\n    }\n    _internal_longTapEvent(event) {\n        this._private__longTap = true;\n        if (this._private__startTrackPoint === null) {\n            const point = { x: event.localX, y: event.localY };\n            this._private__startTrackingMode(point, point, event);\n        }\n    }\n    _internal_mouseLeaveEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        this._private__onMouseEvent();\n        this._private__state._internal_model()._internal_setHoveredSource(null);\n        this._private__clearCrosshairPosition();\n    }\n    _internal_clicked() {\n        return this._private__clicked;\n    }\n    _internal_dblClicked() {\n        return this._private__dblClicked;\n    }\n    _internal_pinchStartEvent() {\n        this._private__prevPinchScale = 1;\n        this._private__model()._internal_stopTimeScaleAnimation();\n    }\n    _internal_pinchEvent(middlePoint, scale) {\n        if (!this._private__chart._internal_options()['handleScale'].pinch) {\n            return;\n        }\n        const zoomScale = (scale - this._private__prevPinchScale) * 5;\n        this._private__prevPinchScale = scale;\n        this._private__model()._internal_zoomTime(middlePoint._internal_x, zoomScale);\n    }\n    _internal_touchStartEvent(event) {\n        this._private__longTap = false;\n        this._private__exitTrackingModeOnNextTry = this._private__startTrackPoint !== null;\n        this._private__mouseTouchDownEvent();\n        const crosshair = this._private__model()._internal_crosshairSource();\n        if (this._private__startTrackPoint !== null && crosshair._internal_visible()) {\n            this._private__initCrosshairPosition = { x: crosshair._internal_appliedX(), y: crosshair._internal_appliedY() };\n            this._private__startTrackPoint = { x: event.localX, y: event.localY };\n        }\n    }\n    _internal_touchMoveEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        const x = event.localX;\n        const y = event.localY;\n        if (this._private__startTrackPoint !== null) {\n            // tracking mode: move crosshair\n            this._private__exitTrackingModeOnNextTry = false;\n            const origPoint = ensureNotNull(this._private__initCrosshairPosition);\n            const newX = origPoint.x + (x - this._private__startTrackPoint.x);\n            const newY = origPoint.y + (y - this._private__startTrackPoint.y);\n            this._private__setCrosshairPosition(newX, newY, event);\n            return;\n        }\n        this._private__pressedMouseTouchMoveEvent(event);\n    }\n    _internal_touchEndEvent(event) {\n        if (this._internal_chart()._internal_options().trackingMode.exitMode === 0 /* TrackingModeExitMode.OnTouchEnd */) {\n            this._private__exitTrackingModeOnNextTry = true;\n        }\n        this._private__tryExitTrackingMode();\n        this._private__endScroll(event);\n    }\n    _internal_hitTest(x, y) {\n        const state = this._private__state;\n        if (state === null) {\n            return null;\n        }\n        return hitTestPane(state, x, y);\n    }\n    _internal_setPriceAxisSize(width, position) {\n        const priceAxisWidget = position === 'left' ? this._private__leftPriceAxisWidget : this._private__rightPriceAxisWidget;\n        ensureNotNull(priceAxisWidget)._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width, height: this._private__size.height }));\n    }\n    _internal_getSize() {\n        return this._private__size;\n    }\n    _internal_setSize(newSize) {\n        if ((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, newSize)) {\n            return;\n        }\n        this._private__size = newSize;\n        this._private__isSettingSize = true;\n        this._private__canvasBinding.resizeCanvasElement(newSize);\n        this._private__topCanvasBinding.resizeCanvasElement(newSize);\n        this._private__isSettingSize = false;\n        this._private__paneCell.style.width = newSize.width + 'px';\n        this._private__paneCell.style.height = newSize.height + 'px';\n    }\n    _internal_recalculatePriceScales() {\n        const pane = ensureNotNull(this._private__state);\n        pane._internal_recalculatePriceScale(pane._internal_leftPriceScale());\n        pane._internal_recalculatePriceScale(pane._internal_rightPriceScale());\n        for (const source of pane._internal_dataSources()) {\n            if (pane._internal_isOverlay(source)) {\n                const priceScale = source._internal_priceScale();\n                if (priceScale !== null) {\n                    pane._internal_recalculatePriceScale(priceScale);\n                }\n                // for overlay drawings price scale is owner's price scale\n                // however owner's price scale could not contain ds\n                source._internal_updateAllViews();\n            }\n        }\n        for (const primitive of pane._internal_primitives()) {\n            primitive._internal_updateAllViews();\n        }\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _internal_paint(type) {\n        if (type === 0 /* InvalidationLevel.None */) {\n            return;\n        }\n        if (this._private__state === null) {\n            return;\n        }\n        if (type > 1 /* InvalidationLevel.Cursor */) {\n            this._internal_recalculatePriceScales();\n        }\n        if (this._private__leftPriceAxisWidget !== null) {\n            this._private__leftPriceAxisWidget._internal_paint(type);\n        }\n        if (this._private__rightPriceAxisWidget !== null) {\n            this._private__rightPriceAxisWidget._internal_paint(type);\n        }\n        const canvasOptions = {\n            colorSpace: this._private__chart._internal_options().layout.colorSpace,\n        };\n        if (type !== 1 /* InvalidationLevel.Cursor */) {\n            this._private__canvasBinding.applySuggestedBitmapSize();\n            const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding, canvasOptions);\n            if (target !== null) {\n                target.useBitmapCoordinateSpace((scope) => {\n                    this._private__drawBackground(scope);\n                });\n                if (this._private__state) {\n                    this._private__drawSources(target, sourceBottomPaneViews$1);\n                    this._private__drawGrid(target);\n                    this._private__drawSources(target, sourcePaneViews$1);\n                    this._private__drawSources(target, sourceLabelPaneViews);\n                }\n            }\n        }\n        this._private__topCanvasBinding.applySuggestedBitmapSize();\n        const topTarget = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__topCanvasBinding, canvasOptions);\n        if (topTarget !== null) {\n            topTarget.useBitmapCoordinateSpace(({ context: ctx, bitmapSize }) => {\n                ctx.clearRect(0, 0, bitmapSize.width, bitmapSize.height);\n            });\n            this._private__drawCrosshair(topTarget);\n            this._private__drawSources(topTarget, sourceTopPaneViews$1);\n            this._private__drawSources(topTarget, sourceLabelPaneViews);\n        }\n    }\n    _internal_leftPriceAxisWidget() {\n        return this._private__leftPriceAxisWidget;\n    }\n    _internal_rightPriceAxisWidget() {\n        return this._private__rightPriceAxisWidget;\n    }\n    _internal_drawAdditionalSources(target, paneViewsGetter) {\n        this._private__drawSources(target, paneViewsGetter);\n    }\n    _private__onStateDestroyed() {\n        if (this._private__state !== null) {\n            this._private__state._internal_onDestroyed()._internal_unsubscribeAll(this);\n        }\n        this._private__state = null;\n    }\n    _private__fireClickedDelegate(event) {\n        this._private__fireMouseClickDelegate(this._private__clicked, event);\n    }\n    _private__fireMouseClickDelegate(delegate, event) {\n        const x = event.localX;\n        const y = event.localY;\n        if (delegate._internal_hasListeners()) {\n            delegate._internal_fire(this._private__model()._internal_timeScale()._internal_coordinateToIndex(x), { x, y }, event);\n        }\n    }\n    _private__drawBackground({ context: ctx, bitmapSize }) {\n        const { width, height } = bitmapSize;\n        const model = this._private__model();\n        const topColor = model._internal_backgroundTopColor();\n        const bottomColor = model._internal_backgroundBottomColor();\n        if (topColor === bottomColor) {\n            clearRect(ctx, 0, 0, width, height, bottomColor);\n        }\n        else {\n            clearRectWithGradient(ctx, 0, 0, width, height, topColor, bottomColor);\n        }\n    }\n    _private__drawGrid(target) {\n        const state = ensureNotNull(this._private__state);\n        const paneView = state._internal_grid()._internal_paneView();\n        const renderer = paneView._internal_renderer(state);\n        if (renderer !== null) {\n            renderer._internal_draw(target, false);\n        }\n    }\n    _private__drawCrosshair(target) {\n        this._private__drawSourceImpl(target, sourcePaneViews$1, drawForeground, this._private__model()._internal_crosshairSource());\n    }\n    _private__drawSources(target, paneViewsGetter) {\n        const state = ensureNotNull(this._private__state);\n        const sources = state._internal_orderedSources();\n        const panePrimitives = state._internal_primitives();\n        for (const panePrimitive of panePrimitives) {\n            this._private__drawSourceImpl(target, paneViewsGetter, drawBackground, panePrimitive);\n        }\n        for (const source of sources) {\n            this._private__drawSourceImpl(target, paneViewsGetter, drawBackground, source);\n        }\n        for (const panePrimitive of panePrimitives) {\n            this._private__drawSourceImpl(target, paneViewsGetter, drawForeground, panePrimitive);\n        }\n        for (const source of sources) {\n            this._private__drawSourceImpl(target, paneViewsGetter, drawForeground, source);\n        }\n    }\n    _private__drawSourceImpl(target, paneViewsGetter, drawFn, source) {\n        const state = ensureNotNull(this._private__state);\n        const hoveredSource = state._internal_model()._internal_hoveredSource();\n        const isHovered = hoveredSource !== null && hoveredSource._internal_source === source;\n        const objecId = hoveredSource !== null && isHovered && hoveredSource._internal_object !== undefined\n            ? hoveredSource._internal_object._internal_hitTestData\n            : undefined;\n        const drawRendererFn = (renderer) => drawFn(renderer, target, isHovered, objecId);\n        drawSourceViews(paneViewsGetter, drawRendererFn, source, state);\n    }\n    _private__recreatePriceAxisWidgets() {\n        if (this._private__state === null) {\n            return;\n        }\n        const chart = this._private__chart;\n        const leftAxisVisible = this._private__state._internal_leftPriceScale()._internal_options().visible;\n        const rightAxisVisible = this._private__state._internal_rightPriceScale()._internal_options().visible;\n        if (!leftAxisVisible && this._private__leftPriceAxisWidget !== null) {\n            this._private__leftAxisCell.removeChild(this._private__leftPriceAxisWidget._internal_getElement());\n            this._private__leftPriceAxisWidget._internal_destroy();\n            this._private__leftPriceAxisWidget = null;\n        }\n        if (!rightAxisVisible && this._private__rightPriceAxisWidget !== null) {\n            this._private__rightAxisCell.removeChild(this._private__rightPriceAxisWidget._internal_getElement());\n            this._private__rightPriceAxisWidget._internal_destroy();\n            this._private__rightPriceAxisWidget = null;\n        }\n        const rendererOptionsProvider = chart._internal_model()._internal_rendererOptionsProvider();\n        if (leftAxisVisible && this._private__leftPriceAxisWidget === null) {\n            this._private__leftPriceAxisWidget = new PriceAxisWidget(this, chart._internal_options(), rendererOptionsProvider, 'left');\n            this._private__leftAxisCell.appendChild(this._private__leftPriceAxisWidget._internal_getElement());\n        }\n        if (rightAxisVisible && this._private__rightPriceAxisWidget === null) {\n            this._private__rightPriceAxisWidget = new PriceAxisWidget(this, chart._internal_options(), rendererOptionsProvider, 'right');\n            this._private__rightAxisCell.appendChild(this._private__rightPriceAxisWidget._internal_getElement());\n        }\n    }\n    _private__preventScroll(event) {\n        return event._internal_isTouch && this._private__longTap || this._private__startTrackPoint !== null;\n    }\n    _private__correctXCoord(x) {\n        return Math.max(0, Math.min(x, this._private__size.width - 1));\n    }\n    _private__correctYCoord(y) {\n        return Math.max(0, Math.min(y, this._private__size.height - 1));\n    }\n    _private__setCrosshairPosition(x, y, event) {\n        this._private__model()._internal_setAndSaveCurrentPosition(this._private__correctXCoord(x), this._private__correctYCoord(y), event, ensureNotNull(this._private__state));\n    }\n    _private__clearCrosshairPosition() {\n        this._private__model()._internal_clearCurrentPosition();\n    }\n    _private__tryExitTrackingMode() {\n        if (this._private__exitTrackingModeOnNextTry) {\n            this._private__startTrackPoint = null;\n            this._private__clearCrosshairPosition();\n        }\n    }\n    _private__startTrackingMode(startTrackPoint, crossHairPosition, event) {\n        this._private__startTrackPoint = startTrackPoint;\n        this._private__exitTrackingModeOnNextTry = false;\n        this._private__setCrosshairPosition(crossHairPosition.x, crossHairPosition.y, event);\n        const crosshair = this._private__model()._internal_crosshairSource();\n        this._private__initCrosshairPosition = { x: crosshair._internal_appliedX(), y: crosshair._internal_appliedY() };\n    }\n    _private__model() {\n        return this._private__chart._internal_model();\n    }\n    _private__endScroll(event) {\n        if (!this._private__isScrolling) {\n            return;\n        }\n        const model = this._private__model();\n        const state = this._internal_state();\n        model._internal_endScrollPrice(state, state._internal_defaultPriceScale());\n        this._private__startScrollingPos = null;\n        this._private__isScrolling = false;\n        model._internal_endScrollTime();\n        if (this._private__scrollXAnimation !== null) {\n            const startAnimationTime = performance.now();\n            const timeScale = model._internal_timeScale();\n            this._private__scrollXAnimation._internal_start(timeScale._internal_rightOffset(), startAnimationTime);\n            if (!this._private__scrollXAnimation._internal_finished(startAnimationTime)) {\n                model._internal_setTimeScaleAnimation(this._private__scrollXAnimation);\n            }\n        }\n    }\n    _private__onMouseEvent() {\n        this._private__startTrackPoint = null;\n    }\n    _private__mouseTouchDownEvent() {\n        if (!this._private__state) {\n            return;\n        }\n        this._private__model()._internal_stopTimeScaleAnimation();\n        if (document.activeElement !== document.body && document.activeElement !== document.documentElement) {\n            // If any focusable element except the page itself is focused, remove the focus\n            ensureNotNull(document.activeElement).blur();\n        }\n        else {\n            // Clear selection\n            const selection = document.getSelection();\n            if (selection !== null) {\n                selection.removeAllRanges();\n            }\n        }\n        const priceScale = this._private__state._internal_defaultPriceScale();\n        if (priceScale._internal_isEmpty() || this._private__model()._internal_timeScale()._internal_isEmpty()) {\n            return;\n        }\n    }\n    // eslint-disable-next-line complexity\n    _private__pressedMouseTouchMoveEvent(event) {\n        if (this._private__state === null) {\n            return;\n        }\n        const model = this._private__model();\n        const timeScale = model._internal_timeScale();\n        if (timeScale._internal_isEmpty()) {\n            return;\n        }\n        const chartOptions = this._private__chart._internal_options();\n        const scrollOptions = chartOptions['handleScroll'];\n        const kineticScrollOptions = chartOptions.kineticScroll;\n        if ((!scrollOptions.pressedMouseMove || event._internal_isTouch) &&\n            (!scrollOptions.horzTouchDrag && !scrollOptions.vertTouchDrag || !event._internal_isTouch)) {\n            return;\n        }\n        const priceScale = this._private__state._internal_defaultPriceScale();\n        const now = performance.now();\n        if (this._private__startScrollingPos === null && !this._private__preventScroll(event)) {\n            this._private__startScrollingPos = {\n                x: event.clientX,\n                y: event.clientY,\n                _internal_timestamp: now,\n                _internal_localX: event.localX,\n                _internal_localY: event.localY,\n            };\n        }\n        if (this._private__startScrollingPos !== null &&\n            !this._private__isScrolling &&\n            (this._private__startScrollingPos.x !== event.clientX || this._private__startScrollingPos.y !== event.clientY)) {\n            if (event._internal_isTouch && kineticScrollOptions.touch || !event._internal_isTouch && kineticScrollOptions.mouse) {\n                const barSpacing = timeScale._internal_barSpacing();\n                this._private__scrollXAnimation = new KineticAnimation(0.2 /* KineticScrollConstants.MinScrollSpeed */ / barSpacing, 7 /* KineticScrollConstants.MaxScrollSpeed */ / barSpacing, 0.997 /* KineticScrollConstants.DumpingCoeff */, 15 /* KineticScrollConstants.ScrollMinMove */ / barSpacing);\n                this._private__scrollXAnimation._internal_addPosition(timeScale._internal_rightOffset(), this._private__startScrollingPos._internal_timestamp);\n            }\n            else {\n                this._private__scrollXAnimation = null;\n            }\n            if (!priceScale._internal_isEmpty()) {\n                model._internal_startScrollPrice(this._private__state, priceScale, event.localY);\n            }\n            model._internal_startScrollTime(event.localX);\n            this._private__isScrolling = true;\n        }\n        if (this._private__isScrolling) {\n            // this allows scrolling not default price scales\n            if (!priceScale._internal_isEmpty()) {\n                model._internal_scrollPriceTo(this._private__state, priceScale, event.localY);\n            }\n            model._internal_scrollTimeTo(event.localX);\n            if (this._private__scrollXAnimation !== null) {\n                this._private__scrollXAnimation._internal_addPosition(timeScale._internal_rightOffset(), now);\n            }\n        }\n    }\n}\n\nclass PriceAxisStub {\n    constructor(side, options, params, borderVisible, bottomColor) {\n        this._private__invalidated = true;\n        this._private__size = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: 0, height: 0 });\n        this._private__canvasSuggestedBitmapSizeChangedHandler = () => this._internal_paint(3 /* InvalidationLevel.Full */);\n        this._private__isLeft = side === 'left';\n        this._private__rendererOptionsProvider = params._internal_rendererOptionsProvider;\n        this._private__options = options;\n        this._private__borderVisible = borderVisible;\n        this._private__bottomColor = bottomColor;\n        this._private__cell = document.createElement('div');\n        this._private__cell.style.width = '25px';\n        this._private__cell.style.height = '100%';\n        this._private__cell.style.overflow = 'hidden';\n        this._private__canvasBinding = createBoundCanvas(this._private__cell, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: 16, height: 16 }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n    }\n    _internal_destroy() {\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n    }\n    _internal_getElement() {\n        return this._private__cell;\n    }\n    _internal_getSize() {\n        return this._private__size;\n    }\n    _internal_setSize(newSize) {\n        if (!(0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, newSize)) {\n            this._private__size = newSize;\n            this._private__canvasBinding.resizeCanvasElement(newSize);\n            this._private__cell.style.width = `${newSize.width}px`;\n            this._private__cell.style.height = `${newSize.height}px`;\n            this._private__invalidated = true;\n        }\n    }\n    _internal_paint(type) {\n        if (type < 3 /* InvalidationLevel.Full */ && !this._private__invalidated) {\n            return;\n        }\n        if (this._private__size.width === 0 || this._private__size.height === 0) {\n            return;\n        }\n        this._private__invalidated = false;\n        this._private__canvasBinding.applySuggestedBitmapSize();\n        const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding, {\n            colorSpace: this._private__options.layout.colorSpace,\n        });\n        if (target !== null) {\n            target.useBitmapCoordinateSpace((scope) => {\n                this._private__drawBackground(scope);\n                this._private__drawBorder(scope);\n            });\n        }\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _private__drawBorder({ context: ctx, bitmapSize, horizontalPixelRatio, verticalPixelRatio }) {\n        if (!this._private__borderVisible()) {\n            return;\n        }\n        ctx.fillStyle = this._private__options.timeScale.borderColor;\n        const horzBorderSize = Math.floor(this._private__rendererOptionsProvider._internal_options()._internal_borderSize * horizontalPixelRatio);\n        const vertBorderSize = Math.floor(this._private__rendererOptionsProvider._internal_options()._internal_borderSize * verticalPixelRatio);\n        const left = (this._private__isLeft) ? bitmapSize.width - horzBorderSize : 0;\n        ctx.fillRect(left, 0, horzBorderSize, vertBorderSize);\n    }\n    _private__drawBackground({ context: ctx, bitmapSize }) {\n        clearRect(ctx, 0, 0, bitmapSize.width, bitmapSize.height, this._private__bottomColor());\n    }\n}\n\nfunction buildTimeAxisViewsGetter(zOrder) {\n    return (source) => source._internal_timePaneViews?.(zOrder) ?? [];\n}\nconst sourcePaneViews = buildTimeAxisViewsGetter('normal');\nconst sourceTopPaneViews = buildTimeAxisViewsGetter('top');\nconst sourceBottomPaneViews = buildTimeAxisViewsGetter('bottom');\nclass TimeAxisWidget {\n    constructor(chartWidget, horzScaleBehavior) {\n        this._private__leftStub = null;\n        this._private__rightStub = null;\n        this._private__rendererOptions = null;\n        this._private__mouseDown = false;\n        this._private__size = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: 0, height: 0 });\n        this._private__sizeChanged = new Delegate();\n        this._private__widthCache = new TextWidthCache(5);\n        this._private__isSettingSize = false;\n        this._private__canvasSuggestedBitmapSizeChangedHandler = () => {\n            if (!this._private__isSettingSize) {\n                this._private__chart._internal_model()._internal_lightUpdate();\n            }\n        };\n        this._private__topCanvasSuggestedBitmapSizeChangedHandler = () => {\n            if (!this._private__isSettingSize) {\n                this._private__chart._internal_model()._internal_lightUpdate();\n            }\n        };\n        this._private__chart = chartWidget;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__options = chartWidget._internal_options()['layout'];\n        this._private__element = document.createElement('tr');\n        this._private__leftStubCell = document.createElement('td');\n        this._private__leftStubCell.style.padding = '0';\n        this._private__rightStubCell = document.createElement('td');\n        this._private__rightStubCell.style.padding = '0';\n        this._private__cell = document.createElement('td');\n        this._private__cell.style.height = '25px';\n        this._private__cell.style.padding = '0';\n        this._private__dv = document.createElement('div');\n        this._private__dv.style.width = '100%';\n        this._private__dv.style.height = '100%';\n        this._private__dv.style.position = 'relative';\n        this._private__dv.style.overflow = 'hidden';\n        this._private__cell.appendChild(this._private__dv);\n        this._private__canvasBinding = createBoundCanvas(this._private__dv, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: 16, height: 16 }));\n        this._private__canvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        const canvas = this._private__canvasBinding.canvasElement;\n        canvas.style.position = 'absolute';\n        canvas.style.zIndex = '1';\n        canvas.style.left = '0';\n        canvas.style.top = '0';\n        this._private__topCanvasBinding = createBoundCanvas(this._private__dv, (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: 16, height: 16 }));\n        this._private__topCanvasBinding.subscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        const topCanvas = this._private__topCanvasBinding.canvasElement;\n        topCanvas.style.position = 'absolute';\n        topCanvas.style.zIndex = '2';\n        topCanvas.style.left = '0';\n        topCanvas.style.top = '0';\n        this._private__element.appendChild(this._private__leftStubCell);\n        this._private__element.appendChild(this._private__cell);\n        this._private__element.appendChild(this._private__rightStubCell);\n        this._private__recreateStubs();\n        this._private__chart._internal_model()._internal_priceScalesOptionsChanged()._internal_subscribe(this._private__recreateStubs.bind(this), this);\n        this._private__mouseEventHandler = new MouseEventHandler(this._private__topCanvasBinding.canvasElement, this, {\n            _internal_treatVertTouchDragAsPageScroll: () => true,\n            _internal_treatHorzTouchDragAsPageScroll: () => !this._private__chart._internal_options()['handleScroll'].horzTouchDrag,\n        });\n    }\n    _internal_destroy() {\n        this._private__mouseEventHandler._internal_destroy();\n        if (this._private__leftStub !== null) {\n            this._private__leftStub._internal_destroy();\n        }\n        if (this._private__rightStub !== null) {\n            this._private__rightStub._internal_destroy();\n        }\n        this._private__topCanvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__topCanvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__topCanvasBinding.canvasElement);\n        this._private__topCanvasBinding.dispose();\n        this._private__canvasBinding.unsubscribeSuggestedBitmapSizeChanged(this._private__canvasSuggestedBitmapSizeChangedHandler);\n        releaseCanvas(this._private__canvasBinding.canvasElement);\n        this._private__canvasBinding.dispose();\n    }\n    _internal_getElement() {\n        return this._private__element;\n    }\n    _internal_leftStub() {\n        return this._private__leftStub;\n    }\n    _internal_rightStub() {\n        return this._private__rightStub;\n    }\n    _internal_mouseDownEvent(event) {\n        if (this._private__mouseDown) {\n            return;\n        }\n        this._private__mouseDown = true;\n        const model = this._private__chart._internal_model();\n        if (model._internal_timeScale()._internal_isEmpty() || !this._private__chart._internal_options()['handleScale'].axisPressedMouseMove.time) {\n            return;\n        }\n        model._internal_startScaleTime(event.localX);\n    }\n    _internal_touchStartEvent(event) {\n        this._internal_mouseDownEvent(event);\n    }\n    _internal_mouseDownOutsideEvent() {\n        const model = this._private__chart._internal_model();\n        if (!model._internal_timeScale()._internal_isEmpty() && this._private__mouseDown) {\n            this._private__mouseDown = false;\n            if (this._private__chart._internal_options()['handleScale'].axisPressedMouseMove.time) {\n                model._internal_endScaleTime();\n            }\n        }\n    }\n    _internal_pressedMouseMoveEvent(event) {\n        const model = this._private__chart._internal_model();\n        if (model._internal_timeScale()._internal_isEmpty() || !this._private__chart._internal_options()['handleScale'].axisPressedMouseMove.time) {\n            return;\n        }\n        model._internal_scaleTimeTo(event.localX);\n    }\n    _internal_touchMoveEvent(event) {\n        this._internal_pressedMouseMoveEvent(event);\n    }\n    _internal_mouseUpEvent() {\n        this._private__mouseDown = false;\n        const model = this._private__chart._internal_model();\n        if (model._internal_timeScale()._internal_isEmpty() && !this._private__chart._internal_options()['handleScale'].axisPressedMouseMove.time) {\n            return;\n        }\n        model._internal_endScaleTime();\n    }\n    _internal_touchEndEvent() {\n        this._internal_mouseUpEvent();\n    }\n    _internal_mouseDoubleClickEvent() {\n        if (this._private__chart._internal_options()['handleScale'].axisDoubleClickReset.time) {\n            this._private__chart._internal_model()._internal_resetTimeScale();\n        }\n    }\n    _internal_doubleTapEvent() {\n        this._internal_mouseDoubleClickEvent();\n    }\n    _internal_mouseEnterEvent() {\n        if (this._private__chart._internal_model()._internal_options()['handleScale'].axisPressedMouseMove.time) {\n            this._private__setCursor(1 /* CursorType.EwResize */);\n        }\n    }\n    _internal_mouseLeaveEvent() {\n        this._private__setCursor(0 /* CursorType.Default */);\n    }\n    _internal_getSize() {\n        return this._private__size;\n    }\n    _internal_sizeChanged() {\n        return this._private__sizeChanged;\n    }\n    _internal_setSizes(timeAxisSize, leftStubWidth, rightStubWidth) {\n        if (!(0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.equalSizes)(this._private__size, timeAxisSize)) {\n            this._private__size = timeAxisSize;\n            this._private__isSettingSize = true;\n            this._private__canvasBinding.resizeCanvasElement(timeAxisSize);\n            this._private__topCanvasBinding.resizeCanvasElement(timeAxisSize);\n            this._private__isSettingSize = false;\n            this._private__cell.style.width = `${timeAxisSize.width}px`;\n            this._private__cell.style.height = `${timeAxisSize.height}px`;\n            this._private__sizeChanged._internal_fire(timeAxisSize);\n        }\n        if (this._private__leftStub !== null) {\n            this._private__leftStub._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: leftStubWidth, height: timeAxisSize.height }));\n        }\n        if (this._private__rightStub !== null) {\n            this._private__rightStub._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: rightStubWidth, height: timeAxisSize.height }));\n        }\n    }\n    _internal_optimalHeight() {\n        const rendererOptions = this._private__getRendererOptions();\n        return Math.ceil(\n        // rendererOptions.offsetSize +\n        rendererOptions._internal_borderSize +\n            rendererOptions._internal_tickLength +\n            rendererOptions._internal_fontSize +\n            rendererOptions._internal_paddingTop +\n            rendererOptions._internal_paddingBottom +\n            rendererOptions._internal_labelBottomOffset);\n    }\n    _internal_update() {\n        // this call has side-effect - it regenerates marks on the time scale\n        this._private__chart._internal_model()._internal_timeScale()._internal_marks();\n    }\n    _internal_getBitmapSize() {\n        return this._private__canvasBinding.bitmapSize;\n    }\n    _internal_drawBitmap(ctx, x, y) {\n        const bitmapSize = this._internal_getBitmapSize();\n        if (bitmapSize.width > 0 && bitmapSize.height > 0) {\n            ctx.drawImage(this._private__canvasBinding.canvasElement, x, y);\n        }\n    }\n    _internal_paint(type) {\n        if (type === 0 /* InvalidationLevel.None */) {\n            return;\n        }\n        const canvasOptions = {\n            colorSpace: this._private__options.colorSpace,\n        };\n        if (type !== 1 /* InvalidationLevel.Cursor */) {\n            this._private__canvasBinding.applySuggestedBitmapSize();\n            const target = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__canvasBinding, canvasOptions);\n            if (target !== null) {\n                target.useBitmapCoordinateSpace((scope) => {\n                    this._private__drawBackground(scope);\n                    this._private__drawBorder(scope);\n                    this._private__drawAdditionalSources(target, sourceBottomPaneViews);\n                });\n                this._private__drawTickMarks(target);\n                this._private__drawAdditionalSources(target, sourcePaneViews);\n                // atm we don't have sources to be drawn on time axis except crosshair which is rendered on top level canvas\n                // so let's don't call this code at all for now\n                // this._drawLabels(this._chart.model().dataSources(), target);\n            }\n            if (this._private__leftStub !== null) {\n                this._private__leftStub._internal_paint(type);\n            }\n            if (this._private__rightStub !== null) {\n                this._private__rightStub._internal_paint(type);\n            }\n        }\n        this._private__topCanvasBinding.applySuggestedBitmapSize();\n        const topTarget = (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.tryCreateCanvasRenderingTarget2D)(this._private__topCanvasBinding, canvasOptions);\n        if (topTarget !== null) {\n            topTarget.useBitmapCoordinateSpace(({ context: ctx, bitmapSize }) => {\n                ctx.clearRect(0, 0, bitmapSize.width, bitmapSize.height);\n            });\n            this._private__drawLabels([...this._private__chart._internal_model()._internal_serieses(), this._private__chart._internal_model()._internal_crosshairSource()], topTarget);\n            this._private__drawAdditionalSources(topTarget, sourceTopPaneViews);\n        }\n    }\n    _private__drawAdditionalSources(target, axisViewsGetter) {\n        const sources = this._private__chart._internal_model()._internal_serieses();\n        for (const source of sources) {\n            drawSourceViews(axisViewsGetter, (renderer) => drawBackground(renderer, target, false, undefined), source, undefined);\n        }\n        for (const source of sources) {\n            drawSourceViews(axisViewsGetter, (renderer) => drawForeground(renderer, target, false, undefined), source, undefined);\n        }\n    }\n    _private__drawBackground({ context: ctx, bitmapSize }) {\n        clearRect(ctx, 0, 0, bitmapSize.width, bitmapSize.height, this._private__chart._internal_model()._internal_backgroundBottomColor());\n    }\n    _private__drawBorder({ context: ctx, bitmapSize, verticalPixelRatio }) {\n        if (this._private__chart._internal_options().timeScale.borderVisible) {\n            ctx.fillStyle = this._private__lineColor();\n            const borderSize = Math.max(1, Math.floor(this._private__getRendererOptions()._internal_borderSize * verticalPixelRatio));\n            ctx.fillRect(0, 0, bitmapSize.width, borderSize);\n        }\n    }\n    _private__drawTickMarks(target) {\n        const timeScale = this._private__chart._internal_model()._internal_timeScale();\n        const tickMarks = timeScale._internal_marks();\n        if (!tickMarks || tickMarks.length === 0) {\n            return;\n        }\n        const maxWeight = this._private__horzScaleBehavior.maxTickMarkWeight(tickMarks);\n        const rendererOptions = this._private__getRendererOptions();\n        const options = timeScale._internal_options();\n        if (options.borderVisible && options.ticksVisible) {\n            target.useBitmapCoordinateSpace(({ context: ctx, horizontalPixelRatio, verticalPixelRatio }) => {\n                ctx.strokeStyle = this._private__lineColor();\n                ctx.fillStyle = this._private__lineColor();\n                const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n                const tickOffset = Math.floor(horizontalPixelRatio * 0.5);\n                ctx.beginPath();\n                const tickLen = Math.round(rendererOptions._internal_tickLength * verticalPixelRatio);\n                for (let index = tickMarks.length; index--;) {\n                    const x = Math.round(tickMarks[index].coord * horizontalPixelRatio);\n                    ctx.rect(x - tickOffset, 0, tickWidth, tickLen);\n                }\n                ctx.fill();\n            });\n        }\n        target.useMediaCoordinateSpace(({ context: ctx }) => {\n            const yText = (rendererOptions._internal_borderSize +\n                rendererOptions._internal_tickLength +\n                rendererOptions._internal_paddingTop +\n                rendererOptions._internal_fontSize / 2);\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillStyle = this._private__textColor();\n            // draw base marks\n            ctx.font = this._private__baseFont();\n            for (const tickMark of tickMarks) {\n                if (tickMark.weight < maxWeight) {\n                    const coordinate = tickMark.needAlignCoordinate ? this._private__alignTickMarkLabelCoordinate(ctx, tickMark.coord, tickMark.label) : tickMark.coord;\n                    ctx.fillText(tickMark.label, coordinate, yText);\n                }\n            }\n            if (this._private__chart._internal_options().timeScale.allowBoldLabels) {\n                ctx.font = this._private__baseBoldFont();\n            }\n            for (const tickMark of tickMarks) {\n                if (tickMark.weight >= maxWeight) {\n                    const coordinate = tickMark.needAlignCoordinate ? this._private__alignTickMarkLabelCoordinate(ctx, tickMark.coord, tickMark.label) : tickMark.coord;\n                    ctx.fillText(tickMark.label, coordinate, yText);\n                }\n            }\n        });\n    }\n    _private__alignTickMarkLabelCoordinate(ctx, coordinate, labelText) {\n        const labelWidth = this._private__widthCache._internal_measureText(ctx, labelText);\n        const labelWidthHalf = labelWidth / 2;\n        const leftTextCoordinate = Math.floor(coordinate - labelWidthHalf) + 0.5;\n        if (leftTextCoordinate < 0) {\n            coordinate = coordinate + Math.abs(0 - leftTextCoordinate);\n        }\n        else if (leftTextCoordinate + labelWidth > this._private__size.width) {\n            coordinate = coordinate - Math.abs(this._private__size.width - (leftTextCoordinate + labelWidth));\n        }\n        return coordinate;\n    }\n    _private__drawLabels(sources, target) {\n        const rendererOptions = this._private__getRendererOptions();\n        for (const source of sources) {\n            for (const view of source._internal_timeAxisViews()) {\n                view._internal_renderer()._internal_draw(target, rendererOptions);\n            }\n        }\n    }\n    _private__lineColor() {\n        return this._private__chart._internal_options().timeScale.borderColor;\n    }\n    _private__textColor() {\n        return this._private__options.textColor;\n    }\n    _private__fontSize() {\n        return this._private__options.fontSize;\n    }\n    _private__baseFont() {\n        return makeFont(this._private__fontSize(), this._private__options.fontFamily);\n    }\n    _private__baseBoldFont() {\n        return makeFont(this._private__fontSize(), this._private__options.fontFamily, 'bold');\n    }\n    _private__getRendererOptions() {\n        if (this._private__rendererOptions === null) {\n            this._private__rendererOptions = {\n                _internal_borderSize: 1 /* Constants.BorderSize */,\n                _internal_baselineOffset: NaN,\n                _internal_paddingTop: NaN,\n                _internal_paddingBottom: NaN,\n                _internal_paddingHorizontal: NaN,\n                _internal_tickLength: 5 /* Constants.TickLength */,\n                _internal_fontSize: NaN,\n                _internal_font: '',\n                _internal_widthCache: new TextWidthCache(),\n                _internal_labelBottomOffset: 0,\n            };\n        }\n        const rendererOptions = this._private__rendererOptions;\n        const newFont = this._private__baseFont();\n        if (rendererOptions._internal_font !== newFont) {\n            const fontSize = this._private__fontSize();\n            rendererOptions._internal_fontSize = fontSize;\n            rendererOptions._internal_font = newFont;\n            rendererOptions._internal_paddingTop = 3 * fontSize / 12;\n            rendererOptions._internal_paddingBottom = 3 * fontSize / 12;\n            rendererOptions._internal_paddingHorizontal = 9 * fontSize / 12;\n            rendererOptions._internal_baselineOffset = 0;\n            rendererOptions._internal_labelBottomOffset = 4 * fontSize / 12;\n            rendererOptions._internal_widthCache._internal_reset();\n        }\n        return this._private__rendererOptions;\n    }\n    _private__setCursor(type) {\n        this._private__cell.style.cursor = type === 1 /* CursorType.EwResize */ ? 'ew-resize' : 'default';\n    }\n    _private__recreateStubs() {\n        const model = this._private__chart._internal_model();\n        const options = model._internal_options();\n        if (!options.leftPriceScale.visible && this._private__leftStub !== null) {\n            this._private__leftStubCell.removeChild(this._private__leftStub._internal_getElement());\n            this._private__leftStub._internal_destroy();\n            this._private__leftStub = null;\n        }\n        if (!options.rightPriceScale.visible && this._private__rightStub !== null) {\n            this._private__rightStubCell.removeChild(this._private__rightStub._internal_getElement());\n            this._private__rightStub._internal_destroy();\n            this._private__rightStub = null;\n        }\n        const rendererOptionsProvider = this._private__chart._internal_model()._internal_rendererOptionsProvider();\n        const params = {\n            _internal_rendererOptionsProvider: rendererOptionsProvider,\n        };\n        const borderVisibleGetter = () => {\n            return options.leftPriceScale.borderVisible && model._internal_timeScale()._internal_options().borderVisible;\n        };\n        const bottomColorGetter = () => model._internal_backgroundBottomColor();\n        if (options.leftPriceScale.visible && this._private__leftStub === null) {\n            this._private__leftStub = new PriceAxisStub('left', options, params, borderVisibleGetter, bottomColorGetter);\n            this._private__leftStubCell.appendChild(this._private__leftStub._internal_getElement());\n        }\n        if (options.rightPriceScale.visible && this._private__rightStub === null) {\n            this._private__rightStub = new PriceAxisStub('right', options, params, borderVisibleGetter, bottomColorGetter);\n            this._private__rightStubCell.appendChild(this._private__rightStub._internal_getElement());\n        }\n    }\n}\n\nconst windowsChrome = isChromiumBased() && isWindows();\nclass ChartWidget {\n    constructor(container, options, horzScaleBehavior) {\n        this._private__paneWidgets = [];\n        this._private__paneSeparators = [];\n        this._private__drawRafId = 0;\n        this._private__height = 0;\n        this._private__width = 0;\n        this._private__leftPriceAxisWidth = 0;\n        this._private__rightPriceAxisWidth = 0;\n        this._private__invalidateMask = null;\n        this._private__drawPlanned = false;\n        this._private__clicked = new Delegate();\n        this._private__dblClicked = new Delegate();\n        this._private__crosshairMoved = new Delegate();\n        this._private__observer = null;\n        this._private__cursorStyleOverride = null;\n        this._private__container = container;\n        this._private__options = options;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._private__element = document.createElement('div');\n        this._private__element.classList.add('tv-lightweight-charts');\n        this._private__element.style.overflow = 'hidden';\n        this._private__element.style.direction = 'ltr';\n        this._private__element.style.width = '100%';\n        this._private__element.style.height = '100%';\n        disableSelection(this._private__element);\n        this._private__tableElement = document.createElement('table');\n        this._private__tableElement.setAttribute('cellspacing', '0');\n        this._private__element.appendChild(this._private__tableElement);\n        this._private__onWheelBound = this._private__onMousewheel.bind(this);\n        if (shouldSubscribeMouseWheel(this._private__options)) {\n            this._private__setMouseWheelEventListener(true);\n        }\n        this._private__model = new ChartModel(this._private__invalidateHandler.bind(this), this._private__options, horzScaleBehavior);\n        this._internal_model()._internal_crosshairMoved()._internal_subscribe(this._private__onPaneWidgetCrosshairMoved.bind(this), this);\n        this._private__timeAxisWidget = new TimeAxisWidget(this, this._private__horzScaleBehavior);\n        this._private__tableElement.appendChild(this._private__timeAxisWidget._internal_getElement());\n        const usedObserver = options.autoSize && this._private__installObserver();\n        // observer could not fire event immediately for some cases\n        // so we have to set initial size manually\n        let width = this._private__options.width;\n        let height = this._private__options.height;\n        // ignore width/height options if observer has actually been used\n        // however respect options if installing resize observer failed\n        if (usedObserver || width === 0 || height === 0) {\n            const containerRect = container.getBoundingClientRect();\n            width = width || containerRect.width;\n            height = height || containerRect.height;\n        }\n        // BEWARE: resize must be called BEFORE _syncGuiWithModel (in constructor only)\n        // or after but with adjustSize to properly update time scale\n        this._internal_resize(width, height);\n        this._private__syncGuiWithModel();\n        container.appendChild(this._private__element);\n        this._private__updateTimeAxisVisibility();\n        this._private__model._internal_timeScale()._internal_optionsApplied()._internal_subscribe(this._private__model._internal_fullUpdate.bind(this._private__model), this);\n        this._private__model._internal_priceScalesOptionsChanged()._internal_subscribe(this._private__model._internal_fullUpdate.bind(this._private__model), this);\n    }\n    _internal_model() {\n        return this._private__model;\n    }\n    _internal_options() {\n        return this._private__options;\n    }\n    _internal_paneWidgets() {\n        return this._private__paneWidgets;\n    }\n    _internal_timeAxisWidget() {\n        return this._private__timeAxisWidget;\n    }\n    _internal_destroy() {\n        this._private__setMouseWheelEventListener(false);\n        if (this._private__drawRafId !== 0) {\n            window.cancelAnimationFrame(this._private__drawRafId);\n        }\n        this._private__model._internal_crosshairMoved()._internal_unsubscribeAll(this);\n        this._private__model._internal_timeScale()._internal_optionsApplied()._internal_unsubscribeAll(this);\n        this._private__model._internal_priceScalesOptionsChanged()._internal_unsubscribeAll(this);\n        this._private__model._internal_destroy();\n        for (const paneWidget of this._private__paneWidgets) {\n            this._private__tableElement.removeChild(paneWidget._internal_getElement());\n            paneWidget._internal_clicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_dblClicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_destroy();\n        }\n        this._private__paneWidgets = [];\n        for (const paneSeparator of this._private__paneSeparators) {\n            this._private__destroySeparator(paneSeparator);\n        }\n        this._private__paneSeparators = [];\n        ensureNotNull(this._private__timeAxisWidget)._internal_destroy();\n        if (this._private__element.parentElement !== null) {\n            this._private__element.parentElement.removeChild(this._private__element);\n        }\n        this._private__crosshairMoved._internal_destroy();\n        this._private__clicked._internal_destroy();\n        this._private__dblClicked._internal_destroy();\n        this._private__uninstallObserver();\n    }\n    _internal_resize(width, height, forceRepaint = false) {\n        if (this._private__height === height && this._private__width === width) {\n            return;\n        }\n        const sizeHint = suggestChartSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width, height }));\n        this._private__height = sizeHint.height;\n        this._private__width = sizeHint.width;\n        const heightStr = this._private__height + 'px';\n        const widthStr = this._private__width + 'px';\n        ensureNotNull(this._private__element).style.height = heightStr;\n        ensureNotNull(this._private__element).style.width = widthStr;\n        this._private__tableElement.style.height = heightStr;\n        this._private__tableElement.style.width = widthStr;\n        if (forceRepaint) {\n            this._private__drawImpl(InvalidateMask._internal_full(), performance.now());\n        }\n        else {\n            this._private__model._internal_fullUpdate();\n        }\n    }\n    _internal_paint(invalidateMask) {\n        if (invalidateMask === undefined) {\n            invalidateMask = InvalidateMask._internal_full();\n        }\n        for (let i = 0; i < this._private__paneWidgets.length; i++) {\n            this._private__paneWidgets[i]._internal_paint(invalidateMask._internal_invalidateForPane(i)._internal_level);\n        }\n        if (this._private__options.timeScale.visible) {\n            this._private__timeAxisWidget._internal_paint(invalidateMask._internal_fullInvalidation());\n        }\n    }\n    _internal_applyOptions(options) {\n        const currentlyHasMouseWheelListener = shouldSubscribeMouseWheel(this._private__options);\n        // we don't need to merge options here because it's done in chart model\n        // and since both model and widget share the same object it will be done automatically for widget as well\n        // not ideal solution for sure, but it work's for now \\_()_/\n        this._private__model._internal_applyOptions(options);\n        const shouldHaveMouseWheelListener = shouldSubscribeMouseWheel(this._private__options);\n        if (shouldHaveMouseWheelListener !== currentlyHasMouseWheelListener) {\n            this._private__setMouseWheelEventListener(shouldHaveMouseWheelListener);\n        }\n        if (options['layout']?.panes) {\n            this._private__applyPanesOptions();\n        }\n        this._private__updateTimeAxisVisibility();\n        this._private__applyAutoSizeOptions(options);\n    }\n    _internal_clicked() {\n        return this._private__clicked;\n    }\n    _internal_dblClicked() {\n        return this._private__dblClicked;\n    }\n    _internal_crosshairMoved() {\n        return this._private__crosshairMoved;\n    }\n    _internal_takeScreenshot() {\n        if (this._private__invalidateMask !== null) {\n            this._private__drawImpl(this._private__invalidateMask, performance.now());\n            this._private__invalidateMask = null;\n        }\n        const screeshotBitmapSize = this._private__traverseLayout(null);\n        const screenshotCanvas = document.createElement('canvas');\n        screenshotCanvas.width = screeshotBitmapSize.width;\n        screenshotCanvas.height = screeshotBitmapSize.height;\n        const ctx = ensureNotNull(screenshotCanvas.getContext('2d'));\n        this._private__traverseLayout(ctx);\n        return screenshotCanvas;\n    }\n    _internal_getPriceAxisWidth(position) {\n        if (position === \"left\" /* DefaultPriceScaleId.Left */ && !this._private__isLeftAxisVisible()) {\n            return 0;\n        }\n        if (position === \"right\" /* DefaultPriceScaleId.Right */ && !this._private__isRightAxisVisible()) {\n            return 0;\n        }\n        if (this._private__paneWidgets.length === 0) {\n            return 0;\n        }\n        // we don't need to worry about exactly pane widget here\n        // because all pane widgets have the same width of price axis widget\n        // see _adjustSizeImpl\n        const priceAxisWidget = position === \"left\" /* DefaultPriceScaleId.Left */\n            ? this._private__paneWidgets[0]._internal_leftPriceAxisWidget()\n            : this._private__paneWidgets[0]._internal_rightPriceAxisWidget();\n        return ensureNotNull(priceAxisWidget)._internal_getWidth();\n    }\n    _internal_autoSizeActive() {\n        return this._private__options.autoSize && this._private__observer !== null;\n    }\n    _internal_element() {\n        return this._private__element;\n    }\n    _internal_setCursorStyle(style) {\n        this._private__cursorStyleOverride = style;\n        if (this._private__cursorStyleOverride) {\n            this._internal_element().style.setProperty('cursor', style);\n        }\n        else {\n            this._internal_element().style.removeProperty('cursor');\n        }\n    }\n    _internal_getCursorOverrideStyle() {\n        return this._private__cursorStyleOverride;\n    }\n    _internal_paneSize(paneIndex) {\n        return ensureDefined(this._private__paneWidgets[paneIndex])._internal_getSize();\n    }\n    _private__applyPanesOptions() {\n        this._private__paneSeparators.forEach((separator) => {\n            separator._internal_update();\n        });\n    }\n    // eslint-disable-next-line complexity\n    _private__applyAutoSizeOptions(options) {\n        if (options.autoSize === undefined && this._private__observer && (options.width !== undefined || options.height !== undefined)) {\n            warn(`You should turn autoSize off explicitly before specifying sizes; try adding options.autoSize: false to new options`);\n            return;\n        }\n        if (options.autoSize && !this._private__observer) {\n            // installing observer will override resize if successful\n            this._private__installObserver();\n        }\n        if (options.autoSize === false && this._private__observer !== null) {\n            this._private__uninstallObserver();\n        }\n        if (!options.autoSize && (options.width !== undefined || options.height !== undefined)) {\n            this._internal_resize(options.width || this._private__width, options.height || this._private__height);\n        }\n    }\n    /**\n     * Traverses the widget's layout (pane and axis child widgets),\n     * draws the screenshot (if rendering context is passed) and returns the screenshot bitmap size\n     *\n     * @param ctx - if passed, used to draw the screenshot of widget\n     * @returns screenshot bitmap size\n     */\n    _private__traverseLayout(ctx) {\n        let totalWidth = 0;\n        let totalHeight = 0;\n        const firstPane = this._private__paneWidgets[0];\n        const drawPriceAxises = (position, targetX) => {\n            let targetY = 0;\n            for (let paneIndex = 0; paneIndex < this._private__paneWidgets.length; paneIndex++) {\n                const paneWidget = this._private__paneWidgets[paneIndex];\n                const priceAxisWidget = ensureNotNull(position === 'left' ? paneWidget._internal_leftPriceAxisWidget() : paneWidget._internal_rightPriceAxisWidget());\n                const bitmapSize = priceAxisWidget._internal_getBitmapSize();\n                if (ctx !== null) {\n                    priceAxisWidget._internal_drawBitmap(ctx, targetX, targetY);\n                }\n                targetY += bitmapSize.height;\n                if (paneIndex < this._private__paneWidgets.length - 1) {\n                    const separator = this._private__paneSeparators[paneIndex];\n                    const separatorBitmapSize = separator._internal_getBitmapSize();\n                    if (ctx !== null) {\n                        separator._internal_drawBitmap(ctx, targetX, targetY);\n                    }\n                    targetY += separatorBitmapSize.height;\n                }\n            }\n        };\n        // draw left price scale if exists\n        if (this._private__isLeftAxisVisible()) {\n            drawPriceAxises('left', 0);\n            const leftAxisBitmapWidth = ensureNotNull(firstPane._internal_leftPriceAxisWidget())._internal_getBitmapSize().width;\n            totalWidth += leftAxisBitmapWidth;\n        }\n        for (let paneIndex = 0; paneIndex < this._private__paneWidgets.length; paneIndex++) {\n            const paneWidget = this._private__paneWidgets[paneIndex];\n            const bitmapSize = paneWidget._internal_getBitmapSize();\n            if (ctx !== null) {\n                paneWidget._internal_drawBitmap(ctx, totalWidth, totalHeight);\n            }\n            totalHeight += bitmapSize.height;\n            if (paneIndex < this._private__paneWidgets.length - 1) {\n                const separator = this._private__paneSeparators[paneIndex];\n                const separatorBitmapSize = separator._internal_getBitmapSize();\n                if (ctx !== null) {\n                    separator._internal_drawBitmap(ctx, totalWidth, totalHeight);\n                }\n                totalHeight += separatorBitmapSize.height;\n            }\n        }\n        const firstPaneBitmapWidth = firstPane._internal_getBitmapSize().width;\n        totalWidth += firstPaneBitmapWidth;\n        // draw right price scale if exists\n        if (this._private__isRightAxisVisible()) {\n            drawPriceAxises('right', totalWidth);\n            const rightAxisBitmapWidth = ensureNotNull(firstPane._internal_rightPriceAxisWidget())._internal_getBitmapSize().width;\n            totalWidth += rightAxisBitmapWidth;\n        }\n        const drawStub = (position, targetX, targetY) => {\n            const stub = ensureNotNull(position === 'left' ? this._private__timeAxisWidget._internal_leftStub() : this._private__timeAxisWidget._internal_rightStub());\n            stub._internal_drawBitmap(ensureNotNull(ctx), targetX, targetY);\n        };\n        // draw time scale and stubs\n        if (this._private__options.timeScale.visible) {\n            const timeAxisBitmapSize = this._private__timeAxisWidget._internal_getBitmapSize();\n            if (ctx !== null) {\n                let targetX = 0;\n                if (this._private__isLeftAxisVisible()) {\n                    drawStub('left', targetX, totalHeight);\n                    targetX = ensureNotNull(firstPane._internal_leftPriceAxisWidget())._internal_getBitmapSize().width;\n                }\n                this._private__timeAxisWidget._internal_drawBitmap(ctx, targetX, totalHeight);\n                targetX += timeAxisBitmapSize.width;\n                if (this._private__isRightAxisVisible()) {\n                    drawStub('right', targetX, totalHeight);\n                }\n            }\n            totalHeight += timeAxisBitmapSize.height;\n        }\n        return (0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({\n            width: totalWidth,\n            height: totalHeight,\n        });\n    }\n    // eslint-disable-next-line complexity\n    _private__adjustSizeImpl() {\n        let totalStretch = 0;\n        let leftPriceAxisWidth = 0;\n        let rightPriceAxisWidth = 0;\n        for (const paneWidget of this._private__paneWidgets) {\n            if (this._private__isLeftAxisVisible()) {\n                leftPriceAxisWidth = Math.max(leftPriceAxisWidth, ensureNotNull(paneWidget._internal_leftPriceAxisWidget())._internal_optimalWidth(), this._private__options.leftPriceScale.minimumWidth);\n            }\n            if (this._private__isRightAxisVisible()) {\n                rightPriceAxisWidth = Math.max(rightPriceAxisWidth, ensureNotNull(paneWidget._internal_rightPriceAxisWidget())._internal_optimalWidth(), this._private__options.rightPriceScale.minimumWidth);\n            }\n            totalStretch += paneWidget._internal_stretchFactor();\n        }\n        leftPriceAxisWidth = suggestPriceScaleWidth(leftPriceAxisWidth);\n        rightPriceAxisWidth = suggestPriceScaleWidth(rightPriceAxisWidth);\n        const width = this._private__width;\n        const height = this._private__height;\n        const paneWidth = Math.max(width - leftPriceAxisWidth - rightPriceAxisWidth, 0);\n        const separatorCount = this._private__paneSeparators.length;\n        const separatorHeight = 1 /* SeparatorConstants.SeparatorHeight */;\n        const separatorsHeight = separatorHeight * separatorCount;\n        const timeAxisVisible = this._private__options.timeScale.visible;\n        let timeAxisHeight = timeAxisVisible ? Math.max(this._private__timeAxisWidget._internal_optimalHeight(), this._private__options.timeScale.minimumHeight) : 0;\n        timeAxisHeight = suggestTimeScaleHeight(timeAxisHeight);\n        const otherWidgetHeight = separatorsHeight + timeAxisHeight;\n        const totalPaneHeight = height < otherWidgetHeight ? 0 : height - otherWidgetHeight;\n        const stretchPixels = totalPaneHeight / totalStretch;\n        let accumulatedHeight = 0;\n        const pixelRatio = window.devicePixelRatio || 1;\n        for (let paneIndex = 0; paneIndex < this._private__paneWidgets.length; ++paneIndex) {\n            const paneWidget = this._private__paneWidgets[paneIndex];\n            paneWidget._internal_setState(this._private__model._internal_panes()[paneIndex]);\n            let paneHeight = 0;\n            let calculatePaneHeight = 0;\n            if (paneIndex === this._private__paneWidgets.length - 1) {\n                calculatePaneHeight = Math.ceil((totalPaneHeight - accumulatedHeight) * pixelRatio) / pixelRatio;\n            }\n            else {\n                calculatePaneHeight = Math.round(paneWidget._internal_stretchFactor() * stretchPixels * pixelRatio) / pixelRatio;\n            }\n            paneHeight = Math.max(calculatePaneHeight, 2);\n            accumulatedHeight += paneHeight;\n            paneWidget._internal_setSize((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: paneWidth, height: paneHeight }));\n            if (this._private__isLeftAxisVisible()) {\n                paneWidget._internal_setPriceAxisSize(leftPriceAxisWidth, 'left');\n            }\n            if (this._private__isRightAxisVisible()) {\n                paneWidget._internal_setPriceAxisSize(rightPriceAxisWidth, 'right');\n            }\n            if (paneWidget._internal_state()) {\n                this._private__model._internal_setPaneHeight(paneWidget._internal_state(), paneHeight);\n            }\n        }\n        this._private__timeAxisWidget._internal_setSizes((0,fancy_canvas__WEBPACK_IMPORTED_MODULE_0__.size)({ width: timeAxisVisible ? paneWidth : 0, height: timeAxisHeight }), timeAxisVisible ? leftPriceAxisWidth : 0, timeAxisVisible ? rightPriceAxisWidth : 0);\n        this._private__model._internal_setWidth(paneWidth);\n        if (this._private__leftPriceAxisWidth !== leftPriceAxisWidth) {\n            this._private__leftPriceAxisWidth = leftPriceAxisWidth;\n        }\n        if (this._private__rightPriceAxisWidth !== rightPriceAxisWidth) {\n            this._private__rightPriceAxisWidth = rightPriceAxisWidth;\n        }\n    }\n    _private__setMouseWheelEventListener(add) {\n        if (add) {\n            this._private__element.addEventListener('wheel', this._private__onWheelBound, { passive: false });\n            return;\n        }\n        this._private__element.removeEventListener('wheel', this._private__onWheelBound);\n    }\n    _private__determineWheelSpeedAdjustment(event) {\n        switch (event.deltaMode) {\n            case event.DOM_DELTA_PAGE:\n                // one screen at time scroll mode\n                return 120;\n            case event.DOM_DELTA_LINE:\n                // one line at time scroll mode\n                return 32;\n        }\n        if (!windowsChrome) {\n            return 1;\n        }\n        // Chromium on Windows has a bug where the scroll speed isn't correctly\n        // adjusted for high density displays. We need to correct for this so that\n        // scroll speed is consistent between browsers.\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1001735\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1207308\n        return (1 / window.devicePixelRatio);\n    }\n    _private__onMousewheel(event) {\n        if ((event.deltaX === 0 || !this._private__options['handleScroll'].mouseWheel) &&\n            (event.deltaY === 0 || !this._private__options['handleScale'].mouseWheel)) {\n            return;\n        }\n        const scrollSpeedAdjustment = this._private__determineWheelSpeedAdjustment(event);\n        const deltaX = scrollSpeedAdjustment * event.deltaX / 100;\n        const deltaY = -(scrollSpeedAdjustment * event.deltaY / 100);\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        if (deltaY !== 0 && this._private__options['handleScale'].mouseWheel) {\n            const zoomScale = Math.sign(deltaY) * Math.min(1, Math.abs(deltaY));\n            const scrollPosition = event.clientX - this._private__element.getBoundingClientRect().left;\n            this._internal_model()._internal_zoomTime(scrollPosition, zoomScale);\n        }\n        if (deltaX !== 0 && this._private__options['handleScroll'].mouseWheel) {\n            this._internal_model()._internal_scrollChart(deltaX * -80); // 80 is a made up coefficient, and minus is for the \"natural\" scroll\n        }\n    }\n    _private__drawImpl(invalidateMask, time) {\n        const invalidationType = invalidateMask._internal_fullInvalidation();\n        // actions for full invalidation ONLY (not shared with light)\n        if (invalidationType === 3 /* InvalidationLevel.Full */) {\n            this._private__updateGui();\n        }\n        // light or full invalidate actions\n        if (invalidationType === 3 /* InvalidationLevel.Full */ ||\n            invalidationType === 2 /* InvalidationLevel.Light */) {\n            this._private__applyMomentaryAutoScale(invalidateMask);\n            this._private__applyTimeScaleInvalidations(invalidateMask, time);\n            this._private__timeAxisWidget._internal_update();\n            this._private__paneWidgets.forEach((pane) => {\n                pane._internal_updatePriceAxisWidgets();\n            });\n            // In the case a full invalidation has been postponed during the draw, reapply\n            // the timescale invalidations. A full invalidation would mean there is a change\n            // in the timescale width (caused by price scale changes) that needs to be drawn\n            // right away to avoid flickering.\n            if (this._private__invalidateMask?._internal_fullInvalidation() === 3 /* InvalidationLevel.Full */) {\n                this._private__invalidateMask._internal_merge(invalidateMask);\n                this._private__updateGui();\n                this._private__applyMomentaryAutoScale(this._private__invalidateMask);\n                this._private__applyTimeScaleInvalidations(this._private__invalidateMask, time);\n                invalidateMask = this._private__invalidateMask;\n                this._private__invalidateMask = null;\n            }\n        }\n        this._internal_paint(invalidateMask);\n    }\n    _private__applyTimeScaleInvalidations(invalidateMask, time) {\n        for (const tsInvalidation of invalidateMask._internal_timeScaleInvalidations()) {\n            this._private__applyTimeScaleInvalidation(tsInvalidation, time);\n        }\n    }\n    _private__applyMomentaryAutoScale(invalidateMask) {\n        const panes = this._private__model._internal_panes();\n        for (let i = 0; i < panes.length; i++) {\n            if (invalidateMask._internal_invalidateForPane(i)._internal_autoScale) {\n                panes[i]._internal_momentaryAutoScale();\n            }\n        }\n    }\n    _private__applyTimeScaleInvalidation(invalidation, time) {\n        const timeScale = this._private__model._internal_timeScale();\n        switch (invalidation._internal_type) {\n            case 0 /* TimeScaleInvalidationType.FitContent */:\n                timeScale._internal_fitContent();\n                break;\n            case 1 /* TimeScaleInvalidationType.ApplyRange */:\n                timeScale._internal_setLogicalRange(invalidation._internal_value);\n                break;\n            case 2 /* TimeScaleInvalidationType.ApplyBarSpacing */:\n                timeScale._internal_setBarSpacing(invalidation._internal_value);\n                break;\n            case 3 /* TimeScaleInvalidationType.ApplyRightOffset */:\n                timeScale._internal_setRightOffset(invalidation._internal_value);\n                break;\n            case 4 /* TimeScaleInvalidationType.Reset */:\n                timeScale._internal_restoreDefault();\n                break;\n            case 5 /* TimeScaleInvalidationType.Animation */:\n                if (!invalidation._internal_value._internal_finished(time)) {\n                    timeScale._internal_setRightOffset(invalidation._internal_value._internal_getPosition(time));\n                }\n                break;\n        }\n    }\n    _private__invalidateHandler(invalidateMask) {\n        if (this._private__invalidateMask !== null) {\n            this._private__invalidateMask._internal_merge(invalidateMask);\n        }\n        else {\n            this._private__invalidateMask = invalidateMask;\n        }\n        if (!this._private__drawPlanned) {\n            this._private__drawPlanned = true;\n            this._private__drawRafId = window.requestAnimationFrame((time) => {\n                this._private__drawPlanned = false;\n                this._private__drawRafId = 0;\n                if (this._private__invalidateMask !== null) {\n                    const mask = this._private__invalidateMask;\n                    this._private__invalidateMask = null;\n                    this._private__drawImpl(mask, time);\n                    for (const tsInvalidation of mask._internal_timeScaleInvalidations()) {\n                        if (tsInvalidation._internal_type === 5 /* TimeScaleInvalidationType.Animation */ && !tsInvalidation._internal_value._internal_finished(time)) {\n                            this._internal_model()._internal_setTimeScaleAnimation(tsInvalidation._internal_value);\n                            break;\n                        }\n                    }\n                }\n            });\n        }\n    }\n    _private__updateGui() {\n        this._private__syncGuiWithModel();\n    }\n    _private__destroySeparator(separator) {\n        this._private__tableElement.removeChild(separator._internal_getElement());\n        separator._internal_destroy();\n    }\n    _private__syncGuiWithModel() {\n        const panes = this._private__model._internal_panes();\n        const targetPaneWidgetsCount = panes.length;\n        const actualPaneWidgetsCount = this._private__paneWidgets.length;\n        // Remove (if needed) pane widgets and separators\n        for (let i = targetPaneWidgetsCount; i < actualPaneWidgetsCount; i++) {\n            const paneWidget = ensureDefined(this._private__paneWidgets.pop());\n            this._private__tableElement.removeChild(paneWidget._internal_getElement());\n            paneWidget._internal_clicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_dblClicked()._internal_unsubscribeAll(this);\n            paneWidget._internal_destroy();\n            const paneSeparator = this._private__paneSeparators.pop();\n            if (paneSeparator !== undefined) {\n                this._private__destroySeparator(paneSeparator);\n            }\n        }\n        // Create (if needed) new pane widgets and separators\n        for (let i = actualPaneWidgetsCount; i < targetPaneWidgetsCount; i++) {\n            const paneWidget = new PaneWidget(this, panes[i]);\n            paneWidget._internal_clicked()._internal_subscribe(this._private__onPaneWidgetClicked.bind(this, paneWidget), this);\n            paneWidget._internal_dblClicked()._internal_subscribe(this._private__onPaneWidgetDblClicked.bind(this, paneWidget), this);\n            this._private__paneWidgets.push(paneWidget);\n            // create and insert separator\n            if (i > 0) {\n                const paneSeparator = new PaneSeparator(this, i - 1, i);\n                this._private__paneSeparators.push(paneSeparator);\n                this._private__tableElement.insertBefore(paneSeparator._internal_getElement(), this._private__timeAxisWidget._internal_getElement());\n            }\n            // insert paneWidget\n            this._private__tableElement.insertBefore(paneWidget._internal_getElement(), this._private__timeAxisWidget._internal_getElement());\n        }\n        for (let i = 0; i < targetPaneWidgetsCount; i++) {\n            const state = panes[i];\n            const paneWidget = this._private__paneWidgets[i];\n            if (paneWidget._internal_state() !== state) {\n                paneWidget._internal_setState(state);\n            }\n            else {\n                paneWidget._internal_updatePriceAxisWidgetsStates();\n            }\n        }\n        this._private__updateTimeAxisVisibility();\n        this._private__adjustSizeImpl();\n    }\n    _private__getMouseEventParamsImpl(index, point, event, pane) {\n        const seriesData = new Map();\n        if (index !== null) {\n            const serieses = this._private__model._internal_serieses();\n            serieses.forEach((s) => {\n                // TODO: replace with search left\n                const data = s._internal_bars()._internal_search(index);\n                if (data !== null) {\n                    seriesData.set(s, data);\n                }\n            });\n        }\n        let clientTime;\n        if (index !== null) {\n            const timePoint = this._private__model._internal_timeScale()._internal_indexToTimeScalePoint(index)?.originalTime;\n            if (timePoint !== undefined) {\n                clientTime = timePoint;\n            }\n        }\n        const hoveredSource = this._internal_model()._internal_hoveredSource();\n        const hoveredSeries = hoveredSource !== null && hoveredSource._internal_source instanceof Series\n            ? hoveredSource._internal_source\n            : undefined;\n        const hoveredObject = hoveredSource !== null && hoveredSource._internal_object !== undefined\n            ? hoveredSource._internal_object._internal_externalId\n            : undefined;\n        const paneIndex = this._private__getPaneIndex(pane);\n        return {\n            _internal_originalTime: clientTime,\n            _internal_index: index ?? undefined,\n            _internal_point: point ?? undefined,\n            _internal_paneIndex: paneIndex !== -1 ? paneIndex : undefined,\n            _internal_hoveredSeries: hoveredSeries,\n            _internal_seriesData: seriesData,\n            _internal_hoveredObject: hoveredObject,\n            _internal_touchMouseEventData: event ?? undefined,\n        };\n    }\n    _private__getPaneIndex(pane) {\n        let paneIndex = -1;\n        if (pane) {\n            paneIndex = this._private__paneWidgets.indexOf(pane);\n        }\n        else {\n            const crosshairPane = this._internal_model()._internal_crosshairSource()._internal_pane();\n            if (crosshairPane !== null) {\n                paneIndex = this._internal_model()._internal_panes().indexOf(crosshairPane);\n            }\n        }\n        return paneIndex;\n    }\n    _private__onPaneWidgetClicked(pane, time, point, event) {\n        this._private__clicked._internal_fire(() => this._private__getMouseEventParamsImpl(time, point, event, pane));\n    }\n    _private__onPaneWidgetDblClicked(pane, time, point, event) {\n        this._private__dblClicked._internal_fire(() => this._private__getMouseEventParamsImpl(time, point, event, pane));\n    }\n    _private__onPaneWidgetCrosshairMoved(time, point, event) {\n        this._internal_setCursorStyle(this._internal_model()._internal_hoveredSource()?._internal_cursorStyle ?? null);\n        this._private__crosshairMoved._internal_fire(() => this._private__getMouseEventParamsImpl(time, point, event));\n    }\n    _private__updateTimeAxisVisibility() {\n        const display = this._private__options.timeScale.visible ? '' : 'none';\n        this._private__timeAxisWidget._internal_getElement().style.display = display;\n    }\n    _private__isLeftAxisVisible() {\n        return this._private__paneWidgets[0]._internal_state()._internal_leftPriceScale()._internal_options().visible;\n    }\n    _private__isRightAxisVisible() {\n        return this._private__paneWidgets[0]._internal_state()._internal_rightPriceScale()._internal_options().visible;\n    }\n    _private__installObserver() {\n        // eslint-disable-next-line no-restricted-syntax\n        if (!('ResizeObserver' in window)) {\n            warn('Options contains \"autoSize\" flag, but the browser does not support ResizeObserver feature. Please provide polyfill.');\n            return false;\n        }\n        else {\n            this._private__observer = new ResizeObserver((entries) => {\n                // There is no need to check if entry.target === this._container since there is only\n                // a single element being observed.\n                // and we want to use the last entry (if multiple) because it would be most up to date\n                // (since the browser may batch multiple updates).\n                const containerEntry = entries[entries.length - 1];\n                if (!containerEntry) {\n                    // this may be undefined if the entries array was empty.\n                    return;\n                }\n                this._internal_resize(containerEntry.contentRect.width, containerEntry.contentRect.height);\n            });\n            this._private__observer.observe(this._private__container, { box: 'border-box' });\n            return true;\n        }\n    }\n    _private__uninstallObserver() {\n        if (this._private__observer !== null) {\n            this._private__observer.disconnect();\n        }\n        this._private__observer = null;\n    }\n}\nfunction disableSelection(element) {\n    element.style.userSelect = 'none';\n    // eslint-disable-next-line deprecation/deprecation\n    element.style.webkitUserSelect = 'none';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-member-access\n    element.style.msUserSelect = 'none';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-member-access\n    element.style.MozUserSelect = 'none';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-member-access\n    element.style.webkitTapHighlightColor = 'transparent';\n}\nfunction shouldSubscribeMouseWheel(options) {\n    return Boolean(options['handleScroll'].mouseWheel || options['handleScale'].mouseWheel);\n}\n\nfunction isWhitespaceData(data) {\n    return data.open === undefined && data.value === undefined;\n}\nfunction isFulfilledData(data) {\n    return isFulfilledBarData(data) || isFulfilledLineData(data);\n}\nfunction isFulfilledBarData(data) {\n    return data.open !== undefined;\n}\nfunction isFulfilledLineData(data) {\n    return data.value !== undefined;\n}\n\nfunction getColoredLineBasedSeriesPlotRow(time, index, item, originalTime) {\n    const val = item.value;\n    const res = { _internal_index: index, _internal_time: time, _internal_value: [val, val, val, val], _internal_originalTime: originalTime };\n    if (item.color !== undefined) {\n        res._internal_color = item.color;\n    }\n    return res;\n}\nfunction getAreaSeriesPlotRow(time, index, item, originalTime) {\n    const val = item.value;\n    const res = { _internal_index: index, _internal_time: time, _internal_value: [val, val, val, val], _internal_originalTime: originalTime };\n    if (item.lineColor !== undefined) {\n        res._internal_lineColor = item.lineColor;\n    }\n    if (item.topColor !== undefined) {\n        res._internal_topColor = item.topColor;\n    }\n    if (item.bottomColor !== undefined) {\n        res._internal_bottomColor = item.bottomColor;\n    }\n    return res;\n}\nfunction getBaselineSeriesPlotRow(time, index, item, originalTime) {\n    const val = item.value;\n    const res = { _internal_index: index, _internal_time: time, _internal_value: [val, val, val, val], _internal_originalTime: originalTime };\n    if (item.topLineColor !== undefined) {\n        res._internal_topLineColor = item.topLineColor;\n    }\n    if (item.bottomLineColor !== undefined) {\n        res._internal_bottomLineColor = item.bottomLineColor;\n    }\n    if (item.topFillColor1 !== undefined) {\n        res._internal_topFillColor1 = item.topFillColor1;\n    }\n    if (item.topFillColor2 !== undefined) {\n        res._internal_topFillColor2 = item.topFillColor2;\n    }\n    if (item.bottomFillColor1 !== undefined) {\n        res._internal_bottomFillColor1 = item.bottomFillColor1;\n    }\n    if (item.bottomFillColor2 !== undefined) {\n        res._internal_bottomFillColor2 = item.bottomFillColor2;\n    }\n    return res;\n}\nfunction getBarSeriesPlotRow(time, index, item, originalTime) {\n    const res = { _internal_index: index, _internal_time: time, _internal_value: [item.open, item.high, item.low, item.close], _internal_originalTime: originalTime };\n    if (item.color !== undefined) {\n        res._internal_color = item.color;\n    }\n    return res;\n}\nfunction getCandlestickSeriesPlotRow(time, index, item, originalTime) {\n    const res = { _internal_index: index, _internal_time: time, _internal_value: [item.open, item.high, item.low, item.close], _internal_originalTime: originalTime };\n    if (item.color !== undefined) {\n        res._internal_color = item.color;\n    }\n    if (item.borderColor !== undefined) {\n        res._internal_borderColor = item.borderColor;\n    }\n    if (item.wickColor !== undefined) {\n        res._internal_wickColor = item.wickColor;\n    }\n    return res;\n}\nfunction getCustomSeriesPlotRow(time, index, item, originalTime, dataToPlotRow) {\n    const values = ensureDefined(dataToPlotRow)(item);\n    const max = Math.max(...values);\n    const min = Math.min(...values);\n    const last = values[values.length - 1];\n    const value = [last, max, min, last];\n    const { time: excludedTime, color, ...data } = item;\n    return { _internal_index: index, _internal_time: time, _internal_value: value, _internal_originalTime: originalTime, _internal_data: data, _internal_color: color };\n}\nfunction isSeriesPlotRow(row) {\n    return row._internal_value !== undefined;\n}\nfunction wrapCustomValues(plotRow, bar) {\n    if (bar.customValues !== undefined) {\n        plotRow._internal_customValues = bar.customValues;\n    }\n    return plotRow;\n}\nfunction isWhitespaceDataWithCustomCheck(bar, customIsWhitespace) {\n    if (customIsWhitespace) {\n        return customIsWhitespace(bar);\n    }\n    return isWhitespaceData(bar);\n}\nfunction wrapWhitespaceData(createPlotRowFn) {\n    return (time, index, bar, originalTime, dataToPlotRow, customIsWhitespace) => {\n        if (isWhitespaceDataWithCustomCheck(bar, customIsWhitespace)) {\n            return wrapCustomValues({ _internal_time: time, _internal_index: index, _internal_originalTime: originalTime }, bar);\n        }\n        return wrapCustomValues(createPlotRowFn(time, index, bar, originalTime, dataToPlotRow), bar);\n    };\n}\nfunction getSeriesPlotRowCreator(seriesType) {\n    const seriesPlotRowFnMap = {\n        Candlestick: wrapWhitespaceData(getCandlestickSeriesPlotRow),\n        Bar: wrapWhitespaceData(getBarSeriesPlotRow),\n        Area: wrapWhitespaceData(getAreaSeriesPlotRow),\n        Baseline: wrapWhitespaceData(getBaselineSeriesPlotRow),\n        Histogram: wrapWhitespaceData(getColoredLineBasedSeriesPlotRow),\n        Line: wrapWhitespaceData(getColoredLineBasedSeriesPlotRow),\n        Custom: wrapWhitespaceData(getCustomSeriesPlotRow),\n    };\n    return seriesPlotRowFnMap[seriesType];\n}\n\n/// <reference types=\"_build-time-constants\" />\nfunction createEmptyTimePointData(timePoint) {\n    return { _internal_index: 0, _internal_mapping: new Map(), _internal_timePoint: timePoint };\n}\nfunction seriesRowsFirstAndLastTime(seriesRows, bh) {\n    if (seriesRows === undefined || seriesRows.length === 0) {\n        return undefined;\n    }\n    return {\n        _internal_firstTime: bh.key(seriesRows[0]._internal_time),\n        _internal_lastTime: bh.key(seriesRows[seriesRows.length - 1]._internal_time),\n    };\n}\nfunction seriesUpdateInfo(seriesRows, prevSeriesRows, bh) {\n    const firstAndLastTime = seriesRowsFirstAndLastTime(seriesRows, bh);\n    const prevFirstAndLastTime = seriesRowsFirstAndLastTime(prevSeriesRows, bh);\n    if (firstAndLastTime !== undefined && prevFirstAndLastTime !== undefined) {\n        return {\n            _internal_historicalUpdate: false,\n            _internal_lastBarUpdatedOrNewBarsAddedToTheRight: firstAndLastTime._internal_lastTime >= prevFirstAndLastTime._internal_lastTime &&\n                firstAndLastTime._internal_firstTime >= prevFirstAndLastTime._internal_firstTime,\n        };\n    }\n    return undefined;\n}\nfunction timeScalePointTime(mergedPointData) {\n    let result;\n    mergedPointData.forEach((v) => {\n        if (result === undefined) {\n            result = v._internal_originalTime;\n        }\n    });\n    return ensureDefined(result);\n}\nfunction saveOriginalTime(data) {\n    if (data._internal_originalTime === undefined) {\n        data._internal_originalTime = data.time;\n    }\n}\nclass DataLayer {\n    constructor(horzScaleBehavior) {\n        // note that _pointDataByTimePoint and _seriesRowsBySeries shares THE SAME objects in their values between each other\n        // it's just different kind of maps to make usages/perf better\n        this._private__pointDataByTimePoint = new Map();\n        this._private__seriesRowsBySeries = new Map();\n        this._private__seriesLastTimePoint = new Map();\n        // this is kind of \"dest\" values (in opposite to \"source\" ones) - we don't need to modify it manually, the only by calling _updateTimeScalePoints or updateSeriesData methods\n        this._private__sortedTimePoints = [];\n        this._private__horzScaleBehavior = horzScaleBehavior;\n    }\n    _internal_destroy() {\n        this._private__pointDataByTimePoint.clear();\n        this._private__seriesRowsBySeries.clear();\n        this._private__seriesLastTimePoint.clear();\n        this._private__sortedTimePoints = [];\n    }\n    _internal_setSeriesData(series, data) {\n        let needCleanupPoints = this._private__pointDataByTimePoint.size !== 0;\n        let isTimeScaleAffected = false;\n        // save previous series rows data before it's replaced inside this._setRowsToSeries\n        const prevSeriesRows = this._private__seriesRowsBySeries.get(series);\n        if (prevSeriesRows !== undefined) {\n            if (this._private__seriesRowsBySeries.size === 1) {\n                needCleanupPoints = false;\n                isTimeScaleAffected = true;\n                // perf optimization - if there is only 1 series, then we can just clear and fill everything from scratch\n                this._private__pointDataByTimePoint.clear();\n            }\n            else {\n                // perf optimization - actually we have to use this._pointDataByTimePoint for going through here\n                // but as soon as this._sortedTimePoints is just a different form of _pointDataByTimePoint we can use it as well\n                for (const point of this._private__sortedTimePoints) {\n                    if (point.pointData._internal_mapping.delete(series)) {\n                        isTimeScaleAffected = true;\n                    }\n                }\n            }\n        }\n        let seriesRows = [];\n        if (data.length !== 0) {\n            const originalTimes = data.map((d) => d.time);\n            const timeConverter = this._private__horzScaleBehavior.createConverterToInternalObj(data);\n            const createPlotRow = getSeriesPlotRowCreator(series._internal_seriesType());\n            const dataToPlotRow = series._internal_customSeriesPlotValuesBuilder();\n            const customWhitespaceChecker = series._internal_customSeriesWhitespaceCheck();\n            seriesRows = data.map((item, index) => {\n                const time = timeConverter(item.time);\n                const horzItemKey = this._private__horzScaleBehavior.key(time);\n                let timePointData = this._private__pointDataByTimePoint.get(horzItemKey);\n                if (timePointData === undefined) {\n                    // the indexes will be sync later\n                    timePointData = createEmptyTimePointData(time);\n                    this._private__pointDataByTimePoint.set(horzItemKey, timePointData);\n                    isTimeScaleAffected = true;\n                }\n                const row = createPlotRow(time, timePointData._internal_index, item, originalTimes[index], dataToPlotRow, customWhitespaceChecker);\n                timePointData._internal_mapping.set(series, row);\n                return row;\n            });\n        }\n        if (needCleanupPoints) {\n            // we deleted the old data from mapping and added the new ones\n            // so there might be empty points now, let's remove them first\n            this._private__cleanupPointsData();\n        }\n        this._private__setRowsToSeries(series, seriesRows);\n        let firstChangedPointIndex = -1;\n        if (isTimeScaleAffected) {\n            // then generate the time scale points\n            // timeWeight will be updates in _updateTimeScalePoints later\n            const newTimeScalePoints = [];\n            this._private__pointDataByTimePoint.forEach((pointData) => {\n                newTimeScalePoints.push({\n                    timeWeight: 0,\n                    time: pointData._internal_timePoint,\n                    pointData,\n                    originalTime: timeScalePointTime(pointData._internal_mapping),\n                });\n            });\n            newTimeScalePoints.sort((t1, t2) => this._private__horzScaleBehavior.key(t1.time) - this._private__horzScaleBehavior.key(t2.time));\n            firstChangedPointIndex = this._private__replaceTimeScalePoints(newTimeScalePoints);\n        }\n        return this._private__getUpdateResponse(series, firstChangedPointIndex, seriesUpdateInfo(this._private__seriesRowsBySeries.get(series), prevSeriesRows, this._private__horzScaleBehavior));\n    }\n    _internal_removeSeries(series) {\n        return this._internal_setSeriesData(series, []);\n    }\n    _internal_updateSeriesData(series, data, historicalUpdate) {\n        const extendedData = data;\n        saveOriginalTime(extendedData);\n        // convertStringToBusinessDay(data);\n        this._private__horzScaleBehavior.preprocessData(data);\n        const timeConverter = this._private__horzScaleBehavior.createConverterToInternalObj([data]);\n        const time = timeConverter(data.time);\n        const lastSeriesTime = this._private__seriesLastTimePoint.get(series);\n        if (!historicalUpdate && lastSeriesTime !== undefined && this._private__horzScaleBehavior.key(time) < this._private__horzScaleBehavior.key(lastSeriesTime)) {\n            // eslint-disable-next-line @typescript-eslint/no-base-to-string\n            throw new Error(`Cannot update oldest data, last time=${lastSeriesTime}, new time=${time}`);\n        }\n        let pointDataAtTime = this._private__pointDataByTimePoint.get(this._private__horzScaleBehavior.key(time));\n        if (historicalUpdate && pointDataAtTime === undefined) {\n            throw new Error('Cannot update non-existing data point when historicalUpdate is true');\n        }\n        // if no point data found for the new data item\n        // that means that we need to update scale\n        const affectsTimeScale = pointDataAtTime === undefined;\n        if (pointDataAtTime === undefined) {\n            // the indexes will be sync later\n            pointDataAtTime = createEmptyTimePointData(time);\n            this._private__pointDataByTimePoint.set(this._private__horzScaleBehavior.key(time), pointDataAtTime);\n        }\n        const createPlotRow = getSeriesPlotRowCreator(series._internal_seriesType());\n        const dataToPlotRow = series._internal_customSeriesPlotValuesBuilder();\n        const customWhitespaceChecker = series._internal_customSeriesWhitespaceCheck();\n        const plotRow = createPlotRow(time, pointDataAtTime._internal_index, data, extendedData._internal_originalTime, dataToPlotRow, customWhitespaceChecker);\n        pointDataAtTime._internal_mapping.set(series, plotRow);\n        if (historicalUpdate) {\n            this._private__updateHistoricalSeriesRow(series, plotRow, pointDataAtTime._internal_index);\n        }\n        else {\n            this._private__updateLastSeriesRow(series, plotRow);\n        }\n        const info = {\n            _internal_lastBarUpdatedOrNewBarsAddedToTheRight: isSeriesPlotRow(plotRow),\n            _internal_historicalUpdate: historicalUpdate,\n        };\n        // if point already exist on the time scale - we don't need to make a full update and just make an incremental one\n        if (!affectsTimeScale) {\n            return this._private__getUpdateResponse(series, -1, info);\n        }\n        const newPoint = {\n            timeWeight: 0,\n            time: pointDataAtTime._internal_timePoint,\n            pointData: pointDataAtTime,\n            originalTime: timeScalePointTime(pointDataAtTime._internal_mapping),\n        };\n        const insertIndex = lowerBound(this._private__sortedTimePoints, this._private__horzScaleBehavior.key(newPoint.time), (a, b) => this._private__horzScaleBehavior.key(a.time) < b);\n        // yes, I know that this array is readonly and this change is intended to make it performative\n        // we marked _sortedTimePoints array as readonly to avoid modifying this array anywhere else\n        // but this place is exceptional case due performance reasons, sorry\n        this._private__sortedTimePoints.splice(insertIndex, 0, newPoint);\n        for (let index = insertIndex; index < this._private__sortedTimePoints.length; ++index) {\n            assignIndexToPointData(this._private__sortedTimePoints[index].pointData, index);\n        }\n        this._private__horzScaleBehavior.fillWeightsForPoints(this._private__sortedTimePoints, insertIndex);\n        return this._private__getUpdateResponse(series, insertIndex, info);\n    }\n    _private__updateLastSeriesRow(series, plotRow) {\n        let seriesData = this._private__seriesRowsBySeries.get(series);\n        if (seriesData === undefined) {\n            seriesData = [];\n            this._private__seriesRowsBySeries.set(series, seriesData);\n        }\n        const lastSeriesRow = seriesData.length !== 0 ? seriesData[seriesData.length - 1] : null;\n        if (lastSeriesRow === null || this._private__horzScaleBehavior.key(plotRow._internal_time) > this._private__horzScaleBehavior.key(lastSeriesRow._internal_time)) {\n            if (isSeriesPlotRow(plotRow)) {\n                seriesData.push(plotRow);\n            }\n        }\n        else {\n            if (isSeriesPlotRow(plotRow)) {\n                seriesData[seriesData.length - 1] = plotRow;\n            }\n            else {\n                seriesData.splice(-1, 1);\n            }\n        }\n        this._private__seriesLastTimePoint.set(series, plotRow._internal_time);\n    }\n    _private__updateHistoricalSeriesRow(series, plotRow, pointDataIndex) {\n        const seriesData = this._private__seriesRowsBySeries.get(series);\n        if (seriesData === undefined) {\n            return;\n        }\n        // binary search for actual index in array.\n        const index = lowerBound(seriesData, pointDataIndex, (row, currentIndex) => row._internal_index < currentIndex);\n        if (isSeriesPlotRow(plotRow)) {\n            seriesData[index] = plotRow;\n        }\n        else {\n            seriesData.splice(index, 1);\n        }\n    }\n    _private__setRowsToSeries(series, seriesRows) {\n        if (seriesRows.length !== 0) {\n            this._private__seriesRowsBySeries.set(series, seriesRows.filter(isSeriesPlotRow));\n            this._private__seriesLastTimePoint.set(series, seriesRows[seriesRows.length - 1]._internal_time);\n        }\n        else {\n            this._private__seriesRowsBySeries.delete(series);\n            this._private__seriesLastTimePoint.delete(series);\n        }\n    }\n    _private__cleanupPointsData() {\n        // let's treat all current points as \"potentially removed\"\n        // we could create an array with actually potentially removed points\n        // but most likely this array will be similar to _sortedTimePoints so let's avoid using additional memory\n        // note that we can use _sortedTimePoints here since a point might be removed only it was here previously\n        for (const point of this._private__sortedTimePoints) {\n            if (point.pointData._internal_mapping.size === 0) {\n                this._private__pointDataByTimePoint.delete(this._private__horzScaleBehavior.key(point.time));\n            }\n        }\n    }\n    /**\n     * Sets new time scale and make indexes valid for all series\n     *\n     * @returns The index of the first changed point or `-1` if there is no change.\n     */\n    _private__replaceTimeScalePoints(newTimePoints) {\n        let firstChangedPointIndex = -1;\n        // search the first different point and \"syncing\" time weight by the way\n        for (let index = 0; index < this._private__sortedTimePoints.length && index < newTimePoints.length; ++index) {\n            const oldPoint = this._private__sortedTimePoints[index];\n            const newPoint = newTimePoints[index];\n            if (this._private__horzScaleBehavior.key(oldPoint.time) !== this._private__horzScaleBehavior.key(newPoint.time)) {\n                firstChangedPointIndex = index;\n                break;\n            }\n            // re-assign point's time weight for points if time is the same (and all prior times was the same)\n            newPoint.timeWeight = oldPoint.timeWeight;\n            assignIndexToPointData(newPoint.pointData, index);\n        }\n        if (firstChangedPointIndex === -1 && this._private__sortedTimePoints.length !== newTimePoints.length) {\n            // the common part of the prev and the new points are the same\n            // so the first changed point is the next after the common part\n            firstChangedPointIndex = Math.min(this._private__sortedTimePoints.length, newTimePoints.length);\n        }\n        if (firstChangedPointIndex === -1) {\n            // if no time scale changed, then do nothing\n            return -1;\n        }\n        // if time scale points are changed that means that we need to make full update to all series (with clearing points)\n        // but first we need to synchronize indexes and re-fill time weights\n        for (let index = firstChangedPointIndex; index < newTimePoints.length; ++index) {\n            assignIndexToPointData(newTimePoints[index].pointData, index);\n        }\n        // re-fill time weights for point after the first changed one\n        this._private__horzScaleBehavior.fillWeightsForPoints(newTimePoints, firstChangedPointIndex);\n        this._private__sortedTimePoints = newTimePoints;\n        return firstChangedPointIndex;\n    }\n    _private__getBaseIndex() {\n        if (this._private__seriesRowsBySeries.size === 0) {\n            // if we have no data then 'reset' the base index to null\n            return null;\n        }\n        let baseIndex = 0;\n        this._private__seriesRowsBySeries.forEach((data) => {\n            if (data.length !== 0) {\n                baseIndex = Math.max(baseIndex, data[data.length - 1]._internal_index);\n            }\n        });\n        return baseIndex;\n    }\n    _private__getUpdateResponse(updatedSeries, firstChangedPointIndex, info) {\n        const dataUpdateResponse = {\n            _internal_series: new Map(),\n            _internal_timeScale: {\n                _internal_baseIndex: this._private__getBaseIndex(),\n            },\n        };\n        if (firstChangedPointIndex !== -1) {\n            // TODO: it's possible to make perf improvements by checking what series has data after firstChangedPointIndex\n            // but let's skip for now\n            this._private__seriesRowsBySeries.forEach((data, s) => {\n                dataUpdateResponse._internal_series.set(s, {\n                    _internal_data: data,\n                    _internal_info: s === updatedSeries ? info : undefined,\n                });\n            });\n            // if the series data was set to [] it will have already been removed from _seriesRowBySeries\n            // meaning the forEach above won't add the series to the data update response\n            // so we handle that case here\n            if (!this._private__seriesRowsBySeries.has(updatedSeries)) {\n                dataUpdateResponse._internal_series.set(updatedSeries, { _internal_data: [], _internal_info: info });\n            }\n            dataUpdateResponse._internal_timeScale._internal_points = this._private__sortedTimePoints;\n            dataUpdateResponse._internal_timeScale._internal_firstChangedPointIndex = firstChangedPointIndex;\n        }\n        else {\n            const seriesData = this._private__seriesRowsBySeries.get(updatedSeries);\n            // if no seriesData found that means that we just removed the series\n            dataUpdateResponse._internal_series.set(updatedSeries, { _internal_data: seriesData || [], _internal_info: info });\n        }\n        return dataUpdateResponse;\n    }\n}\nfunction assignIndexToPointData(pointData, index) {\n    // first, nevertheless update index of point data (\"make it valid\")\n    pointData._internal_index = index;\n    // and then we need to sync indexes for all series\n    pointData._internal_mapping.forEach((seriesRow) => {\n        seriesRow._internal_index = index;\n    });\n}\n\nfunction lowerBoundItemsCompare(item, time) {\n    return item._internal_time < time;\n}\nfunction upperBoundItemsCompare(item, time) {\n    return time < item._internal_time;\n}\nfunction visibleTimedValues(items, range, extendedRange) {\n    const firstBar = range._internal_left();\n    const lastBar = range._internal_right();\n    const from = lowerBound(items, firstBar, lowerBoundItemsCompare);\n    const to = upperBound(items, lastBar, upperBoundItemsCompare);\n    if (!extendedRange) {\n        return { from, to };\n    }\n    let extendedFrom = from;\n    let extendedTo = to;\n    if (from > 0 && from < items.length && items[from]._internal_time >= firstBar) {\n        extendedFrom = from - 1;\n    }\n    if (to > 0 && to < items.length && items[to - 1]._internal_time <= lastBar) {\n        extendedTo = to + 1;\n    }\n    return { from: extendedFrom, to: extendedTo };\n}\n\nclass SeriesPaneViewBase {\n    constructor(series, model, extendedVisibleRange) {\n        this._internal__invalidated = true;\n        this._internal__dataInvalidated = true;\n        this._internal__optionsInvalidated = true;\n        this._internal__items = [];\n        this._internal__itemsVisibleRange = null;\n        this._internal__series = series;\n        this._internal__model = model;\n        this._private__extendedVisibleRange = extendedVisibleRange;\n    }\n    _internal_update(updateType) {\n        this._internal__invalidated = true;\n        if (updateType === 'data') {\n            this._internal__dataInvalidated = true;\n        }\n        if (updateType === 'options') {\n            this._internal__optionsInvalidated = true;\n        }\n    }\n    _internal_renderer() {\n        if (!this._internal__series._internal_visible()) {\n            return null;\n        }\n        this._private__makeValid();\n        return this._internal__itemsVisibleRange === null ? null : this._internal__renderer;\n    }\n    _internal__updateOptions() {\n        this._internal__items = this._internal__items.map((item) => ({\n            ...item,\n            ...this._internal__series._internal_barColorer()._internal_barStyle(item._internal_time),\n        }));\n    }\n    _internal__clearVisibleRange() {\n        this._internal__itemsVisibleRange = null;\n    }\n    _private__makeValid() {\n        if (this._internal__dataInvalidated) {\n            this._internal__fillRawPoints();\n            this._internal__dataInvalidated = false;\n        }\n        if (this._internal__optionsInvalidated) {\n            this._internal__updateOptions();\n            this._internal__optionsInvalidated = false;\n        }\n        if (this._internal__invalidated) {\n            this._private__makeValidImpl();\n            this._internal__invalidated = false;\n        }\n    }\n    _private__makeValidImpl() {\n        const priceScale = this._internal__series._internal_priceScale();\n        const timeScale = this._internal__model._internal_timeScale();\n        this._internal__clearVisibleRange();\n        if (timeScale._internal_isEmpty() || priceScale._internal_isEmpty()) {\n            return;\n        }\n        const visibleBars = timeScale._internal_visibleStrictRange();\n        if (visibleBars === null) {\n            return;\n        }\n        if (this._internal__series._internal_bars()._internal_size() === 0) {\n            return;\n        }\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return;\n        }\n        this._internal__itemsVisibleRange = visibleTimedValues(this._internal__items, visibleBars, this._private__extendedVisibleRange);\n        this._internal__convertToCoordinates(priceScale, timeScale, firstValue._internal_value);\n        this._internal__prepareRendererData();\n    }\n}\n\nclass CustomSeriesPaneRendererWrapper {\n    constructor(sourceRenderer, priceScale) {\n        this._private__sourceRenderer = sourceRenderer;\n        this._private__priceScale = priceScale;\n    }\n    _internal_draw(target, isHovered, hitTestData) {\n        this._private__sourceRenderer.draw(target, this._private__priceScale, isHovered, hitTestData);\n    }\n}\nclass SeriesCustomPaneView extends SeriesPaneViewBase {\n    constructor(series, model, paneView) {\n        super(series, model, false);\n        this._private__paneView = paneView;\n        this._internal__renderer = new CustomSeriesPaneRendererWrapper(this._private__paneView.renderer(), (price) => {\n            const firstValue = series._internal_firstValue();\n            if (firstValue === null) {\n                return null;\n            }\n            return series._internal_priceScale()._internal_priceToCoordinate(price, firstValue._internal_value);\n        });\n    }\n    _internal_priceValueBuilder(plotRow) {\n        return this._private__paneView.priceValueBuilder(plotRow);\n    }\n    _internal_isWhitespace(data) {\n        return this._private__paneView.isWhitespace(data);\n    }\n    _internal__fillRawPoints() {\n        const colorer = this._internal__series._internal_barColorer();\n        this._internal__items = this._internal__series._internal_bars()._internal_rows()\n            .map((row) => {\n            return {\n                _internal_time: row._internal_index,\n                _internal_x: NaN,\n                ...colorer._internal_barStyle(row._internal_index),\n                _internal_originalData: row._internal_data,\n            };\n        });\n    }\n    _internal__convertToCoordinates(priceScale, timeScale) {\n        timeScale._internal_indexesToCoordinates(this._internal__items, undefinedIfNull(this._internal__itemsVisibleRange));\n    }\n    _internal__prepareRendererData() {\n        this._private__paneView.update({\n            bars: this._internal__items.map(unwrapItemData),\n            barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            visibleRange: this._internal__itemsVisibleRange,\n        }, this._internal__series._internal_options());\n    }\n}\nfunction unwrapItemData(item) {\n    return {\n        x: item._internal_x,\n        time: item._internal_time,\n        originalData: item._internal_originalData,\n        barColor: item._internal_barColor,\n    };\n}\n\nconst customStyleDefaults = {\n    color: '#2196f3',\n};\nconst createPaneView$6 = (series, model, customPaneView) => {\n    const paneView = ensure(customPaneView);\n    return new SeriesCustomPaneView(series, model, paneView);\n};\nconst createCustomSeriesDefinition = (paneView) => {\n    const definition = {\n        type: 'Custom',\n        isBuiltIn: false,\n        defaultOptions: { ...customStyleDefaults, ...paneView.defaultOptions() },\n        /**\n         * @internal\n         */\n        _internal_createPaneView: createPaneView$6,\n        _internal_customPaneView: paneView,\n    };\n    return definition;\n};\n\nconst isSeriesDefinition = (value) => {\n    return value._internal_createPaneView !== undefined;\n};\n\nfunction singleValueData(plotRow) {\n    const data = {\n        value: plotRow._internal_value[3 /* PlotRowValueIndex.Close */],\n        time: plotRow._internal_originalTime,\n    };\n    if (plotRow._internal_customValues !== undefined) {\n        data.customValues = plotRow._internal_customValues;\n    }\n    return data;\n}\nfunction lineData(plotRow) {\n    const result = singleValueData(plotRow);\n    if (plotRow._internal_color !== undefined) {\n        result.color = plotRow._internal_color;\n    }\n    return result;\n}\nfunction areaData(plotRow) {\n    const result = singleValueData(plotRow);\n    if (plotRow._internal_lineColor !== undefined) {\n        result.lineColor = plotRow._internal_lineColor;\n    }\n    if (plotRow._internal_topColor !== undefined) {\n        result.topColor = plotRow._internal_topColor;\n    }\n    if (plotRow._internal_bottomColor !== undefined) {\n        result.bottomColor = plotRow._internal_bottomColor;\n    }\n    return result;\n}\nfunction baselineData(plotRow) {\n    const result = singleValueData(plotRow);\n    if (plotRow._internal_topLineColor !== undefined) {\n        result.topLineColor = plotRow._internal_topLineColor;\n    }\n    if (plotRow._internal_bottomLineColor !== undefined) {\n        result.bottomLineColor = plotRow._internal_bottomLineColor;\n    }\n    if (plotRow._internal_topFillColor1 !== undefined) {\n        result.topFillColor1 = plotRow._internal_topFillColor1;\n    }\n    if (plotRow._internal_topFillColor2 !== undefined) {\n        result.topFillColor2 = plotRow._internal_topFillColor2;\n    }\n    if (plotRow._internal_bottomFillColor1 !== undefined) {\n        result.bottomFillColor1 = plotRow._internal_bottomFillColor1;\n    }\n    if (plotRow._internal_bottomFillColor2 !== undefined) {\n        result.bottomFillColor2 = plotRow._internal_bottomFillColor2;\n    }\n    return result;\n}\nfunction ohlcData(plotRow) {\n    const data = {\n        open: plotRow._internal_value[0 /* PlotRowValueIndex.Open */],\n        high: plotRow._internal_value[1 /* PlotRowValueIndex.High */],\n        low: plotRow._internal_value[2 /* PlotRowValueIndex.Low */],\n        close: plotRow._internal_value[3 /* PlotRowValueIndex.Close */],\n        time: plotRow._internal_originalTime,\n    };\n    if (plotRow._internal_customValues !== undefined) {\n        data.customValues = plotRow._internal_customValues;\n    }\n    return data;\n}\nfunction barData(plotRow) {\n    const result = ohlcData(plotRow);\n    if (plotRow._internal_color !== undefined) {\n        result.color = plotRow._internal_color;\n    }\n    return result;\n}\nfunction candlestickData(plotRow) {\n    const result = ohlcData(plotRow);\n    const { _internal_color: color, _internal_borderColor: borderColor, _internal_wickColor: wickColor } = plotRow;\n    if (color !== undefined) {\n        result.color = color;\n    }\n    if (borderColor !== undefined) {\n        result.borderColor = borderColor;\n    }\n    if (wickColor !== undefined) {\n        result.wickColor = wickColor;\n    }\n    return result;\n}\nfunction getSeriesDataCreator(seriesType) {\n    const seriesPlotRowToDataMap = {\n        Area: (areaData),\n        Line: (lineData),\n        Baseline: (baselineData),\n        Histogram: (lineData),\n        Bar: (barData),\n        Candlestick: (candlestickData),\n        Custom: (customData),\n    };\n    return seriesPlotRowToDataMap[seriesType];\n}\nfunction customData(plotRow) {\n    const time = plotRow._internal_originalTime;\n    return {\n        ...plotRow._internal_data,\n        time,\n    };\n}\n\nconst crosshairOptionsDefaults = {\n    vertLine: {\n        color: '#9598A1',\n        width: 1,\n        style: 3 /* LineStyle.LargeDashed */,\n        visible: true,\n        labelVisible: true,\n        labelBackgroundColor: '#131722',\n    },\n    horzLine: {\n        color: '#9598A1',\n        width: 1,\n        style: 3 /* LineStyle.LargeDashed */,\n        visible: true,\n        labelVisible: true,\n        labelBackgroundColor: '#131722',\n    },\n    mode: 1 /* CrosshairMode.Magnet */,\n};\n\nconst gridOptionsDefaults = {\n    vertLines: {\n        color: '#D6DCDE',\n        style: 0 /* LineStyle.Solid */,\n        visible: true,\n    },\n    horzLines: {\n        color: '#D6DCDE',\n        style: 0 /* LineStyle.Solid */,\n        visible: true,\n    },\n};\n\nconst layoutOptionsDefaults = {\n    background: {\n        type: \"solid\" /* ColorType.Solid */,\n        color: '#FFFFFF',\n    },\n    textColor: '#191919',\n    fontSize: 12,\n    fontFamily: defaultFontFamily,\n    panes: {\n        enableResize: true,\n        separatorColor: '#E0E3EB',\n        separatorHoverColor: 'rgba(178, 181, 189, 0.2)',\n    },\n    attributionLogo: true,\n    colorSpace: 'srgb',\n    colorParsers: [],\n};\n\nconst priceScaleOptionsDefaults = {\n    autoScale: true,\n    mode: 0 /* PriceScaleMode.Normal */,\n    invertScale: false,\n    alignLabels: true,\n    borderVisible: true,\n    borderColor: '#2B2B43',\n    entireTextOnly: false,\n    visible: false,\n    ticksVisible: false,\n    scaleMargins: {\n        bottom: 0.1,\n        top: 0.2,\n    },\n    minimumWidth: 0,\n    ensureEdgeTickMarksVisible: false,\n};\n\nconst timeScaleOptionsDefaults = {\n    rightOffset: 0,\n    barSpacing: 6,\n    minBarSpacing: 0.5,\n    maxBarSpacing: 0,\n    fixLeftEdge: false,\n    fixRightEdge: false,\n    lockVisibleTimeRangeOnResize: false,\n    rightBarStaysOnScroll: false,\n    borderVisible: true,\n    borderColor: '#2B2B43',\n    visible: true,\n    timeVisible: false,\n    secondsVisible: true,\n    shiftVisibleRangeOnNewBar: true,\n    allowShiftVisibleRangeOnWhitespaceReplacement: false,\n    ticksVisible: false,\n    uniformDistribution: false,\n    minimumHeight: 0,\n    allowBoldLabels: true,\n    ignoreWhitespaceIndices: false,\n};\n\nfunction chartOptionsDefaults() {\n    return {\n        width: 0,\n        height: 0,\n        autoSize: false,\n        layout: layoutOptionsDefaults,\n        crosshair: crosshairOptionsDefaults,\n        grid: gridOptionsDefaults,\n        overlayPriceScales: {\n            ...priceScaleOptionsDefaults,\n        },\n        leftPriceScale: {\n            ...priceScaleOptionsDefaults,\n            visible: false,\n        },\n        rightPriceScale: {\n            ...priceScaleOptionsDefaults,\n            visible: true,\n        },\n        timeScale: timeScaleOptionsDefaults,\n        localization: {\n            locale: isRunningOnClientSide ? navigator.language : '',\n            dateFormat: 'dd MMM \\'yy',\n        },\n        handleScroll: {\n            mouseWheel: true,\n            pressedMouseMove: true,\n            horzTouchDrag: true,\n            vertTouchDrag: true,\n        },\n        handleScale: {\n            axisPressedMouseMove: {\n                time: true,\n                price: true,\n            },\n            axisDoubleClickReset: {\n                time: true,\n                price: true,\n            },\n            mouseWheel: true,\n            pinch: true,\n        },\n        kineticScroll: {\n            mouse: false,\n            touch: true,\n        },\n        trackingMode: {\n            exitMode: 1 /* TrackingModeExitMode.OnNextTap */,\n        },\n    };\n}\n\nclass PriceScaleApi {\n    constructor(chartWidget, priceScaleId, paneIndex) {\n        this._private__chartWidget = chartWidget;\n        this._private__priceScaleId = priceScaleId;\n        this._private__paneIndex = paneIndex ?? 0;\n    }\n    applyOptions(options) {\n        this._private__chartWidget._internal_model()._internal_applyPriceScaleOptions(this._private__priceScaleId, options, this._private__paneIndex);\n    }\n    options() {\n        return this._private__priceScale()._internal_options();\n    }\n    width() {\n        if (!isDefaultPriceScale(this._private__priceScaleId)) {\n            return 0;\n        }\n        return this._private__chartWidget._internal_getPriceAxisWidth(this._private__priceScaleId);\n    }\n    setVisibleRange(range) {\n        this.setAutoScale(false);\n        this._private__priceScale()._internal_setCustomPriceRange(new PriceRangeImpl(range.from, range.to));\n    }\n    getVisibleRange() {\n        const range = this._private__priceScale()._internal_priceRange();\n        return range === null ? null : {\n            from: range._internal_minValue(),\n            to: range._internal_maxValue(),\n        };\n    }\n    setAutoScale(on) {\n        this.applyOptions({ autoScale: on });\n    }\n    _private__priceScale() {\n        return ensureNotNull(this._private__chartWidget._internal_model()._internal_findPriceScale(this._private__priceScaleId, this._private__paneIndex))._internal_priceScale;\n    }\n}\n\nclass PaneApi {\n    constructor(chartWidget, seriesApiGetter, pane, chartApi) {\n        this._private__chartWidget = chartWidget;\n        this._private__pane = pane;\n        this._private__seriesApiGetter = seriesApiGetter;\n        this._internal__chartApi = chartApi;\n    }\n    getHeight() {\n        return this._private__pane._internal_height();\n    }\n    setHeight(height) {\n        const chartModel = this._private__chartWidget._internal_model();\n        const paneIndex = chartModel._internal_getPaneIndex(this._private__pane);\n        chartModel._internal_changePanesHeight(paneIndex, height);\n    }\n    paneIndex() {\n        return this._private__chartWidget._internal_model()._internal_getPaneIndex(this._private__pane);\n    }\n    moveTo(paneIndex) {\n        const currentIndex = this.paneIndex();\n        if (currentIndex === paneIndex) {\n            return;\n        }\n        assert(paneIndex >= 0 && paneIndex < this._private__chartWidget._internal_paneWidgets().length, 'Invalid pane index');\n        this._private__chartWidget._internal_model()._internal_swapPanes(currentIndex, paneIndex);\n    }\n    getSeries() {\n        return this._private__pane._internal_series().map((source) => this._private__seriesApiGetter(source)) ?? [];\n    }\n    getHTMLElement() {\n        return this._private__chartWidget._internal_paneWidgets()[this.paneIndex()]._internal_getElement();\n    }\n    attachPrimitive(primitive) {\n        this._private__pane._internal_attachPrimitive(primitive);\n        if (primitive.attached) {\n            primitive.attached({\n                chart: this._internal__chartApi,\n                requestUpdate: () => this._private__pane._internal_model()._internal_fullUpdate(),\n            });\n        }\n    }\n    detachPrimitive(primitive) {\n        this._private__pane._internal_detachPrimitive(primitive);\n    }\n    priceScale(priceScaleId) {\n        const priceScale = this._private__pane._internal_priceScaleById(priceScaleId);\n        if (priceScale === null) {\n            throw new Error(`Cannot find price scale with id: ${priceScaleId}`);\n        }\n        return new PriceScaleApi(this._private__chartWidget, priceScaleId, this.paneIndex());\n    }\n}\n\n/// <reference types=\"_build-time-constants\" />\nfunction checkPriceLineOptions(options) {\n    assert(typeof options.price === 'number', `the type of 'price' price line's property must be a number, got '${typeof options.price}'`);\n}\nfunction checkItemsAreOrdered(data, bh, allowDuplicates = false) {\n    if (data.length === 0) {\n        return;\n    }\n    let prevTime = bh.key(data[0].time);\n    for (let i = 1; i < data.length; ++i) {\n        const currentTime = bh.key(data[i].time);\n        const checkResult = allowDuplicates ? prevTime <= currentTime : prevTime < currentTime;\n        assert(checkResult, `data must be asc ordered by time, index=${i}, time=${currentTime}, prev time=${prevTime}`);\n        prevTime = currentTime;\n    }\n}\nfunction checkSeriesValuesType(type, data) {\n    data.forEach(getChecker(type));\n}\nfunction getChecker(type) {\n    switch (type) {\n        case 'Bar':\n        case 'Candlestick':\n            return checkBarItem.bind(null, type);\n        case 'Area':\n        case 'Baseline':\n        case 'Line':\n        case 'Histogram':\n            return checkLineItem.bind(null, type);\n        case 'Custom':\n            return checkCustomItem.bind(null);\n    }\n}\nfunction checkBarItem(type, barItem) {\n    if (!isFulfilledData(barItem)) {\n        return;\n    }\n    ['open', 'high', 'low', 'close'].forEach((key) => {\n        assert(typeof barItem[key] === 'number', `${type} series item data value of ${key} must be a number, got=${typeof barItem[key]}, value=${barItem[key]}`);\n        assert(isSafeValue(barItem[key]), `${type} series item data value of ${key} must be between ${MIN_SAFE_VALUE.toPrecision(16)} and ${MAX_SAFE_VALUE.toPrecision(16)}, got=${typeof barItem[key]}, value=${barItem[key]}`);\n    });\n}\nfunction checkLineItem(type, lineItem) {\n    if (!isFulfilledData(lineItem)) {\n        return;\n    }\n    assert(typeof lineItem.value === 'number', `${type} series item data value must be a number, got=${typeof lineItem.value}, value=${lineItem.value}`);\n    assert(isSafeValue(lineItem.value), `${type} series item data value must be between ${MIN_SAFE_VALUE.toPrecision(16)} and ${MAX_SAFE_VALUE.toPrecision(16)}, got=${typeof lineItem.value}, value=${lineItem.value}`);\n}\nfunction checkCustomItem(\n// type: 'Custom',\n// customItem: SeriesDataItemTypeMap[typeof type]\n) {\n    // Nothing to check yet...\n    return;\n}\nconst MIN_SAFE_VALUE = Number.MIN_SAFE_INTEGER / 100;\nconst MAX_SAFE_VALUE = Number.MAX_SAFE_INTEGER / 100;\nfunction isSafeValue(value) {\n    return value >= MIN_SAFE_VALUE && value <= MAX_SAFE_VALUE;\n}\n\nconst priceLineOptionsDefaults = {\n    color: '#FF0000',\n    price: 0,\n    lineStyle: 2 /* LineStyle.Dashed */,\n    lineWidth: 1,\n    lineVisible: true,\n    axisLabelVisible: true,\n    title: '',\n    axisLabelColor: '',\n    axisLabelTextColor: '',\n};\n\nclass PriceLine {\n    constructor(priceLine) {\n        this._private__priceLine = priceLine;\n    }\n    applyOptions(options) {\n        this._private__priceLine._internal_applyOptions(options);\n    }\n    options() {\n        return this._private__priceLine._internal_options();\n    }\n    _internal_priceLine() {\n        return this._private__priceLine;\n    }\n}\n\nclass SeriesApi {\n    constructor(series, dataUpdatesConsumer, priceScaleApiProvider, chartApi, horzScaleBehavior, paneApiGetter) {\n        this._private__dataChangedDelegate = new Delegate();\n        this._internal__series = series;\n        this._internal__dataUpdatesConsumer = dataUpdatesConsumer;\n        this._private__priceScaleApiProvider = priceScaleApiProvider;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        this._internal__chartApi = chartApi;\n        this._private__paneApiGetter = paneApiGetter;\n    }\n    _internal_destroy() {\n        this._private__dataChangedDelegate._internal_destroy();\n    }\n    priceFormatter() {\n        return this._internal__series._internal_formatter();\n    }\n    priceToCoordinate(price) {\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return null;\n        }\n        return this._internal__series._internal_priceScale()._internal_priceToCoordinate(price, firstValue._internal_value);\n    }\n    coordinateToPrice(coordinate) {\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return null;\n        }\n        return this._internal__series._internal_priceScale()._internal_coordinateToPrice(coordinate, firstValue._internal_value);\n    }\n    barsInLogicalRange(range) {\n        if (range === null) {\n            return null;\n        }\n        // we use TimeScaleVisibleRange here to convert LogicalRange to strict range properly\n        const correctedRange = new TimeScaleVisibleRange(new RangeImpl(range.from, range.to))._internal_strictRange();\n        const bars = this._internal__series._internal_bars();\n        if (bars._internal_isEmpty()) {\n            return null;\n        }\n        const dataFirstBarInRange = bars._internal_search(correctedRange._internal_left(), 1 /* MismatchDirection.NearestRight */);\n        const dataLastBarInRange = bars._internal_search(correctedRange._internal_right(), -1 /* MismatchDirection.NearestLeft */);\n        const dataFirstIndex = ensureNotNull(bars._internal_firstIndex());\n        const dataLastIndex = ensureNotNull(bars._internal_lastIndex());\n        // this means that we request data in the data gap\n        // e.g. let's say we have series with data [0..10, 30..60]\n        // and we request bars info in range [15, 25]\n        // thus, dataFirstBarInRange will be with index 30 and dataLastBarInRange with 10\n        if (dataFirstBarInRange !== null && dataLastBarInRange !== null && dataFirstBarInRange._internal_index > dataLastBarInRange._internal_index) {\n            return {\n                barsBefore: range.from - dataFirstIndex,\n                barsAfter: dataLastIndex - range.to,\n            };\n        }\n        const barsBefore = (dataFirstBarInRange === null || dataFirstBarInRange._internal_index === dataFirstIndex)\n            ? range.from - dataFirstIndex\n            : dataFirstBarInRange._internal_index - dataFirstIndex;\n        const barsAfter = (dataLastBarInRange === null || dataLastBarInRange._internal_index === dataLastIndex)\n            ? dataLastIndex - range.to\n            : dataLastIndex - dataLastBarInRange._internal_index;\n        const result = { barsBefore, barsAfter };\n        // actually they can't exist separately\n        if (dataFirstBarInRange !== null && dataLastBarInRange !== null) {\n            result.from = dataFirstBarInRange._internal_originalTime;\n            result.to = dataLastBarInRange._internal_originalTime;\n        }\n        return result;\n    }\n    setData(data) {\n        checkItemsAreOrdered(data, this._private__horzScaleBehavior);\n        checkSeriesValuesType(this._internal__series._internal_seriesType(), data);\n        this._internal__dataUpdatesConsumer._internal_applyNewData(this._internal__series, data);\n        this._private__onDataChanged('full');\n    }\n    update(bar, historicalUpdate = false) {\n        checkSeriesValuesType(this._internal__series._internal_seriesType(), [bar]);\n        this._internal__dataUpdatesConsumer._internal_updateData(this._internal__series, bar, historicalUpdate);\n        this._private__onDataChanged('update');\n    }\n    dataByIndex(logicalIndex, mismatchDirection) {\n        const data = this._internal__series._internal_bars()._internal_search(logicalIndex, mismatchDirection);\n        if (data === null) {\n            // actually it can be a whitespace\n            return null;\n        }\n        const creator = getSeriesDataCreator(this.seriesType());\n        return creator(data);\n    }\n    data() {\n        const seriesCreator = getSeriesDataCreator(this.seriesType());\n        const rows = this._internal__series._internal_bars()._internal_rows();\n        return rows.map((row) => seriesCreator(row));\n    }\n    subscribeDataChanged(handler) {\n        this._private__dataChangedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeDataChanged(handler) {\n        this._private__dataChangedDelegate._internal_unsubscribe(handler);\n    }\n    applyOptions(options) {\n        this._internal__series._internal_applyOptions(options);\n    }\n    options() {\n        return clone(this._internal__series._internal_options());\n    }\n    priceScale() {\n        return this._private__priceScaleApiProvider.priceScale(this._internal__series._internal_priceScale()._internal_id(), this.getPane().paneIndex());\n    }\n    createPriceLine(options) {\n        checkPriceLineOptions(options);\n        const strictOptions = merge(clone(priceLineOptionsDefaults), options);\n        const priceLine = this._internal__series._internal_createPriceLine(strictOptions);\n        return new PriceLine(priceLine);\n    }\n    removePriceLine(line) {\n        this._internal__series._internal_removePriceLine(line._internal_priceLine());\n    }\n    priceLines() {\n        return this._internal__series._internal_priceLines().map((priceLine) => new PriceLine(priceLine));\n    }\n    seriesType() {\n        return this._internal__series._internal_seriesType();\n    }\n    attachPrimitive(primitive) {\n        // at this point we cast the generic to unknown because we\n        // don't want the model to know the types of the API (_)\n        this._internal__series._internal_attachPrimitive(primitive);\n        if (primitive.attached) {\n            primitive.attached({\n                chart: this._internal__chartApi,\n                series: this,\n                requestUpdate: () => this._internal__series._internal_model()._internal_fullUpdate(),\n                horzScaleBehavior: this._private__horzScaleBehavior,\n            });\n        }\n    }\n    detachPrimitive(primitive) {\n        this._internal__series._internal_detachPrimitive(primitive);\n        if (primitive.detached) {\n            primitive.detached();\n        }\n        this._internal__series._internal_model()._internal_fullUpdate();\n    }\n    getPane() {\n        const series = this._internal__series;\n        const pane = ensureNotNull(this._internal__series._internal_model()._internal_paneForSource(series));\n        return this._private__paneApiGetter(pane);\n    }\n    moveToPane(paneIndex) {\n        this._internal__series._internal_model()._internal_moveSeriesToPane(this._internal__series, paneIndex);\n    }\n    seriesOrder() {\n        const pane = this._internal__series._internal_model()._internal_paneForSource(this._internal__series);\n        if (pane === null) {\n            return -1;\n        }\n        return pane._internal_series().indexOf(this._internal__series);\n    }\n    setSeriesOrder(order) {\n        const pane = this._internal__series._internal_model()._internal_paneForSource(this._internal__series);\n        if (pane === null) {\n            return;\n        }\n        pane._internal_setSeriesOrder(this._internal__series, order);\n    }\n    _private__onDataChanged(scope) {\n        if (this._private__dataChangedDelegate._internal_hasListeners()) {\n            this._private__dataChangedDelegate._internal_fire(scope);\n        }\n    }\n}\n\nclass TimeScaleApi {\n    constructor(model, timeAxisWidget, horzScaleBehavior) {\n        this._private__timeRangeChanged = new Delegate();\n        this._private__logicalRangeChanged = new Delegate();\n        this._private__sizeChanged = new Delegate();\n        this._private__model = model;\n        this._private__timeScale = model._internal_timeScale();\n        this._private__timeAxisWidget = timeAxisWidget;\n        this._private__timeScale._internal_visibleBarsChanged()._internal_subscribe(this._private__onVisibleBarsChanged.bind(this));\n        this._private__timeScale._internal_logicalRangeChanged()._internal_subscribe(this._private__onVisibleLogicalRangeChanged.bind(this));\n        this._private__timeAxisWidget._internal_sizeChanged()._internal_subscribe(this._private__onSizeChanged.bind(this));\n        this._private__horzScaleBehavior = horzScaleBehavior;\n    }\n    _internal_destroy() {\n        this._private__timeScale._internal_visibleBarsChanged()._internal_unsubscribeAll(this);\n        this._private__timeScale._internal_logicalRangeChanged()._internal_unsubscribeAll(this);\n        this._private__timeAxisWidget._internal_sizeChanged()._internal_unsubscribeAll(this);\n        this._private__timeRangeChanged._internal_destroy();\n        this._private__logicalRangeChanged._internal_destroy();\n        this._private__sizeChanged._internal_destroy();\n    }\n    scrollPosition() {\n        return this._private__timeScale._internal_rightOffset();\n    }\n    scrollToPosition(position, animated) {\n        if (!animated) {\n            this._private__model._internal_setRightOffset(position);\n            return;\n        }\n        this._private__timeScale._internal_scrollToOffsetAnimated(position, 1000 /* Constants.AnimationDurationMs */);\n    }\n    scrollToRealTime() {\n        this._private__timeScale._internal_scrollToRealTime();\n    }\n    getVisibleRange() {\n        const timeRange = this._private__timeScale._internal_visibleTimeRange();\n        if (timeRange === null) {\n            return null;\n        }\n        return {\n            from: timeRange.from.originalTime,\n            to: timeRange.to.originalTime,\n        };\n    }\n    setVisibleRange(range) {\n        const convertedRange = {\n            from: this._private__horzScaleBehavior.convertHorzItemToInternal(range.from),\n            to: this._private__horzScaleBehavior.convertHorzItemToInternal(range.to),\n        };\n        const logicalRange = this._private__timeScale._internal_logicalRangeForTimeRange(convertedRange);\n        this._private__model._internal_setTargetLogicalRange(logicalRange);\n    }\n    getVisibleLogicalRange() {\n        const logicalRange = this._private__timeScale._internal_visibleLogicalRange();\n        if (logicalRange === null) {\n            return null;\n        }\n        return {\n            from: logicalRange._internal_left(),\n            to: logicalRange._internal_right(),\n        };\n    }\n    setVisibleLogicalRange(range) {\n        assert(range.from <= range.to, 'The from index cannot be after the to index.');\n        this._private__model._internal_setTargetLogicalRange(range);\n    }\n    resetTimeScale() {\n        this._private__model._internal_resetTimeScale();\n    }\n    fitContent() {\n        this._private__model._internal_fitContent();\n    }\n    logicalToCoordinate(logical) {\n        const timeScale = this._private__model._internal_timeScale();\n        if (timeScale._internal_isEmpty()) {\n            return null;\n        }\n        else {\n            return timeScale._internal_indexToCoordinate(logical);\n        }\n    }\n    coordinateToLogical(x) {\n        if (this._private__timeScale._internal_isEmpty()) {\n            return null;\n        }\n        else {\n            return this._private__timeScale._internal_coordinateToIndex(x);\n        }\n    }\n    timeToIndex(time, findNearest) {\n        const timePoint = this._private__horzScaleBehavior.convertHorzItemToInternal(time);\n        return this._private__timeScale._internal_timeToIndex(timePoint, findNearest);\n    }\n    timeToCoordinate(time) {\n        const timePointIndex = this.timeToIndex(time, false);\n        if (timePointIndex === null) {\n            return null;\n        }\n        return this._private__timeScale._internal_indexToCoordinate(timePointIndex);\n    }\n    coordinateToTime(x) {\n        const timeScale = this._private__model._internal_timeScale();\n        const timePointIndex = timeScale._internal_coordinateToIndex(x);\n        const timePoint = timeScale._internal_indexToTimeScalePoint(timePointIndex);\n        if (timePoint === null) {\n            return null;\n        }\n        return timePoint.originalTime;\n    }\n    width() {\n        return this._private__timeAxisWidget._internal_getSize().width;\n    }\n    height() {\n        return this._private__timeAxisWidget._internal_getSize().height;\n    }\n    subscribeVisibleTimeRangeChange(handler) {\n        this._private__timeRangeChanged._internal_subscribe(handler);\n    }\n    unsubscribeVisibleTimeRangeChange(handler) {\n        this._private__timeRangeChanged._internal_unsubscribe(handler);\n    }\n    subscribeVisibleLogicalRangeChange(handler) {\n        this._private__logicalRangeChanged._internal_subscribe(handler);\n    }\n    unsubscribeVisibleLogicalRangeChange(handler) {\n        this._private__logicalRangeChanged._internal_unsubscribe(handler);\n    }\n    subscribeSizeChange(handler) {\n        this._private__sizeChanged._internal_subscribe(handler);\n    }\n    unsubscribeSizeChange(handler) {\n        this._private__sizeChanged._internal_unsubscribe(handler);\n    }\n    applyOptions(options) {\n        this._private__timeScale._internal_applyOptions(options);\n    }\n    options() {\n        return {\n            ...clone(this._private__timeScale._internal_options()),\n            barSpacing: this._private__timeScale._internal_barSpacing(),\n        };\n    }\n    _private__onVisibleBarsChanged() {\n        if (this._private__timeRangeChanged._internal_hasListeners()) {\n            this._private__timeRangeChanged._internal_fire(this.getVisibleRange());\n        }\n    }\n    _private__onVisibleLogicalRangeChanged() {\n        if (this._private__logicalRangeChanged._internal_hasListeners()) {\n            this._private__logicalRangeChanged._internal_fire(this.getVisibleLogicalRange());\n        }\n    }\n    _private__onSizeChanged(size) {\n        this._private__sizeChanged._internal_fire(size.width, size.height);\n    }\n}\n\n/// <reference types=\"_build-time-constants\" />\nfunction patchPriceFormat(priceFormat) {\n    if (priceFormat === undefined || priceFormat.type === 'custom') {\n        return;\n    }\n    const priceFormatBuiltIn = priceFormat;\n    if (priceFormatBuiltIn.minMove !== undefined && priceFormatBuiltIn.precision === undefined) {\n        priceFormatBuiltIn.precision = precisionByMinMove(priceFormatBuiltIn.minMove);\n    }\n}\nfunction migrateHandleScaleScrollOptions(options) {\n    if (isBoolean(options['handleScale'])) {\n        const handleScale = options['handleScale'];\n        options['handleScale'] = {\n            axisDoubleClickReset: {\n                time: handleScale,\n                price: handleScale,\n            },\n            axisPressedMouseMove: {\n                time: handleScale,\n                price: handleScale,\n            },\n            mouseWheel: handleScale,\n            pinch: handleScale,\n        };\n    }\n    else if (options['handleScale'] !== undefined) {\n        const { axisPressedMouseMove, axisDoubleClickReset } = options['handleScale'];\n        if (isBoolean(axisPressedMouseMove)) {\n            options['handleScale'].axisPressedMouseMove = {\n                time: axisPressedMouseMove,\n                price: axisPressedMouseMove,\n            };\n        }\n        if (isBoolean(axisDoubleClickReset)) {\n            options['handleScale'].axisDoubleClickReset = {\n                time: axisDoubleClickReset,\n                price: axisDoubleClickReset,\n            };\n        }\n    }\n    const handleScroll = options['handleScroll'];\n    if (isBoolean(handleScroll)) {\n        options['handleScroll'] = {\n            horzTouchDrag: handleScroll,\n            vertTouchDrag: handleScroll,\n            mouseWheel: handleScroll,\n            pressedMouseMove: handleScroll,\n        };\n    }\n}\nfunction toInternalOptions(options) {\n    migrateHandleScaleScrollOptions(options);\n    return options;\n}\nclass ChartApi {\n    constructor(container, horzScaleBehavior, options) {\n        this._private__seriesMap = new Map();\n        this._private__seriesMapReversed = new Map();\n        this._private__clickedDelegate = new Delegate();\n        this._private__dblClickedDelegate = new Delegate();\n        this._private__crosshairMovedDelegate = new Delegate();\n        this._private__panes = new WeakMap();\n        this._private__dataLayer = new DataLayer(horzScaleBehavior);\n        const internalOptions = (options === undefined) ?\n            clone(chartOptionsDefaults()) :\n            merge(clone(chartOptionsDefaults()), toInternalOptions(options));\n        this._internal__horzScaleBehavior = horzScaleBehavior;\n        this._private__chartWidget = new ChartWidget(container, internalOptions, horzScaleBehavior);\n        this._private__chartWidget._internal_clicked()._internal_subscribe((paramSupplier) => {\n            if (this._private__clickedDelegate._internal_hasListeners()) {\n                this._private__clickedDelegate._internal_fire(this._private__convertMouseParams(paramSupplier()));\n            }\n        }, this);\n        this._private__chartWidget._internal_dblClicked()._internal_subscribe((paramSupplier) => {\n            if (this._private__dblClickedDelegate._internal_hasListeners()) {\n                this._private__dblClickedDelegate._internal_fire(this._private__convertMouseParams(paramSupplier()));\n            }\n        }, this);\n        this._private__chartWidget._internal_crosshairMoved()._internal_subscribe((paramSupplier) => {\n            if (this._private__crosshairMovedDelegate._internal_hasListeners()) {\n                this._private__crosshairMovedDelegate._internal_fire(this._private__convertMouseParams(paramSupplier()));\n            }\n        }, this);\n        const model = this._private__chartWidget._internal_model();\n        this._private__timeScaleApi = new TimeScaleApi(model, this._private__chartWidget._internal_timeAxisWidget(), this._internal__horzScaleBehavior);\n    }\n    remove() {\n        this._private__chartWidget._internal_clicked()._internal_unsubscribeAll(this);\n        this._private__chartWidget._internal_dblClicked()._internal_unsubscribeAll(this);\n        this._private__chartWidget._internal_crosshairMoved()._internal_unsubscribeAll(this);\n        this._private__timeScaleApi._internal_destroy();\n        this._private__chartWidget._internal_destroy();\n        this._private__seriesMap.clear();\n        this._private__seriesMapReversed.clear();\n        this._private__clickedDelegate._internal_destroy();\n        this._private__dblClickedDelegate._internal_destroy();\n        this._private__crosshairMovedDelegate._internal_destroy();\n        this._private__dataLayer._internal_destroy();\n    }\n    resize(width, height, forceRepaint) {\n        if (this.autoSizeActive()) {\n            // We return early here instead of checking this within the actual _chartWidget.resize method\n            // because this should only apply to external resize requests.\n            warn(`Height and width values ignored because 'autoSize' option is enabled.`);\n            return;\n        }\n        this._private__chartWidget._internal_resize(width, height, forceRepaint);\n    }\n    addCustomSeries(customPaneView, options = {}, paneIndex = 0) {\n        const paneView = ensure(customPaneView);\n        const definition = createCustomSeriesDefinition(paneView);\n        return this._private__addSeriesImpl(definition, options, paneIndex);\n    }\n    addSeries(definition, options = {}, paneIndex = 0) {\n        return this._private__addSeriesImpl(definition, options, paneIndex);\n    }\n    removeSeries(seriesApi) {\n        const series = ensureDefined(this._private__seriesMap.get(seriesApi));\n        const update = this._private__dataLayer._internal_removeSeries(series);\n        const model = this._private__chartWidget._internal_model();\n        model._internal_removeSeries(series);\n        this._private__sendUpdateToChart(update);\n        this._private__seriesMap.delete(seriesApi);\n        this._private__seriesMapReversed.delete(series);\n    }\n    _internal_applyNewData(series, data) {\n        this._private__sendUpdateToChart(this._private__dataLayer._internal_setSeriesData(series, data));\n    }\n    _internal_updateData(series, data, historicalUpdate) {\n        this._private__sendUpdateToChart(this._private__dataLayer._internal_updateSeriesData(series, data, historicalUpdate));\n    }\n    subscribeClick(handler) {\n        this._private__clickedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeClick(handler) {\n        this._private__clickedDelegate._internal_unsubscribe(handler);\n    }\n    subscribeCrosshairMove(handler) {\n        this._private__crosshairMovedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeCrosshairMove(handler) {\n        this._private__crosshairMovedDelegate._internal_unsubscribe(handler);\n    }\n    subscribeDblClick(handler) {\n        this._private__dblClickedDelegate._internal_subscribe(handler);\n    }\n    unsubscribeDblClick(handler) {\n        this._private__dblClickedDelegate._internal_unsubscribe(handler);\n    }\n    priceScale(priceScaleId, paneIndex = 0) {\n        return new PriceScaleApi(this._private__chartWidget, priceScaleId, paneIndex);\n    }\n    timeScale() {\n        return this._private__timeScaleApi;\n    }\n    applyOptions(options) {\n        {\n            const colorSpace = options.layout?.colorSpace;\n            if (colorSpace !== undefined && colorSpace !== this.options().layout.colorSpace) {\n                throw new Error(`colorSpace option should not be changed once the chart has been created.`);\n            }\n            const colorParsers = options.layout?.colorParsers;\n            if (colorParsers !== undefined && colorParsers !== this.options().layout.colorParsers) {\n                throw new Error(`colorParsers option should not be changed once the chart has been created.`);\n            }\n        }\n        this._private__chartWidget._internal_applyOptions(toInternalOptions(options));\n    }\n    options() {\n        return this._private__chartWidget._internal_options();\n    }\n    takeScreenshot() {\n        return this._private__chartWidget._internal_takeScreenshot();\n    }\n    removePane(index) {\n        this._private__chartWidget._internal_model()._internal_removePane(index);\n    }\n    swapPanes(first, second) {\n        this._private__chartWidget._internal_model()._internal_swapPanes(first, second);\n    }\n    autoSizeActive() {\n        return this._private__chartWidget._internal_autoSizeActive();\n    }\n    chartElement() {\n        return this._private__chartWidget._internal_element();\n    }\n    panes() {\n        return this._private__chartWidget._internal_model()._internal_panes().map((pane) => this._private__getPaneApi(pane));\n    }\n    paneSize(paneIndex = 0) {\n        const size = this._private__chartWidget._internal_paneSize(paneIndex);\n        return {\n            height: size.height,\n            width: size.width,\n        };\n    }\n    setCrosshairPosition(price, horizontalPosition, seriesApi) {\n        const series = this._private__seriesMap.get(seriesApi);\n        if (series === undefined) {\n            return;\n        }\n        const pane = this._private__chartWidget._internal_model()._internal_paneForSource(series);\n        if (pane === null) {\n            return;\n        }\n        this._private__chartWidget._internal_model()._internal_setAndSaveSyntheticPosition(price, horizontalPosition, pane);\n    }\n    clearCrosshairPosition() {\n        this._private__chartWidget._internal_model()._internal_clearCurrentPosition(true);\n    }\n    horzBehaviour() {\n        return this._internal__horzScaleBehavior;\n    }\n    _private__addSeriesImpl(definition, options = {}, paneIndex = 0) {\n        assert(isSeriesDefinition(definition));\n        patchPriceFormat(options.priceFormat);\n        if (definition.type === 'Candlestick') {\n            fillUpDownCandlesticksColors(options);\n        }\n        const strictOptions = merge(clone(seriesOptionsDefaults), clone(definition.defaultOptions), options);\n        const createPaneView = definition._internal_createPaneView;\n        const series = new Series(this._private__chartWidget._internal_model(), definition.type, strictOptions, createPaneView, definition._internal_customPaneView);\n        this._private__chartWidget._internal_model()._internal_addSeriesToPane(series, paneIndex);\n        const res = new SeriesApi(series, this, this, this, this._internal__horzScaleBehavior, (pane) => this._private__getPaneApi(pane));\n        this._private__seriesMap.set(res, series);\n        this._private__seriesMapReversed.set(series, res);\n        return res;\n    }\n    _private__sendUpdateToChart(update) {\n        const model = this._private__chartWidget._internal_model();\n        model._internal_updateTimeScale(update._internal_timeScale._internal_baseIndex, update._internal_timeScale._internal_points, update._internal_timeScale._internal_firstChangedPointIndex);\n        update._internal_series.forEach((value, series) => series._internal_setData(value._internal_data, value._internal_info));\n        model._internal_timeScale()._internal_recalculateIndicesWithData();\n        model._internal_recalculateAllPanes();\n    }\n    _private__mapSeriesToApi(series) {\n        return ensureDefined(this._private__seriesMapReversed.get(series));\n    }\n    _private__convertMouseParams(param) {\n        const seriesData = new Map();\n        param._internal_seriesData.forEach((plotRow, series) => {\n            const seriesType = series._internal_seriesType();\n            const data = getSeriesDataCreator(seriesType)(plotRow);\n            if (seriesType !== 'Custom') {\n                assert(isFulfilledData(data));\n            }\n            else {\n                const customWhitespaceChecker = series._internal_customSeriesWhitespaceCheck();\n                assert(!customWhitespaceChecker || customWhitespaceChecker(data) === false);\n            }\n            seriesData.set(this._private__mapSeriesToApi(series), data);\n        });\n        const hoveredSeries = param._internal_hoveredSeries === undefined ||\n            !this._private__seriesMapReversed.has(param._internal_hoveredSeries)\n            ? undefined\n            : this._private__mapSeriesToApi(param._internal_hoveredSeries);\n        return {\n            time: param._internal_originalTime,\n            logical: param._internal_index,\n            point: param._internal_point,\n            paneIndex: param._internal_paneIndex,\n            hoveredSeries,\n            hoveredObjectId: param._internal_hoveredObject,\n            seriesData,\n            sourceEvent: param._internal_touchMouseEventData,\n        };\n    }\n    _private__getPaneApi(pane) {\n        let result = this._private__panes.get(pane);\n        if (!result) {\n            result = new PaneApi(this._private__chartWidget, (series) => this._private__mapSeriesToApi(series), pane, this);\n            this._private__panes.set(pane, result);\n        }\n        return result;\n    }\n}\n\nfunction fetchHtmlElement(container) {\n    if (isString(container)) {\n        const element = document.getElementById(container);\n        assert(element !== null, `Cannot find element in DOM with id=${container}`);\n        return element;\n    }\n    return container;\n}\n/**\n * This function is the main entry point of the Lightweight Charting Library. If you are using time values\n * for the horizontal scale then it is recommended that you rather use the {@link createChart} function.\n *\n * @template HorzScaleItem - type of points on the horizontal scale\n * @template THorzScaleBehavior - type of horizontal axis strategy that encapsulate all the specific behaviors of the horizontal scale type\n *\n * @param container - ID of HTML element or element itself\n * @param horzScaleBehavior - Horizontal scale behavior\n * @param options - Any subset of options to be applied at start.\n * @returns An interface to the created chart\n */\nfunction createChartEx(container, horzScaleBehavior, options) {\n    const htmlElement = fetchHtmlElement(container);\n    const res = new ChartApi(htmlElement, horzScaleBehavior, options);\n    horzScaleBehavior.setOptions(res.options());\n    return res;\n}\n/**\n * This function is the simplified main entry point of the Lightweight Charting Library with time points for the horizontal scale.\n *\n * @param container - ID of HTML element or element itself\n * @param options - Any subset of options to be applied at start.\n * @returns An interface to the created chart\n */\nfunction createChart(container, options) {\n    return createChartEx(container, new HorzScaleBehaviorTime(), HorzScaleBehaviorTime._internal_applyDefaults(options));\n}\n/**\n * Provides the default implementation of the horizontal scale (time-based) that can be used as a base for extending the horizontal scale with custom behavior.\n * This allows for the introduction of custom functionality without re-implementing the entire {@link IHorzScaleBehavior}&lt;{@link Time}&gt; interface.\n *\n * For further details, refer to the {@link createChartEx} chart constructor method.\n *\n * @returns An uninitialized class implementing the {@link IHorzScaleBehavior}&lt;{@link Time}&gt; interface\n */\nfunction defaultHorzScaleBehavior() {\n    return HorzScaleBehaviorTime;\n}\n\nclass LinePaneViewBase extends SeriesPaneViewBase {\n    constructor(series, model) {\n        super(series, model, true);\n    }\n    _internal__convertToCoordinates(priceScale, timeScale, firstValue) {\n        timeScale._internal_indexesToCoordinates(this._internal__items, undefinedIfNull(this._internal__itemsVisibleRange));\n        priceScale._internal_pointsArrayToCoordinates(this._internal__items, firstValue, undefinedIfNull(this._internal__itemsVisibleRange));\n    }\n    _internal__createRawItemBase(time, price) {\n        return {\n            _internal_time: time,\n            _internal_price: price,\n            _internal_x: NaN,\n            _internal_y: NaN,\n        };\n    }\n    _internal__fillRawPoints() {\n        const colorer = this._internal__series._internal_barColorer();\n        this._internal__items = this._internal__series._internal_bars()._internal_rows().map((row) => {\n            const value = row._internal_value[3 /* PlotRowValueIndex.Close */];\n            return this._internal__createRawItem(row._internal_index, value, colorer);\n        });\n    }\n}\n\nfunction drawSeriesPointMarkers(renderingScope, items, pointMarkersRadius, visibleRange, \n// the values returned by styleGetter are compared using the operator !==,\n// so if styleGetter returns objects, then styleGetter should return the same object for equal styles\nstyleGetter) {\n    if (visibleRange.to - visibleRange.from <= 0) {\n        return;\n    }\n    const { horizontalPixelRatio, verticalPixelRatio, context } = renderingScope;\n    let prevStyle = null;\n    const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n    const correction = (tickWidth % 2) / 2;\n    const radius = pointMarkersRadius * verticalPixelRatio + correction;\n    for (let i = visibleRange.to - 1; i >= visibleRange.from; --i) {\n        const point = items[i];\n        if (point) {\n            const style = styleGetter(renderingScope, point);\n            if (style !== prevStyle) {\n                context.beginPath();\n                if (prevStyle !== null) {\n                    context.fill();\n                }\n                context.fillStyle = style;\n                prevStyle = style;\n            }\n            const centerX = Math.round(point._internal_x * horizontalPixelRatio) + correction; // correct x coordinate only\n            const centerY = point._internal_y * verticalPixelRatio;\n            context.moveTo(centerX, centerY);\n            context.arc(centerX, centerY, radius, 0, Math.PI * 2);\n        }\n    }\n    context.fill();\n}\n\n// eslint-disable-next-line max-params, complexity\nfunction walkLine(renderingScope, items, lineType, visibleRange, barWidth, \n// the values returned by styleGetter are compared using the operator !==,\n// so if styleGetter returns objects, then styleGetter should return the same object for equal styles\nstyleGetter, finishStyledArea) {\n    if (items.length === 0 || visibleRange.from >= items.length || visibleRange.to <= 0) {\n        return;\n    }\n    const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n    const firstItem = items[visibleRange.from];\n    let currentStyle = styleGetter(renderingScope, firstItem);\n    let currentStyleFirstItem = firstItem;\n    if (visibleRange.to - visibleRange.from < 2) {\n        const halfBarWidth = barWidth / 2;\n        ctx.beginPath();\n        const item1 = { _internal_x: firstItem._internal_x - halfBarWidth, _internal_y: firstItem._internal_y };\n        const item2 = { _internal_x: firstItem._internal_x + halfBarWidth, _internal_y: firstItem._internal_y };\n        ctx.moveTo(item1._internal_x * horizontalPixelRatio, item1._internal_y * verticalPixelRatio);\n        ctx.lineTo(item2._internal_x * horizontalPixelRatio, item2._internal_y * verticalPixelRatio);\n        finishStyledArea(renderingScope, currentStyle, item1, item2);\n    }\n    else {\n        const changeStyle = (newStyle, currentItem) => {\n            finishStyledArea(renderingScope, currentStyle, currentStyleFirstItem, currentItem);\n            ctx.beginPath();\n            currentStyle = newStyle;\n            currentStyleFirstItem = currentItem;\n        };\n        let currentItem = currentStyleFirstItem;\n        ctx.beginPath();\n        ctx.moveTo(firstItem._internal_x * horizontalPixelRatio, firstItem._internal_y * verticalPixelRatio);\n        for (let i = visibleRange.from + 1; i < visibleRange.to; ++i) {\n            currentItem = items[i];\n            const itemStyle = styleGetter(renderingScope, currentItem);\n            switch (lineType) {\n                case 0 /* LineType.Simple */:\n                    ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n                    break;\n                case 1 /* LineType.WithSteps */:\n                    ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, items[i - 1]._internal_y * verticalPixelRatio);\n                    if (itemStyle !== currentStyle) {\n                        changeStyle(itemStyle, currentItem);\n                        ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, items[i - 1]._internal_y * verticalPixelRatio);\n                    }\n                    ctx.lineTo(currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n                    break;\n                case 2 /* LineType.Curved */: {\n                    const [cp1, cp2] = getControlPoints(items, i - 1, i);\n                    ctx.bezierCurveTo(cp1._internal_x * horizontalPixelRatio, cp1._internal_y * verticalPixelRatio, cp2._internal_x * horizontalPixelRatio, cp2._internal_y * verticalPixelRatio, currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n                    break;\n                }\n            }\n            if (lineType !== 1 /* LineType.WithSteps */ && itemStyle !== currentStyle) {\n                changeStyle(itemStyle, currentItem);\n                ctx.moveTo(currentItem._internal_x * horizontalPixelRatio, currentItem._internal_y * verticalPixelRatio);\n            }\n        }\n        if (currentStyleFirstItem !== currentItem || currentStyleFirstItem === currentItem && lineType === 1 /* LineType.WithSteps */) {\n            finishStyledArea(renderingScope, currentStyle, currentStyleFirstItem, currentItem);\n        }\n    }\n}\nconst curveTension = 6;\nfunction subtract(p1, p2) {\n    return { _internal_x: p1._internal_x - p2._internal_x, _internal_y: p1._internal_y - p2._internal_y };\n}\nfunction add(p1, p2) {\n    return { _internal_x: p1._internal_x + p2._internal_x, _internal_y: p1._internal_y + p2._internal_y };\n}\nfunction divide(p1, n) {\n    return { _internal_x: p1._internal_x / n, _internal_y: p1._internal_y / n };\n}\n/**\n * @returns Two control points that can be used as arguments to {@link CanvasRenderingContext2D.bezierCurveTo} to draw a curved line between `points[fromPointIndex]` and `points[toPointIndex]`.\n */\nfunction getControlPoints(points, fromPointIndex, toPointIndex) {\n    const beforeFromPointIndex = Math.max(0, fromPointIndex - 1);\n    const afterToPointIndex = Math.min(points.length - 1, toPointIndex + 1);\n    const cp1 = add(points[fromPointIndex], divide(subtract(points[toPointIndex], points[beforeFromPointIndex]), curveTension));\n    const cp2 = subtract(points[toPointIndex], divide(subtract(points[afterToPointIndex], points[fromPointIndex]), curveTension));\n    return [cp1, cp2];\n}\n\nfunction finishStyledArea$1(scope, style) {\n    const ctx = scope.context;\n    ctx.strokeStyle = style;\n    ctx.stroke();\n}\nclass PaneRendererLineBase extends BitmapCoordinatesPaneRenderer {\n    constructor() {\n        super(...arguments);\n        this._internal__data = null;\n    }\n    _internal_setData(data) {\n        this._internal__data = data;\n    }\n    _internal__drawImpl(renderingScope) {\n        if (this._internal__data === null) {\n            return;\n        }\n        const { _internal_items: items, _internal_visibleRange: visibleRange, _internal_barWidth: barWidth, _internal_lineType: lineType, _internal_lineWidth: lineWidth, _internal_lineStyle: lineStyle, _internal_pointMarkersRadius: pointMarkersRadius } = this._internal__data;\n        if (visibleRange === null) {\n            return;\n        }\n        const ctx = renderingScope.context;\n        ctx.lineCap = 'butt';\n        ctx.lineWidth = lineWidth * renderingScope.verticalPixelRatio;\n        setLineStyle(ctx, lineStyle);\n        ctx.lineJoin = 'round';\n        const styleGetter = this._internal__strokeStyle.bind(this);\n        if (lineType !== undefined) {\n            walkLine(renderingScope, items, lineType, visibleRange, barWidth, styleGetter, finishStyledArea$1);\n        }\n        if (pointMarkersRadius) {\n            drawSeriesPointMarkers(renderingScope, items, pointMarkersRadius, visibleRange, styleGetter);\n        }\n    }\n}\n\nclass PaneRendererLine extends PaneRendererLineBase {\n    _internal__strokeStyle(renderingScope, item) {\n        return item._internal_lineColor;\n    }\n}\n\nclass SeriesLinePaneView extends LinePaneViewBase {\n    constructor() {\n        super(...arguments);\n        this._internal__renderer = new PaneRendererLine();\n    }\n    _internal__createRawItem(time, price, colorer) {\n        return {\n            ...this._internal__createRawItemBase(time, price),\n            ...colorer._internal_barStyle(time),\n        };\n    }\n    _internal__prepareRendererData() {\n        const options = this._internal__series._internal_options();\n        const data = {\n            _internal_items: this._internal__items,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineType: options.lineVisible ? options.lineType : undefined,\n            _internal_lineWidth: options.lineWidth,\n            _internal_pointMarkersRadius: options.pointMarkersVisible ? (options.pointMarkersRadius || options.lineWidth / 2 + 2) : undefined,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: this._internal__model._internal_timeScale()._internal_barSpacing(),\n        };\n        this._internal__renderer._internal_setData(data);\n    }\n}\n\nconst lineStyleDefaults = {\n    color: '#2196f3',\n    lineStyle: 0 /* LineStyle.Solid */,\n    lineWidth: 3,\n    lineType: 0 /* LineType.Simple */,\n    lineVisible: true,\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: '',\n    lastPriceAnimation: 0 /* LastPriceAnimationMode.Disabled */,\n    pointMarkersVisible: false,\n};\nconst createPaneView$5 = (series, model) => new SeriesLinePaneView(series, model);\nconst createLineSeries = () => {\n    const definition = {\n        type: 'Line',\n        isBuiltIn: true,\n        defaultOptions: lineStyleDefaults,\n        /**\n         * @internal\n         */\n        _internal_createPaneView: createPaneView$5,\n    };\n    return definition;\n};\nconst lineSeries = createLineSeries();\n\nfunction createDebouncedMicroTaskHandler(callback) {\n    let scheduled = false;\n    return function (...args) {\n        if (!scheduled) {\n            scheduled = true;\n            queueMicrotask(() => {\n                callback(...args);\n                scheduled = false;\n            });\n        }\n    };\n}\nfunction markWithGreaterWeight$1(a, b) {\n    return a.weight > b.weight ? a : b;\n}\nfunction toInternalHorzScaleItem(item) {\n    return item;\n}\nfunction fromInternalHorzScaleItem(item) {\n    return item;\n}\nclass YieldCurveHorzScaleBehavior {\n    constructor() {\n        this._private__pointsChangedDelegate = new Delegate();\n        this._private__invalidateWhitespace = createDebouncedMicroTaskHandler(() => this._private__pointsChangedDelegate._internal_fire(this._private__largestIndex));\n        this._private__largestIndex = 0;\n    }\n    /** Data changes might require that the whitespace be generated again */\n    _internal_whitespaceInvalidated() {\n        return this._private__pointsChangedDelegate;\n    }\n    _internal_destroy() {\n        this._private__pointsChangedDelegate._internal_destroy();\n    }\n    options() {\n        return this._private__options;\n    }\n    setOptions(options) {\n        this._private__options = options;\n    }\n    preprocessData(data) {\n        // No preprocessing needed for yield curve data\n    }\n    updateFormatter(options) {\n        if (!this._private__options) {\n            return;\n        }\n        this._private__options.localization = options;\n    }\n    createConverterToInternalObj(data) {\n        this._private__invalidateWhitespace();\n        return (time) => {\n            if (time > this._private__largestIndex) {\n                this._private__largestIndex = time;\n            }\n            return toInternalHorzScaleItem(time);\n        };\n    }\n    key(internalItem) {\n        return internalItem;\n    }\n    cacheKey(internalItem) {\n        return fromInternalHorzScaleItem(internalItem);\n    }\n    convertHorzItemToInternal(item) {\n        return toInternalHorzScaleItem(item);\n    }\n    formatHorzItem(item) {\n        return this._private__formatTime(item);\n    }\n    formatTickmark(item) {\n        return this._private__formatTime(item.time);\n    }\n    maxTickMarkWeight(marks) {\n        return marks.reduce(markWithGreaterWeight$1, marks[0]).weight;\n    }\n    fillWeightsForPoints(sortedTimePoints, startIndex) {\n        const timeWeight = (time) => {\n            if (time % 120 === 0) {\n                return 10;\n            }\n            if (time % 60 === 0) {\n                return 9;\n            }\n            if (time % 36 === 0) {\n                return 8;\n            }\n            if (time % 12 === 0) {\n                return 7;\n            }\n            if (time % 6 === 0) {\n                return 6;\n            }\n            if (time % 3 === 0) {\n                return 5;\n            }\n            if (time % 1 === 0) {\n                return 4;\n            }\n            return 0;\n        };\n        for (let index = startIndex; index < sortedTimePoints.length; ++index) {\n            sortedTimePoints[index].timeWeight = timeWeight(fromInternalHorzScaleItem(sortedTimePoints[index].time));\n        }\n        this._private__largestIndex = fromInternalHorzScaleItem(sortedTimePoints[sortedTimePoints.length - 1].time);\n        this._private__invalidateWhitespace();\n    }\n    _private__formatTime(months) {\n        if (this._private__options.localization?.timeFormatter) {\n            return this._private__options.localization.timeFormatter(months);\n        }\n        if (months < 12) {\n            return `${months}M`;\n        }\n        const years = Math.floor(months / 12);\n        const remainingMonths = months % 12;\n        if (remainingMonths === 0) {\n            return `${years}Y`;\n        }\n        return `${years}Y${remainingMonths}M`;\n    }\n}\n\nconst yieldChartOptionsDefaults = {\n    baseResolution: 1,\n    minimumTimeRange: 120,\n    startTimeRange: 0,\n};\n\nfunction generateWhitespaceData({ _internal_start: start, _internal_end: end, _internal_resolution: resolution, }) {\n    return Array.from({ length: Math.floor((end - start) / resolution) + 1 }, \n    // eslint-disable-next-line quote-props\n    (item, i) => ({ 'time': start + i * resolution }));\n}\nfunction buildWhitespaceState(options, lastIndex) {\n    return {\n        _internal_start: Math.max(0, options.startTimeRange),\n        _internal_end: Math.max(0, options.minimumTimeRange, lastIndex || 0),\n        _internal_resolution: Math.max(1, options.baseResolution),\n    };\n}\nconst generateWhitespaceHash = ({ _internal_start: start, _internal_end: end, _internal_resolution: resolution, }) => `${start}~${end}~${resolution}`;\nconst defaultOptions = {\n    yieldCurve: yieldChartOptionsDefaults,\n    // and add sensible default options for yield charts which\n    // are different from the usual defaults.\n    timeScale: {\n        ignoreWhitespaceIndices: true,\n    },\n    leftPriceScale: {\n        visible: true,\n    },\n    rightPriceScale: {\n        visible: false,\n    },\n    localization: {\n        priceFormatter: (value) => {\n            return value.toFixed(3) + '%';\n        },\n    },\n};\nconst lineStyleDefaultOptionOverrides = {\n    lastValueVisible: false,\n    priceLineVisible: false,\n};\nclass YieldChartApi extends ChartApi {\n    constructor(container, options) {\n        const fullOptions = merge(defaultOptions, options || {});\n        const horzBehaviour = new YieldCurveHorzScaleBehavior();\n        super(container, horzBehaviour, fullOptions);\n        horzBehaviour.setOptions(this.options());\n        this._initWhitespaceSeries();\n    }\n    addSeries(definition, options = {}, paneIndex = 0) {\n        if (definition.isBuiltIn && ['Area', 'Line'].includes(definition.type) === false) {\n            throw new Error('Yield curve only support Area and Line series');\n        }\n        const optionOverrides = {\n            ...lineStyleDefaultOptionOverrides,\n            ...options,\n        };\n        return super.addSeries(definition, optionOverrides, paneIndex);\n    }\n    _initWhitespaceSeries() {\n        const horzBehaviour = this.horzBehaviour();\n        const whiteSpaceSeries = this.addSeries(lineSeries);\n        let currentWhitespaceHash;\n        function updateWhitespace(lastIndex) {\n            const newWhitespaceState = buildWhitespaceState(horzBehaviour.options().yieldCurve, lastIndex);\n            const newWhitespaceHash = generateWhitespaceHash(newWhitespaceState);\n            if (newWhitespaceHash !== currentWhitespaceHash) {\n                currentWhitespaceHash = newWhitespaceHash;\n                whiteSpaceSeries.setData(generateWhitespaceData(newWhitespaceState));\n            }\n        }\n        updateWhitespace(0);\n        horzBehaviour._internal_whitespaceInvalidated()._internal_subscribe(updateWhitespace);\n    }\n}\n\n/**\n * Creates a yield curve chart with the specified options.\n *\n * A yield curve chart differs from the default chart type\n * in the following ways:\n * - Horizontal scale is linearly spaced, and defined in monthly\n * time duration units\n * - Whitespace is ignored for the crosshair and grid lines\n *\n * @param container - ID of HTML element or element itself\n * @param options - The yield chart options.\n * @returns An interface to the created chart\n */\nfunction createYieldCurveChart(container, options) {\n    const htmlElement = fetchHtmlElement(container);\n    const chartApi = new YieldChartApi(htmlElement, options);\n    return chartApi;\n}\n\nfunction markWithGreaterWeight(a, b) {\n    return a.weight > b.weight ? a : b;\n}\nclass HorzScaleBehaviorPrice {\n    options() {\n        return this._private__options;\n    }\n    setOptions(options) {\n        this._private__options = options;\n    }\n    preprocessData(data) { }\n    updateFormatter(options) {\n        if (!this._private__options) {\n            return;\n        }\n        this._private__options.localization = options;\n    }\n    createConverterToInternalObj(data) {\n        return (price) => price;\n    }\n    key(internalItem) {\n        return internalItem;\n    }\n    cacheKey(internalItem) {\n        return internalItem;\n    }\n    convertHorzItemToInternal(item) {\n        return item;\n    }\n    formatHorzItem(item) {\n        return item.toFixed(this._private__precision());\n    }\n    formatTickmark(item, localizationOptions) {\n        return item.time.toFixed(this._private__precision());\n    }\n    maxTickMarkWeight(marks) {\n        return marks.reduce(markWithGreaterWeight, marks[0]).weight;\n    }\n    fillWeightsForPoints(sortedTimePoints, startIndex) {\n        const priceWeight = (price) => {\n            if (price === Math.ceil(price / 100) * 100) {\n                return 8;\n            }\n            if (price === Math.ceil(price / 50) * 50) {\n                return 7;\n            }\n            if (price === Math.ceil(price / 25) * 25) {\n                return 6;\n            }\n            if (price === Math.ceil(price / 10) * 10) {\n                return 5;\n            }\n            if (price === Math.ceil(price / 5) * 5) {\n                return 4;\n            }\n            if (price === Math.ceil(price)) {\n                return 3;\n            }\n            if (price * 2 === Math.ceil(price * 2)) {\n                return 1;\n            }\n            return 0;\n        };\n        for (let index = startIndex; index < sortedTimePoints.length; ++index) {\n            sortedTimePoints[index].timeWeight = priceWeight(sortedTimePoints[index].time);\n        }\n    }\n    _private__precision() {\n        return this._private__options.localization\n            .precision;\n    }\n}\n\n/**\n * Creates an 'options' chart with price values on the horizontal scale.\n *\n * This function is used to create a specialized chart type where the horizontal scale\n * represents price values instead of time. It's particularly useful for visualizing\n * option chains, price distributions, or any data where price is the primary x-axis metric.\n *\n * @param container - The DOM element or its id where the chart will be rendered.\n * @param options - Optional configuration options for the price chart.\n * @returns An instance of IChartApiBase configured for price-based horizontal scaling.\n */\nfunction createOptionsChart(container, options) {\n    return createChartEx(container, new HorzScaleBehaviorPrice(), options);\n}\n\nfunction finishStyledArea(baseLevelCoordinate, scope, style, areaFirstItem, newAreaFirstItem) {\n    const { context, horizontalPixelRatio, verticalPixelRatio } = scope;\n    context.lineTo(newAreaFirstItem._internal_x * horizontalPixelRatio, baseLevelCoordinate * verticalPixelRatio);\n    context.lineTo(areaFirstItem._internal_x * horizontalPixelRatio, baseLevelCoordinate * verticalPixelRatio);\n    context.closePath();\n    context.fillStyle = style;\n    context.fill();\n}\nclass PaneRendererAreaBase extends BitmapCoordinatesPaneRenderer {\n    constructor() {\n        super(...arguments);\n        this._internal__data = null;\n    }\n    _internal_setData(data) {\n        this._internal__data = data;\n    }\n    _internal__drawImpl(renderingScope) {\n        if (this._internal__data === null) {\n            return;\n        }\n        const { _internal_items: items, _internal_visibleRange: visibleRange, _internal_barWidth: barWidth, _internal_lineWidth: lineWidth, _internal_lineStyle: lineStyle, _internal_lineType: lineType } = this._internal__data;\n        const baseLevelCoordinate = this._internal__data._internal_baseLevelCoordinate ??\n            (this._internal__data._internal_invertFilledArea ? 0 : renderingScope.mediaSize.height);\n        if (visibleRange === null) {\n            return;\n        }\n        const ctx = renderingScope.context;\n        ctx.lineCap = 'butt';\n        ctx.lineJoin = 'round';\n        ctx.lineWidth = lineWidth;\n        setLineStyle(ctx, lineStyle);\n        // walk lines with width=1 to have more accurate gradient's filling\n        ctx.lineWidth = 1;\n        walkLine(renderingScope, items, lineType, visibleRange, barWidth, this._internal__fillStyle.bind(this), finishStyledArea.bind(null, baseLevelCoordinate));\n    }\n}\n\nclass GradientStyleCache {\n    // eslint-disable-next-line complexity\n    _internal_get(scope, params) {\n        const cachedParams = this._private__params;\n        const { _internal_topColor1: topColor1, _internal_topColor2: topColor2, _internal_bottomColor1: bottomColor1, _internal_bottomColor2: bottomColor2, _internal_baseLevelCoordinate: baseLevelCoordinate, _internal_topCoordinate: topCoordinate, _internal_bottomCoordinate: bottomCoordinate, } = params;\n        if (this._private__cachedValue === undefined ||\n            cachedParams === undefined ||\n            cachedParams._internal_topColor1 !== topColor1 ||\n            cachedParams._internal_topColor2 !== topColor2 ||\n            cachedParams._internal_bottomColor1 !== bottomColor1 ||\n            cachedParams._internal_bottomColor2 !== bottomColor2 ||\n            cachedParams._internal_baseLevelCoordinate !== baseLevelCoordinate ||\n            cachedParams._internal_topCoordinate !== topCoordinate ||\n            cachedParams._internal_bottomCoordinate !== bottomCoordinate) {\n            const { verticalPixelRatio } = scope;\n            const multiplier = baseLevelCoordinate || topCoordinate > 0 ? verticalPixelRatio : 1;\n            const top = topCoordinate * multiplier;\n            const bottom = bottomCoordinate === scope.bitmapSize.height ? bottomCoordinate : bottomCoordinate * multiplier;\n            const baseline = (baseLevelCoordinate ?? 0) * multiplier;\n            const gradient = scope.context.createLinearGradient(0, top, 0, bottom);\n            gradient.addColorStop(0, topColor1);\n            if (baseLevelCoordinate !== null && baseLevelCoordinate !== undefined) {\n                const range = bottom - top;\n                const baselineRatio = clamp(((baseline - top) / range), 0, 1);\n                gradient.addColorStop(baselineRatio, topColor2);\n                gradient.addColorStop(baselineRatio, bottomColor1);\n            }\n            gradient.addColorStop(1, bottomColor2);\n            this._private__cachedValue = gradient;\n            this._private__params = params;\n        }\n        return this._private__cachedValue;\n    }\n}\n\nclass PaneRendererBaselineArea extends PaneRendererAreaBase {\n    constructor() {\n        super(...arguments);\n        this._private__fillCache = new GradientStyleCache();\n    }\n    _internal__fillStyle(renderingScope, item) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const data = this._internal__data;\n        return this._private__fillCache._internal_get(renderingScope, {\n            _internal_topColor1: item._internal_topFillColor1,\n            _internal_topColor2: item._internal_topFillColor2,\n            _internal_bottomColor1: item._internal_bottomFillColor1,\n            _internal_bottomColor2: item._internal_bottomFillColor2,\n            _internal_baseLevelCoordinate: data._internal_baseLevelCoordinate,\n            _internal_topCoordinate: data._internal_topCoordinate ?? 0,\n            _internal_bottomCoordinate: data._internal_bottomCoordinate ?? renderingScope.bitmapSize.height,\n        });\n    }\n}\n\nclass PaneRendererBaselineLine extends PaneRendererLineBase {\n    constructor() {\n        super(...arguments);\n        this._private__strokeCache = new GradientStyleCache();\n    }\n    _internal__strokeStyle(renderingScope, item) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const data = this._internal__data;\n        return this._private__strokeCache._internal_get(renderingScope, {\n            _internal_topColor1: item._internal_topLineColor,\n            _internal_topColor2: item._internal_topLineColor,\n            _internal_bottomColor1: item._internal_bottomLineColor,\n            _internal_bottomColor2: item._internal_bottomLineColor,\n            _internal_baseLevelCoordinate: data._internal_baseLevelCoordinate,\n            _internal_topCoordinate: data._internal_topCoordinate ?? 0,\n            _internal_bottomCoordinate: data._internal_bottomCoordinate ?? renderingScope.bitmapSize.height,\n        });\n    }\n}\n\nclass SeriesBaselinePaneView extends LinePaneViewBase {\n    constructor(series, model) {\n        super(series, model);\n        this._internal__renderer = new CompositeRenderer();\n        this._private__baselineAreaRenderer = new PaneRendererBaselineArea();\n        this._private__baselineLineRenderer = new PaneRendererBaselineLine();\n        this._internal__renderer._internal_setRenderers([this._private__baselineAreaRenderer, this._private__baselineLineRenderer]);\n    }\n    _internal__createRawItem(time, price, colorer) {\n        return {\n            ...this._internal__createRawItemBase(time, price),\n            ...colorer._internal_barStyle(time),\n        };\n    }\n    _internal__prepareRendererData() {\n        const firstValue = this._internal__series._internal_firstValue();\n        if (firstValue === null) {\n            return;\n        }\n        const options = this._internal__series._internal_options();\n        const baseLevelCoordinate = this._internal__series._internal_priceScale()._internal_priceToCoordinate(options.baseValue.price, firstValue._internal_value);\n        const barWidth = this._internal__model._internal_timeScale()._internal_barSpacing();\n        if (this._internal__itemsVisibleRange === null || this._internal__items.length === 0) {\n            return;\n        }\n        let topCoordinate;\n        let bottomCoordinate;\n        if (options.relativeGradient) {\n            topCoordinate = this._internal__items[this._internal__itemsVisibleRange.from]._internal_y;\n            bottomCoordinate = this._internal__items[this._internal__itemsVisibleRange.from]._internal_y;\n            for (let i = this._internal__itemsVisibleRange.from; i < this._internal__itemsVisibleRange.to; i++) {\n                const item = this._internal__items[i];\n                if (item._internal_y < topCoordinate) {\n                    topCoordinate = item._internal_y;\n                }\n                if (item._internal_y > bottomCoordinate) {\n                    bottomCoordinate = item._internal_y;\n                }\n            }\n        }\n        this._private__baselineAreaRenderer._internal_setData({\n            _internal_items: this._internal__items,\n            _internal_lineWidth: options.lineWidth,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineType: options.lineType,\n            _internal_baseLevelCoordinate: baseLevelCoordinate,\n            _internal_topCoordinate: topCoordinate,\n            _internal_bottomCoordinate: bottomCoordinate,\n            _internal_invertFilledArea: false,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: barWidth,\n        });\n        this._private__baselineLineRenderer._internal_setData({\n            _internal_items: this._internal__items,\n            _internal_lineWidth: options.lineWidth,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineType: options.lineVisible ? options.lineType : undefined,\n            _internal_pointMarkersRadius: options.pointMarkersVisible ? (options.pointMarkersRadius || options.lineWidth / 2 + 2) : undefined,\n            _internal_baseLevelCoordinate: baseLevelCoordinate,\n            _internal_topCoordinate: topCoordinate,\n            _internal_bottomCoordinate: bottomCoordinate,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: barWidth,\n        });\n    }\n}\n\nconst baselineStyleDefaults = {\n    baseValue: {\n        type: 'price',\n        price: 0,\n    },\n    relativeGradient: false,\n    topFillColor1: 'rgba(38, 166, 154, 0.28)',\n    topFillColor2: 'rgba(38, 166, 154, 0.05)',\n    topLineColor: 'rgba(38, 166, 154, 1)',\n    bottomFillColor1: 'rgba(239, 83, 80, 0.05)',\n    bottomFillColor2: 'rgba(239, 83, 80, 0.28)',\n    bottomLineColor: 'rgba(239, 83, 80, 1)',\n    lineWidth: 3,\n    lineStyle: 0 /* LineStyle.Solid */,\n    lineType: 0 /* LineType.Simple */,\n    lineVisible: true,\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: '',\n    lastPriceAnimation: 0 /* LastPriceAnimationMode.Disabled */,\n    pointMarkersVisible: false,\n};\nconst createPaneView$4 = (series, model) => new SeriesBaselinePaneView(series, model);\nconst createSeries$4 = () => {\n    const definition = {\n        type: 'Baseline',\n        isBuiltIn: true,\n        defaultOptions: baselineStyleDefaults,\n        /**\n         * @internal\n         */\n        _internal_createPaneView: createPaneView$4,\n    };\n    return definition;\n};\nconst baselineSeries = createSeries$4();\n\nclass PaneRendererArea extends PaneRendererAreaBase {\n    constructor() {\n        super(...arguments);\n        this._private__fillCache = new GradientStyleCache();\n    }\n    _internal__fillStyle(renderingScope, item) {\n        return this._private__fillCache._internal_get(renderingScope, {\n            _internal_topColor1: item._internal_topColor,\n            _internal_topColor2: '',\n            _internal_bottomColor1: '',\n            _internal_bottomColor2: item._internal_bottomColor,\n            _internal_topCoordinate: this._internal__data?._internal_topCoordinate ?? 0,\n            _internal_bottomCoordinate: renderingScope.bitmapSize.height,\n        });\n    }\n}\n\nclass SeriesAreaPaneView extends LinePaneViewBase {\n    constructor(series, model) {\n        super(series, model);\n        this._internal__renderer = new CompositeRenderer();\n        this._private__areaRenderer = new PaneRendererArea();\n        this._private__lineRenderer = new PaneRendererLine();\n        this._internal__renderer._internal_setRenderers([this._private__areaRenderer, this._private__lineRenderer]);\n    }\n    _internal__createRawItem(time, price, colorer) {\n        return {\n            ...this._internal__createRawItemBase(time, price),\n            ...colorer._internal_barStyle(time),\n        };\n    }\n    _internal__prepareRendererData() {\n        const options = this._internal__series._internal_options();\n        if (this._internal__itemsVisibleRange === null || this._internal__items.length === 0) {\n            return;\n        }\n        let topCoordinate;\n        if (options.relativeGradient) {\n            topCoordinate = this._internal__items[this._internal__itemsVisibleRange.from]._internal_y;\n            for (let i = this._internal__itemsVisibleRange.from; i < this._internal__itemsVisibleRange.to; i++) {\n                const item = this._internal__items[i];\n                if (item._internal_y < topCoordinate) {\n                    topCoordinate = item._internal_y;\n                }\n            }\n        }\n        this._private__areaRenderer._internal_setData({\n            _internal_lineType: options.lineType,\n            _internal_items: this._internal__items,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineWidth: options.lineWidth,\n            _internal_baseLevelCoordinate: null,\n            _internal_topCoordinate: topCoordinate,\n            _internal_invertFilledArea: options.invertFilledArea,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: this._internal__model._internal_timeScale()._internal_barSpacing(),\n        });\n        this._private__lineRenderer._internal_setData({\n            _internal_lineType: options.lineVisible ? options.lineType : undefined,\n            _internal_items: this._internal__items,\n            _internal_lineStyle: options.lineStyle,\n            _internal_lineWidth: options.lineWidth,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_barWidth: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_pointMarkersRadius: options.pointMarkersVisible ? (options.pointMarkersRadius || options.lineWidth / 2 + 2) : undefined,\n        });\n    }\n}\n\nconst areaStyleDefaults = {\n    topColor: 'rgba( 46, 220, 135, 0.4)',\n    bottomColor: 'rgba( 40, 221, 100, 0)',\n    invertFilledArea: false,\n    relativeGradient: false,\n    lineColor: '#33D778',\n    lineStyle: 0 /* LineStyle.Solid */,\n    lineWidth: 3,\n    lineType: 0 /* LineType.Simple */,\n    lineVisible: true,\n    crosshairMarkerVisible: true,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: '',\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: '',\n    lastPriceAnimation: 0 /* LastPriceAnimationMode.Disabled */,\n    pointMarkersVisible: false,\n};\nconst createPaneView$3 = (series, model) => new SeriesAreaPaneView(series, model);\nconst createSeries$3 = () => {\n    const definition = {\n        type: 'Area',\n        isBuiltIn: true,\n        defaultOptions: areaStyleDefaults,\n        /**\n         * @internal\n         */\n        _internal_createPaneView: createPaneView$3,\n    };\n    return definition;\n};\nconst areaSeries = createSeries$3();\n\nfunction optimalBarWidth(barSpacing, pixelRatio) {\n    return Math.floor(barSpacing * 0.3 * pixelRatio);\n}\nfunction optimalCandlestickWidth(barSpacing, pixelRatio) {\n    const barSpacingSpecialCaseFrom = 2.5;\n    const barSpacingSpecialCaseTo = 4;\n    const barSpacingSpecialCaseCoeff = 3;\n    if (barSpacing >= barSpacingSpecialCaseFrom && barSpacing <= barSpacingSpecialCaseTo) {\n        return Math.floor(barSpacingSpecialCaseCoeff * pixelRatio);\n    }\n    // coeff should be 1 on small barspacing and go to 0.8 while groing bar spacing\n    const barSpacingReducingCoeff = 0.2;\n    const coeff = 1 - barSpacingReducingCoeff * Math.atan(Math.max(barSpacingSpecialCaseTo, barSpacing) - barSpacingSpecialCaseTo) / (Math.PI * 0.5);\n    const res = Math.floor(barSpacing * coeff * pixelRatio);\n    const scaledBarSpacing = Math.floor(barSpacing * pixelRatio);\n    const optimal = Math.min(res, scaledBarSpacing);\n    return Math.max(Math.floor(pixelRatio), optimal);\n}\n\nclass PaneRendererBars extends BitmapCoordinatesPaneRenderer {\n    constructor() {\n        super(...arguments);\n        this._private__data = null;\n        this._private__barWidth = 0;\n        this._private__barLineWidth = 0;\n    }\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    // eslint-disable-next-line complexity\n    _internal__drawImpl({ context: ctx, horizontalPixelRatio, verticalPixelRatio }) {\n        if (this._private__data === null || this._private__data._internal_bars.length === 0 || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        this._private__barWidth = this._private__calcBarWidth(horizontalPixelRatio);\n        // grid and crosshair have line width = Math.floor(pixelRatio)\n        // if this value is odd, we have to make bars' width odd\n        // if this value is even, we have to make bars' width even\n        // in order of keeping crosshair-over-bar drawing symmetric\n        if (this._private__barWidth >= 2) {\n            const lineWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n            if ((lineWidth % 2) !== (this._private__barWidth % 2)) {\n                this._private__barWidth--;\n            }\n        }\n        // if scale is compressed, bar could become less than 1 CSS pixel\n        this._private__barLineWidth = this._private__data._internal_thinBars ? Math.min(this._private__barWidth, Math.floor(horizontalPixelRatio)) : this._private__barWidth;\n        let prevColor = null;\n        const drawOpenClose = this._private__barLineWidth <= this._private__barWidth && this._private__data._internal_barSpacing >= Math.floor(1.5 * horizontalPixelRatio);\n        for (let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; ++i) {\n            const bar = this._private__data._internal_bars[i];\n            if (prevColor !== bar._internal_barColor) {\n                ctx.fillStyle = bar._internal_barColor;\n                prevColor = bar._internal_barColor;\n            }\n            const bodyWidthHalf = Math.floor(this._private__barLineWidth * 0.5);\n            const bodyCenter = Math.round(bar._internal_x * horizontalPixelRatio);\n            const bodyLeft = bodyCenter - bodyWidthHalf;\n            const bodyWidth = this._private__barLineWidth;\n            const bodyRight = bodyLeft + bodyWidth - 1;\n            const high = Math.min(bar._internal_highY, bar._internal_lowY);\n            const low = Math.max(bar._internal_highY, bar._internal_lowY);\n            const bodyTop = Math.round(high * verticalPixelRatio) - bodyWidthHalf;\n            const bodyBottom = Math.round(low * verticalPixelRatio) + bodyWidthHalf;\n            const bodyHeight = Math.max((bodyBottom - bodyTop), this._private__barLineWidth);\n            ctx.fillRect(bodyLeft, bodyTop, bodyWidth, bodyHeight);\n            const sideWidth = Math.ceil(this._private__barWidth * 1.5);\n            if (drawOpenClose) {\n                if (this._private__data._internal_openVisible) {\n                    const openLeft = bodyCenter - sideWidth;\n                    let openTop = Math.max(bodyTop, Math.round(bar._internal_openY * verticalPixelRatio) - bodyWidthHalf);\n                    let openBottom = openTop + bodyWidth - 1;\n                    if (openBottom > bodyTop + bodyHeight - 1) {\n                        openBottom = bodyTop + bodyHeight - 1;\n                        openTop = openBottom - bodyWidth + 1;\n                    }\n                    ctx.fillRect(openLeft, openTop, bodyLeft - openLeft, openBottom - openTop + 1);\n                }\n                const closeRight = bodyCenter + sideWidth;\n                let closeTop = Math.max(bodyTop, Math.round(bar._internal_closeY * verticalPixelRatio) - bodyWidthHalf);\n                let closeBottom = closeTop + bodyWidth - 1;\n                if (closeBottom > bodyTop + bodyHeight - 1) {\n                    closeBottom = bodyTop + bodyHeight - 1;\n                    closeTop = closeBottom - bodyWidth + 1;\n                }\n                ctx.fillRect(bodyRight + 1, closeTop, closeRight - bodyRight, closeBottom - closeTop + 1);\n            }\n        }\n    }\n    _private__calcBarWidth(pixelRatio) {\n        const limit = Math.floor(pixelRatio);\n        return Math.max(limit, Math.floor(optimalBarWidth(ensureNotNull(this._private__data)._internal_barSpacing, pixelRatio)));\n    }\n}\n\nclass BarsPaneViewBase extends SeriesPaneViewBase {\n    constructor(series, model) {\n        super(series, model, false);\n    }\n    _internal__convertToCoordinates(priceScale, timeScale, firstValue) {\n        timeScale._internal_indexesToCoordinates(this._internal__items, undefinedIfNull(this._internal__itemsVisibleRange));\n        priceScale._internal_barPricesToCoordinates(this._internal__items, firstValue, undefinedIfNull(this._internal__itemsVisibleRange));\n    }\n    _internal__createDefaultItem(time, bar, colorer) {\n        return {\n            _internal_time: time,\n            _internal_open: bar._internal_value[0 /* PlotRowValueIndex.Open */],\n            _internal_high: bar._internal_value[1 /* PlotRowValueIndex.High */],\n            _internal_low: bar._internal_value[2 /* PlotRowValueIndex.Low */],\n            _internal_close: bar._internal_value[3 /* PlotRowValueIndex.Close */],\n            _internal_x: NaN,\n            _internal_openY: NaN,\n            _internal_highY: NaN,\n            _internal_lowY: NaN,\n            _internal_closeY: NaN,\n        };\n    }\n    _internal__fillRawPoints() {\n        const colorer = this._internal__series._internal_barColorer();\n        this._internal__items = this._internal__series._internal_bars()._internal_rows().map((row) => this._internal__createRawItem(row._internal_index, row, colorer));\n    }\n}\n\nclass SeriesBarsPaneView extends BarsPaneViewBase {\n    constructor() {\n        super(...arguments);\n        this._internal__renderer = new PaneRendererBars();\n    }\n    _internal__createRawItem(time, bar, colorer) {\n        return {\n            ...this._internal__createDefaultItem(time, bar, colorer),\n            ...colorer._internal_barStyle(time),\n        };\n    }\n    _internal__prepareRendererData() {\n        const barStyleProps = this._internal__series._internal_options();\n        this._internal__renderer._internal_setData({\n            _internal_bars: this._internal__items,\n            _internal_barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_openVisible: barStyleProps.openVisible,\n            _internal_thinBars: barStyleProps.thinBars,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n        });\n    }\n}\n\nconst barStyleDefaults = {\n    upColor: '#26a69a',\n    downColor: '#ef5350',\n    openVisible: true,\n    thinBars: true,\n};\nconst createPaneView$2 = (series, model) => new SeriesBarsPaneView(series, model);\nconst createSeries$2 = () => {\n    const definition = {\n        type: 'Bar',\n        isBuiltIn: true,\n        defaultOptions: barStyleDefaults,\n        /**\n         * @internal\n         */\n        _internal_createPaneView: createPaneView$2,\n    };\n    return definition;\n};\nconst barSeries = createSeries$2();\n\nclass PaneRendererCandlesticks extends BitmapCoordinatesPaneRenderer {\n    constructor() {\n        super(...arguments);\n        this._private__data = null;\n        // scaled with pixelRatio\n        this._private__barWidth = 0;\n    }\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal__drawImpl(renderingScope) {\n        if (this._private__data === null || this._private__data._internal_bars.length === 0 || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        const { horizontalPixelRatio } = renderingScope;\n        // now we know pixelRatio and we could calculate barWidth effectively\n        this._private__barWidth = optimalCandlestickWidth(this._private__data._internal_barSpacing, horizontalPixelRatio);\n        // grid and crosshair have line width = Math.floor(pixelRatio)\n        // if this value is odd, we have to make candlesticks' width odd\n        // if this value is even, we have to make candlesticks' width even\n        // in order of keeping crosshair-over-candlesticks drawing symmetric\n        if (this._private__barWidth >= 2) {\n            const wickWidth = Math.floor(horizontalPixelRatio);\n            if ((wickWidth % 2) !== (this._private__barWidth % 2)) {\n                this._private__barWidth--;\n            }\n        }\n        const bars = this._private__data._internal_bars;\n        if (this._private__data._internal_wickVisible) {\n            this._private__drawWicks(renderingScope, bars, this._private__data._internal_visibleRange);\n        }\n        if (this._private__data._internal_borderVisible) {\n            this._private__drawBorder(renderingScope, bars, this._private__data._internal_visibleRange);\n        }\n        const borderWidth = this._private__calculateBorderWidth(horizontalPixelRatio);\n        if (!this._private__data._internal_borderVisible || this._private__barWidth > borderWidth * 2) {\n            this._private__drawCandles(renderingScope, bars, this._private__data._internal_visibleRange);\n        }\n    }\n    _private__drawWicks(renderingScope, bars, visibleRange) {\n        if (this._private__data === null) {\n            return;\n        }\n        const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n        let prevWickColor = '';\n        let wickWidth = Math.min(Math.floor(horizontalPixelRatio), Math.floor(this._private__data._internal_barSpacing * horizontalPixelRatio));\n        wickWidth = Math.max(Math.floor(horizontalPixelRatio), Math.min(wickWidth, this._private__barWidth));\n        const wickOffset = Math.floor(wickWidth * 0.5);\n        let prevEdge = null;\n        for (let i = visibleRange.from; i < visibleRange.to; i++) {\n            const bar = bars[i];\n            if (bar._internal_barWickColor !== prevWickColor) {\n                ctx.fillStyle = bar._internal_barWickColor;\n                prevWickColor = bar._internal_barWickColor;\n            }\n            const top = Math.round(Math.min(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            const bottom = Math.round(Math.max(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            const high = Math.round(bar._internal_highY * verticalPixelRatio);\n            const low = Math.round(bar._internal_lowY * verticalPixelRatio);\n            const scaledX = Math.round(horizontalPixelRatio * bar._internal_x);\n            let left = scaledX - wickOffset;\n            const right = left + wickWidth - 1;\n            if (prevEdge !== null) {\n                left = Math.max(prevEdge + 1, left);\n                left = Math.min(left, right);\n            }\n            const width = right - left + 1;\n            ctx.fillRect(left, high, width, top - high);\n            ctx.fillRect(left, bottom + 1, width, low - bottom);\n            prevEdge = right;\n        }\n    }\n    _private__calculateBorderWidth(pixelRatio) {\n        let borderWidth = Math.floor(1 /* Constants.BarBorderWidth */ * pixelRatio);\n        if (this._private__barWidth <= 2 * borderWidth) {\n            borderWidth = Math.floor((this._private__barWidth - 1) * 0.5);\n        }\n        const res = Math.max(Math.floor(pixelRatio), borderWidth);\n        if (this._private__barWidth <= res * 2) {\n            // do not draw bodies, restore original value\n            return Math.max(Math.floor(pixelRatio), Math.floor(1 /* Constants.BarBorderWidth */ * pixelRatio));\n        }\n        return res;\n    }\n    _private__drawBorder(renderingScope, bars, visibleRange) {\n        if (this._private__data === null) {\n            return;\n        }\n        const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n        let prevBorderColor = '';\n        const borderWidth = this._private__calculateBorderWidth(horizontalPixelRatio);\n        let prevEdge = null;\n        for (let i = visibleRange.from; i < visibleRange.to; i++) {\n            const bar = bars[i];\n            if (bar._internal_barBorderColor !== prevBorderColor) {\n                ctx.fillStyle = bar._internal_barBorderColor;\n                prevBorderColor = bar._internal_barBorderColor;\n            }\n            let left = Math.round(bar._internal_x * horizontalPixelRatio) - Math.floor(this._private__barWidth * 0.5);\n            // this is important to calculate right before patching left\n            const right = left + this._private__barWidth - 1;\n            const top = Math.round(Math.min(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            const bottom = Math.round(Math.max(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            if (prevEdge !== null) {\n                left = Math.max(prevEdge + 1, left);\n                left = Math.min(left, right);\n            }\n            if (this._private__data._internal_barSpacing * horizontalPixelRatio > 2 * borderWidth) {\n                fillRectInnerBorder(ctx, left, top, right - left + 1, bottom - top + 1, borderWidth);\n            }\n            else {\n                const width = right - left + 1;\n                ctx.fillRect(left, top, width, bottom - top + 1);\n            }\n            prevEdge = right;\n        }\n    }\n    _private__drawCandles(renderingScope, bars, visibleRange) {\n        if (this._private__data === null) {\n            return;\n        }\n        const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;\n        let prevBarColor = '';\n        const borderWidth = this._private__calculateBorderWidth(horizontalPixelRatio);\n        for (let i = visibleRange.from; i < visibleRange.to; i++) {\n            const bar = bars[i];\n            let top = Math.round(Math.min(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            let bottom = Math.round(Math.max(bar._internal_openY, bar._internal_closeY) * verticalPixelRatio);\n            let left = Math.round(bar._internal_x * horizontalPixelRatio) - Math.floor(this._private__barWidth * 0.5);\n            let right = left + this._private__barWidth - 1;\n            if (bar._internal_barColor !== prevBarColor) {\n                const barColor = bar._internal_barColor;\n                ctx.fillStyle = barColor;\n                prevBarColor = barColor;\n            }\n            if (this._private__data._internal_borderVisible) {\n                left += borderWidth;\n                top += borderWidth;\n                right -= borderWidth;\n                bottom -= borderWidth;\n            }\n            if (top > bottom) {\n                continue;\n            }\n            ctx.fillRect(left, top, right - left + 1, bottom - top + 1);\n        }\n    }\n}\n\nclass SeriesCandlesticksPaneView extends BarsPaneViewBase {\n    constructor() {\n        super(...arguments);\n        this._internal__renderer = new PaneRendererCandlesticks();\n    }\n    _internal__createRawItem(time, bar, colorer) {\n        return {\n            ...this._internal__createDefaultItem(time, bar, colorer),\n            ...colorer._internal_barStyle(time),\n        };\n    }\n    _internal__prepareRendererData() {\n        const candlestickStyleProps = this._internal__series._internal_options();\n        this._internal__renderer._internal_setData({\n            _internal_bars: this._internal__items,\n            _internal_barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_wickVisible: candlestickStyleProps.wickVisible,\n            _internal_borderVisible: candlestickStyleProps.borderVisible,\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n        });\n    }\n}\n\nconst candlestickStyleDefaults = {\n    upColor: '#26a69a',\n    downColor: '#ef5350',\n    wickVisible: true,\n    borderVisible: true,\n    borderColor: '#378658',\n    borderUpColor: '#26a69a',\n    borderDownColor: '#ef5350',\n    wickColor: '#737375',\n    wickUpColor: '#26a69a',\n    wickDownColor: '#ef5350',\n};\nconst createPaneView$1 = (series, model) => new SeriesCandlesticksPaneView(series, model);\nconst createSeries$1 = () => {\n    const definition = {\n        type: 'Candlestick',\n        isBuiltIn: true,\n        defaultOptions: candlestickStyleDefaults,\n        /**\n         * @internal\n         */\n        _internal_createPaneView: createPaneView$1,\n    };\n    return definition;\n};\nconst candlestickSeries = createSeries$1();\n\nconst showSpacingMinimalBarWidth = 1;\nconst alignToMinimalWidthLimit = 4;\nclass PaneRendererHistogram extends BitmapCoordinatesPaneRenderer {\n    constructor() {\n        super(...arguments);\n        this._private__data = null;\n        this._private__precalculatedCache = [];\n    }\n    _internal_setData(data) {\n        this._private__data = data;\n        this._private__precalculatedCache = [];\n    }\n    _internal__drawImpl({ context: ctx, horizontalPixelRatio, verticalPixelRatio }) {\n        if (this._private__data === null || this._private__data._internal_items.length === 0 || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        if (!this._private__precalculatedCache.length) {\n            this._private__fillPrecalculatedCache(horizontalPixelRatio);\n        }\n        const tickWidth = Math.max(1, Math.floor(verticalPixelRatio));\n        const histogramBase = Math.round((this._private__data._internal_histogramBase) * verticalPixelRatio);\n        const topHistogramBase = histogramBase - Math.floor(tickWidth / 2);\n        const bottomHistogramBase = topHistogramBase + tickWidth;\n        for (let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++) {\n            const item = this._private__data._internal_items[i];\n            const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n            const y = Math.round(item._internal_y * verticalPixelRatio);\n            ctx.fillStyle = item._internal_barColor;\n            let top;\n            let bottom;\n            if (y <= topHistogramBase) {\n                top = y;\n                bottom = bottomHistogramBase;\n            }\n            else {\n                top = topHistogramBase;\n                bottom = y - Math.floor(tickWidth / 2) + tickWidth;\n            }\n            ctx.fillRect(current._internal_left, top, current._internal_right - current._internal_left + 1, bottom - top);\n        }\n    }\n    // eslint-disable-next-line complexity\n    _private__fillPrecalculatedCache(pixelRatio) {\n        if (this._private__data === null || this._private__data._internal_items.length === 0 || this._private__data._internal_visibleRange === null) {\n            this._private__precalculatedCache = [];\n            return;\n        }\n        const spacing = Math.ceil(this._private__data._internal_barSpacing * pixelRatio) <= showSpacingMinimalBarWidth ? 0 : Math.max(1, Math.floor(pixelRatio));\n        const columnWidth = Math.round(this._private__data._internal_barSpacing * pixelRatio) - spacing;\n        this._private__precalculatedCache = new Array(this._private__data._internal_visibleRange.to - this._private__data._internal_visibleRange.from);\n        for (let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++) {\n            const item = this._private__data._internal_items[i];\n            // force cast to avoid ensureDefined call\n            const x = Math.round(item._internal_x * pixelRatio);\n            let left;\n            let right;\n            if (columnWidth % 2) {\n                const halfWidth = (columnWidth - 1) / 2;\n                left = x - halfWidth;\n                right = x + halfWidth;\n            }\n            else {\n                // shift pixel to left\n                const halfWidth = columnWidth / 2;\n                left = x - halfWidth;\n                right = x + halfWidth - 1;\n            }\n            this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from] = {\n                _internal_left: left,\n                _internal_right: right,\n                _internal_roundedCenter: x,\n                _internal_center: (item._internal_x * pixelRatio),\n                _internal_time: item._internal_time,\n            };\n        }\n        // correct positions\n        for (let i = this._private__data._internal_visibleRange.from + 1; i < this._private__data._internal_visibleRange.to; i++) {\n            const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n            const prev = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from - 1];\n            if (current._internal_time !== prev._internal_time + 1) {\n                continue;\n            }\n            if (current._internal_left - prev._internal_right !== (spacing + 1)) {\n                // have to align\n                if (prev._internal_roundedCenter > prev._internal_center) {\n                    // prev wasshifted to left, so add pixel to right\n                    prev._internal_right = current._internal_left - spacing - 1;\n                }\n                else {\n                    // extend current to left\n                    current._internal_left = prev._internal_right + spacing + 1;\n                }\n            }\n        }\n        let minWidth = Math.ceil(this._private__data._internal_barSpacing * pixelRatio);\n        for (let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++) {\n            const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n            // this could happen if barspacing < 1\n            if (current._internal_right < current._internal_left) {\n                current._internal_right = current._internal_left;\n            }\n            const width = current._internal_right - current._internal_left + 1;\n            minWidth = Math.min(width, minWidth);\n        }\n        if (spacing > 0 && minWidth < alignToMinimalWidthLimit) {\n            for (let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++) {\n                const current = this._private__precalculatedCache[i - this._private__data._internal_visibleRange.from];\n                const width = current._internal_right - current._internal_left + 1;\n                if (width > minWidth) {\n                    if (current._internal_roundedCenter > current._internal_center) {\n                        current._internal_right -= 1;\n                    }\n                    else {\n                        current._internal_left += 1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nclass SeriesHistogramPaneView extends LinePaneViewBase {\n    constructor() {\n        super(...arguments);\n        this._internal__renderer = new PaneRendererHistogram();\n    }\n    _internal__createRawItem(time, price, colorer) {\n        return {\n            ...this._internal__createRawItemBase(time, price),\n            ...colorer._internal_barStyle(time),\n        };\n    }\n    _internal__prepareRendererData() {\n        const data = {\n            _internal_items: this._internal__items,\n            _internal_barSpacing: this._internal__model._internal_timeScale()._internal_barSpacing(),\n            _internal_visibleRange: this._internal__itemsVisibleRange,\n            _internal_histogramBase: this._internal__series._internal_priceScale()._internal_priceToCoordinate(this._internal__series._internal_options().base, ensureNotNull(this._internal__series._internal_firstValue())._internal_value),\n        };\n        this._internal__renderer._internal_setData(data);\n    }\n}\n\nconst histogramStyleDefaults = {\n    color: '#26a69a',\n    base: 0,\n};\nconst createPaneView = (series, model) => new SeriesHistogramPaneView(series, model);\nconst createSeries = () => {\n    const definition = {\n        type: 'Histogram',\n        isBuiltIn: true,\n        defaultOptions: histogramStyleDefaults,\n        /**\n         * @internal\n         */\n        _internal_createPaneView: createPaneView,\n    };\n    return definition;\n};\nconst histogramSeries = createSeries();\n\nclass PanePrimitiveWrapper {\n    constructor(pane, primitive) {\n        this._private__pane = pane;\n        this._private__primitive = primitive;\n        this._private__attach();\n    }\n    detach() {\n        this._private__pane.detachPrimitive(this._private__primitive);\n    }\n    getPane() {\n        return this._private__pane;\n    }\n    applyOptions(options) {\n        this._private__primitive._internal_applyOptions?.(options);\n    }\n    _private__attach() {\n        this._private__pane.attachPrimitive(this._private__primitive);\n    }\n}\n\nconst textWatermarkOptionsDefaults = {\n    visible: true,\n    horzAlign: 'center',\n    vertAlign: 'center',\n    lines: [],\n};\nconst textWatermarkLineOptionsDefaults = {\n    color: 'rgba(0, 0, 0, 0.5)',\n    fontSize: 48,\n    fontFamily: defaultFontFamily,\n    fontStyle: '',\n    text: '',\n};\n\nclass TextWatermarkRenderer {\n    constructor(options) {\n        this._private__metricsCache = new Map();\n        this._private__data = options;\n    }\n    draw(target) {\n        target.useMediaCoordinateSpace((scope) => {\n            if (!this._private__data.visible) {\n                return;\n            }\n            const { context: ctx, mediaSize } = scope;\n            let textHeight = 0;\n            for (const line of this._private__data.lines) {\n                if (line.text.length === 0) {\n                    continue;\n                }\n                ctx.font = line._internal_font;\n                const textWidth = this._private__metrics(ctx, line.text);\n                if (textWidth > mediaSize.width) {\n                    line._internal_zoom = mediaSize.width / textWidth;\n                }\n                else {\n                    line._internal_zoom = 1;\n                }\n                textHeight += line.lineHeight * line._internal_zoom;\n            }\n            let vertOffset = 0;\n            switch (this._private__data.vertAlign) {\n                case 'top':\n                    vertOffset = 0;\n                    break;\n                case 'center':\n                    vertOffset = Math.max((mediaSize.height - textHeight) / 2, 0);\n                    break;\n                case 'bottom':\n                    vertOffset = Math.max(mediaSize.height - textHeight, 0);\n                    break;\n            }\n            for (const line of this._private__data.lines) {\n                ctx.save();\n                ctx.fillStyle = line.color;\n                let horzOffset = 0;\n                switch (this._private__data.horzAlign) {\n                    case 'left':\n                        ctx.textAlign = 'left';\n                        horzOffset = line.lineHeight / 2;\n                        break;\n                    case 'center':\n                        ctx.textAlign = 'center';\n                        horzOffset = mediaSize.width / 2;\n                        break;\n                    case 'right':\n                        ctx.textAlign = 'right';\n                        horzOffset = mediaSize.width - 1 - line.lineHeight / 2;\n                        break;\n                }\n                ctx.translate(horzOffset, vertOffset);\n                ctx.textBaseline = 'top';\n                ctx.font = line._internal_font;\n                ctx.scale(line._internal_zoom, line._internal_zoom);\n                ctx.fillText(line.text, 0, line._internal_vertOffset);\n                ctx.restore();\n                vertOffset += line.lineHeight * line._internal_zoom;\n            }\n        });\n    }\n    _private__metrics(ctx, text) {\n        const fontCache = this._private__fontCache(ctx.font);\n        let result = fontCache.get(text);\n        if (result === undefined) {\n            result = ctx.measureText(text).width;\n            fontCache.set(text, result);\n        }\n        return result;\n    }\n    _private__fontCache(font) {\n        let fontCache = this._private__metricsCache.get(font);\n        if (fontCache === undefined) {\n            fontCache = new Map();\n            this._private__metricsCache.set(font, fontCache);\n        }\n        return fontCache;\n    }\n}\n\nclass TextWatermarkPaneView {\n    constructor(options) {\n        this._private__options = buildRendererOptions$1(options);\n    }\n    _internal_update(options) {\n        this._private__options = buildRendererOptions$1(options);\n    }\n    renderer() {\n        return new TextWatermarkRenderer(this._private__options);\n    }\n}\nfunction buildRendererLineOptions(lineOption) {\n    return {\n        ...lineOption,\n        _internal_font: makeFont(lineOption.fontSize, lineOption.fontFamily, lineOption.fontStyle),\n        lineHeight: lineOption.lineHeight || lineOption.fontSize * 1.2,\n        _internal_vertOffset: 0,\n        _internal_zoom: 0,\n    };\n}\nfunction buildRendererOptions$1(options) {\n    return {\n        ...options,\n        lines: options.lines.map(buildRendererLineOptions),\n    };\n}\n\nfunction mergeLineOptionsWithDefaults(options) {\n    return {\n        ...textWatermarkLineOptionsDefaults,\n        ...options,\n    };\n}\nfunction mergeOptionsWithDefaults$2(options) {\n    return {\n        ...textWatermarkOptionsDefaults,\n        ...options,\n        lines: options.lines?.map(mergeLineOptionsWithDefaults) ?? [],\n    };\n}\nclass TextWatermark {\n    constructor(options) {\n        this._private__options = mergeOptionsWithDefaults$2(options);\n        this._private__paneViews = [new TextWatermarkPaneView(this._private__options)];\n    }\n    updateAllViews() {\n        this._private__paneViews.forEach((pw) => pw._internal_update(this._private__options));\n    }\n    paneViews() {\n        return this._private__paneViews;\n    }\n    attached({ requestUpdate }) {\n        this._internal_requestUpdate = requestUpdate;\n    }\n    detached() {\n        this._internal_requestUpdate = undefined;\n    }\n    _internal_applyOptions(options) {\n        this._private__options = mergeOptionsWithDefaults$2({ ...this._private__options, ...options });\n        if (this._internal_requestUpdate) {\n            this._internal_requestUpdate();\n        }\n    }\n}\n/**\n * Creates an image watermark.\n *\n * @param pane - Target pane.\n * @param options - Watermark options.\n *\n * @returns Image watermark wrapper.\n *\n * @example\n * ```js\n * import { createTextWatermark } from 'lightweight-charts';\n *\n * const firstPane = chart.panes()[0];\n * const textWatermark = createTextWatermark(firstPane, {\n * \t  horzAlign: 'center',\n * \t  vertAlign: 'center',\n * \t  lines: [\n * \t    {\n * \t      text: 'Hello',\n * \t      color: 'rgba(255,0,0,0.5)',\n * \t      fontSize: 100,\n * \t      fontStyle: 'bold',\n * \t    },\n * \t    {\n * \t      text: 'This is a text watermark',\n * \t      color: 'rgba(0,0,255,0.5)',\n * \t      fontSize: 50,\n * \t      fontStyle: 'italic',\n * \t      fontFamily: 'monospace',\n * \t    },\n * \t  ],\n * });\n * // to change options\n * textWatermark.applyOptions({ horzAlign: 'left' });\n * // to remove watermark from the pane\n * textWatermark.detach();\n * ```\n */\nfunction createTextWatermark(pane, options) {\n    return new PanePrimitiveWrapper(pane, new TextWatermark(options));\n}\n\nconst imageWatermarkOptionsDefaults = {\n    alpha: 1,\n    padding: 0,\n};\n\nclass ImageWatermarkRenderer {\n    constructor(data) {\n        this._private__data = data;\n    }\n    draw(target) {\n        target.useMediaCoordinateSpace((scope) => {\n            const ctx = scope.context;\n            const pos = this._private__determinePlacement(this._private__data, scope.mediaSize);\n            if (!pos || !this._private__data._internal_imgElement) {\n                return;\n            }\n            ctx.globalAlpha = this._private__data.alpha ?? 1;\n            ctx.drawImage(this._private__data._internal_imgElement, pos._internal_x, pos._internal_y, pos._internal_width, pos._internal_height);\n        });\n    }\n    _private__determinePlacement(data, paneSize) {\n        const { maxHeight, maxWidth, _internal_imgHeight: imgHeight, _internal_imgWidth: imgWidth, padding } = data;\n        const plotCentreX = Math.round(paneSize.width / 2);\n        const plotCentreY = Math.round(paneSize.height / 2);\n        const paddingSize = padding ?? 0;\n        let availableWidth = paneSize.width - 2 * paddingSize;\n        let availableHeight = paneSize.height - 2 * paddingSize;\n        if (maxHeight) {\n            availableHeight = Math.min(availableHeight, maxHeight);\n        }\n        if (maxWidth) {\n            availableWidth = Math.min(availableWidth, maxWidth);\n        }\n        const scaleX = availableWidth / imgWidth;\n        const scaleY = availableHeight / imgHeight;\n        const scaleToUse = Math.min(scaleX, scaleY);\n        const drawWidth = imgWidth * scaleToUse;\n        const drawHeight = imgHeight * scaleToUse;\n        const x = plotCentreX - 0.5 * drawWidth;\n        const y = plotCentreY - 0.5 * drawHeight;\n        return {\n            _internal_x: x,\n            _internal_y: y,\n            _internal_height: drawHeight,\n            _internal_width: drawWidth,\n        };\n    }\n}\n\nclass ImageWatermarkPaneView {\n    constructor(options) {\n        this._private__image = null;\n        this._private__imageWidth = 0; // don't draw until loaded\n        this._private__imageHeight = 0;\n        this._private__options = options;\n        this._private__rendererOptions = buildRendererOptions(this._private__options, this._private__image, this._private__imageWidth, this._private__imageHeight);\n    }\n    _internal_stateUpdate(state) {\n        if (state._internal_imageWidth !== undefined) {\n            this._private__imageWidth = state._internal_imageWidth;\n        }\n        if (state._internal_imageHeight !== undefined) {\n            this._private__imageHeight = state._internal_imageHeight;\n        }\n        if (state._internal_image !== undefined) {\n            this._private__image = state._internal_image;\n        }\n        this._internal_update();\n    }\n    _internal_optionsUpdate(options) {\n        this._private__options = options;\n        this._internal_update();\n    }\n    zOrder() {\n        return 'bottom';\n    }\n    _internal_update() {\n        this._private__rendererOptions = buildRendererOptions(this._private__options, this._private__image, this._private__imageWidth, this._private__imageHeight);\n    }\n    renderer() {\n        return new ImageWatermarkRenderer(this._private__rendererOptions);\n    }\n}\nfunction buildRendererOptions(options, imgElement, imgWidth, imgHeight) {\n    return {\n        ...options,\n        _internal_imgElement: imgElement,\n        _internal_imgWidth: imgWidth,\n        _internal_imgHeight: imgHeight,\n    };\n}\n\nfunction mergeOptionsWithDefaults$1(options) {\n    return {\n        ...imageWatermarkOptionsDefaults,\n        ...options,\n    };\n}\nclass ImageWatermark {\n    constructor(imageUrl, options) {\n        this._private__imgElement = null;\n        this._private__imageUrl = imageUrl;\n        this._private__options = mergeOptionsWithDefaults$1(options);\n        this._private__paneViews = [new ImageWatermarkPaneView(this._private__options)];\n    }\n    updateAllViews() {\n        this._private__paneViews.forEach((pw) => pw._internal_update());\n    }\n    paneViews() {\n        return this._private__paneViews;\n    }\n    attached(attachedParams) {\n        const { requestUpdate } = attachedParams;\n        this._private__requestUpdate = requestUpdate;\n        this._private__imgElement = new Image();\n        this._private__imgElement.onload = () => {\n            const imageHeight = this._private__imgElement?.naturalHeight ?? 1;\n            const imageWidth = this._private__imgElement?.naturalWidth ?? 1;\n            this._private__paneViews.forEach((pv) => pv._internal_stateUpdate({\n                _internal_imageHeight: imageHeight,\n                _internal_imageWidth: imageWidth,\n                _internal_image: this._private__imgElement,\n            }));\n            if (this._private__requestUpdate) {\n                this._private__requestUpdate();\n            }\n        };\n        this._private__imgElement.src = this._private__imageUrl;\n    }\n    detached() {\n        this._private__requestUpdate = undefined;\n        this._private__imgElement = null;\n    }\n    _internal_applyOptions(options) {\n        this._private__options = mergeOptionsWithDefaults$1({ ...this._private__options, ...options });\n        this._private__updateOptions();\n        if (this._internal_requestUpdate) {\n            this._internal_requestUpdate();\n        }\n    }\n    _internal_requestUpdate() {\n        if (this._private__requestUpdate) {\n            this._private__requestUpdate();\n        }\n    }\n    _private__updateOptions() {\n        this._private__paneViews.forEach((pw) => pw._internal_optionsUpdate(this._private__options));\n    }\n}\n/**\n * Creates an image watermark.\n *\n * @param pane - Target pane.\n * @param imageUrl - Image URL.\n * @param options - Watermark options.\n *\n * @returns Image watermark wrapper.\n *\n * @example\n * ```js\n * import { createImageWatermark } from 'lightweight-charts';\n *\n * const firstPane = chart.panes()[0];\n * const imageWatermark = createImageWatermark(firstPane, '/images/my-image.png', {\n *   alpha: 0.5,\n *   padding: 20,\n * });\n * // to change options\n * imageWatermark.applyOptions({ padding: 10 });\n * // to remove watermark from the pane\n * imageWatermark.detach();\n * ```\n */\nfunction createImageWatermark(pane, imageUrl, options) {\n    return new PanePrimitiveWrapper(pane, new ImageWatermark(imageUrl, options));\n}\n\nclass SeriesPrimitiveAdapter {\n    constructor(series, primitive) {\n        this._internal__series = series;\n        this._internal__primitive = primitive;\n        this._private__attach();\n    }\n    detach() {\n        this._internal__series.detachPrimitive(this._internal__primitive);\n    }\n    getSeries() {\n        return this._internal__series;\n    }\n    applyOptions(options) {\n        if (this._internal__primitive && this._internal__primitive._internal_applyOptions) {\n            this._internal__primitive._internal_applyOptions(options);\n        }\n    }\n    _private__attach() {\n        this._internal__series.attachPrimitive(this._internal__primitive);\n    }\n}\n\nconst seriesMarkerOptionsDefaults = {\n    zOrder: 'normal',\n};\n\nfunction size(barSpacing, coeff) {\n    const result = Math.min(Math.max(barSpacing, 12 /* Constants.MinShapeSize */), 30 /* Constants.MaxShapeSize */) * coeff;\n    return ceiledOdd(result);\n}\nfunction shapeSize(shape, originalSize) {\n    switch (shape) {\n        case 'arrowDown':\n        case 'arrowUp':\n            return size(originalSize, 1);\n        case 'circle':\n            return size(originalSize, 0.8);\n        case 'square':\n            return size(originalSize, 0.7);\n    }\n}\nfunction calculateShapeHeight(barSpacing) {\n    return ceiledEven(size(barSpacing, 1));\n}\nfunction shapeMargin(barSpacing) {\n    return Math.max(size(barSpacing, 0.1), 3 /* Constants.MinShapeMargin */);\n}\nfunction calculateAdjustedMargin(margin, hasSide, hasInBar) {\n    if (hasSide) {\n        return margin;\n    }\n    else if (hasInBar) {\n        return Math.ceil(margin / 2);\n    }\n    return 0;\n}\n\nfunction drawArrow(up, ctx, coords, size) {\n    const arrowSize = shapeSize('arrowUp', size);\n    const halfArrowSize = ((arrowSize - 1) / 2) * coords._internal_pixelRatio;\n    const baseSize = ceiledOdd(size / 2);\n    const halfBaseSize = ((baseSize - 1) / 2) * coords._internal_pixelRatio;\n    ctx.beginPath();\n    if (up) {\n        ctx.moveTo(coords._internal_x - halfArrowSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x, coords._internal_y - halfArrowSize);\n        ctx.lineTo(coords._internal_x + halfArrowSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x + halfBaseSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x + halfBaseSize, coords._internal_y + halfArrowSize);\n        ctx.lineTo(coords._internal_x - halfBaseSize, coords._internal_y + halfArrowSize);\n        ctx.lineTo(coords._internal_x - halfBaseSize, coords._internal_y);\n    }\n    else {\n        ctx.moveTo(coords._internal_x - halfArrowSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x, coords._internal_y + halfArrowSize);\n        ctx.lineTo(coords._internal_x + halfArrowSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x + halfBaseSize, coords._internal_y);\n        ctx.lineTo(coords._internal_x + halfBaseSize, coords._internal_y - halfArrowSize);\n        ctx.lineTo(coords._internal_x - halfBaseSize, coords._internal_y - halfArrowSize);\n        ctx.lineTo(coords._internal_x - halfBaseSize, coords._internal_y);\n    }\n    ctx.fill();\n}\nfunction hitTestArrow(up, centerX, centerY, size, x, y) {\n    const arrowSize = shapeSize('arrowUp', size);\n    const halfArrowSize = (arrowSize - 1) / 2;\n    const baseSize = ceiledOdd(size / 2);\n    const halfBaseSize = (baseSize - 1) / 2;\n    const triangleTolerance = 3;\n    const rectTolerance = 2;\n    const baseLeft = centerX - halfBaseSize - rectTolerance;\n    const baseRight = centerX + halfBaseSize + rectTolerance;\n    const baseTop = up ? centerY : centerY - halfArrowSize;\n    const baseBottom = up ? centerY + halfArrowSize : centerY;\n    if (x >= baseLeft && x <= baseRight &&\n        y >= baseTop - rectTolerance && y <= baseBottom + rectTolerance) {\n        return true;\n    }\n    const isInTriangleBounds = () => {\n        const headLeft = centerX - halfArrowSize - triangleTolerance;\n        const headRight = centerX + halfArrowSize + triangleTolerance;\n        const headTop = up ? centerY - halfArrowSize - triangleTolerance : centerY;\n        const headBottom = up ? centerY : centerY + halfArrowSize + triangleTolerance;\n        if (x < headLeft || x > headRight ||\n            y < headTop || y > headBottom) {\n            return false;\n        }\n        const dx = Math.abs(x - centerX);\n        const dy = up\n            ? Math.abs(y - centerY) // up arrow\n            : Math.abs(y - centerY); // down arrow\n        return dy + triangleTolerance >= dx / 2;\n    };\n    return isInTriangleBounds();\n}\n\nfunction drawCircle(ctx, coords, size) {\n    const circleSize = shapeSize('circle', size);\n    const halfSize = (circleSize - 1) / 2;\n    ctx.beginPath();\n    ctx.arc(coords._internal_x, coords._internal_y, halfSize * coords._internal_pixelRatio, 0, 2 * Math.PI, false);\n    ctx.fill();\n}\nfunction hitTestCircle(centerX, centerY, size, x, y) {\n    const circleSize = shapeSize('circle', size);\n    const tolerance = 2 + circleSize / 2;\n    const xOffset = centerX - x;\n    const yOffset = centerY - y;\n    const dist = Math.sqrt(xOffset * xOffset + yOffset * yOffset);\n    return dist <= tolerance;\n}\n\nfunction drawSquare(ctx, coords, size) {\n    const squareSize = shapeSize('square', size);\n    const halfSize = ((squareSize - 1) * coords._internal_pixelRatio) / 2;\n    const left = coords._internal_x - halfSize;\n    const top = coords._internal_y - halfSize;\n    ctx.fillRect(left, top, squareSize * coords._internal_pixelRatio, squareSize * coords._internal_pixelRatio);\n}\nfunction hitTestSquare(centerX, centerY, size, x, y) {\n    const squareSize = shapeSize('square', size);\n    const halfSize = (squareSize - 1) / 2;\n    const left = centerX - halfSize;\n    const top = centerY - halfSize;\n    return x >= left && x <= left + squareSize &&\n        y >= top && y <= top + squareSize;\n}\n\nfunction drawText(ctx, text, x, y, horizontalPixelRatio, verticalPixelRatio) {\n    ctx.save();\n    ctx.scale(horizontalPixelRatio, verticalPixelRatio);\n    ctx.fillText(text, x, y);\n    ctx.restore();\n}\nfunction hitTestText(textX, textY, textWidth, textHeight, x, y) {\n    const halfHeight = textHeight / 2;\n    return x >= textX && x <= textX + textWidth &&\n        y >= textY - halfHeight && y <= textY + halfHeight;\n}\n\nclass SeriesMarkersRenderer {\n    constructor() {\n        this._private__data = null;\n        this._private__textWidthCache = new TextWidthCache();\n        this._private__fontSize = -1;\n        this._private__fontFamily = '';\n        this._private__font = '';\n        this._private__zOrder = 'normal';\n    }\n    _internal_setData(data) {\n        this._private__data = data;\n    }\n    _internal_setParams(fontSize, fontFamily, zOrder) {\n        if (this._private__fontSize !== fontSize || this._private__fontFamily !== fontFamily) {\n            this._private__fontSize = fontSize;\n            this._private__fontFamily = fontFamily;\n            this._private__font = makeFont(fontSize, fontFamily);\n            this._private__textWidthCache._internal_reset();\n        }\n        this._private__zOrder = zOrder;\n    }\n    _internal_hitTest(x, y) {\n        if (this._private__data === null || this._private__data._internal_visibleRange === null) {\n            return null;\n        }\n        for (let i = this._private__data._internal_visibleRange.from; i < this._private__data._internal_visibleRange.to; i++) {\n            const item = this._private__data._internal_items[i];\n            if (item && hitTestItem(item, x, y)) {\n                return {\n                    zOrder: 'normal',\n                    externalId: item._internal_externalId ?? '',\n                };\n            }\n        }\n        return null;\n    }\n    draw(target) {\n        if (this._private__zOrder === 'aboveSeries') {\n            return;\n        }\n        target.useBitmapCoordinateSpace((scope) => {\n            this._internal__drawImpl(scope);\n        });\n    }\n    drawBackground(target) {\n        if (this._private__zOrder !== 'aboveSeries') {\n            return;\n        }\n        target.useBitmapCoordinateSpace((scope) => {\n            this._internal__drawImpl(scope);\n        });\n    }\n    _internal__drawImpl({ context: ctx, horizontalPixelRatio, verticalPixelRatio }) {\n        if (this._private__data === null || this._private__data._internal_visibleRange === null) {\n            return;\n        }\n        ctx.textBaseline = 'middle';\n        ctx.font = this._private__font;\n        for (let index = this._private__data._internal_visibleRange.from; index < this._private__data._internal_visibleRange.to; index++) {\n            const item = this._private__data._internal_items[index];\n            if (item._internal_text !== undefined) {\n                item._internal_text._internal_width = this._private__textWidthCache._internal_measureText(ctx, item._internal_text._internal_content);\n                item._internal_text._internal_height = this._private__fontSize;\n                item._internal_text._internal_x = item._internal_x - item._internal_text._internal_width / 2;\n            }\n            drawItem(item, ctx, horizontalPixelRatio, verticalPixelRatio);\n        }\n    }\n}\nfunction bitmapShapeItemCoordinates(item, horizontalPixelRatio, verticalPixelRatio) {\n    const tickWidth = Math.max(1, Math.floor(horizontalPixelRatio));\n    const correction = (tickWidth % 2) / 2;\n    return {\n        _internal_x: Math.round(item._internal_x * horizontalPixelRatio) + correction,\n        _internal_y: item._internal_y * verticalPixelRatio,\n        _internal_pixelRatio: horizontalPixelRatio,\n    };\n}\nfunction drawItem(item, ctx, horizontalPixelRatio, verticalPixelRatio) {\n    ctx.fillStyle = item._internal_color;\n    if (item._internal_text !== undefined) {\n        drawText(ctx, item._internal_text._internal_content, item._internal_text._internal_x, item._internal_text._internal_y, horizontalPixelRatio, verticalPixelRatio);\n    }\n    drawShape(item, ctx, bitmapShapeItemCoordinates(item, horizontalPixelRatio, verticalPixelRatio));\n}\nfunction drawShape(item, ctx, coordinates) {\n    if (item._internal_size === 0) {\n        return;\n    }\n    switch (item._internal_shape) {\n        case 'arrowDown':\n            drawArrow(false, ctx, coordinates, item._internal_size);\n            return;\n        case 'arrowUp':\n            drawArrow(true, ctx, coordinates, item._internal_size);\n            return;\n        case 'circle':\n            drawCircle(ctx, coordinates, item._internal_size);\n            return;\n        case 'square':\n            drawSquare(ctx, coordinates, item._internal_size);\n            return;\n    }\n    ensureNever(item._internal_shape);\n}\nfunction hitTestItem(item, x, y) {\n    if (item._internal_text !== undefined && hitTestText(item._internal_text._internal_x, item._internal_text._internal_y, item._internal_text._internal_width, item._internal_text._internal_height, x, y)) {\n        return true;\n    }\n    return hitTestShape(item, x, y);\n}\nfunction hitTestShape(item, x, y) {\n    if (item._internal_size === 0) {\n        return false;\n    }\n    switch (item._internal_shape) {\n        case 'arrowDown':\n            return hitTestArrow(true, item._internal_x, item._internal_y, item._internal_size, x, y);\n        case 'arrowUp':\n            return hitTestArrow(false, item._internal_x, item._internal_y, item._internal_size, x, y);\n        case 'circle':\n            return hitTestCircle(item._internal_x, item._internal_y, item._internal_size, x, y);\n        case 'square':\n            return hitTestSquare(item._internal_x, item._internal_y, item._internal_size, x, y);\n    }\n}\n\nfunction isPriceMarker(position) {\n    return position === 'atPriceTop' || position === 'atPriceBottom' || position === 'atPriceMiddle';\n}\nfunction getPrice(seriesData, marker) {\n    if (isPriceMarker(marker.position) && marker.price !== undefined) {\n        return marker.price;\n    }\n    if (isValueData(seriesData)) {\n        return seriesData.value;\n    }\n    if (isOhlcData(seriesData)) {\n        if (marker.position === 'inBar') {\n            return seriesData.close;\n        }\n        if (marker.position === 'aboveBar') {\n            return seriesData.high;\n        }\n        if (marker.position === 'belowBar') {\n            return seriesData.low;\n        }\n    }\n    return;\n}\n// eslint-disable-next-line max-params, complexity\nfunction fillSizeAndY(rendererItem, marker, seriesData, offsets, textHeight, shapeMargin, series, chart) {\n    const price = getPrice(seriesData, marker);\n    if (price === undefined) {\n        return;\n    }\n    const ignoreOffset = isPriceMarker(marker.position);\n    const timeScale = chart.timeScale();\n    const sizeMultiplier = isNumber(marker.size) ? Math.max(marker.size, 0) : 1;\n    const shapeSize = calculateShapeHeight(timeScale.options().barSpacing) * sizeMultiplier;\n    const halfSize = shapeSize / 2;\n    rendererItem._internal_size = shapeSize;\n    const position = marker.position;\n    switch (position) {\n        case 'inBar':\n        case 'atPriceMiddle': {\n            rendererItem._internal_y = ensureNotNull(series.priceToCoordinate(price));\n            if (rendererItem._internal_text !== undefined) {\n                rendererItem._internal_text._internal_y = rendererItem._internal_y + halfSize + shapeMargin + textHeight * (0.5 + 0.1 /* Constants.TextMargin */);\n            }\n            return;\n        }\n        case 'aboveBar':\n        case 'atPriceTop': {\n            const offset = ignoreOffset ? 0 : offsets._internal_aboveBar;\n            rendererItem._internal_y = (ensureNotNull(series.priceToCoordinate(price)) - halfSize - offset);\n            if (rendererItem._internal_text !== undefined) {\n                rendererItem._internal_text._internal_y = rendererItem._internal_y - halfSize - textHeight * (0.5 + 0.1 /* Constants.TextMargin */);\n                offsets._internal_aboveBar += textHeight * (1 + 2 * 0.1 /* Constants.TextMargin */);\n            }\n            if (!ignoreOffset) {\n                offsets._internal_aboveBar += shapeSize + shapeMargin;\n            }\n            return;\n        }\n        case 'belowBar':\n        case 'atPriceBottom': {\n            const offset = ignoreOffset ? 0 : offsets._internal_belowBar;\n            rendererItem._internal_y = (ensureNotNull(series.priceToCoordinate(price)) + halfSize + offset);\n            if (rendererItem._internal_text !== undefined) {\n                rendererItem._internal_text._internal_y = (rendererItem._internal_y + halfSize + shapeMargin + textHeight * (0.5 + 0.1 /* Constants.TextMargin */));\n                offsets._internal_belowBar += textHeight * (1 + 2 * 0.1 /* Constants.TextMargin */);\n            }\n            if (!ignoreOffset) {\n                offsets._internal_belowBar += shapeSize + shapeMargin;\n            }\n            return;\n        }\n    }\n}\nfunction isValueData(data) {\n    // eslint-disable-next-line no-restricted-syntax\n    return 'value' in data && typeof data.value === 'number';\n}\nfunction isOhlcData(data) {\n    // eslint-disable-next-line no-restricted-syntax\n    return 'open' in data && 'high' in data && 'low' in data && 'close' in data;\n}\nclass SeriesMarkersPaneView {\n    constructor(series, chart, options) {\n        this._private__markers = [];\n        this._private__invalidated = true;\n        this._private__dataInvalidated = true;\n        this._private__renderer = new SeriesMarkersRenderer();\n        this._private__series = series;\n        this._private__chart = chart;\n        this._private__data = {\n            _internal_items: [],\n            _internal_visibleRange: null,\n        };\n        this._private__options = options;\n    }\n    renderer() {\n        if (!this._private__series.options().visible) {\n            return null;\n        }\n        if (this._private__invalidated) {\n            this._internal__makeValid();\n        }\n        const layout = this._private__chart.options()['layout'];\n        this._private__renderer._internal_setParams(layout.fontSize, layout.fontFamily, this._private__options.zOrder);\n        this._private__renderer._internal_setData(this._private__data);\n        return this._private__renderer;\n    }\n    _internal_setMarkers(markers) {\n        this._private__markers = markers;\n        this._internal_update('data');\n    }\n    _internal_update(updateType) {\n        this._private__invalidated = true;\n        if (updateType === 'data') {\n            this._private__dataInvalidated = true;\n        }\n    }\n    _internal_updateOptions(options) {\n        this._private__invalidated = true;\n        this._private__options = options;\n    }\n    zOrder() {\n        return this._private__options.zOrder === 'aboveSeries' ? 'top' : this._private__options.zOrder;\n    }\n    _internal__makeValid() {\n        const timeScale = this._private__chart.timeScale();\n        const seriesMarkers = this._private__markers;\n        if (this._private__dataInvalidated) {\n            this._private__data._internal_items = seriesMarkers.map((marker) => ({\n                _internal_time: marker.time,\n                _internal_x: 0,\n                _internal_y: 0,\n                _internal_size: 0,\n                _internal_shape: marker.shape,\n                _internal_color: marker.color,\n                _internal_externalId: marker.id,\n                _internal_internalId: marker._internal_internalId,\n                _internal_text: undefined,\n            }));\n            this._private__dataInvalidated = false;\n        }\n        const layoutOptions = this._private__chart.options()['layout'];\n        this._private__data._internal_visibleRange = null;\n        const visibleBars = timeScale.getVisibleLogicalRange();\n        if (visibleBars === null) {\n            return;\n        }\n        const visibleBarsRange = new RangeImpl(Math.floor(visibleBars.from), Math.ceil(visibleBars.to));\n        const firstValue = this._private__series.data()[0];\n        if (firstValue === null) {\n            return;\n        }\n        if (this._private__data._internal_items.length === 0) {\n            return;\n        }\n        let prevTimeIndex = NaN;\n        const shapeMargin$1 = shapeMargin(timeScale.options().barSpacing);\n        const offsets = {\n            _internal_aboveBar: shapeMargin$1,\n            _internal_belowBar: shapeMargin$1,\n        };\n        this._private__data._internal_visibleRange = visibleTimedValues(this._private__data._internal_items, visibleBarsRange, true);\n        for (let index = this._private__data._internal_visibleRange.from; index < this._private__data._internal_visibleRange.to; index++) {\n            const marker = seriesMarkers[index];\n            if (marker.time !== prevTimeIndex) {\n                // new bar, reset stack counter\n                offsets._internal_aboveBar = shapeMargin$1;\n                offsets._internal_belowBar = shapeMargin$1;\n                prevTimeIndex = marker.time;\n            }\n            const rendererItem = this._private__data._internal_items[index];\n            rendererItem._internal_x = ensureNotNull(timeScale.logicalToCoordinate(marker.time));\n            if (marker.text !== undefined && marker.text.length > 0) {\n                rendererItem._internal_text = {\n                    _internal_content: marker.text,\n                    _internal_x: 0,\n                    _internal_y: 0,\n                    _internal_width: 0,\n                    _internal_height: 0,\n                };\n            }\n            const dataAt = this._private__series.dataByIndex(marker.time, 0 /* MismatchDirection.None */);\n            if (dataAt === null) {\n                continue;\n            }\n            fillSizeAndY(rendererItem, marker, dataAt, offsets, layoutOptions.fontSize, shapeMargin$1, this._private__series, this._private__chart);\n        }\n        this._private__invalidated = false;\n    }\n}\n\nfunction mergeOptionsWithDefaults(options) {\n    return {\n        ...seriesMarkerOptionsDefaults,\n        ...options,\n    };\n}\nclass SeriesMarkersPrimitive {\n    constructor(options) {\n        this._private__paneView = null;\n        this._private__markers = [];\n        this._private__indexedMarkers = [];\n        this._private__dataChangedHandler = null;\n        this._private__series = null;\n        this._private__chart = null;\n        this._private__autoScaleMarginsInvalidated = true;\n        this._private__autoScaleMargins = null;\n        this._private__markersPositions = null;\n        this._private__cachedBarSpacing = null;\n        this._private__recalculationRequired = true;\n        this._private__options = mergeOptionsWithDefaults(options);\n    }\n    attached(param) {\n        this._private__recalculateMarkers();\n        this._private__chart = param.chart;\n        this._private__series = param.series;\n        this._private__paneView = new SeriesMarkersPaneView(this._private__series, ensureNotNull(this._private__chart), this._private__options);\n        this._private__requestUpdate = param.requestUpdate;\n        this._private__series.subscribeDataChanged((scope) => this._private__onDataChanged(scope));\n        this._private__recalculationRequired = true;\n        this._internal_requestUpdate();\n    }\n    _internal_requestUpdate() {\n        if (this._private__requestUpdate) {\n            this._private__requestUpdate();\n        }\n    }\n    detached() {\n        if (this._private__series && this._private__dataChangedHandler) {\n            this._private__series.unsubscribeDataChanged(this._private__dataChangedHandler);\n        }\n        this._private__chart = null;\n        this._private__series = null;\n        this._private__paneView = null;\n        this._private__dataChangedHandler = null;\n    }\n    _internal_setMarkers(markers) {\n        this._private__recalculationRequired = true;\n        this._private__markers = markers;\n        this._private__recalculateMarkers();\n        this._private__autoScaleMarginsInvalidated = true;\n        this._private__markersPositions = null;\n        this._internal_requestUpdate();\n    }\n    _internal_markers() {\n        return this._private__markers;\n    }\n    paneViews() {\n        return this._private__paneView ? [this._private__paneView] : [];\n    }\n    updateAllViews() {\n        this._private__updateAllViews();\n    }\n    hitTest(x, y) {\n        if (this._private__paneView) {\n            return this._private__paneView.renderer()?._internal_hitTest(x, y) ?? null;\n        }\n        return null;\n    }\n    autoscaleInfo(startTimePoint, endTimePoint) {\n        if (this._private__paneView) {\n            const margins = this._private__getAutoScaleMargins();\n            if (margins) {\n                return {\n                    priceRange: null,\n                    margins: margins,\n                };\n            }\n        }\n        return null;\n    }\n    _internal_applyOptions(options) {\n        this._private__options = mergeOptionsWithDefaults({ ...this._private__options, ...options });\n        if (this._internal_requestUpdate) {\n            this._internal_requestUpdate();\n        }\n    }\n    _private__getAutoScaleMargins() {\n        const chart = ensureNotNull(this._private__chart);\n        const barSpacing = chart.timeScale().options().barSpacing;\n        if (this._private__autoScaleMarginsInvalidated || barSpacing !== this._private__cachedBarSpacing) {\n            this._private__cachedBarSpacing = barSpacing;\n            if (this._private__markers.length > 0) {\n                const shapeMargin$1 = shapeMargin(barSpacing);\n                const marginValue = calculateShapeHeight(barSpacing) * 1.5 + shapeMargin$1 * 2;\n                const positions = this._private__getMarkerPositions();\n                this._private__autoScaleMargins = {\n                    above: calculateAdjustedMargin(marginValue, positions.aboveBar, positions.inBar),\n                    below: calculateAdjustedMargin(marginValue, positions.belowBar, positions.inBar),\n                };\n            }\n            else {\n                this._private__autoScaleMargins = null;\n            }\n            this._private__autoScaleMarginsInvalidated = false;\n        }\n        return this._private__autoScaleMargins;\n    }\n    _private__getMarkerPositions() {\n        if (this._private__markersPositions === null) {\n            this._private__markersPositions = this._private__markers.reduce((acc, marker) => {\n                if (!acc[marker.position]) {\n                    acc[marker.position] = true;\n                }\n                return acc;\n            }, {\n                inBar: false,\n                aboveBar: false,\n                belowBar: false,\n                atPriceTop: false,\n                atPriceBottom: false,\n                atPriceMiddle: false,\n            });\n        }\n        return this._private__markersPositions;\n    }\n    _private__recalculateMarkers() {\n        if (!this._private__recalculationRequired || !this._private__chart || !this._private__series) {\n            return;\n        }\n        const timeScale = this._private__chart.timeScale();\n        const seriesData = this._private__series?.data();\n        if (timeScale.getVisibleLogicalRange() == null || !this._private__series || seriesData.length === 0) {\n            this._private__indexedMarkers = [];\n            return;\n        }\n        const firstDataIndex = timeScale.timeToIndex(ensureNotNull(seriesData[0].time), true);\n        this._private__indexedMarkers = this._private__markers.map((marker, index) => {\n            const timePointIndex = timeScale.timeToIndex(marker.time, true);\n            const searchMode = timePointIndex < firstDataIndex ? 1 /* MismatchDirection.NearestRight */ : -1 /* MismatchDirection.NearestLeft */;\n            const seriesDataByIndex = ensureNotNull(this._private__series).dataByIndex(timePointIndex, searchMode);\n            const finalIndex = timeScale.timeToIndex(ensureNotNull(seriesDataByIndex).time, false);\n            // You must explicitly define the types so that the minification build processes the field names correctly\n            const baseMarker = {\n                time: finalIndex,\n                position: marker.position,\n                shape: marker.shape,\n                color: marker.color,\n                id: marker.id,\n                _internal_internalId: index,\n                text: marker.text,\n                size: marker.size,\n                price: marker.price,\n                _internal_originalTime: marker.time,\n            };\n            if (marker.position === 'atPriceTop' ||\n                marker.position === 'atPriceBottom' ||\n                marker.position === 'atPriceMiddle') {\n                if (marker.price === undefined) {\n                    throw new Error(`Price is required for position ${marker.position}`);\n                }\n                return {\n                    ...baseMarker,\n                    position: marker.position, // TypeScript knows this is SeriesMarkerPricePosition\n                    price: marker.price,\n                };\n            }\n            else {\n                return {\n                    ...baseMarker,\n                    position: marker.position, // TypeScript knows this is SeriesMarkerBarPosition\n                    price: marker.price, // Optional for bar positions\n                };\n            }\n        });\n        this._private__recalculationRequired = false;\n    }\n    _private__updateAllViews(updateType) {\n        if (this._private__paneView) {\n            this._private__recalculateMarkers();\n            this._private__paneView._internal_setMarkers(this._private__indexedMarkers);\n            this._private__paneView._internal_updateOptions(this._private__options);\n            this._private__paneView._internal_update(updateType);\n        }\n    }\n    _private__onDataChanged(scope) {\n        this._private__recalculationRequired = true;\n        this._internal_requestUpdate();\n    }\n}\n\nclass SeriesMarkersPrimitiveWrapper extends SeriesPrimitiveAdapter {\n    constructor(series, primitive, markers) {\n        super(series, primitive);\n        if (markers) {\n            this.setMarkers(markers);\n        }\n    }\n    setMarkers(markers) {\n        this._internal__primitive._internal_setMarkers(markers);\n    }\n    markers() {\n        return this._internal__primitive._internal_markers();\n    }\n}\n/**\n * A function to create a series markers primitive.\n *\n * @param series - The series to which the primitive will be attached.\n *\n * @param markers - An array of markers to be displayed on the series.\n *\n * @param options - Options for the series markers plugin.\n *\n * @example\n * ```js\n * import { createSeriesMarkers } from 'lightweight-charts';\n *\n *\tconst seriesMarkers = createSeriesMarkers(\n *\t\tseries,\n *\t\t[\n *\t\t\t{\n *\t\t\t\tcolor: 'green',\n *\t\t\t\tposition: 'inBar',\n * \t\t\t\tshape: 'arrowDown',\n *\t\t\t\ttime: 1556880900,\n *\t\t\t},\n *\t\t]\n *\t);\n *  // and then you can modify the markers\n *  // set it to empty array to remove all markers\n *  seriesMarkers.setMarkers([]);\n *\n *  // `seriesMarkers.markers()` returns current markers\n * ```\n */\nfunction createSeriesMarkers(series, markers, options) {\n    const wrapper = new SeriesMarkersPrimitiveWrapper(series, new SeriesMarkersPrimitive(options ?? {}));\n    if (markers) {\n        wrapper.setMarkers(markers);\n    }\n    return wrapper;\n}\n\nclass ExpiringMarkerManager {\n    constructor(updateCallback) {\n        this._private__markers = new Map();\n        this._private__updateCallback = updateCallback;\n    }\n    _internal_setMarker(marker, key, timeout) {\n        this._internal_clearMarker(key);\n        if (timeout !== undefined) {\n            const timeoutId = window.setTimeout(() => {\n                this._private__markers.delete(key);\n                this._private__triggerUpdate();\n            }, timeout);\n            const markerWithTimeout = {\n                ...marker,\n                _internal_timeoutId: timeoutId,\n                _internal_expiresAt: Date.now() + timeout,\n            };\n            this._private__markers.set(key, markerWithTimeout);\n        }\n        else {\n            // For markers without timeout, we set timeoutId and expiresAt to undefined\n            this._private__markers.set(key, {\n                ...marker,\n                _internal_timeoutId: undefined,\n                _internal_expiresAt: undefined,\n            });\n        }\n        this._private__triggerUpdate();\n    }\n    _internal_clearMarker(key) {\n        const marker = this._private__markers.get(key);\n        if (marker && marker._internal_timeoutId !== undefined) {\n            window.clearTimeout(marker._internal_timeoutId);\n        }\n        this._private__markers.delete(key);\n        this._private__triggerUpdate();\n    }\n    _internal_clearAllMarkers() {\n        for (const [point] of this._private__markers) {\n            this._internal_clearMarker(point);\n        }\n    }\n    _internal_getMarkers() {\n        const now = Date.now();\n        const activeMarkers = [];\n        for (const [time, marker] of this._private__markers) {\n            if (!marker._internal_expiresAt || marker._internal_expiresAt > now) {\n                activeMarkers.push({ time: marker.time, sign: marker.sign, value: marker.value });\n            }\n            else {\n                this._internal_clearMarker(time);\n            }\n        }\n        return activeMarkers;\n    }\n    _internal_setUpdateCallback(callback) {\n        this._private__updateCallback = callback;\n    }\n    _private__triggerUpdate() {\n        if (this._private__updateCallback) {\n            this._private__updateCallback();\n        }\n    }\n}\n\nconst upDownMarkersPluginOptionDefaults = {\n    positiveColor: '#22AB94',\n    negativeColor: '#F7525F',\n    updateVisibilityDuration: 5000,\n};\n\nclass MarkersPrimitiveRenderer {\n    constructor(data, neutralColor, negativeColor, positiveColor) {\n        this._private__data = data;\n        this._private__neutralColor = neutralColor;\n        this._private__negativeColor = negativeColor;\n        this._private__positiveColor = positiveColor;\n    }\n    draw(target) {\n        target.useBitmapCoordinateSpace((scope) => {\n            const ctx = scope.context;\n            const tickWidth = Math.max(1, Math.floor(scope.horizontalPixelRatio));\n            const correction = (tickWidth % 2) / 2;\n            const rad = 4 /* Constants.Radius */ * scope.verticalPixelRatio + correction;\n            this._private__data.forEach((item) => {\n                const centreX = Math.round(item._internal_x * scope.horizontalPixelRatio) + correction;\n                ctx.beginPath();\n                const color = this._private__getColor(item._internal_sign);\n                ctx.fillStyle = color;\n                ctx.arc(centreX, item._internal_y * scope.verticalPixelRatio, rad, 0, 2 * Math.PI, false);\n                ctx.fill();\n                if (item._internal_sign) {\n                    ctx.strokeStyle = color;\n                    ctx.lineWidth = Math.floor(2 /* Constants.ArrowLineWidth */ * scope.horizontalPixelRatio);\n                    ctx.beginPath();\n                    ctx.moveTo((item._internal_x - 4.7 /* Constants.ArrowSize */) * scope.horizontalPixelRatio + correction, (item._internal_y - 7 /* Constants.ArrowOffset */ * item._internal_sign) *\n                        scope.verticalPixelRatio);\n                    ctx.lineTo(item._internal_x * scope.horizontalPixelRatio + correction, (item._internal_y -\n                        7 /* Constants.ArrowOffset */ * item._internal_sign -\n                        7 /* Constants.ArrowOffset */ * item._internal_sign * 0.5 /* Constants.VerticalScale */) *\n                        scope.verticalPixelRatio);\n                    ctx.lineTo((item._internal_x + 4.7 /* Constants.ArrowSize */) * scope.horizontalPixelRatio + correction, (item._internal_y - 7 /* Constants.ArrowOffset */ * item._internal_sign) *\n                        scope.verticalPixelRatio);\n                    ctx.stroke();\n                }\n            });\n        });\n    }\n    _private__getColor(sign) {\n        if (sign === 0) {\n            return this._private__neutralColor;\n        }\n        return sign > 0 ? this._private__positiveColor : this._private__negativeColor;\n    }\n}\n\nfunction isAreaStyleOptions(opts, seriesType) {\n    return seriesType === 'Area';\n}\nfunction getNeutralColor(opts, seriesType) {\n    if (isAreaStyleOptions(opts, seriesType)) {\n        return opts.lineColor;\n    }\n    return opts.color;\n}\nclass MarkersPrimitivePaneView {\n    constructor(series, timeScale, options) {\n        this._private__data = [];\n        this._private__series = series;\n        this._private__timeScale = timeScale;\n        this._private__options = options;\n    }\n    _internal_update(markers) {\n        this._private__data = markers.map((marker) => {\n            const y = this._private__series.priceToCoordinate(marker.value);\n            if (y === null) {\n                return null;\n            }\n            const x = ensureNotNull(this._private__timeScale.timeToCoordinate(marker.time));\n            return {\n                _internal_x: x,\n                _internal_y: y,\n                _internal_sign: marker.sign,\n            };\n        })\n            .filter(notNull);\n    }\n    renderer() {\n        const options = this._private__series.options();\n        const seriesType = this._private__series.seriesType();\n        const neutralColor = getNeutralColor(options, seriesType);\n        return new MarkersPrimitiveRenderer(this._private__data, neutralColor, this._private__options.negativeColor, this._private__options.positiveColor);\n    }\n}\n\nfunction isLineData(item, type) {\n    return type === 'Line' || type === 'Area';\n}\nclass UpDownMarkersPrimitive {\n    constructor(options) {\n        this._private__chart = undefined;\n        this._private__series = undefined;\n        this._private__paneViews = [];\n        this._private__horzScaleBehavior = null;\n        this._private__managedDataPoints = new Map();\n        this._private__markersManager = new ExpiringMarkerManager(() => this._internal_requestUpdate());\n        this._private__options = {\n            ...upDownMarkersPluginOptionDefaults,\n            ...options,\n        };\n    }\n    _internal_applyOptions(options) {\n        this._private__options = {\n            ...this._private__options,\n            ...options,\n        };\n        this._internal_requestUpdate();\n    }\n    _internal_setMarkers(markers) {\n        this._private__markersManager._internal_clearAllMarkers();\n        const horzBehaviour = this._private__horzScaleBehavior;\n        if (!horzBehaviour) {\n            return;\n        }\n        markers.forEach((marker) => {\n            this._private__markersManager._internal_setMarker(marker, horzBehaviour.key(marker.time));\n        });\n    }\n    _internal_markers() {\n        return this._private__markersManager._internal_getMarkers();\n    }\n    _internal_requestUpdate() {\n        this._private__requestUpdate?.();\n    }\n    attached(params) {\n        const { chart, series, requestUpdate, horzScaleBehavior, } = params;\n        this._private__chart = chart;\n        this._private__series = series;\n        this._private__horzScaleBehavior = horzScaleBehavior;\n        const seriesType = this._private__series.seriesType();\n        if (seriesType !== 'Area' && seriesType !== 'Line') {\n            throw new Error('UpDownMarkersPrimitive is only supported for Area and Line series types');\n        }\n        this._private__paneViews = [\n            new MarkersPrimitivePaneView(this._private__series, this._private__chart.timeScale(), this._private__options),\n        ];\n        this._private__requestUpdate = requestUpdate;\n        this._internal_requestUpdate();\n    }\n    detached() {\n        this._private__chart = undefined;\n        this._private__series = undefined;\n        this._private__requestUpdate = undefined;\n    }\n    _internal_chart() {\n        return ensureDefined(this._private__chart);\n    }\n    _internal_series() {\n        return ensureDefined(this._private__series);\n    }\n    updateAllViews() {\n        this._private__paneViews.forEach((pw) => pw._internal_update(this._internal_markers()));\n    }\n    paneViews() {\n        return this._private__paneViews;\n    }\n    _internal_setData(data) {\n        if (!this._private__series) {\n            throw new Error('Primitive not attached to series');\n        }\n        const seriesType = this._private__series.seriesType();\n        this._private__managedDataPoints.clear();\n        const horzBehaviour = this._private__horzScaleBehavior;\n        if (horzBehaviour) {\n            data.forEach((d) => {\n                if (isFulfilledData(d) && isLineData(d, seriesType)) {\n                    this._private__managedDataPoints.set(horzBehaviour.key(d.time), d.value);\n                }\n            });\n        }\n        ensureDefined(this._private__series).setData(data);\n    }\n    _internal_update(data, historicalUpdate) {\n        if (!this._private__series || !this._private__horzScaleBehavior) {\n            throw new Error('Primitive not attached to series');\n        }\n        const seriesType = this._private__series.seriesType();\n        const horzKey = this._private__horzScaleBehavior.key(data.time);\n        if (isWhitespaceData(data)) {\n            this._private__managedDataPoints.delete(horzKey);\n        }\n        if (isFulfilledData(data) && isLineData(data, seriesType)) {\n            const existingPrice = this._private__managedDataPoints.get(horzKey);\n            if (existingPrice) {\n                this._private__markersManager._internal_setMarker({\n                    time: data.time,\n                    value: data.value,\n                    sign: getSign(data.value, existingPrice),\n                }, horzKey, this._private__options.updateVisibilityDuration);\n            }\n        }\n        ensureDefined(this._private__series).update(data, historicalUpdate);\n    }\n    _internal_clearMarkers() {\n        this._private__markersManager._internal_clearAllMarkers();\n    }\n}\nfunction getSign(newValue, oldValue) {\n    if (newValue === oldValue) {\n        return 0;\n    }\n    return newValue - oldValue > 0 ? 1 : -1;\n}\n\nclass SeriesUpDownMarkerPrimitiveWrapper extends SeriesPrimitiveAdapter {\n    setData(data) {\n        return this._internal__primitive._internal_setData(data);\n    }\n    update(data, historicalUpdate) {\n        return this._internal__primitive._internal_update(data, historicalUpdate);\n    }\n    markers() {\n        return this._internal__primitive._internal_markers();\n    }\n    setMarkers(markers) {\n        return this._internal__primitive._internal_setMarkers(markers);\n    }\n    clearMarkers() {\n        return this._internal__primitive._internal_clearMarkers();\n    }\n}\n/**\n * Creates and attaches the Series Up Down Markers Plugin.\n *\n * @param series - Series to which attach the Up Down Markers Plugin\n * @param options - options for the Up Down Markers Plugin\n *\n * @returns Api for Series Up Down Marker Plugin. {@link ISeriesUpDownMarkerPluginApi}\n *\n * @example\n * ```js\n * import { createUpDownMarkers, createChart, LineSeries } from 'lightweight-charts';\n *\n * const chart = createChart('container');\n * const lineSeries = chart.addSeries(LineSeries);\n * const upDownMarkers = createUpDownMarkers(lineSeries, {\n *     positiveColor: '#22AB94',\n *     negativeColor: '#F7525F',\n *     updateVisibilityDuration: 5000,\n * });\n * // to add some data\n * upDownMarkers.setData(\n *     [\n *         { time: '2020-02-02', value: 12.34 },\n *         //... more line series data\n *     ]\n * );\n * // ... Update some values\n * upDownMarkers.update({ time: '2020-02-02', value: 13.54 }, true);\n * // to remove plugin from the series\n * upDownMarkers.detach();\n * ```\n */\nfunction createUpDownMarkers(series, options = {}) {\n    const wrapper = new SeriesUpDownMarkerPrimitiveWrapper(series, new UpDownMarkersPrimitive(options));\n    return wrapper;\n}\n\n/// <reference types=\"_build-time-constants\" />\nconst customSeriesDefaultOptions = {\n    ...seriesOptionsDefaults,\n    ...customStyleDefaults$1,\n};\n/**\n * Returns the current version as a string. For example `'3.3.0'`.\n */\nfunction version() {\n    return \"5.0.7\";\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9saWdodHdlaWdodC1jaGFydHMvZGlzdC9saWdodHdlaWdodC1jaGFydHMuZGV2ZWxvcG1lbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMySDs7QUFFM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTSxFQUFFLEtBQUssS0FBSyxPQUFPO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjLElBQUksY0FBYyxJQUFJLGNBQWMsSUFBSSxvQkFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjLElBQUksY0FBYyxJQUFJLGNBQWMsSUFBSSxjQUFjO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQXdEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3QkFBd0I7QUFDdEU7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvRUFBb0U7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdGQUFnRjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3REFBd0Q7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhEQUE4RDtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzRkFBc0Y7QUFDekk7QUFDQTtBQUNBO0FBQ0EscURBQXFELHlGQUF5RjtBQUM5STtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUVBQWlFO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlEQUF5RDtBQUM1RztBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0dBQWdHO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw2RkFBNkY7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0VBQXNFO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUZBQXVGO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvRUFBb0U7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUF3RDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9FQUFvRTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZUFBZTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4QkFBOEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixJQUFJO0FBQ2hHO0FBQ0E7QUFDQSwrRkFBK0YsT0FBTztBQUN0RztBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlFQUFpRTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLFVBQVU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0pBQXNKO0FBQy9NLDhHQUE4RyxNQUFNO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdEQUF3RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0Isa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQXdELEVBQUUseUJBQXlCLEVBQUUsd0RBQXdEO0FBQy9KO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUZBQWlGO0FBQ3ZGLE1BQU0sa0ZBQWtGO0FBQ3hGLE1BQU0sa0ZBQWtGO0FBQ3hGLE1BQU0sb0ZBQW9GO0FBQzFGLE1BQU0sOEVBQThFO0FBQ3BGLE1BQU0sOEVBQThFO0FBQ3BGLE1BQU0sOEVBQThFO0FBQ3BGLE1BQU0sZ0ZBQWdGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQ0FBaUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0IsNkJBQTZCLGVBQWU7QUFDbkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrREFBTSxHQUFHLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaURBQWlEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaURBQWlEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUdBQXlHO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFpRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBaUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGdCQUFnQjtBQUN2Ryw2RUFBNkUsZ0JBQWdCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGVBQWU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxlQUFlO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsSUFBSSxnQkFBZ0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUgsZUFBZTtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQU07QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSxrREFBTTtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZUFBZSxjQUFjLGtCQUFrQixVQUFVLFlBQVksWUFBWSxXQUFXLFNBQVMsVUFBVSxTQUFTLFdBQVcsMEJBQTBCLGVBQWUsa0JBQWtCO0FBQzFOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsOEJBQThCO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJFQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsa0RBQU0sR0FBRyx1QkFBdUI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGtEQUFNLEdBQUcsdUJBQXVCO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0RBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9ELGtEQUFrRCxlQUFlO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4RUFBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEVBQWdDO0FBQzFEO0FBQ0Esa0RBQWtELDBCQUEwQjtBQUM1RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pELGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWdEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdEQUF3RDtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBTSxHQUFHLHFCQUFxQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usa0RBQU0sR0FBRyx1QkFBdUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGtEQUFNLEdBQUcsdUJBQXVCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxrREFBTSxHQUFHLDJDQUEyQztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhFQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhFQUFnQztBQUMxRDtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1ILE1BQU07QUFDekg7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtEQUFNLEdBQUcscUJBQXFCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGtEQUFNLEdBQUcsdUJBQXVCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdEQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxpREFBaUQsY0FBYztBQUMvRCxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOEVBQWdDO0FBQ3ZEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0VBQW9FO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrREFBTSxHQUFHLHFCQUFxQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsa0RBQU0sR0FBRyx1QkFBdUI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGtEQUFNLEdBQUcsdUJBQXVCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxtQkFBbUI7QUFDcEUsa0RBQWtELG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0RBQU0sR0FBRyxtREFBbUQ7QUFDbEg7QUFDQTtBQUNBLHVEQUF1RCxrREFBTSxHQUFHLG9EQUFvRDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhFQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEVBQWdDO0FBQzFEO0FBQ0Esa0RBQWtELDBCQUEwQjtBQUM1RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBOEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0RBQXdEO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQU0sR0FBRyxlQUFlO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0NBQStDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQStDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQStDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBTSxHQUFHLHNDQUFzQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxrREFBTSxHQUFHLGdFQUFnRTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixnQkFBZ0I7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix3RUFBd0UsbUJBQW1CO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0ZBQW9GO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGVBQWUsYUFBYSxLQUFLO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdEQUFnRDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnRkFBZ0Y7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDhCQUE4QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDBDQUEwQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSx3REFBd0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQXNEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZGQUE2RjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtIQUFrSCxxQkFBcUI7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0EsdUVBQXVFLEVBQUUsU0FBUyxZQUFZLGNBQWMsU0FBUztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNLDRCQUE0QixLQUFLLHdCQUF3QixvQkFBb0IsVUFBVSxhQUFhO0FBQzlKLDZDQUE2QyxNQUFNLDRCQUE0QixLQUFLLGtCQUFrQixnQ0FBZ0MsTUFBTSwrQkFBK0IsUUFBUSxvQkFBb0IsVUFBVSxhQUFhO0FBQzlOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU0sK0NBQStDLHNCQUFzQixVQUFVLGVBQWU7QUFDdEosMkNBQTJDLE1BQU0seUNBQXlDLGdDQUFnQyxNQUFNLCtCQUErQixRQUFRLHNCQUFzQixVQUFVLGVBQWU7QUFDdE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQTZDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxVQUFVO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxtQkFBbUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHlCQUF5QixLQUFLLFdBQVcsS0FBSztBQUM5STtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQSxxREFBcUQseUJBQXlCLEtBQUssV0FBVyxLQUFLO0FBQ25HO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBb0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0JBQXdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQXlEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlFQUFpRSw4Q0FBOEM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZPQUE2TztBQUM3UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQSxrQkFBa0IsTUFBTSxHQUFHLGdCQUFnQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLCtFQUErRTtBQUNqSCx3QkFBd0Isb0RBQW9EO0FBQzVFO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtFQUErRSxRQUFRLE1BQU0sR0FBRyxJQUFJLEdBQUcsV0FBVztBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG9EQUFvRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkxBQTJMO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3UkFBd1I7QUFDeFM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDBDQUEwQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwwQ0FBMEM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQXdEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxtREFBbUQ7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQXdEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLG1EQUFtRDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLG1EQUFtRDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxtREFBbUQ7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLG1EQUFtRDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsbURBQW1EO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdUNBQXVDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLDZGQUE2RjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHVDQUF1QztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxtREFBbUQ7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQkFBMEIsd0RBQXdEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsdURBQXVEO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHVEQUF1RDtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHVDQUF1QztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZ0JBQWdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMkRBQTJEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQW1EO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBK0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2bEIiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxsaWdodHdlaWdodC1jaGFydHNcXGRpc3RcXGxpZ2h0d2VpZ2h0LWNoYXJ0cy5kZXZlbG9wbWVudC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogVHJhZGluZ1ZpZXcgTGlnaHR3ZWlnaHQgQ2hhcnRz4oSiIHY1LjAuN1xuICogQ29weXJpZ2h0IChjKSAyMDI1IFRyYWRpbmdWaWV3LCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBBcGFjaGUgTGljZW5zZSAyLjAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5pbXBvcnQgeyBzaXplIGFzIHNpemUkMSwgYmluZENhbnZhc0VsZW1lbnRCaXRtYXBTaXplVG8sIGVxdWFsU2l6ZXMsIHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEIH0gZnJvbSAnZmFuY3ktY2FudmFzJztcblxuY29uc3QgY3VzdG9tU3R5bGVEZWZhdWx0cyQxID0ge1xuICAgIGNvbG9yOiAnIzIxOTZmMycsXG59O1xuY29uc3Qgc2VyaWVzT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIHRpdGxlOiAnJyxcbiAgICB2aXNpYmxlOiB0cnVlLFxuICAgIGxhc3RWYWx1ZVZpc2libGU6IHRydWUsXG4gICAgcHJpY2VMaW5lVmlzaWJsZTogdHJ1ZSxcbiAgICBwcmljZUxpbmVTb3VyY2U6IDAgLyogUHJpY2VMaW5lU291cmNlLkxhc3RCYXIgKi8sXG4gICAgcHJpY2VMaW5lV2lkdGg6IDEsXG4gICAgcHJpY2VMaW5lQ29sb3I6ICcnLFxuICAgIHByaWNlTGluZVN0eWxlOiAyIC8qIExpbmVTdHlsZS5EYXNoZWQgKi8sXG4gICAgYmFzZUxpbmVWaXNpYmxlOiB0cnVlLFxuICAgIGJhc2VMaW5lV2lkdGg6IDEsXG4gICAgYmFzZUxpbmVDb2xvcjogJyNCMkI1QkUnLFxuICAgIGJhc2VMaW5lU3R5bGU6IDAgLyogTGluZVN0eWxlLlNvbGlkICovLFxuICAgIHByaWNlRm9ybWF0OiB7XG4gICAgICAgIHR5cGU6ICdwcmljZScsXG4gICAgICAgIHByZWNpc2lvbjogMixcbiAgICAgICAgbWluTW92ZTogMC4wMSxcbiAgICB9LFxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBwb3NzaWJsZSBsaW5lIHR5cGVzLlxuICovXG52YXIgTGluZVR5cGU7XG4oZnVuY3Rpb24gKExpbmVUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQSBsaW5lLlxuICAgICAqL1xuICAgIExpbmVUeXBlW0xpbmVUeXBlW1wiU2ltcGxlXCJdID0gMF0gPSBcIlNpbXBsZVwiO1xuICAgIC8qKlxuICAgICAqIEEgc3RlcHBlZCBsaW5lLlxuICAgICAqL1xuICAgIExpbmVUeXBlW0xpbmVUeXBlW1wiV2l0aFN0ZXBzXCJdID0gMV0gPSBcIldpdGhTdGVwc1wiO1xuICAgIC8qKlxuICAgICAqIEEgY3VydmVkIGxpbmUuXG4gICAgICovXG4gICAgTGluZVR5cGVbTGluZVR5cGVbXCJDdXJ2ZWRcIl0gPSAyXSA9IFwiQ3VydmVkXCI7XG59KShMaW5lVHlwZSB8fCAoTGluZVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBwb3NzaWJsZSBsaW5lIHN0eWxlcy5cbiAqL1xudmFyIExpbmVTdHlsZTtcbihmdW5jdGlvbiAoTGluZVN0eWxlKSB7XG4gICAgLyoqXG4gICAgICogQSBzb2xpZCBsaW5lLlxuICAgICAqL1xuICAgIExpbmVTdHlsZVtMaW5lU3R5bGVbXCJTb2xpZFwiXSA9IDBdID0gXCJTb2xpZFwiO1xuICAgIC8qKlxuICAgICAqIEEgZG90dGVkIGxpbmUuXG4gICAgICovXG4gICAgTGluZVN0eWxlW0xpbmVTdHlsZVtcIkRvdHRlZFwiXSA9IDFdID0gXCJEb3R0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBBIGRhc2hlZCBsaW5lLlxuICAgICAqL1xuICAgIExpbmVTdHlsZVtMaW5lU3R5bGVbXCJEYXNoZWRcIl0gPSAyXSA9IFwiRGFzaGVkXCI7XG4gICAgLyoqXG4gICAgICogQSBkYXNoZWQgbGluZSB3aXRoIGJpZ2dlciBkYXNoZXMuXG4gICAgICovXG4gICAgTGluZVN0eWxlW0xpbmVTdHlsZVtcIkxhcmdlRGFzaGVkXCJdID0gM10gPSBcIkxhcmdlRGFzaGVkXCI7XG4gICAgLyoqXG4gICAgICogQSBkb3R0ZWQgbGluZSB3aXRoIG1vcmUgc3BhY2UgYmV0d2VlbiBkb3RzLlxuICAgICAqL1xuICAgIExpbmVTdHlsZVtMaW5lU3R5bGVbXCJTcGFyc2VEb3R0ZWRcIl0gPSA0XSA9IFwiU3BhcnNlRG90dGVkXCI7XG59KShMaW5lU3R5bGUgfHwgKExpbmVTdHlsZSA9IHt9KSk7XG5mdW5jdGlvbiBzZXRMaW5lU3R5bGUoY3R4LCBzdHlsZSkge1xuICAgIGNvbnN0IGRhc2hQYXR0ZXJucyA9IHtcbiAgICAgICAgWzAgLyogTGluZVN0eWxlLlNvbGlkICovXTogW10sXG4gICAgICAgIFsxIC8qIExpbmVTdHlsZS5Eb3R0ZWQgKi9dOiBbY3R4LmxpbmVXaWR0aCwgY3R4LmxpbmVXaWR0aF0sXG4gICAgICAgIFsyIC8qIExpbmVTdHlsZS5EYXNoZWQgKi9dOiBbMiAqIGN0eC5saW5lV2lkdGgsIDIgKiBjdHgubGluZVdpZHRoXSxcbiAgICAgICAgWzMgLyogTGluZVN0eWxlLkxhcmdlRGFzaGVkICovXTogWzYgKiBjdHgubGluZVdpZHRoLCA2ICogY3R4LmxpbmVXaWR0aF0sXG4gICAgICAgIFs0IC8qIExpbmVTdHlsZS5TcGFyc2VEb3R0ZWQgKi9dOiBbY3R4LmxpbmVXaWR0aCwgNCAqIGN0eC5saW5lV2lkdGhdLFxuICAgIH07XG4gICAgY29uc3QgZGFzaFBhdHRlcm4gPSBkYXNoUGF0dGVybnNbc3R5bGVdO1xuICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoUGF0dGVybik7XG59XG5mdW5jdGlvbiBkcmF3SG9yaXpvbnRhbExpbmUoY3R4LCB5LCBsZWZ0LCByaWdodCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjb25zdCBjb3JyZWN0aW9uID0gKGN0eC5saW5lV2lkdGggJSAyKSA/IDAuNSA6IDA7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5ICsgY29ycmVjdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeSArIGNvcnJlY3Rpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbn1cbmZ1bmN0aW9uIGRyYXdWZXJ0aWNhbExpbmUoY3R4LCB4LCB0b3AsIGJvdHRvbSkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjb25zdCBjb3JyZWN0aW9uID0gKGN0eC5saW5lV2lkdGggJSAyKSA/IDAuNSA6IDA7XG4gICAgY3R4Lm1vdmVUbyh4ICsgY29ycmVjdGlvbiwgdG9wKTtcbiAgICBjdHgubGluZVRvKHggKyBjb3JyZWN0aW9uLCBib3R0b20pO1xuICAgIGN0eC5zdHJva2UoKTtcbn1cbmZ1bmN0aW9uIHN0cm9rZUluUGl4ZWwoY3R4LCBkcmF3RnVuY3Rpb24pIHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChjdHgubGluZVdpZHRoICUgMikge1xuICAgICAgICBjdHgudHJhbnNsYXRlKDAuNSwgMC41KTtcbiAgICB9XG4gICAgZHJhd0Z1bmN0aW9uKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYW4gYXNzZXJ0aW9uLiBUaHJvd3MgaWYgdGhlIGFzc2VydGlvbiBpcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIGNvbmRpdGlvbiAtIFJlc3VsdCBvZiB0aGUgYXNzZXJ0aW9uIGV2YWx1YXRpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGV4dCB0byBpbmNsdWRlIGluIHRoZSBleGNlcHRpb24gbWVzc2FnZVxuICovXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyArIChtZXNzYWdlID8gJzogJyArIG1lc3NhZ2UgOiAnJykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZURlZmluZWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBlbnN1cmVOb3ROdWxsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgaXMgbnVsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBlbnN1cmUodmFsdWUpIHtcbiAgICByZXR1cm4gZW5zdXJlTm90TnVsbChlbnN1cmVEZWZpbmVkKHZhbHVlKSk7XG59XG4vKipcbiAqIENvbXBpbGUgdGltZSBjaGVjayBmb3IgbmV2ZXJcbiAqL1xuZnVuY3Rpb24gZW5zdXJlTmV2ZXIodmFsdWUpIHsgfVxuXG5jbGFzcyBEZWxlZ2F0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3Vic2NyaWJlKGNhbGxiYWNrLCBsaW5rZWRPYmplY3QsIHNpbmdsZXNob3QpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmtlZE9iamVjdDogbGlua2VkT2JqZWN0LFxuICAgICAgICAgICAgX2ludGVybmFsX3NpbmdsZXNob3Q6IHNpbmdsZXNob3QgPT09IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Vuc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fbGlzdGVuZXJzLmZpbmRJbmRleCgobGlzdGVuZXIpID0+IGNhbGxiYWNrID09PSBsaXN0ZW5lci5faW50ZXJuYWxfY2FsbGJhY2spO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKGxpbmtlZE9iamVjdCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19saXN0ZW5lcnMgPSB0aGlzLl9wcml2YXRlX19saXN0ZW5lcnMuZmlsdGVyKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIuX2ludGVybmFsX2xpbmtlZE9iamVjdCAhPT0gbGlua2VkT2JqZWN0KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZpcmUocGFyYW0xLCBwYXJhbTIsIHBhcmFtMykge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnNTbmFwc2hvdCA9IFsuLi50aGlzLl9wcml2YXRlX19saXN0ZW5lcnNdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19saXN0ZW5lcnMgPSB0aGlzLl9wcml2YXRlX19saXN0ZW5lcnMuZmlsdGVyKChsaXN0ZW5lcikgPT4gIWxpc3RlbmVyLl9pbnRlcm5hbF9zaW5nbGVzaG90KTtcbiAgICAgICAgbGlzdGVuZXJzU25hcHNob3QuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyLl9pbnRlcm5hbF9jYWxsYmFjayhwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19saXN0ZW5lcnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xpc3RlbmVycyA9IFtdO1xuICAgIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIG1lcmdlKGRzdCwgLi4uc291cmNlcykge1xuICAgIGZvciAoY29uc3Qgc3JjIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiBzcmMpIHtcbiAgICAgICAgICAgIGlmIChzcmNbaV0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCBpKSB8fFxuICAgICAgICAgICAgICAgIFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddLmluY2x1ZGVzKGkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ29iamVjdCcgIT09IHR5cGVvZiBzcmNbaV0gfHwgZHN0W2ldID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShzcmNbaV0pKSB7XG4gICAgICAgICAgICAgICAgZHN0W2ldID0gc3JjW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBtZXJnZShkc3RbaV0sIHNyY1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSAmJiAoaXNGaW5pdGUodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgJiYgKCh2YWx1ZSAlIDEpID09PSAwKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBjbG9uZShvYmplY3QpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IG8gPSBvYmplY3Q7XG4gICAgaWYgKCFvIHx8ICdvYmplY3QnICE9PSB0eXBlb2Ygbykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGV0IGM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgYyA9IFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYyA9IHt9O1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBsZXQgdjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICBmb3IgKHAgaW4gbykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCxuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgIHYgPSBvW3BdO1xuICAgICAgICAgICAgaWYgKHYgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGNbcF0gPSBjbG9uZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBjW3BdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIG5vdE51bGwodCkge1xuICAgIHJldHVybiB0ICE9PSBudWxsO1xufVxuZnVuY3Rpb24gdW5kZWZpbmVkSWZOdWxsKHQpIHtcbiAgICByZXR1cm4gKHQgPT09IG51bGwpID8gdW5kZWZpbmVkIDogdDtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGZvbnQgZmFtaWx5LlxuICogTXVzdCBiZSB1c2VkIHRvIGdlbmVyYXRlIGZvbnQgc3RyaW5nIHdoZW4gZm9udCBpcyBub3Qgc3BlY2lmaWVkLlxuICovXG5jb25zdCBkZWZhdWx0Rm9udEZhbWlseSA9IGAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdUcmVidWNoZXQgTVMnLCBSb2JvdG8sIFVidW50dSwgc2Fucy1zZXJpZmA7XG4vKipcbiAqIEdlbmVyYXRlcyBhIGZvbnQgc3RyaW5nLCB3aGljaCBjYW4gYmUgdXNlZCB0byBzZXQgaW4gY2FudmFzJyBmb250IHByb3BlcnR5LlxuICogSWYgbm8gZmFtaWx5IHByb3ZpZGVkLCB7QGxpbmsgZGVmYXVsdEZvbnRGYW1pbHl9IHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gc2l6ZSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0gZmFtaWx5IC0gT3B0aW9uYWwgZm9udCBmYW1pbHkuXG4gKiBAcGFyYW0gc3R5bGUgLSBPcHRpb25hbCBmb250IHN0eWxlLlxuICogQHJldHVybnMgVGhlIGZvbnQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBtYWtlRm9udChzaXplLCBmYW1pbHksIHN0eWxlKSB7XG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3R5bGUgPSBgJHtzdHlsZX0gYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0eWxlID0gJyc7XG4gICAgfVxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmYW1pbHkgPSBkZWZhdWx0Rm9udEZhbWlseTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3N0eWxlfSR7c2l6ZX1weCAke2ZhbWlseX1gO1xufVxuXG5jbGFzcyBQcmljZUF4aXNSZW5kZXJlck9wdGlvbnNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY2hhcnRNb2RlbCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYm9yZGVyU2l6ZTogMSAvKiBSZW5kZXJlckNvbnN0YW50cy5Cb3JkZXJTaXplICovLFxuICAgICAgICAgICAgX2ludGVybmFsX3RpY2tMZW5ndGg6IDUgLyogUmVuZGVyZXJDb25zdGFudHMuVGlja0xlbmd0aCAqLyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9mb250U2l6ZTogTmFOLFxuICAgICAgICAgICAgX2ludGVybmFsX2ZvbnQ6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX2ZvbnRGYW1pbHk6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX2NvbG9yOiAnJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wYW5lQmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wYWRkaW5nQm90dG9tOiAwLFxuICAgICAgICAgICAgX2ludGVybmFsX3BhZGRpbmdJbm5lcjogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wYWRkaW5nT3V0ZXI6IDAsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcGFkZGluZ1RvcDogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlbGluZU9mZnNldDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbCA9IGNoYXJ0TW9kZWw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpb25zKCkge1xuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGb250U2l6ZSA9IHRoaXMuX3ByaXZhdGVfX2ZvbnRTaXplKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGb250RmFtaWx5ID0gdGhpcy5fcHJpdmF0ZV9fZm9udEZhbWlseSgpO1xuICAgICAgICBpZiAocmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSAhPT0gY3VycmVudEZvbnRTaXplIHx8IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udEZhbWlseSAhPT0gY3VycmVudEZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemUgPSBjdXJyZW50Rm9udFNpemU7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnRGYW1pbHkgPSBjdXJyZW50Rm9udEZhbWlseTtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udCA9IG1ha2VGb250KGN1cnJlbnRGb250U2l6ZSwgY3VycmVudEZvbnRGYW1pbHkpO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nVG9wID0gMi41IC8gMTIgKiBjdXJyZW50Rm9udFNpemU7IC8vIDIuNSBweCBmb3IgMTJweCBmb250XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdCb3R0b20gPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3A7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdJbm5lciA9IGN1cnJlbnRGb250U2l6ZSAvIDEyICogcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nT3V0ZXIgPSBjdXJyZW50Rm9udFNpemUgLyAxMiAqIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfdGlja0xlbmd0aDtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfYmFzZWxpbmVPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfY29sb3IgPSB0aGlzLl9wcml2YXRlX190ZXh0Q29sb3IoKTtcbiAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYW5lQmFja2dyb3VuZENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fcGFuZUJhY2tncm91bmRDb2xvcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdGV4dENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpWydsYXlvdXQnXS50ZXh0Q29sb3I7XG4gICAgfVxuICAgIF9wcml2YXRlX19wYW5lQmFja2dyb3VuZENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfYmFja2dyb3VuZFRvcENvbG9yKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb250U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0TW9kZWwuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10uZm9udFNpemU7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb250RmFtaWx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpWydsYXlvdXQnXS5mb250RmFtaWx5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUmdiQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGlmIChjb21wb25lbnQgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50ID4gMjU1KSB7XG4gICAgICAgIHJldHVybiAyNTU7XG4gICAgfVxuICAgIC8vIE5hTiB2YWx1ZXMgYXJlIHRyZWF0ZWQgYXMgMFxuICAgIHJldHVybiAoTWF0aC5yb3VuZChjb21wb25lbnQpIHx8IDApO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQWxwaGFDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgaWYgKGNvbXBvbmVudCA8PSAwIHx8IGNvbXBvbmVudCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGNvbXBvbmVudCwgMCksIDEpO1xuICAgIH1cbiAgICAvLyBsaW1pdCB0aGUgcHJlY2lzaW9uIG9mIGFsbCBudW1iZXJzIHRvIGF0IG1vc3QgNCBkaWdpdHMgaW4gZnJhY3Rpb25hbCBwYXJ0XG4gICAgcmV0dXJuIChNYXRoLnJvdW5kKGNvbXBvbmVudCAqIDEwMDAwKSAvIDEwMDAwKTtcbn1cbmZ1bmN0aW9uIHJnYmFUb0dyYXlzY2FsZShyZ2JWYWx1ZSkge1xuICAgIC8vIE9yaWdpbmFsbHksIHRoZSBOVFNDIFJHQiB0byBZVVYgZm9ybXVsYVxuICAgIC8vIHBlcmZlY3RlZCBieSBAZXVnZW5lLWtvcm9ia28ncyBibGFjayBtYWdpY1xuICAgIGNvbnN0IHJlZENvbXBvbmVudEdyYXlzY2FsZVdlaWdodCA9IDAuMTk5O1xuICAgIGNvbnN0IGdyZWVuQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0ID0gMC42ODc7XG4gICAgY29uc3QgYmx1ZUNvbXBvbmVudEdyYXlzY2FsZVdlaWdodCA9IDAuMTE0O1xuICAgIHJldHVybiAocmVkQ29tcG9uZW50R3JheXNjYWxlV2VpZ2h0ICogcmdiVmFsdWVbMF0gK1xuICAgICAgICBncmVlbkNvbXBvbmVudEdyYXlzY2FsZVdlaWdodCAqIHJnYlZhbHVlWzFdICtcbiAgICAgICAgYmx1ZUNvbXBvbmVudEdyYXlzY2FsZVdlaWdodCAqIHJnYlZhbHVlWzJdKTtcbn1cbi8qKlxuICogRm9yIGNvbG9ycyB3aGljaCBmYWxsIHdpdGhpbiB0aGUgc1JHQiBzcGFjZSwgdGhlIGJyb3dzZXIgY2FuXG4gKiBiZSB1c2VkIHRvIGNvbnZlcnQgdGhlIGNvbG9yIHN0cmluZyBpbnRvIGEgcmdiIC9yZ2JhIHN0cmluZy5cbiAqXG4gKiBGb3Igb3RoZXIgY29sb3JzLCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIHNwZWNpZmllZCAoaS5lLiBmb3JcbiAqIG5ld2VyIGZvcm1hdHMgbGlrZSBkaXNwbGF5LXAzKVxuICpcbiAqIFNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci00LyNzZXJpYWxpemluZy1zUkdCLXZhbHVlc1xuICovXG5mdW5jdGlvbiBnZXRSZ2JTdHJpbmdWaWFCcm93c2VyKGNvbG9yKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAvLyBXZSBhcHBlbmQgdG8gdGhlIGJvZHkgYXMgaXQgaXMgdGhlIG1vc3QgcmVsaWFibGUgd2F5IHRvIGdldCBhIGNvbG9yIHJlYWRpbmdcbiAgICAvLyBhcHBlbmRpbmcgdG8gdGhlIGNoYXJ0IGNvbnRhaW5lciBvciBzaW1pbGFyIGVsZW1lbnQgY2FuIHJlc3VsdCBpbiB0aGUgZm9sbG93aW5nXG4gICAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5pbmcgZW1wdHkgc3RyaW5ncyBvbiBlYWNoIGNoZWNrLlxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgIGNvbnN0IGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuY29sb3I7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICByZXR1cm4gY29tcHV0ZWQ7XG59XG5jbGFzcyBDb2xvclBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoY3VzdG9tUGFyc2VycywgaW5pdGlhbENhY2hlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JnYmFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3VzdG9tUGFyc2VycyA9IGN1c3RvbVBhcnNlcnM7XG4gICAgICAgIGlmIChpbml0aWFsQ2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JnYmFDYWNoZSA9IGluaXRpYWxDYWNoZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXZSBmYWxsYmFjayB0byBSR0JBIGhlcmUgc2luY2Ugc3VwcG9ydGluZyBhbHBoYSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBvbiB3aWRlciBjb2xvciBnYW11dHMgd291bGQgY3VycmVudGx5IGJlIGEgbG90IG9mIGV4dHJhIGNvZGVcbiAgICAgKiBmb3IgdmVyeSBsaXR0bGUgYmVuZWZpdCBkdWUgdG8gYWN0dWFsIHVzYWdlLlxuICAgICAqL1xuICAgIF9pbnRlcm5hbF9hcHBseUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugb3B0aW1pemF0aW9uXG4gICAgICAgIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpblJnYmEgPSB0aGlzLl9wcml2YXRlX19wYXJzZUNvbG9yKGNvbG9yKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luQWxwaGEgPSBvcmlnaW5SZ2JhWzNdO1xuICAgICAgICByZXR1cm4gYHJnYmEoJHtvcmlnaW5SZ2JhWzBdfSwgJHtvcmlnaW5SZ2JhWzFdfSwgJHtvcmlnaW5SZ2JhWzJdfSwgJHthbHBoYSAqIG9yaWdpbkFscGhhfSlgO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2VuZXJhdGVDb250cmFzdENvbG9ycyhiYWNrZ3JvdW5kKSB7XG4gICAgICAgIGNvbnN0IHJnYmEgPSB0aGlzLl9wcml2YXRlX19wYXJzZUNvbG9yKGJhY2tncm91bmQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX2JhY2tncm91bmQ6IGByZ2IoJHtyZ2JhWzBdfSwgJHtyZ2JhWzFdfSwgJHtyZ2JhWzJdfSlgLCAvLyBubyBhbHBoYVxuICAgICAgICAgICAgX2ludGVybmFsX2ZvcmVncm91bmQ6IHJnYmFUb0dyYXlzY2FsZShyZ2JhKSA+IDE2MCA/ICdibGFjaycgOiAnd2hpdGUnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY29sb3JTdHJpbmdUb0dyYXlzY2FsZShiYWNrZ3JvdW5kKSB7XG4gICAgICAgIHJldHVybiByZ2JhVG9HcmF5c2NhbGUodGhpcy5fcHJpdmF0ZV9fcGFyc2VDb2xvcihiYWNrZ3JvdW5kKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9ncmFkaWVudENvbG9yQXRQZXJjZW50KHRvcENvbG9yLCBib3R0b21Db2xvciwgcGVyY2VudCkge1xuICAgICAgICBjb25zdCBbdG9wUiwgdG9wRywgdG9wQiwgdG9wQV0gPSB0aGlzLl9wcml2YXRlX19wYXJzZUNvbG9yKHRvcENvbG9yKTtcbiAgICAgICAgY29uc3QgW2JvdHRvbVIsIGJvdHRvbUcsIGJvdHRvbUIsIGJvdHRvbUFdID0gdGhpcy5fcHJpdmF0ZV9fcGFyc2VDb2xvcihib3R0b21Db2xvcik7XG4gICAgICAgIGNvbnN0IHJlc3VsdFJnYmEgPSBbXG4gICAgICAgICAgICBub3JtYWxpemVSZ2JDb21wb25lbnQoKHRvcFIgKyBwZXJjZW50ICogKGJvdHRvbVIgLSB0b3BSKSkpLFxuICAgICAgICAgICAgbm9ybWFsaXplUmdiQ29tcG9uZW50KCh0b3BHICsgcGVyY2VudCAqIChib3R0b21HIC0gdG9wRykpKSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZVJnYkNvbXBvbmVudCgodG9wQiArIHBlcmNlbnQgKiAoYm90dG9tQiAtIHRvcEIpKSksXG4gICAgICAgICAgICBub3JtYWxpemVBbHBoYUNvbXBvbmVudCgodG9wQSArIHBlcmNlbnQgKiAoYm90dG9tQSAtIHRvcEEpKSksXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBgcmdiYSgke3Jlc3VsdFJnYmFbMF19LCAke3Jlc3VsdFJnYmFbMV19LCAke3Jlc3VsdFJnYmFbMl19LCAke3Jlc3VsdFJnYmFbM119KWA7XG4gICAgfVxuICAgIF9wcml2YXRlX19wYXJzZUNvbG9yKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX3ByaXZhdGVfX3JnYmFDYWNoZS5nZXQoY29sb3IpO1xuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gZ2V0UmdiU3RyaW5nVmlhQnJvd3Nlcihjb2xvcik7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gY29tcHV0ZWQubWF0Y2goL15yZ2JhP1xccypcXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspKD86LFxccyooXFxkKlxcLj9cXGQrKSk/XFwpJC8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY3VzdG9tUGFyc2Vycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnNlciBvZiB0aGlzLl9wcml2YXRlX19jdXN0b21QYXJzZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JnYmFDYWNoZS5zZXQoY29sb3IsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgY29sb3I6ICR7Y29sb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmdiYSA9IFtcbiAgICAgICAgICAgIHBhcnNlSW50KG1hdGNoWzFdLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtYXRjaFsyXSwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQobWF0Y2hbM10sIDEwKSxcbiAgICAgICAgICAgIChtYXRjaFs0XSA/IHBhcnNlRmxvYXQobWF0Y2hbNF0pIDogMSksXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JnYmFDYWNoZS5zZXQoY29sb3IsIHJnYmEpO1xuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9XG59XG5cbmNsYXNzIENvbXBvc2l0ZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJzID0gW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRSZW5kZXJlcnMocmVuZGVyZXJzKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVycyA9IHJlbmRlcmVycztcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXcodGFyZ2V0LCBpc0hvdmVyZWQsIGhpdFRlc3REYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVycy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgICAgICByLl9pbnRlcm5hbF9kcmF3KHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIF9pbnRlcm5hbF9kcmF3KHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSkge1xuICAgICAgICB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4gdGhpcy5faW50ZXJuYWxfX2RyYXdJbXBsKHNjb3BlLCBpc0hvdmVyZWQsIGhpdFRlc3REYXRhKSk7XG4gICAgfVxufVxuXG5jbGFzcyBQYW5lUmVuZGVyZXJNYXJrcyBleHRlbmRzIEJpdG1hcENvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX19kcmF3SW1wbCh7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9fZGF0YSA9PT0gbnVsbCB8fCB0aGlzLl9pbnRlcm5hbF9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZVJhbmdlID0gdGhpcy5faW50ZXJuYWxfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2ludGVybmFsX19kYXRhO1xuICAgICAgICBjb25zdCB0aWNrV2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSk7XG4gICAgICAgIGNvbnN0IGNvcnJlY3Rpb24gPSAodGlja1dpZHRoICUgMikgLyAyO1xuICAgICAgICBjb25zdCBkcmF3ID0gKHJhZGl1c01lZGlhKSA9PiB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLnRvIC0gMTsgaSA+PSB2aXNpYmxlUmFuZ2UuZnJvbTsgLS1pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBkYXRhLl9pbnRlcm5hbF9pdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJYID0gTWF0aC5yb3VuZChwb2ludC5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvKSArIGNvcnJlY3Rpb247IC8vIGNvcnJlY3QgeCBjb29yZGluYXRlIG9ubHlcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gcG9pbnQuX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzTWVkaWEgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8gKyBjb3JyZWN0aW9uO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkYXRhLl9pbnRlcm5hbF9saW5lV2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZGF0YS5faW50ZXJuYWxfYmFja0NvbG9yO1xuICAgICAgICAgICAgZHJhdyhkYXRhLl9pbnRlcm5hbF9yYWRpdXMgKyBkYXRhLl9pbnRlcm5hbF9saW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXRhLl9pbnRlcm5hbF9saW5lQ29sb3I7XG4gICAgICAgIGRyYXcoZGF0YS5faW50ZXJuYWxfcmFkaXVzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5TWFya2VyRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZXJuYWxfaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3g6IDAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3k6IDAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RpbWU6IDAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3ByaWNlOiAwLFxuICAgICAgICAgICAgfV0sXG4gICAgICAgIF9pbnRlcm5hbF9saW5lQ29sb3I6ICcnLFxuICAgICAgICBfaW50ZXJuYWxfYmFja0NvbG9yOiAnJyxcbiAgICAgICAgX2ludGVybmFsX3JhZGl1czogMCxcbiAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogMCxcbiAgICAgICAgX2ludGVybmFsX3Zpc2libGVSYW5nZTogbnVsbCxcbiAgICB9O1xufVxuY29uc3QgcmFuZ2VGb3JTaW5nbGVQb2ludCA9IHsgZnJvbTogMCwgdG86IDEgfTtcbmNsYXNzIENyb3NzaGFpck1hcmtzUGFuZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJ0TW9kZWwsIGNyb3NzaGFpciwgcGFuZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb21wb3NpdGVSZW5kZXJlciA9IG5ldyBDb21wb3NpdGVSZW5kZXJlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzUmVuZGVyZXJzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNEYXRhID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbCA9IGNoYXJ0TW9kZWw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpciA9IGNyb3NzaGFpcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZSA9IHBhbmU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbXBvc2l0ZVJlbmRlcmVyLl9pbnRlcm5hbF9zZXRSZW5kZXJlcnModGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1JlbmRlcmVycyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUodXBkYXRlVHlwZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcmVhdGVNYXJrZXJSZW5kZXJlcnNJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVJbXBsKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jb21wb3NpdGVSZW5kZXJlcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NyZWF0ZU1hcmtlclJlbmRlcmVyc0lmTmVlZGVkKCkge1xuICAgICAgICBjb25zdCBzZXJpZXNlcyA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX29yZGVyZWRTb3VyY2VzKCk7XG4gICAgICAgIGlmIChzZXJpZXNlcy5sZW5ndGggIT09IHRoaXMuX3ByaXZhdGVfX21hcmtlcnNSZW5kZXJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzRGF0YSA9IHNlcmllc2VzLm1hcChjcmVhdGVFbXB0eU1hcmtlckRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1JlbmRlcmVycyA9IHRoaXMuX3ByaXZhdGVfX21hcmtlcnNEYXRhLm1hcCgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBQYW5lUmVuZGVyZXJNYXJrcygpO1xuICAgICAgICAgICAgICAgIHJlcy5faW50ZXJuYWxfc2V0RGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jb21wb3NpdGVSZW5kZXJlci5faW50ZXJuYWxfc2V0UmVuZGVyZXJzKHRoaXMuX3ByaXZhdGVfX21hcmtlcnNSZW5kZXJlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVJbXBsKCkge1xuICAgICAgICBjb25zdCBmb3JjZUhpZGRlbiA9IHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfb3B0aW9ucygpLm1vZGUgPT09IDIgLyogQ3Jvc3NoYWlyTW9kZS5IaWRkZW4gKi8gfHwgIXRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfdmlzaWJsZSgpO1xuICAgICAgICBjb25zdCBzZXJpZXNlcyA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX29yZGVyZWRTZXJpZXMoKTtcbiAgICAgICAgY29uc3QgdGltZVBvaW50SW5kZXggPSB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX2FwcGxpZWRJbmRleCgpO1xuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSB0aGlzLl9wcml2YXRlX19jaGFydE1vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3JlYXRlTWFya2VyUmVuZGVyZXJzSWZOZWVkZWQoKTtcbiAgICAgICAgc2VyaWVzZXMuZm9yRWFjaCgocywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9wcml2YXRlX19tYXJrZXJzRGF0YVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzZXJpZXNEYXRhID0gcy5faW50ZXJuYWxfbWFya2VyRGF0YUF0SW5kZXgodGltZVBvaW50SW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChmb3JjZUhpZGRlbiB8fCBzZXJpZXNEYXRhID09PSBudWxsIHx8ICFzLl9pbnRlcm5hbF92aXNpYmxlKCkgfHwgZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfbGluZUNvbG9yID0gc2VyaWVzRGF0YS5faW50ZXJuYWxfYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfcmFkaXVzID0gc2VyaWVzRGF0YS5faW50ZXJuYWxfcmFkaXVzO1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfbGluZVdpZHRoID0gc2VyaWVzRGF0YS5faW50ZXJuYWxfYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9pdGVtc1swXS5faW50ZXJuYWxfcHJpY2UgPSBzZXJpZXNEYXRhLl9pbnRlcm5hbF9wcmljZTtcbiAgICAgICAgICAgIGRhdGEuX2ludGVybmFsX2l0ZW1zWzBdLl9pbnRlcm5hbF95ID0gcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShzZXJpZXNEYXRhLl9pbnRlcm5hbF9wcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfYmFja0NvbG9yID0gc2VyaWVzRGF0YS5faW50ZXJuYWxfYm9yZGVyQ29sb3IgPz8gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfYmFja2dyb3VuZENvbG9yQXRZUGVyY2VudEZyb21Ub3AoZGF0YS5faW50ZXJuYWxfaXRlbXNbMF0uX2ludGVybmFsX3kgLyBzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX2hlaWdodCgpKTtcbiAgICAgICAgICAgIGRhdGEuX2ludGVybmFsX2l0ZW1zWzBdLl9pbnRlcm5hbF90aW1lID0gdGltZVBvaW50SW5kZXg7XG4gICAgICAgICAgICBkYXRhLl9pbnRlcm5hbF9pdGVtc1swXS5faW50ZXJuYWxfeCA9IHRpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUodGltZVBvaW50SW5kZXgpO1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID0gcmFuZ2VGb3JTaW5nbGVQb2ludDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBDcm9zc2hhaXJSZW5kZXJlciBleHRlbmRzIEJpdG1hcENvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2RyYXdJbXBsKHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplLCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJ0TGluZXNWaXNpYmxlID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmVydExpbmUuX2ludGVybmFsX3Zpc2libGU7XG4gICAgICAgIGNvbnN0IGhvcnpMaW5lc1Zpc2libGUgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfdmlzaWJsZTtcbiAgICAgICAgaWYgKCF2ZXJ0TGluZXNWaXNpYmxlICYmICFob3J6TGluZXNWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgICAgICBpZiAodmVydExpbmVzVmlzaWJsZSAmJiB4ID49IDApIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLmZsb29yKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3ZlcnRMaW5lLl9pbnRlcm5hbF9saW5lV2lkdGggKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmVydExpbmUuX2ludGVybmFsX2NvbG9yO1xuICAgICAgICAgICAgc2V0TGluZVN0eWxlKGN0eCwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmVydExpbmUuX2ludGVybmFsX2xpbmVTdHlsZSk7XG4gICAgICAgICAgICBkcmF3VmVydGljYWxMaW5lKGN0eCwgeCwgMCwgYml0bWFwU2l6ZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3J6TGluZXNWaXNpYmxlICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaG9yekxpbmUuX2ludGVybmFsX2xpbmVXaWR0aCAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaG9yekxpbmUuX2ludGVybmFsX2NvbG9yO1xuICAgICAgICAgICAgc2V0TGluZVN0eWxlKGN0eCwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaG9yekxpbmUuX2ludGVybmFsX2xpbmVTdHlsZSk7XG4gICAgICAgICAgICBkcmF3SG9yaXpvbnRhbExpbmUoY3R4LCB5LCAwLCBiaXRtYXBTaXplLndpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ3Jvc3NoYWlyUGFuZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgcGFuZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyRGF0YSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF92ZXJ0TGluZToge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2xpbmVTdHlsZTogMCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfY29sb3I6ICcnLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW50ZXJuYWxfaG9yekxpbmU6IHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbGluZVdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lU3R5bGU6IDAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2NvbG9yOiAnJyxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2ludGVybmFsX3g6IDAsXG4gICAgICAgICAgICBfaW50ZXJuYWxfeTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIgPSBuZXcgQ3Jvc3NoYWlyUmVuZGVyZXIodGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJEYXRhKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lID0gcGFuZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXIocGFuZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUltcGwoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlSW1wbCgpIHtcbiAgICAgICAgY29uc3QgdmlzaWJsZSA9IHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfdmlzaWJsZSgpO1xuICAgICAgICBjb25zdCBjcm9zc2hhaXJPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfb3B0aW9ucygpLmNyb3NzaGFpcjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyRGF0YTtcbiAgICAgICAgaWYgKGNyb3NzaGFpck9wdGlvbnMubW9kZSA9PT0gMiAvKiBDcm9zc2hhaXJNb2RlLkhpZGRlbiAqLykge1xuICAgICAgICAgICAgZGF0YS5faW50ZXJuYWxfaG9yekxpbmUuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGRhdGEuX2ludGVybmFsX3ZlcnRMaW5lLl9pbnRlcm5hbF92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5faW50ZXJuYWxfaG9yekxpbmUuX2ludGVybmFsX3Zpc2libGUgPSB2aXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfaG9yekxpbmVWaXNpYmxlKHRoaXMuX3ByaXZhdGVfX3BhbmUpO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfdmlzaWJsZSA9IHZpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF92ZXJ0TGluZVZpc2libGUoKTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfaG9yekxpbmUuX2ludGVybmFsX2xpbmVXaWR0aCA9IGNyb3NzaGFpck9wdGlvbnMuaG9yekxpbmUud2lkdGg7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2hvcnpMaW5lLl9pbnRlcm5hbF9saW5lU3R5bGUgPSBjcm9zc2hhaXJPcHRpb25zLmhvcnpMaW5lLnN0eWxlO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9ob3J6TGluZS5faW50ZXJuYWxfY29sb3IgPSBjcm9zc2hhaXJPcHRpb25zLmhvcnpMaW5lLmNvbG9yO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF92ZXJ0TGluZS5faW50ZXJuYWxfbGluZVdpZHRoID0gY3Jvc3NoYWlyT3B0aW9ucy52ZXJ0TGluZS53aWR0aDtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmVydExpbmUuX2ludGVybmFsX2xpbmVTdHlsZSA9IGNyb3NzaGFpck9wdGlvbnMudmVydExpbmUuc3R5bGU7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3ZlcnRMaW5lLl9pbnRlcm5hbF9jb2xvciA9IGNyb3NzaGFpck9wdGlvbnMudmVydExpbmUuY29sb3I7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3ggPSB0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX2FwcGxpZWRYKCk7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3kgPSB0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX2FwcGxpZWRZKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEZpbGxzIHJlY3RhbmdsZSdzIGlubmVyIGJvcmRlciAoc28sIGFsbCB0aGUgZmlsbGVkIGFyZWEgaXMgbGltaXRlZCBieSB0aGUgW3gsIHggKyB3aWR0aF0qW3ksIHkgKyBoZWlnaHRdIHJlZ2lvbilcbiAqIGBgYFxuICogKHgsIHkpXG4gKiBPKioqKioqKioqKioqKioqKioqKioqKip8KioqKipcbiAqIHwgICAgICAgIGJvcmRlciAgICAgICAgIHwgIF5cbiAqIHwgICAqKioqKioqKioqKioqKioqKiAgIHwgIHxcbiAqIHwgICB8ICAgICAgICAgICAgICAgfCAgIHwgIHxcbiAqIHwgYiB8ICAgICAgICAgICAgICAgfCBiIHwgIGhcbiAqIHwgbyB8ICAgICAgICAgICAgICAgfCBvIHwgIGVcbiAqIHwgciB8ICAgICAgICAgICAgICAgfCByIHwgIGlcbiAqIHwgZCB8ICAgICAgICAgICAgICAgfCBkIHwgIGdcbiAqIHwgZSB8ICAgICAgICAgICAgICAgfCBlIHwgIGhcbiAqIHwgciB8ICAgICAgICAgICAgICAgfCByIHwgIHRcbiAqIHwgICB8ICAgICAgICAgICAgICAgfCAgIHwgIHxcbiAqIHwgICAqKioqKioqKioqKioqKioqKiAgIHwgIHxcbiAqIHwgICAgICAgIGJvcmRlciAgICAgICAgIHwgIHZcbiAqIHwqKioqKioqKioqKioqKioqKioqKioqKnwqKioqKlxuICogfCAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfDwtLS0tLS0tIHdpZHRoIC0tLS0tLS0+fFxuICogYGBgXG4gKlxuICogQHBhcmFtIGN0eCAtIENvbnRleHQgdG8gZHJhdyBvblxuICogQHBhcmFtIHggLSBMZWZ0IHNpZGUgb2YgdGhlIHRhcmdldCByZWN0YW5nbGVcbiAqIEBwYXJhbSB5IC0gVG9wIHNpZGUgb2YgdGhlIHRhcmdldCByZWN0YW5nbGVcbiAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSB0YXJnZXQgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSB0YXJnZXQgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gYm9yZGVyV2lkdGggLSBXaWR0aCBvZiBib3JkZXIgdG8gZmlsbCwgbXVzdCBiZSBsZXNzIHRoYW4gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdGFyZ2V0IHJlY3RhbmdsZVxuICovXG5mdW5jdGlvbiBmaWxsUmVjdElubmVyQm9yZGVyKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYm9yZGVyV2lkdGgpIHtcbiAgICAvLyBob3Jpem9udGFsICh0b3AgYW5kIGJvdHRvbSkgZWRnZXNcbiAgICBjdHguZmlsbFJlY3QoeCArIGJvcmRlcldpZHRoLCB5LCB3aWR0aCAtIGJvcmRlcldpZHRoICogMiwgYm9yZGVyV2lkdGgpO1xuICAgIGN0eC5maWxsUmVjdCh4ICsgYm9yZGVyV2lkdGgsIHkgKyBoZWlnaHQgLSBib3JkZXJXaWR0aCwgd2lkdGggLSBib3JkZXJXaWR0aCAqIDIsIGJvcmRlcldpZHRoKTtcbiAgICAvLyB2ZXJ0aWNhbCAobGVmdCBhbmQgcmlnaHQpIGVkZ2VzXG4gICAgY3R4LmZpbGxSZWN0KHgsIHksIGJvcmRlcldpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5maWxsUmVjdCh4ICsgd2lkdGggLSBib3JkZXJXaWR0aCwgeSwgYm9yZGVyV2lkdGgsIGhlaWdodCk7XG59XG5mdW5jdGlvbiBjbGVhclJlY3QoY3R4LCB4LCB5LCB3LCBoLCBjbGVhckNvbG9yKSB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgIGN0eC5maWxsU3R5bGUgPSBjbGVhckNvbG9yO1xuICAgIGN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY2hhbmdlQm9yZGVyUmFkaXVzKGJvcmRlclJhZGl1cywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGJvcmRlclJhZGl1cy5tYXAoKHgpID0+IHggPT09IDAgPyB4IDogeCArIG9mZnNldCk7XG59XG5mdW5jdGlvbiBkcmF3Um91bmRSZWN0KFxuLy8gZXNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1wYXJhbXNcbmN0eCwgeCwgeSwgdywgaCwgcmFkaWkpIHtcbiAgICAvKipcbiAgICAgKiBBcyBvZiBNYXkgMjAyMywgYWxsIG9mIHRoZSBtYWpvciBicm93c2VycyBub3cgc3VwcG9ydCBjdHgucm91bmRSZWN0KCkgc28gd2Ugc2hvdWxkXG4gICAgICogYmUgYWJsZSB0byBzd2l0Y2ggdG8gdGhlIG5hdGl2ZSB2ZXJzaW9uIHNvb24uXG4gICAgICovXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChjdHgucm91bmRSZWN0KSB7XG4gICAgICAgIGN0eC5yb3VuZFJlY3QoeCwgeSwgdywgaCwgcmFkaWkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qXG4gICAgICogRGVwcmVjYXRlIHRoZSByZXN0IGluIHY1LlxuICAgICAqL1xuICAgIGN0eC5saW5lVG8oeCArIHcgLSByYWRpaVsxXSwgeSk7XG4gICAgaWYgKHJhZGlpWzFdICE9PSAwKSB7XG4gICAgICAgIGN0eC5hcmNUbyh4ICsgdywgeSwgeCArIHcsIHkgKyByYWRpaVsxXSwgcmFkaWlbMV0pO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3LCB5ICsgaCAtIHJhZGlpWzJdKTtcbiAgICBpZiAocmFkaWlbMl0gIT09IDApIHtcbiAgICAgICAgY3R4LmFyY1RvKHggKyB3LCB5ICsgaCwgeCArIHcgLSByYWRpaVsyXSwgeSArIGgsIHJhZGlpWzJdKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgcmFkaWlbM10sIHkgKyBoKTtcbiAgICBpZiAocmFkaWlbM10gIT09IDApIHtcbiAgICAgICAgY3R4LmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIHJhZGlpWzNdLCByYWRpaVszXSk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCwgeSArIHJhZGlpWzBdKTtcbiAgICBpZiAocmFkaWlbMF0gIT09IDApIHtcbiAgICAgICAgY3R4LmFyY1RvKHgsIHksIHggKyByYWRpaVswXSwgeSwgcmFkaWlbMF0pO1xuICAgIH1cbn1cbi8qKlxuICogRHJhd3MgYSByb3VuZGVkIHJlY3Qgd2l0aCBhIGJvcmRlci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgY29sb3JzIHdpbGwgYmUgc29saWQsIHdpdGhvdXRcbiAqIGFueSBhbHBoYS4gKFRoaXMgYWxsb3dzIHVzIHRvIGZpeCBhIHJlbmRlcmluZyBhcnRlZmFjdC4pXG4gKlxuICogQHBhcmFtIG91dGVyQm9yZGVyUmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgYm9yZGVyIChvdXRlciBlZGdlKVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZnVuY3Rpb24gZHJhd1JvdW5kUmVjdFdpdGhCb3JkZXIoY3R4LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIGJhY2tncm91bmRDb2xvciwgYm9yZGVyV2lkdGggPSAwLCBvdXRlckJvcmRlclJhZGl1cyA9IFswLCAwLCAwLCAwXSwgYm9yZGVyQ29sb3IgPSAnJykge1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKCFib3JkZXJXaWR0aCB8fCAhYm9yZGVyQ29sb3IgfHwgYm9yZGVyQ29sb3IgPT09IGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICBkcmF3Um91bmRSZWN0KGN0eCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCBvdXRlckJvcmRlclJhZGl1cyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFsZkJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGggLyAyO1xuICAgIGNvbnN0IHJhZGlpID0gY2hhbmdlQm9yZGVyUmFkaXVzKG91dGVyQm9yZGVyUmFkaXVzLCAtaGFsZkJvcmRlcldpZHRoKTtcbiAgICBkcmF3Um91bmRSZWN0KGN0eCwgbGVmdCArIGhhbGZCb3JkZXJXaWR0aCwgdG9wICsgaGFsZkJvcmRlcldpZHRoLCB3aWR0aCAtIGJvcmRlcldpZHRoLCBoZWlnaHQgLSBib3JkZXJXaWR0aCwgcmFkaWkpO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKGJvcmRlckNvbG9yICE9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbmZ1bmN0aW9uIGNsZWFyUmVjdFdpdGhHcmFkaWVudChjdHgsIHgsIHksIHcsIGgsIHRvcENvbG9yLCBib3R0b21Db2xvcikge1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBoKTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgdG9wQ29sb3IpO1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBib3R0b21Db2xvcik7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgIGN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuXG5jbGFzcyBQcmljZUF4aXNWaWV3UmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGNvbW1vbkRhdGEpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0RGF0YShkYXRhLCBjb21tb25EYXRhKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSwgY29tbW9uRGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29tbW9uRGF0YSA9IGNvbW1vbkRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oZWlnaHQocmVuZGVyZXJPcHRpb25zLCB1c2VTZWNvbmRMaW5lKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemUgKyByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3AgKyByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdCb3R0b207XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3KHRhcmdldCwgcmVuZGVyZXJPcHRpb25zLCB0ZXh0V2lkdGhDYWNoZSwgYWxpZ24pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3RleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IHRoaXMuX3ByaXZhdGVfX2NvbW1vbkRhdGEuX2ludGVybmFsX2JhY2tncm91bmQ7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoc2NvcGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHNjb3BlLmNvbnRleHQ7XG4gICAgICAgICAgICBjdHguZm9udCA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udDtcbiAgICAgICAgICAgIGNvbnN0IGdlb20gPSB0aGlzLl9wcml2YXRlX19jYWxjdWxhdGVHZW9tZXRyeShzY29wZSwgcmVuZGVyZXJPcHRpb25zLCB0ZXh0V2lkdGhDYWNoZSwgYWxpZ24pO1xuICAgICAgICAgICAgY29uc3QgZ2IgPSBnZW9tLl9pbnRlcm5hbF9iaXRtYXA7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgIGRyYXcgbGFiZWwuIGJhY2tncm91bmRDb2xvciB3aWxsIGFsd2F5cyBiZSBhIHNvbGlkIGNvbG9yIChubyBhbHBoYSkgW3NlZSBnZW5lcmF0ZUNvbnRyYXN0Q29sb3JzIGluIGNvbG9yLnRzXS5cbiAgICAgICAgICAgICBUaGVyZWZvcmUgd2UgY2FuIGRyYXcgdGhlIHJvdW5kZWQgbGFiZWwgdXNpbmcgc2ltcGxpZmllZCBjb2RlIChkcmF3Um91bmRSZWN0V2l0aEJvcmRlcikgdGhhdCBkb2Vzbid0IG5lZWQgdG8gZW5zdXJlIHRoZSBiYWNrZ3JvdW5kIGFuZCB0aGUgYm9yZGVyIGRvbid0IG92ZXJsYXAuXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGdlb20uX2ludGVybmFsX2FsaWduUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBkcmF3Um91bmRSZWN0V2l0aEJvcmRlcihjdHgsIGdiLl9pbnRlcm5hbF94T3V0c2lkZSwgZ2IuX2ludGVybmFsX3lUb3AsIGdiLl9pbnRlcm5hbF90b3RhbFdpZHRoLCBnYi5faW50ZXJuYWxfdG90YWxIZWlnaHQsIGJhY2tncm91bmRDb2xvciwgZ2IuX2ludGVybmFsX2hvcnpCb3JkZXIsIFtnYi5faW50ZXJuYWxfcmFkaXVzLCAwLCAwLCBnYi5faW50ZXJuYWxfcmFkaXVzXSwgYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYXdSb3VuZFJlY3RXaXRoQm9yZGVyKGN0eCwgZ2IuX2ludGVybmFsX3hJbnNpZGUsIGdiLl9pbnRlcm5hbF95VG9wLCBnYi5faW50ZXJuYWxfdG90YWxXaWR0aCwgZ2IuX2ludGVybmFsX3RvdGFsSGVpZ2h0LCBiYWNrZ3JvdW5kQ29sb3IsIGdiLl9pbnRlcm5hbF9ob3J6Qm9yZGVyLCBbMCwgZ2IuX2ludGVybmFsX3JhZGl1cywgZ2IuX2ludGVybmFsX3JhZGl1cywgMF0sIGJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkcmF3IHRpY2tcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGdiLl9pbnRlcm5hbF94SW5zaWRlLCBnYi5faW50ZXJuYWxfeU1pZCwgZ2IuX2ludGVybmFsX3hUaWNrIC0gZ2IuX2ludGVybmFsX3hJbnNpZGUsIGdiLl9pbnRlcm5hbF90aWNrSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRyYXcgc2VwYXJhdG9yXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYm9yZGVyVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhbmVCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGdlb20uX2ludGVybmFsX2FsaWduUmlnaHQgPyBnYi5faW50ZXJuYWxfcmlnaHQgLSBnYi5faW50ZXJuYWxfaG9yekJvcmRlciA6IDAsIGdiLl9pbnRlcm5hbF95VG9wLCBnYi5faW50ZXJuYWxfaG9yekJvcmRlciwgZ2IuX2ludGVybmFsX3lCb3R0b20gLSBnYi5faW50ZXJuYWxfeVRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2VvbTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRhcmdldC51c2VNZWRpYUNvb3JkaW5hdGVTcGFjZSgoeyBjb250ZXh0OiBjdHggfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ20gPSBnZW9tZXRyeS5faW50ZXJuYWxfbWVkaWE7XG4gICAgICAgICAgICBjdHguZm9udCA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udDtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBnZW9tZXRyeS5faW50ZXJuYWxfYWxpZ25SaWdodCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3RleHQsIGdtLl9pbnRlcm5hbF94VGV4dCwgKGdtLl9pbnRlcm5hbF95VG9wICsgZ20uX2ludGVybmFsX3lCb3R0b20pIC8gMiArIGdtLl9pbnRlcm5hbF90ZXh0TWlkQ29ycmVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2FsY3VsYXRlR2VvbWV0cnkoc2NvcGUsIHJlbmRlcmVyT3B0aW9ucywgdGV4dFdpZHRoQ2FjaGUsIGFsaWduKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplLCBtZWRpYVNpemUsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSA9IHNjb3BlO1xuICAgICAgICBjb25zdCB0aWNrU2l6ZSA9ICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSB8fCAhdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfbW92ZVRleHRUb0ludmlzaWJsZVRpY2spID8gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoIDogMDtcbiAgICAgICAgY29uc3QgaG9yekJvcmRlciA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3NlcGFyYXRvclZpc2libGUgPyByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2JvcmRlclNpemUgOiAwO1xuICAgICAgICBjb25zdCBwYWRkaW5nVG9wID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nVG9wICsgdGhpcy5fcHJpdmF0ZV9fY29tbW9uRGF0YS5faW50ZXJuYWxfYWRkaXRpb25hbFBhZGRpbmdUb3A7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdCb3R0b20gPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdCb3R0b20gKyB0aGlzLl9wcml2YXRlX19jb21tb25EYXRhLl9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ0JvdHRvbTtcbiAgICAgICAgY29uc3QgcGFkZGluZ0lubmVyID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nSW5uZXI7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdPdXRlciA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ091dGVyO1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdGV4dDtcbiAgICAgICAgY29uc3QgYWN0dWFsVGV4dEhlaWdodCA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemU7XG4gICAgICAgIGNvbnN0IHRleHRNaWRDb3JyZWN0aW9uID0gdGV4dFdpZHRoQ2FjaGUuX2ludGVybmFsX3lNaWRDb3JyZWN0aW9uKGN0eCwgdGV4dCk7XG4gICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IE1hdGguY2VpbCh0ZXh0V2lkdGhDYWNoZS5faW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCB0ZXh0KSk7XG4gICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gYWN0dWFsVGV4dEhlaWdodCArIHBhZGRpbmdUb3AgKyBwYWRkaW5nQm90dG9tO1xuICAgICAgICBjb25zdCB0b3RhbFdpZHRoID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9ib3JkZXJTaXplICsgcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICsgdGV4dFdpZHRoICsgdGlja1NpemU7XG4gICAgICAgIGNvbnN0IHRpY2tIZWlnaHRCaXRtYXAgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHZlcnRpY2FsUGl4ZWxSYXRpbykpO1xuICAgICAgICBsZXQgdG90YWxIZWlnaHRCaXRtYXAgPSBNYXRoLnJvdW5kKHRvdGFsSGVpZ2h0ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgaWYgKHRvdGFsSGVpZ2h0Qml0bWFwICUgMiAhPT0gdGlja0hlaWdodEJpdG1hcCAlIDIpIHtcbiAgICAgICAgICAgIHRvdGFsSGVpZ2h0Qml0bWFwICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9yekJvcmRlckJpdG1hcCA9IGhvcnpCb3JkZXIgPiAwID8gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihob3J6Qm9yZGVyICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pKSA6IDA7XG4gICAgICAgIGNvbnN0IHRvdGFsV2lkdGhCaXRtYXAgPSBNYXRoLnJvdW5kKHRvdGFsV2lkdGggKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgIC8vIHRpY2sgb3ZlcmxhcHMgc2NhbGUgYm9yZGVyXG4gICAgICAgIGNvbnN0IHRpY2tTaXplQml0bWFwID0gTWF0aC5yb3VuZCh0aWNrU2l6ZSAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgY29uc3QgeU1pZCA9IHRoaXMuX3ByaXZhdGVfX2NvbW1vbkRhdGEuX2ludGVybmFsX2ZpeGVkQ29vcmRpbmF0ZSA/PyB0aGlzLl9wcml2YXRlX19jb21tb25EYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlO1xuICAgICAgICBjb25zdCB5TWlkQml0bWFwID0gTWF0aC5yb3VuZCh5TWlkICogdmVydGljYWxQaXhlbFJhdGlvKSAtIE1hdGguZmxvb3IodmVydGljYWxQaXhlbFJhdGlvICogMC41KTtcbiAgICAgICAgY29uc3QgeVRvcEJpdG1hcCA9IE1hdGguZmxvb3IoeU1pZEJpdG1hcCArIHRpY2tIZWlnaHRCaXRtYXAgLyAyIC0gdG90YWxIZWlnaHRCaXRtYXAgLyAyKTtcbiAgICAgICAgY29uc3QgeUJvdHRvbUJpdG1hcCA9IHlUb3BCaXRtYXAgKyB0b3RhbEhlaWdodEJpdG1hcDtcbiAgICAgICAgY29uc3QgYWxpZ25SaWdodCA9IGFsaWduID09PSAncmlnaHQnO1xuICAgICAgICBjb25zdCB4SW5zaWRlID0gYWxpZ25SaWdodCA/IG1lZGlhU2l6ZS53aWR0aCAtIGhvcnpCb3JkZXIgOiBob3J6Qm9yZGVyO1xuICAgICAgICBjb25zdCB4SW5zaWRlQml0bWFwID0gYWxpZ25SaWdodCA/IGJpdG1hcFNpemUud2lkdGggLSBob3J6Qm9yZGVyQml0bWFwIDogaG9yekJvcmRlckJpdG1hcDtcbiAgICAgICAgbGV0IHhPdXRzaWRlQml0bWFwO1xuICAgICAgICBsZXQgeFRpY2tCaXRtYXA7XG4gICAgICAgIGxldCB4VGV4dDtcbiAgICAgICAgaWYgKGFsaWduUmlnaHQpIHtcbiAgICAgICAgICAgIC8vIDIgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIDYgIDVcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAzICAgICAgICAgICAgICAgNFxuICAgICAgICAgICAgeE91dHNpZGVCaXRtYXAgPSB4SW5zaWRlQml0bWFwIC0gdG90YWxXaWR0aEJpdG1hcDtcbiAgICAgICAgICAgIHhUaWNrQml0bWFwID0geEluc2lkZUJpdG1hcCAtIHRpY2tTaXplQml0bWFwO1xuICAgICAgICAgICAgeFRleHQgPSB4SW5zaWRlIC0gdGlja1NpemUgLSBwYWRkaW5nSW5uZXIgLSBob3J6Qm9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gMSAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyA2ICA1XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gNCAgICAgICAgICAgICAgIDNcbiAgICAgICAgICAgIHhPdXRzaWRlQml0bWFwID0geEluc2lkZUJpdG1hcCArIHRvdGFsV2lkdGhCaXRtYXA7XG4gICAgICAgICAgICB4VGlja0JpdG1hcCA9IHhJbnNpZGVCaXRtYXAgKyB0aWNrU2l6ZUJpdG1hcDtcbiAgICAgICAgICAgIHhUZXh0ID0geEluc2lkZSArIHRpY2tTaXplICsgcGFkZGluZ0lubmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYWxpZ25SaWdodDogYWxpZ25SaWdodCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iaXRtYXA6IHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeVRvcDogeVRvcEJpdG1hcCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeU1pZDogeU1pZEJpdG1hcCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeUJvdHRvbTogeUJvdHRvbUJpdG1hcCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdG90YWxXaWR0aDogdG90YWxXaWR0aEJpdG1hcCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdG90YWxIZWlnaHQ6IHRvdGFsSGVpZ2h0Qml0bWFwLFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGl0IGlzIGJldHRlciB0byBoYXZlIGRpZmZlcmVudCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCByYWRpaVxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9yYWRpdXM6IDIgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaG9yekJvcmRlcjogaG9yekJvcmRlckJpdG1hcCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeE91dHNpZGU6IHhPdXRzaWRlQml0bWFwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF94SW5zaWRlOiB4SW5zaWRlQml0bWFwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF94VGljazogeFRpY2tCaXRtYXAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RpY2tIZWlnaHQ6IHRpY2tIZWlnaHRCaXRtYXAsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3JpZ2h0OiBiaXRtYXBTaXplLndpZHRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tZWRpYToge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF95VG9wOiB5VG9wQml0bWFwIC8gdmVydGljYWxQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF95Qm90dG9tOiB5Qm90dG9tQml0bWFwIC8gdmVydGljYWxQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF94VGV4dDogeFRleHQsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RleHRNaWRDb3JyZWN0aW9uOiB0ZXh0TWlkQ29ycmVjdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jbGFzcyBQcmljZUF4aXNWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihjdG9yKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jb29yZGluYXRlOiAwLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhY2tncm91bmQ6ICcjMDAwJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ0JvdHRvbTogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ1RvcDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF90ZXh0OiAnJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90aWNrVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tb3ZlVGV4dFRvSW52aXNpYmxlVGljazogZmFsc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm9yZGVyQ29sb3I6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX2NvbG9yOiAnI0ZGRicsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm9yZGVyVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfc2VwYXJhdG9yVmlzaWJsZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlckRhdGEgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdGV4dDogJycsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdGlja1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgX2ludGVybmFsX21vdmVUZXh0VG9JbnZpc2libGVUaWNrOiB0cnVlLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvcmRlckNvbG9yOiAnJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jb2xvcjogJyNGRkYnLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvcmRlclZpc2libGU6IHRydWUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfc2VwYXJhdG9yVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXIgPSBuZXcgKGN0b3IgfHwgUHJpY2VBeGlzVmlld1JlbmRlcmVyKSh0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhLCB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXIgPSBuZXcgKGN0b3IgfHwgUHJpY2VBeGlzVmlld1JlbmRlcmVyKSh0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXJEYXRhLCB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGV4dCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhSWZOZWVkZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3RleHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jb29yZGluYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFJZk5lZWRlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oZWlnaHQocmVuZGVyZXJPcHRpb25zLCB1c2VTZWNvbmRMaW5lID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlci5faW50ZXJuYWxfaGVpZ2h0KHJlbmRlcmVyT3B0aW9ucywgdXNlU2Vjb25kTGluZSksIHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlci5faW50ZXJuYWxfaGVpZ2h0KHJlbmRlcmVyT3B0aW9ucywgdXNlU2Vjb25kTGluZSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0Rml4ZWRDb29yZGluYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9maXhlZENvb3JkaW5hdGUgfHwgMDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEZpeGVkQ29vcmRpbmF0ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2ZpeGVkQ29vcmRpbmF0ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNWaXNpYmxlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFJZk5lZWRlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSB8fCB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNBeGlzTGFiZWxWaXNpYmxlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFJZk5lZWRlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKHByaWNlU2NhbGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhSWZOZWVkZWQoKTtcbiAgICAgICAgLy8gZm9yY2UgdXBkYXRlIHRpY2tWaXNpYmxlIHN0YXRlIGZyb20gcHJpY2Ugc2NhbGUgb3B0aW9uc1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYW5kIHdlIGNhbid0IGhhdmUgcHJpY2UgYXhpcyBpbiBvdGhlciBtZXRob2RzXG4gICAgICAgIC8vIChsaWtlIHBhbmVSZW5kZXJlciBvciBhbnkgb3RoZXIgd2hvIGNhbGwgX3VwZGF0ZVJlbmRlcmVyRGF0YUlmTmVlZGVkKVxuICAgICAgICB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSA9IHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlICYmIHByaWNlU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKS50aWNrc1Zpc2libGU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGlja1Zpc2libGUgJiYgcHJpY2VTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpLnRpY2tzVmlzaWJsZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHRoaXMuX3ByaXZhdGVfX2F4aXNSZW5kZXJlckRhdGEsIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXJEYXRhLCB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFuZVJlbmRlcmVyKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEodGhpcy5fcHJpdmF0ZV9fYXhpc1JlbmRlcmVyRGF0YSwgdGhpcy5fcHJpdmF0ZV9fY29tbW9uUmVuZGVyZXJEYXRhKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVJlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHRoaXMuX3ByaXZhdGVfX3BhbmVSZW5kZXJlckRhdGEsIHRoaXMuX3ByaXZhdGVfX2NvbW1vblJlbmRlcmVyRGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXI7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX3VwZGF0ZVJlbmRlcmVyRGF0YSh0aGlzLl9wcml2YXRlX19heGlzUmVuZGVyZXJEYXRhLCB0aGlzLl9wcml2YXRlX19wYW5lUmVuZGVyZXJEYXRhLCB0aGlzLl9wcml2YXRlX19jb21tb25SZW5kZXJlckRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDcm9zc2hhaXJQcmljZUF4aXNWaWV3IGV4dGVuZHMgUHJpY2VBeGlzVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBwcmljZVNjYWxlLCB2YWx1ZVByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9IHByaWNlU2NhbGU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ZhbHVlUHJvdmlkZXIgPSB2YWx1ZVByb3ZpZGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3VwZGF0ZVJlbmRlcmVyRGF0YShheGlzUmVuZGVyZXJEYXRhLCBwYW5lUmVuZGVyZXJEYXRhLCBjb21tb25SZW5kZXJlckRhdGEpIHtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF9vcHRpb25zKCkubW9kZSA9PT0gMiAvKiBDcm9zc2hhaXJNb2RlLkhpZGRlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19zb3VyY2UuX2ludGVybmFsX29wdGlvbnMoKS5ob3J6TGluZTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmxhYmVsVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF92aXNpYmxlKCkgfHwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpIHx8IChmaXJzdFZhbHVlID09PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2NvbG9yUGFyc2VyKCkuX2ludGVybmFsX2dlbmVyYXRlQ29udHJhc3RDb2xvcnMob3B0aW9ucy5sYWJlbEJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIGNvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfYmFja2dyb3VuZCA9IGNvbG9ycy5faW50ZXJuYWxfYmFja2dyb3VuZDtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfY29sb3IgPSBjb2xvcnMuX2ludGVybmFsX2ZvcmVncm91bmQ7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxQYWRkaW5nID0gMiAvIDEyICogdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9udFNpemUoKTtcbiAgICAgICAgY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ1RvcCA9IGFkZGl0aW9uYWxQYWRkaW5nO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2FkZGl0aW9uYWxQYWRkaW5nQm90dG9tID0gYWRkaXRpb25hbFBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fdmFsdWVQcm92aWRlcih0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlKTtcbiAgICAgICAgY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlID0gdmFsdWUuX2ludGVybmFsX2Nvb3JkaW5hdGU7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3RleHQgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9mb3JtYXRQcmljZSh2YWx1ZS5faW50ZXJuYWxfcHJpY2UsIGZpcnN0VmFsdWUpO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gdHJ1ZTtcbiAgICB9XG59XG5cbmNvbnN0IG9wdGltaXphdGlvblJlcGxhY2VtZW50UmUgPSAvWzEtOV0vZztcbmNvbnN0IHJhZGl1cyQxID0gMjtcbmNsYXNzIFRpbWVBeGlzVmlld1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3KHRhcmdldCwgcmVuZGVyZXJPcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGUgPT09IGZhbHNlIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3RleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gdGFyZ2V0LnVzZU1lZGlhQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCB9KSA9PiB7XG4gICAgICAgICAgICBjdHguZm9udCA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udDtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfd2lkdGhDYWNoZS5faW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2RhdGEpLl9pbnRlcm5hbF90ZXh0LCBvcHRpbWl6YXRpb25SZXBsYWNlbWVudFJlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGV4dFdpZHRoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3J6TWFyZ2luID0gcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nSG9yaXpvbnRhbDtcbiAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRleHRXaWR0aCArIDIgKiBob3J6TWFyZ2luO1xuICAgICAgICBjb25zdCBsYWJlbFdpZHRoSGFsZiA9IGxhYmVsV2lkdGggLyAyO1xuICAgICAgICBjb25zdCB0aW1lU2NhbGVXaWR0aCA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3dpZHRoO1xuICAgICAgICBsZXQgY29vcmRpbmF0ZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGU7XG4gICAgICAgIGxldCB4MSA9IE1hdGguZmxvb3IoY29vcmRpbmF0ZSAtIGxhYmVsV2lkdGhIYWxmKSArIDAuNTtcbiAgICAgICAgaWYgKHgxIDwgMCkge1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGUgKyBNYXRoLmFicygwIC0geDEpO1xuICAgICAgICAgICAgeDEgPSBNYXRoLmZsb29yKGNvb3JkaW5hdGUgLSBsYWJlbFdpZHRoSGFsZikgKyAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeDEgKyBsYWJlbFdpZHRoID4gdGltZVNjYWxlV2lkdGgpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlIC0gTWF0aC5hYnModGltZVNjYWxlV2lkdGggLSAoeDEgKyBsYWJlbFdpZHRoKSk7XG4gICAgICAgICAgICB4MSA9IE1hdGguZmxvb3IoY29vcmRpbmF0ZSAtIGxhYmVsV2lkdGhIYWxmKSArIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4MiA9IHgxICsgbGFiZWxXaWR0aDtcbiAgICAgICAgY29uc3QgeTEgPSAwO1xuICAgICAgICBjb25zdCB5MiA9IE1hdGguY2VpbCh5MSArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2JvcmRlclNpemUgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ1RvcCArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnRTaXplICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0JvdHRvbSk7XG4gICAgICAgIHRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2RhdGEpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRhdGEuX2ludGVybmFsX2JhY2tncm91bmQ7XG4gICAgICAgICAgICBjb25zdCB4MXNjYWxlZCA9IE1hdGgucm91bmQoeDEgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCB5MXNjYWxlZCA9IE1hdGgucm91bmQoeTEgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgeDJzY2FsZWQgPSBNYXRoLnJvdW5kKHgyICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgeTJzY2FsZWQgPSBNYXRoLnJvdW5kKHkyICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1c1NjYWxlZCA9IE1hdGgucm91bmQocmFkaXVzJDEgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxc2NhbGVkLCB5MXNjYWxlZCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgxc2NhbGVkLCB5MnNjYWxlZCAtIHJhZGl1c1NjYWxlZCk7XG4gICAgICAgICAgICBjdHguYXJjVG8oeDFzY2FsZWQsIHkyc2NhbGVkLCB4MXNjYWxlZCArIHJhZGl1c1NjYWxlZCwgeTJzY2FsZWQsIHJhZGl1c1NjYWxlZCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgyc2NhbGVkIC0gcmFkaXVzU2NhbGVkLCB5MnNjYWxlZCk7XG4gICAgICAgICAgICBjdHguYXJjVG8oeDJzY2FsZWQsIHkyc2NhbGVkLCB4MnNjYWxlZCwgeTJzY2FsZWQgLSByYWRpdXNTY2FsZWQsIHJhZGl1c1NjYWxlZCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgyc2NhbGVkLCB5MXNjYWxlZCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgaWYgKGRhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja1ggPSBNYXRoLnJvdW5kKGRhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGUgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja1RvcCA9IHkxc2NhbGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tCb3R0b20gPSBNYXRoLnJvdW5kKCh0aWNrVG9wICsgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRhdGEuX2ludGVybmFsX2NvbG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrT2Zmc2V0ID0gTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbyAqIDAuNSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHRpY2tYIC0gdGlja09mZnNldCwgdGlja1RvcCwgdGlja1dpZHRoLCB0aWNrQm90dG9tIC0gdGlja1RvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0YXJnZXQudXNlTWVkaWFDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2RhdGEpO1xuICAgICAgICAgICAgY29uc3QgeVRleHQgPSB5MSArXG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9ib3JkZXJTaXplICtcbiAgICAgICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGggK1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ1RvcCArXG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSAvIDI7XG4gICAgICAgICAgICBjdHguZm9udCA9IHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udDtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZGF0YS5faW50ZXJuYWxfY29sb3I7XG4gICAgICAgICAgICBjb25zdCB0ZXh0WUNvcnJlY3Rpb24gPSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3dpZHRoQ2FjaGUuX2ludGVybmFsX3lNaWRDb3JyZWN0aW9uKGN0eCwgJ0FwcjAnKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeDEgKyBob3J6TWFyZ2luLCB5VGV4dCArIHRleHRZQ29ycmVjdGlvbik7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoZGF0YS5faW50ZXJuYWxfdGV4dCwgMCwgMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgQ3Jvc3NoYWlyVGltZUF4aXNWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcihjcm9zc2hhaXIsIG1vZGVsLCB2YWx1ZVByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIgPSBuZXcgVGltZUF4aXNWaWV3UmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJEYXRhID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhY2tncm91bmQ6ICcjNGM1MjVlJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90ZXh0OiAnJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF93aWR0aDogMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9jb29yZGluYXRlOiBOYU4sXG4gICAgICAgICAgICBfaW50ZXJuYWxfdGlja1Zpc2libGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpciA9IGNyb3NzaGFpcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmFsdWVQcm92aWRlciA9IHZhbHVlUHJvdmlkZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUltcGwoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEodGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlSW1wbCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyRGF0YTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyLl9pbnRlcm5hbF9vcHRpb25zKCkubW9kZSA9PT0gMiAvKiBDcm9zc2hhaXJNb2RlLkhpZGRlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX29wdGlvbnMoKS52ZXJ0TGluZTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmxhYmVsVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgaWYgKHRpbWVTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5faW50ZXJuYWxfd2lkdGggPSB0aW1lU2NhbGUuX2ludGVybmFsX3dpZHRoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fdmFsdWVQcm92aWRlcigpO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlID0gdmFsdWUuX2ludGVybmFsX2Nvb3JkaW5hdGU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGltZVNjYWxlLl9pbnRlcm5hbF9pbmRleFRvVGltZVNjYWxlUG9pbnQodGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyLl9pbnRlcm5hbF9hcHBsaWVkSW5kZXgoKSk7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3RleHQgPSB0aW1lU2NhbGUuX2ludGVybmFsX2Zvcm1hdERhdGVUaW1lKGVuc3VyZU5vdE51bGwoY3VycmVudFRpbWUpKTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9jb2xvclBhcnNlcigpLl9pbnRlcm5hbF9nZW5lcmF0ZUNvbnRyYXN0Q29sb3JzKG9wdGlvbnMubGFiZWxCYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9iYWNrZ3JvdW5kID0gY29sb3JzLl9pbnRlcm5hbF9iYWNrZ3JvdW5kO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9jb2xvciA9IGNvbG9ycy5faW50ZXJuYWxfZm9yZWdyb3VuZDtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdGlja1Zpc2libGUgPSB0aW1lU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKS50aWNrc1Zpc2libGU7XG4gICAgfVxufVxuXG5jbGFzcyBEYXRhU291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaWNlU2NhbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX196b3JkZXIgPSAwO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfem9yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fem9yZGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0Wm9yZGVyKHpvcmRlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX196b3JkZXIgPSB6b3JkZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3ByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQcmljZVNjYWxlKHByaWNlU2NhbGUpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaWNlU2NhbGUgPSBwcmljZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGFiZWxQYW5lVmlld3MocGFuZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lQXhpc1ZpZXdzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF92aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY3Jvc3NoYWlyIG1vZGUuXG4gKi9cbnZhciBDcm9zc2hhaXJNb2RlO1xuKGZ1bmN0aW9uIChDcm9zc2hhaXJNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBtb2RlIGFsbG93cyBjcm9zc2hhaXIgdG8gbW92ZSBmcmVlbHkgb24gdGhlIGNoYXJ0LlxuICAgICAqL1xuICAgIENyb3NzaGFpck1vZGVbQ3Jvc3NoYWlyTW9kZVtcIk5vcm1hbFwiXSA9IDBdID0gXCJOb3JtYWxcIjtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGUgc3RpY2tzIGNyb3NzaGFpcidzIGhvcml6b250YWwgbGluZSB0byB0aGUgcHJpY2UgdmFsdWUgb2YgYSBzaW5nbGUtdmFsdWUgc2VyaWVzIG9yIHRvIHRoZSBjbG9zZSBwcmljZSBvZiBPSExDLWJhc2VkIHNlcmllcy5cbiAgICAgKi9cbiAgICBDcm9zc2hhaXJNb2RlW0Nyb3NzaGFpck1vZGVbXCJNYWduZXRcIl0gPSAxXSA9IFwiTWFnbmV0XCI7XG4gICAgLyoqXG4gICAgICogVGhpcyBtb2RlIGRpc2FibGVzIHJlbmRlcmluZyBvZiB0aGUgY3Jvc3NoYWlyLlxuICAgICAqL1xuICAgIENyb3NzaGFpck1vZGVbQ3Jvc3NoYWlyTW9kZVtcIkhpZGRlblwiXSA9IDJdID0gXCJIaWRkZW5cIjtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGUgc3RpY2tzIGNyb3NzaGFpcidzIGhvcml6b250YWwgbGluZSB0byB0aGUgcHJpY2UgdmFsdWUgb2YgYSBzaW5nbGUtdmFsdWUgc2VyaWVzIG9yIHRvIHRoZSBvcGVuL2hpZ2gvbG93L2Nsb3NlIHByaWNlIG9mIE9ITEMtYmFzZWQgc2VyaWVzLlxuICAgICAqL1xuICAgIENyb3NzaGFpck1vZGVbQ3Jvc3NoYWlyTW9kZVtcIk1hZ25ldE9ITENcIl0gPSAzXSA9IFwiTWFnbmV0T0hMQ1wiO1xufSkoQ3Jvc3NoYWlyTW9kZSB8fCAoQ3Jvc3NoYWlyTW9kZSA9IHt9KSk7XG5jbGFzcyBDcm9zc2hhaXIgZXh0ZW5kcyBEYXRhU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2UgPSBOYU47XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZSA9IGZhbHNlOyAvLyBpbml0aWFsbHkgdGhlIGNyb3NzaGFpciBzaG91bGQgbm90IGJlIHZpc2libGUsIHVudGlsIHRoZSB1c2VyIGludGVyYWN0cy5cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlld3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyUGFuZVZpZXdDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNQYW5lVmlld0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9feCA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9feSA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3JpZ2luWCA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3JpZ2luWSA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHZhbHVlUHJpY2VQcm92aWRlciA9IChyYXdQcmljZVByb3ZpZGVyLCByYXdDb29yZGluYXRlUHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocHJpY2VTY2FsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSByYXdDb29yZGluYXRlUHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdQcmljZSA9IHJhd1ByaWNlUHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19wYW5lKS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmljZSBtdXN0IGJlIGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgX2ludGVybmFsX3ByaWNlOiByYXdQcmljZSwgX2ludGVybmFsX2Nvb3JkaW5hdGU6IGNvb3JkaW5hdGUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBjb252ZXJ0IGZyb20gY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gZW5zdXJlTm90TnVsbChwcmljZVNjYWxlLl9pbnRlcm5hbF9maXJzdFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmljZSA9IHByaWNlU2NhbGUuX2ludGVybmFsX2Nvb3JkaW5hdGVUb1ByaWNlKGNvb3JkaW5hdGUsIGZpcnN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBfaW50ZXJuYWxfcHJpY2U6IHByaWNlLCBfaW50ZXJuYWxfY29vcmRpbmF0ZTogY29vcmRpbmF0ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbHVlVGltZVByb3ZpZGVyID0gKHJhd0luZGV4UHJvdmlkZXIsIHJhd0Nvb3JkaW5hdGVQcm92aWRlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9pbmRleFRvVGltZShyYXdJbmRleFByb3ZpZGVyKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSByYXdDb29yZGluYXRlUHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRpbWUgfHwgIU51bWJlci5pc0Zpbml0ZShjb29yZGluYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX3RpbWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9jb29yZGluYXRlOiBjb29yZGluYXRlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyBmb3IgY3VycmVudCBwb3NpdGlvbiBhbHdheXMgcmV0dXJuIGJvdGggcHJpY2UgYW5kIGNvb3JkaW5hdGVcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3VycmVudFBvc1ByaWNlUHJvdmlkZXIgPSB2YWx1ZVByaWNlUHJvdmlkZXIoKCkgPT4gdGhpcy5fcHJpdmF0ZV9fcHJpY2UsICgpID0+IHRoaXMuX3ByaXZhdGVfX3kpO1xuICAgICAgICBjb25zdCBjdXJyZW50UG9zVGltZVByb3ZpZGVyID0gdmFsdWVUaW1lUHJvdmlkZXIoKCkgPT4gdGhpcy5fcHJpdmF0ZV9faW5kZXgsICgpID0+IHRoaXMuX2ludGVybmFsX2FwcGxpZWRYKCkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1ZpZXcgPSBuZXcgQ3Jvc3NoYWlyVGltZUF4aXNWaWV3KHRoaXMsIG1vZGVsLCBjdXJyZW50UG9zVGltZVByb3ZpZGVyKTtcbiAgICB9XG4gICAgX2ludGVybmFsX29wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2F2ZU9yaWdpbkNvb3JkKHgsIHkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3JpZ2luWCA9IHg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29yaWdpblkgPSB5O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2xlYXJPcmlnaW5Db29yZCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3JpZ2luWCA9IE5hTjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3JpZ2luWSA9IE5hTjtcbiAgICB9XG4gICAgX2ludGVybmFsX29yaWdpbkNvb3JkWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29yaWdpblg7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcmlnaW5Db29yZFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcmlnaW5ZO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0UG9zaXRpb24oaW5kZXgsIHByaWNlLCBwYW5lKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RyeVRvVXBkYXRlVmlld3MoaW5kZXgsIHByaWNlLCBwYW5lKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGxpZWRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2luZGV4O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbGllZFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX194O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbGllZFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX195O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Zpc2libGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jbGVhclBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldEluZGV4VG9MYXN0U2VyaWVzQmFySW5kZXgoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2UgPSBOYU47XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ggPSBOYU47XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3kgPSBOYU47XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9jbGVhck9yaWdpbkNvb3JkKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUFsbFZpZXdzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lVmlld3MocGFuZSkge1xuICAgICAgICBsZXQgY3Jvc3NoYWlyUGFuZVZpZXcgPSB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJQYW5lVmlld0NhY2hlLmdldChwYW5lKTtcbiAgICAgICAgaWYgKCFjcm9zc2hhaXJQYW5lVmlldykge1xuICAgICAgICAgICAgY3Jvc3NoYWlyUGFuZVZpZXcgPSBuZXcgQ3Jvc3NoYWlyUGFuZVZpZXcodGhpcywgcGFuZSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJQYW5lVmlld0NhY2hlLnNldChwYW5lLCBjcm9zc2hhaXJQYW5lVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hcmtlcnNQYW5lVmlldyA9IHRoaXMuX3ByaXZhdGVfX21hcmtlcnNQYW5lVmlld0NhY2hlLmdldChwYW5lKTtcbiAgICAgICAgaWYgKCFtYXJrZXJzUGFuZVZpZXcpIHtcbiAgICAgICAgICAgIG1hcmtlcnNQYW5lVmlldyA9IG5ldyBDcm9zc2hhaXJNYXJrc1BhbmVWaWV3KHRoaXMuX3ByaXZhdGVfX21vZGVsLCB0aGlzLCBwYW5lKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNQYW5lVmlld0NhY2hlLnNldChwYW5lLCBtYXJrZXJzUGFuZVZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3Jvc3NoYWlyUGFuZVZpZXcsIG1hcmtlcnNQYW5lVmlld107XG4gICAgfVxuICAgIF9pbnRlcm5hbF9ob3J6TGluZVZpc2libGUocGFuZSkge1xuICAgICAgICByZXR1cm4gcGFuZSA9PT0gdGhpcy5fcHJpdmF0ZV9fcGFuZSAmJiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmhvcnpMaW5lLnZpc2libGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92ZXJ0TGluZVZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnZlcnRMaW5lLnZpc2libGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZUF4aXNWaWV3cyhwYW5lLCBwcmljZVNjYWxlKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZSB8fCB0aGlzLl9wcml2YXRlX19wYW5lICE9PSBwYW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3cy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdzID0gW107XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wYW5lID09PSBwYW5lKSB7XG4gICAgICAgICAgICB2aWV3cy5wdXNoKHRoaXMuX3ByaXZhdGVfX2NyZWF0ZVByaWNlQXhpc1ZpZXdPbkRlbWFuZCh0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3cywgcHJpY2VTY2FsZSwgdGhpcy5fcHJpdmF0ZV9fY3VycmVudFBvc1ByaWNlUHJvdmlkZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3M7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lQXhpc1ZpZXdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZSA/IFt0aGlzLl9wcml2YXRlX190aW1lQXhpc1ZpZXddIDogW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZUFsbFZpZXdzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfcGFuZXMoKS5mb3JFYWNoKChwYW5lKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJQYW5lVmlld0NhY2hlLmdldChwYW5lKT8uX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc1BhbmVWaWV3Q2FjaGUuZ2V0KHBhbmUpPy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3cy5mb3JFYWNoKCh2YWx1ZSkgPT4gdmFsdWUuX2ludGVybmFsX3VwZGF0ZSgpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNWaWV3Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3ByaWNlU2NhbGVCeVBhbmUocGFuZSkge1xuICAgICAgICBpZiAocGFuZSAmJiAhcGFuZS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFuZS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RyeVRvVXBkYXRlVmlld3MoaW5kZXgsIHByaWNlLCBwYW5lKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190cnlUb1VwZGF0ZURhdGEoaW5kZXgsIHByaWNlLCBwYW5lKSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fdHJ5VG9VcGRhdGVEYXRhKG5ld0luZGV4LCBuZXdQcmljZSwgbmV3UGFuZSkge1xuICAgICAgICBjb25zdCBvbGRYID0gdGhpcy5fcHJpdmF0ZV9feDtcbiAgICAgICAgY29uc3Qgb2xkWSA9IHRoaXMuX3ByaXZhdGVfX3k7XG4gICAgICAgIGNvbnN0IG9sZFByaWNlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2U7XG4gICAgICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9faW5kZXg7XG4gICAgICAgIGNvbnN0IG9sZFBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZUJ5UGFuZShuZXdQYW5lKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kZXggPSBuZXdJbmRleDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9feCA9IGlzTmFOKG5ld0luZGV4KSA/IE5hTiA6IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaW5kZXhUb0Nvb3JkaW5hdGUobmV3SW5kZXgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lID0gbmV3UGFuZTtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHByaWNlU2NhbGUgIT09IG51bGwgPyBwcmljZVNjYWxlLl9pbnRlcm5hbF9maXJzdFZhbHVlKCkgOiBudWxsO1xuICAgICAgICBpZiAocHJpY2VTY2FsZSAhPT0gbnVsbCAmJiBmaXJzdFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZSA9IG5ld1ByaWNlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9feSA9IHByaWNlU2NhbGUuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKG5ld1ByaWNlLCBmaXJzdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlID0gTmFOO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9feSA9IE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG9sZFggIT09IHRoaXMuX3ByaXZhdGVfX3ggfHwgb2xkWSAhPT0gdGhpcy5fcHJpdmF0ZV9feSB8fCBvbGRJbmRleCAhPT0gdGhpcy5fcHJpdmF0ZV9faW5kZXggfHxcbiAgICAgICAgICAgIG9sZFByaWNlICE9PSB0aGlzLl9wcml2YXRlX19wcmljZSB8fCBvbGRQYW5lICE9PSB0aGlzLl9wcml2YXRlX19wYW5lKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3NldEluZGV4VG9MYXN0U2VyaWVzQmFySW5kZXgoKSB7XG4gICAgICAgIGNvbnN0IGxhc3RJbmRleGVzID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3Nlcmllc2VzKClcbiAgICAgICAgICAgIC5tYXAoKHMpID0+IHMuX2ludGVybmFsX2JhcnMoKS5faW50ZXJuYWxfbGFzdEluZGV4KCkpXG4gICAgICAgICAgICAuZmlsdGVyKG5vdE51bGwpO1xuICAgICAgICBjb25zdCBsYXN0QmFySW5kZXggPSAobGFzdEluZGV4ZXMubGVuZ3RoID09PSAwKSA/IG51bGwgOiBNYXRoLm1heCguLi5sYXN0SW5kZXhlcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGV4ID0gbGFzdEJhckluZGV4ICE9PSBudWxsID8gbGFzdEJhckluZGV4IDogTmFOO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY3JlYXRlUHJpY2VBeGlzVmlld09uRGVtYW5kKG1hcCwgcHJpY2VTY2FsZSwgdmFsdWVQcm92aWRlcikge1xuICAgICAgICBsZXQgdmlldyA9IG1hcC5nZXQocHJpY2VTY2FsZSk7XG4gICAgICAgIGlmICh2aWV3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZpZXcgPSBuZXcgQ3Jvc3NoYWlyUHJpY2VBeGlzVmlldyh0aGlzLCBwcmljZVNjYWxlLCB2YWx1ZVByb3ZpZGVyKTtcbiAgICAgICAgICAgIG1hcC5zZXQocHJpY2VTY2FsZSwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0RlZmF1bHRQcmljZVNjYWxlKHByaWNlU2NhbGVJZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgIHJldHVybiBwcmljZVNjYWxlSWQgPT09IFwibGVmdFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuTGVmdCAqLyB8fCBwcmljZVNjYWxlSWQgPT09IFwicmlnaHRcIiAvKiBEZWZhdWx0UHJpY2VTY2FsZUlkLlJpZ2h0ICovO1xufVxuXG5mdW5jdGlvbiBtZXJnZVBhbmVJbnZhbGlkYXRpb24oYmVmb3JlVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKGJlZm9yZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IE1hdGgubWF4KGJlZm9yZVZhbHVlLl9pbnRlcm5hbF9sZXZlbCwgbmV3VmFsdWUuX2ludGVybmFsX2xldmVsKTtcbiAgICBjb25zdCBhdXRvU2NhbGUgPSBiZWZvcmVWYWx1ZS5faW50ZXJuYWxfYXV0b1NjYWxlIHx8IG5ld1ZhbHVlLl9pbnRlcm5hbF9hdXRvU2NhbGU7XG4gICAgcmV0dXJuIHsgX2ludGVybmFsX2xldmVsOiBsZXZlbCwgX2ludGVybmFsX2F1dG9TY2FsZTogYXV0b1NjYWxlIH07XG59XG5jbGFzcyBJbnZhbGlkYXRlTWFzayB7XG4gICAgY29uc3RydWN0b3IoZ2xvYmFsTGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWRQYW5lcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlSW52YWxpZGF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19nbG9iYWxMZXZlbCA9IGdsb2JhbExldmVsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW52YWxpZGF0ZVBhbmUocGFuZUluZGV4LCBpbnZhbGlkYXRpb24pIHtcbiAgICAgICAgY29uc3QgcHJldlZhbHVlID0gdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWRQYW5lcy5nZXQocGFuZUluZGV4KTtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBtZXJnZVBhbmVJbnZhbGlkYXRpb24ocHJldlZhbHVlLCBpbnZhbGlkYXRpb24pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZFBhbmVzLnNldChwYW5lSW5kZXgsIG5ld1ZhbHVlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Z1bGxJbnZhbGlkYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19nbG9iYWxMZXZlbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2ludmFsaWRhdGVGb3JQYW5lKHBhbmVJbmRleCkge1xuICAgICAgICBjb25zdCBwYW5lSW52YWxpZGF0aW9uID0gdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWRQYW5lcy5nZXQocGFuZUluZGV4KTtcbiAgICAgICAgaWYgKHBhbmVJbnZhbGlkYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbGV2ZWw6IHRoaXMuX3ByaXZhdGVfX2dsb2JhbExldmVsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX2xldmVsOiBNYXRoLm1heCh0aGlzLl9wcml2YXRlX19nbG9iYWxMZXZlbCwgcGFuZUludmFsaWRhdGlvbi5faW50ZXJuYWxfbGV2ZWwpLFxuICAgICAgICAgICAgX2ludGVybmFsX2F1dG9TY2FsZTogcGFuZUludmFsaWRhdGlvbi5faW50ZXJuYWxfYXV0b1NjYWxlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0Rml0Q29udGVudCgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpO1xuICAgICAgICAvLyBtb2RpZmllcyBib3RoIGJhciBzcGFjaW5nIGFuZCByaWdodCBvZmZzZXRcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlSW52YWxpZGF0aW9ucyA9IFt7IF9pbnRlcm5hbF90eXBlOiAwIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuRml0Q29udGVudCAqLyB9XTtcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGx5UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpO1xuICAgICAgICAvLyBtb2RpZmllcyBib3RoIGJhciBzcGFjaW5nIGFuZCByaWdodCBvZmZzZXRcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlSW52YWxpZGF0aW9ucyA9IFt7IF9pbnRlcm5hbF90eXBlOiAxIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQXBwbHlSYW5nZSAqLywgX2ludGVybmFsX3ZhbHVlOiByYW5nZSB9XTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFRpbWVTY2FsZUFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVtb3ZlVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUludmFsaWRhdGlvbnMucHVzaCh7IF9pbnRlcm5hbF90eXBlOiA1IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQW5pbWF0aW9uICovLCBfaW50ZXJuYWxfdmFsdWU6IGFuaW1hdGlvbiB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0b3BUaW1lU2NhbGVBbmltYXRpb24oKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbW92ZVRpbWVTY2FsZUFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zLnB1c2goeyBfaW50ZXJuYWxfdHlwZTogNiAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLlN0b3BBbmltYXRpb24gKi8gfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZXNldFRpbWVTY2FsZSgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpO1xuICAgICAgICAvLyBtb2RpZmllcyBib3RoIGJhciBzcGFjaW5nIGFuZCByaWdodCBvZmZzZXRcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlSW52YWxpZGF0aW9ucyA9IFt7IF9pbnRlcm5hbF90eXBlOiA0IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuUmVzZXQgKi8gfV07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRCYXJTcGFjaW5nKGJhclNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zLnB1c2goeyBfaW50ZXJuYWxfdHlwZTogMiAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFwcGx5QmFyU3BhY2luZyAqLywgX2ludGVybmFsX3ZhbHVlOiBiYXJTcGFjaW5nIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3N0b3BUaW1lU2NhbGVBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlSW52YWxpZGF0aW9ucy5wdXNoKHsgX2ludGVybmFsX3R5cGU6IDMgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseVJpZ2h0T2Zmc2V0ICovLCBfaW50ZXJuYWxfdmFsdWU6IG9mZnNldCB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RpbWVTY2FsZUludmFsaWRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGVJbnZhbGlkYXRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCB0c0ludmFsaWRhdGlvbiBvZiBvdGhlci5fcHJpdmF0ZV9fdGltZVNjYWxlSW52YWxpZGF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXBwbHlUaW1lU2NhbGVJbnZhbGlkYXRpb24odHNJbnZhbGlkYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2dsb2JhbExldmVsID0gTWF0aC5tYXgodGhpcy5fcHJpdmF0ZV9fZ2xvYmFsTGV2ZWwsIG90aGVyLl9wcml2YXRlX19nbG9iYWxMZXZlbCk7XG4gICAgICAgIG90aGVyLl9wcml2YXRlX19pbnZhbGlkYXRlZFBhbmVzLmZvckVhY2goKGludmFsaWRhdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2ludmFsaWRhdGVQYW5lKGluZGV4LCBpbnZhbGlkYXRpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIF9pbnRlcm5hbF9saWdodCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkYXRlTWFzaygyIC8qIEludmFsaWRhdGlvbkxldmVsLkxpZ2h0ICovKTtcbiAgICB9XG4gICAgc3RhdGljIF9pbnRlcm5hbF9mdWxsKCkge1xuICAgICAgICByZXR1cm4gbmV3IEludmFsaWRhdGVNYXNrKDMgLyogSW52YWxpZGF0aW9uTGV2ZWwuRnVsbCAqLyk7XG4gICAgfVxuICAgIF9wcml2YXRlX19hcHBseVRpbWVTY2FsZUludmFsaWRhdGlvbihpbnZhbGlkYXRpb24pIHtcbiAgICAgICAgc3dpdGNoIChpbnZhbGlkYXRpb24uX2ludGVybmFsX3R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkZpdENvbnRlbnQgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0Rml0Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQXBwbHlSYW5nZSAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9hcHBseVJhbmdlKGludmFsaWRhdGlvbi5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQXBwbHlCYXJTcGFjaW5nICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldEJhclNwYWNpbmcoaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseVJpZ2h0T2Zmc2V0ICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KGludmFsaWRhdGlvbi5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuUmVzZXQgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVzZXRUaW1lU2NhbGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNSAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFuaW1hdGlvbiAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRUaW1lU2NhbGVBbmltYXRpb24oaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5TdG9wQW5pbWF0aW9uICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbW92ZVRpbWVTY2FsZUFuaW1hdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19yZW1vdmVUaW1lU2NhbGVBbmltYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlSW52YWxpZGF0aW9ucy5maW5kSW5kZXgoKGludikgPT4gaW52Ll9pbnRlcm5hbF90eXBlID09PSA1IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQW5pbWF0aW9uICovKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlSW52YWxpZGF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBmb3JtYXR0ZXJPcHRpb25zID0ge1xuICAgIF9pbnRlcm5hbF9kZWNpbWFsU2lnbjogJy4nfTtcbi8qKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciBvZiBjb252ZXJ0LlxuICogQHBhcmFtIGxlbmd0aCAtIFRoZSBsZW5ndGguIE11c3QgYmUgYmV0d2VlbiAwIGFuZCAxNiBpbmNsdXNpdmUuXG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ24vYSc7XG4gICAgfVxuICAgIGlmICghaXNJbnRlZ2VyKGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBsZW5ndGgnKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDAgfHwgbGVuZ3RoID4gMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBsZW5ndGgnKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgZHVtbXlTdHJpbmcgPSAnMDAwMDAwMDAwMDAwMDAwMCc7XG4gICAgcmV0dXJuIChkdW1teVN0cmluZyArIHZhbHVlLnRvU3RyaW5nKCkpLnNsaWNlKC1sZW5ndGgpO1xufVxuY2xhc3MgUHJpY2VGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaWNlU2NhbGUsIG1pbk1vdmUpIHtcbiAgICAgICAgaWYgKCFtaW5Nb3ZlKSB7XG4gICAgICAgICAgICBtaW5Nb3ZlID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTnVtYmVyKHByaWNlU2NhbGUpIHx8ICFpc0ludGVnZXIocHJpY2VTY2FsZSkpIHtcbiAgICAgICAgICAgIHByaWNlU2NhbGUgPSAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaWNlU2NhbGUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID0gcHJpY2VTY2FsZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWluTW92ZSA9IG1pbk1vdmU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbGN1bGF0ZURlY2ltYWwoKTtcbiAgICB9XG4gICAgZm9ybWF0KHByaWNlKSB7XG4gICAgICAgIC8vIFxcdTIyMTIgaXMgdW5pY29kZSdzIG1pbnVzIHNpZ24gaHR0cHM6Ly93d3cuZmlsZWZvcm1hdC5pbmZvL2luZm8vdW5pY29kZS9jaGFyLzIyMTIvaW5kZXguaHRtXG4gICAgICAgIC8vIHdlIHNob3VsZCB1c2UgaXQgYmVjYXVzZSBpdCBoYXMgdGhlIHNhbWUgd2lkdGggYXMgcGx1cyBzaWduICtcbiAgICAgICAgY29uc3Qgc2lnbiA9IHByaWNlIDwgMCA/ICdcXHUyMjEyJyA6ICcnO1xuICAgICAgICBwcmljZSA9IE1hdGguYWJzKHByaWNlKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gKyB0aGlzLl9wcml2YXRlX19mb3JtYXRBc0RlY2ltYWwocHJpY2UpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2FsY3VsYXRlRGVjaW1hbCgpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcy5fYmFzZSBpcyBwb3dlciBvZiAxMFxuICAgICAgICAvLyBmb3IgZG91YmxlIGZyYWN0aW9uYWwgX2ZyYWN0aW9uYWxMZW5ndGggaWYgZm9yIHRoZSBtYWluIGZyYWN0aW9uYWwgb25seVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZnJhY3Rpb25hbExlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID4gMCAmJiB0aGlzLl9wcml2YXRlX19taW5Nb3ZlID4gMCkge1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlO1xuICAgICAgICAgICAgd2hpbGUgKGJhc2UgPiAxKSB7XG4gICAgICAgICAgICAgICAgYmFzZSAvPSAxMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZnJhY3Rpb25hbExlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19mb3JtYXRBc0RlY2ltYWwocHJpY2UpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgLyB0aGlzLl9wcml2YXRlX19taW5Nb3ZlO1xuICAgICAgICBsZXQgaW50UGFydCA9IE1hdGguZmxvb3IocHJpY2UpO1xuICAgICAgICBsZXQgZnJhY1N0cmluZyA9ICcnO1xuICAgICAgICBjb25zdCBmcmFjTGVuZ3RoID0gdGhpcy5faW50ZXJuYWxfX2ZyYWN0aW9uYWxMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2ludGVybmFsX19mcmFjdGlvbmFsTGVuZ3RoIDogTmFOO1xuICAgICAgICBpZiAoYmFzZSA+IDEpIHtcbiAgICAgICAgICAgIGxldCBmcmFjUGFydCA9ICsoTWF0aC5yb3VuZChwcmljZSAqIGJhc2UpIC0gaW50UGFydCAqIGJhc2UpLnRvRml4ZWQodGhpcy5faW50ZXJuYWxfX2ZyYWN0aW9uYWxMZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGZyYWNQYXJ0ID49IGJhc2UpIHtcbiAgICAgICAgICAgICAgICBmcmFjUGFydCAtPSBiYXNlO1xuICAgICAgICAgICAgICAgIGludFBhcnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYWNTdHJpbmcgPSBmb3JtYXR0ZXJPcHRpb25zLl9pbnRlcm5hbF9kZWNpbWFsU2lnbiArIG51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvKCtmcmFjUGFydC50b0ZpeGVkKHRoaXMuX2ludGVybmFsX19mcmFjdGlvbmFsTGVuZ3RoKSAqIHRoaXMuX3ByaXZhdGVfX21pbk1vdmUsIGZyYWNMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2hvdWxkIHJvdW5kIGludCBwYXJ0IHRvIG1pbiBtb3ZlXG4gICAgICAgICAgICBpbnRQYXJ0ID0gTWF0aC5yb3VuZChpbnRQYXJ0ICogYmFzZSkgLyBiYXNlO1xuICAgICAgICAgICAgLy8gaWYgbWluIG1vdmUgPiAxLCBmcmFjdGlvbmFsIHBhcnQgaXMgYWx3YXlzID0gMFxuICAgICAgICAgICAgaWYgKGZyYWNMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZnJhY1N0cmluZyA9IGZvcm1hdHRlck9wdGlvbnMuX2ludGVybmFsX2RlY2ltYWxTaWduICsgbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8oMCwgZnJhY0xlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludFBhcnQudG9GaXhlZCgwKSArIGZyYWNTdHJpbmc7XG4gICAgfVxufVxuXG5jbGFzcyBQZXJjZW50YWdlRm9ybWF0dGVyIGV4dGVuZHMgUHJpY2VGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaWNlU2NhbGUgPSAxMDApIHtcbiAgICAgICAgc3VwZXIocHJpY2VTY2FsZSk7XG4gICAgfVxuICAgIGZvcm1hdChwcmljZSkge1xuICAgICAgICByZXR1cm4gYCR7c3VwZXIuZm9ybWF0KHByaWNlKX0lYDtcbiAgICB9XG59XG5cbmNsYXNzIFZvbHVtZUZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IocHJlY2lzaW9uKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICB9XG4gICAgZm9ybWF0KHZvbCkge1xuICAgICAgICBsZXQgc2lnbiA9ICcnO1xuICAgICAgICBpZiAodm9sIDwgMCkge1xuICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIHZvbCA9IC12b2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZvbCA8IDk5NSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB0aGlzLl9wcml2YXRlX19mb3JtYXROdW1iZXIodm9sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2b2wgPCA5OTk5OTUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWduICsgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0TnVtYmVyKHZvbCAvIDEwMDApICsgJ0snO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZvbCA8IDk5OTk5OTk5NSkge1xuICAgICAgICAgICAgdm9sID0gMTAwMCAqIE1hdGgucm91bmQodm9sIC8gMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdE51bWJlcih2b2wgLyAxMDAwMDAwKSArICdNJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZvbCA9IDEwMDAwMDAgKiBNYXRoLnJvdW5kKHZvbCAvIDEwMDAwMDApO1xuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB0aGlzLl9wcml2YXRlX19mb3JtYXROdW1iZXIodm9sIC8gMTAwMDAwMDAwMCkgKyAnQic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdE51bWJlcih2YWx1ZSkge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gTWF0aC5wb3coMTAsIHRoaXMuX3ByaXZhdGVfX3ByZWNpc2lvbik7XG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIHByaWNlU2NhbGUpIC8gcHJpY2VTY2FsZTtcbiAgICAgICAgaWYgKHZhbHVlID49IDFlLTE1ICYmIHZhbHVlIDwgMSkge1xuICAgICAgICAgICAgcmVzID0gdmFsdWUudG9GaXhlZCh0aGlzLl9wcml2YXRlX19wcmVjaXNpb24pLnJlcGxhY2UoL1xcLj8wKyQvLCAnJyk7IC8vIHJlZ2V4IHJlbW92ZXMgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMucmVwbGFjZSgvKFxcLlsxLTldKikwKyQvLCAoZSwgcDEpID0+IHAxKTtcbiAgICB9XG59XG5cbmNvbnN0IGRlZmF1bHRSZXBsYWNlbWVudFJlID0gL1syLTldL2c7XG5jbGFzcyBUZXh0V2lkdGhDYWNoZSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSA9IDUwKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191c2FnZVRpY2sgPSAxO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbGRlc3RUaWNrID0gMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHMgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21heFNpemUgPSBzaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191c2FnZVRpY2sgPSAxO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbGRlc3RUaWNrID0gMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHMgPSB7fTtcbiAgICB9XG4gICAgX2ludGVybmFsX21lYXN1cmVUZXh0KGN0eCwgdGV4dCwgb3B0aW1pemF0aW9uUmVwbGFjZW1lbnRSZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZ2V0TWV0cmljcyhjdHgsIHRleHQsIG9wdGltaXphdGlvblJlcGxhY2VtZW50UmUpLndpZHRoO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfeU1pZENvcnJlY3Rpb24oY3R4LCB0ZXh0LCBvcHRpbWl6YXRpb25SZXBsYWNlbWVudFJlKSB7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSB0aGlzLl9wcml2YXRlX19nZXRNZXRyaWNzKGN0eCwgdGV4dCwgb3B0aW1pemF0aW9uUmVwbGFjZW1lbnRSZSk7XG4gICAgICAgIC8vIGlmIGFjdHVhbEJvdW5kaW5nQm94QXNjZW50L2FjdHVhbEJvdW5kaW5nQm94RGVzY2VudCBhcmUgbm90IHN1cHBvcnRlZCB3ZSB1c2UgMCBhcyBhIGZhbGxiYWNrXG4gICAgICAgIHJldHVybiAoKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgfHwgMCkgLSAobWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQgfHwgMCkpIC8gMjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldE1ldHJpY3MoY3R4LCB0ZXh0LCBvcHRpbWl6YXRpb25SZXBsYWNlbWVudFJlKSB7XG4gICAgICAgIGNvbnN0IHJlID0gb3B0aW1pemF0aW9uUmVwbGFjZW1lbnRSZSB8fCBkZWZhdWx0UmVwbGFjZW1lbnRSZTtcbiAgICAgICAgY29uc3QgY2FjaGVTdHJpbmcgPSBTdHJpbmcodGV4dCkucmVwbGFjZShyZSwgJzAnKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NhY2hlLmhhcyhjYWNoZVN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX2NhY2hlLmdldChjYWNoZVN0cmluZykpLl9pbnRlcm5hbF9tZXRyaWNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19hY3R1YWxTaXplID09PSB0aGlzLl9wcml2YXRlX19tYXhTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRlc3RWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3RpY2syTGFiZWxzW3RoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2tdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ByaXZhdGVfX3RpY2syTGFiZWxzW3RoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2tdO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUuZGVsZXRlKG9sZGVzdFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2srKztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdHVhbFNpemUtLTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQoY2FjaGVTdHJpbmcpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBpZiAobWV0cmljcy53aWR0aCA9PT0gMCAmJiAhIXRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBtZWFzdXJlVGV4dCBjYW4gcmV0dXJuIDAgaW4gRkYgZGVwZW5kaW5nIG9uIGEgY2FudmFzIHNpemUsIGRvbid0IGNhY2hlIGl0XG4gICAgICAgICAgICByZXR1cm4gbWV0cmljcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZS5zZXQoY2FjaGVTdHJpbmcsIHsgX2ludGVybmFsX21ldHJpY3M6IG1ldHJpY3MsIF9pbnRlcm5hbF90aWNrOiB0aGlzLl9wcml2YXRlX191c2FnZVRpY2sgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpY2syTGFiZWxzW3RoaXMuX3ByaXZhdGVfX3VzYWdlVGlja10gPSBjYWNoZVN0cmluZztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWN0dWFsU2l6ZSsrO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191c2FnZVRpY2srKztcbiAgICAgICAgcmV0dXJuIG1ldHJpY3M7XG4gICAgfVxufVxuXG5jbGFzcyBQYW5lUHJpY2VBeGlzVmlld1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0V2lkdGhDYWNoZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3UmVuZGVyZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlID0gdGV4dFdpZHRoQ2FjaGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQYXJhbXMocHJpY2VBeGlzVmlld1JlbmRlcmVyLCByZW5kZXJlck9wdGlvbnMsIGFsaWduKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdSZW5kZXJlciA9IHByaWNlQXhpc1ZpZXdSZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zID0gcmVuZGVyZXJPcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hbGlnbiA9IGFsaWduO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhdyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucyA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3UmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3UmVuZGVyZXIuX2ludGVybmFsX2RyYXcodGFyZ2V0LCB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMsIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlLCB0aGlzLl9wcml2YXRlX19hbGlnbik7XG4gICAgfVxufVxuY2xhc3MgUGFuZVByaWNlQXhpc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHByaWNlQXhpc1ZpZXcsIGRhdGFTb3VyY2UsIGNoYXJ0TW9kZWwpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlldyA9IHByaWNlQXhpc1ZpZXc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RleHRXaWR0aENhY2hlID0gbmV3IFRleHRXaWR0aENhY2hlKDUwKTsgLy8gd2hlbiBzaG91bGQgd2UgY2xlYXIgY2FjaGU/XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydE1vZGVsID0gY2hhcnRNb2RlbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9udFNpemUgPSAtMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIgPSBuZXcgUGFuZVByaWNlQXhpc1ZpZXdSZW5kZXJlcih0aGlzLl9wcml2YXRlX190ZXh0V2lkdGhDYWNoZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0TW9kZWwuX2ludGVybmFsX3BhbmVGb3JTb3VyY2UodGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZSk7XG4gICAgICAgIGlmIChwYW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIHByaWNlIHNjYWxlIHdpbGwgYmUgdXNlZCB0byBmaW5kIGxhYmVsIHBsYWNlbWVudCBvbmx5IChsZWZ0LCByaWdodCwgbm9uZSlcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHBhbmUuX2ludGVybmFsX2lzT3ZlcmxheSh0aGlzLl9wcml2YXRlX19kYXRhU291cmNlKSA/IHBhbmUuX2ludGVybmFsX2RlZmF1bHRWaXNpYmxlUHJpY2VTY2FsZSgpIDogdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwYW5lLl9pbnRlcm5hbF9wcmljZVNjYWxlUG9zaXRpb24ocHJpY2VTY2FsZSk7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ292ZXJsYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRNb2RlbC5faW50ZXJuYWxfcHJpY2VBeGlzUmVuZGVyZXJPcHRpb25zKCk7XG4gICAgICAgIGlmIChvcHRpb25zLl9pbnRlcm5hbF9mb250U2l6ZSAhPT0gdGhpcy5fcHJpdmF0ZV9fZm9udFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnRTaXplID0gb3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190ZXh0V2lkdGhDYWNoZS5faW50ZXJuYWxfcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlci5faW50ZXJuYWxfc2V0UGFyYW1zKHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXcuX2ludGVybmFsX3BhbmVSZW5kZXJlcigpLCBvcHRpb25zLCBwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlcjtcbiAgICB9XG59XG5cbmNsYXNzIEhvcml6b250YWxMaW5lUmVuZGVyZXIgZXh0ZW5kcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaGl0VGVzdCh4LCB5KSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fZGF0YT8uX2ludGVybmFsX3Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgX2ludGVybmFsX3k6IGl0ZW1ZLCBfaW50ZXJuYWxfbGluZVdpZHRoOiBsaW5lV2lkdGgsIF9pbnRlcm5hbF9leHRlcm5hbElkOiBleHRlcm5hbElkIH0gPSB0aGlzLl9wcml2YXRlX19kYXRhO1xuICAgICAgICAvLyBhZGQgYSBmaXhlZCBhcmVhIHRocmVzaG9sZCBhcm91bmQgbGluZSAoWSArIHdpZHRoKSBmb3IgaGl0IHRlc3RcbiAgICAgICAgaWYgKHkgPj0gaXRlbVkgLSBsaW5lV2lkdGggLSA3IC8qIENvbnN0YW50cy5IaXRUZXN0VGhyZXNob2xkICovICYmIHkgPD0gaXRlbVkgKyBsaW5lV2lkdGggKyA3IC8qIENvbnN0YW50cy5IaXRUZXN0VGhyZXNob2xkICovKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9oaXRUZXN0RGF0YTogdGhpcy5fcHJpdmF0ZV9fZGF0YSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfZXh0ZXJuYWxJZDogZXh0ZXJuYWxJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICBpZiAoeSA8IDAgfHwgeSA+IGJpdG1hcFNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2NvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5mbG9vcih0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9saW5lV2lkdGggKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgIHNldExpbmVTdHlsZShjdHgsIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2xpbmVTdHlsZSk7XG4gICAgICAgIGRyYXdIb3Jpem9udGFsTGluZShjdHgsIHksIDAsIGJpdG1hcFNpemUud2lkdGgpO1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzSG9yaXpvbnRhbExpbmVQYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3k6IDAsXG4gICAgICAgICAgICBfaW50ZXJuYWxfY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDApJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IDEsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVN0eWxlOiAwIC8qIExpbmVTdHlsZS5Tb2xpZCAqLyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlciA9IG5ldyBIb3Jpem9udGFsTGluZVJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3NlcmllcyA9IHNlcmllcztcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX21vZGVsID0gc2VyaWVzLl9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfdmlzaWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX191cGRhdGVJbXBsKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyO1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzSG9yaXpvbnRhbEJhc2VMaW5lUGFuZVZpZXcgZXh0ZW5kcyBTZXJpZXNIb3Jpem9udGFsTGluZVBhbmVWaWV3IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jb25zdHJ1Y3RvclxuICAgIGNvbnN0cnVjdG9yKHNlcmllcykge1xuICAgICAgICBzdXBlcihzZXJpZXMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3VwZGF0ZUltcGwoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBwcmljZVNjYWxlLl9pbnRlcm5hbF9tb2RlKCkuX2ludGVybmFsX21vZGU7XG4gICAgICAgIGlmIChtb2RlICE9PSAyIC8qIFByaWNlU2NhbGVNb2RlLlBlcmNlbnRhZ2UgKi8gJiYgbW9kZSAhPT0gMyAvKiBQcmljZVNjYWxlTW9kZS5JbmRleGVkVG8xMDAgKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpZXNPcHRpb25zID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBpZiAoIXNlcmllc09wdGlvbnMuYmFzZUxpbmVWaXNpYmxlIHx8ICF0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3kgPSBwcmljZVNjYWxlLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbGluZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfY29sb3IgPSBzZXJpZXNPcHRpb25zLmJhc2VMaW5lQ29sb3I7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9saW5lV2lkdGggPSBzZXJpZXNPcHRpb25zLmJhc2VMaW5lV2lkdGg7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19saW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9saW5lU3R5bGUgPSBzZXJpZXNPcHRpb25zLmJhc2VMaW5lU3R5bGU7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNMYXN0UHJpY2VBbmltYXRpb25SZW5kZXJlciBleHRlbmRzIEJpdG1hcENvb3JkaW5hdGVzUGFuZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX19kcmF3SW1wbCh7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9wcml2YXRlX19kYXRhO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICAgICAgY29uc3QgY29ycmVjdGlvbiA9ICh0aWNrV2lkdGggJSAyKSAvIDI7XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBNYXRoLnJvdW5kKGRhdGEuX2ludGVybmFsX2NlbnRlci54ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pICsgY29ycmVjdGlvbjsgLy8gY29ycmVjdCB4IGNvb3JkaW5hdGUgb25seVxuICAgICAgICBjb25zdCBjZW50ZXJZID0gZGF0YS5faW50ZXJuYWxfY2VudGVyLnkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW87XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXRhLl9pbnRlcm5hbF9zZXJpZXNMaW5lQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgLy8gVE9ETzogaXQgaXMgYmV0dGVyIHRvIGhhdmUgZGlmZmVyZW50IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHJhZGlpXG4gICAgICAgIGNvbnN0IGNlbnRlclBvaW50UmFkaXVzID0gTWF0aC5tYXgoMiwgZGF0YS5faW50ZXJuYWxfc2VyaWVzTGluZVdpZHRoICogMS41KSAqIGhvcml6b250YWxQaXhlbFJhdGlvO1xuICAgICAgICBjdHguYXJjKGNlbnRlclgsIGNlbnRlclksIGNlbnRlclBvaW50UmFkaXVzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gZGF0YS5faW50ZXJuYWxfZmlsbENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmMoY2VudGVyWCwgY2VudGVyWSwgZGF0YS5faW50ZXJuYWxfcmFkaXVzICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aWNrV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGRhdGEuX2ludGVybmFsX3N0cm9rZUNvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmMoY2VudGVyWCwgY2VudGVyWSwgZGF0YS5faW50ZXJuYWxfcmFkaXVzICogaG9yaXpvbnRhbFBpeGVsUmF0aW8gKyB0aWNrV2lkdGggLyAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufVxuXG5jb25zdCBhbmltYXRpb25TdGFnZXNEYXRhID0gW1xuICAgIHtcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0OiAwLFxuICAgICAgICBfaW50ZXJuYWxfZW5kOiAwLjI1IC8qIENvbnN0YW50cy5TdGFnZTFQZXJpb2QgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9zdGFydFJhZGl1czogNCAvKiBDb25zdGFudHMuU3RhZ2UxU3RhcnRDaXJjbGVSYWRpdXMgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9lbmRSYWRpdXM6IDEwIC8qIENvbnN0YW50cy5TdGFnZTFFbmRDaXJjbGVSYWRpdXMgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9zdGFydEZpbGxBbHBoYTogMC4yNSAvKiBDb25zdGFudHMuU3RhZ2UxU3RhcnRGaWxsQWxwaGEgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9lbmRGaWxsQWxwaGE6IDAgLyogQ29uc3RhbnRzLlN0YWdlMUVuZEZpbGxBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0U3Ryb2tlQWxwaGE6IDAuNCAvKiBDb25zdGFudHMuU3RhZ2UxU3RhcnRTdHJva2VBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZFN0cm9rZUFscGhhOiAwLjggLyogQ29uc3RhbnRzLlN0YWdlMUVuZFN0cm9rZUFscGhhICovLFxuICAgIH0sXG4gICAge1xuICAgICAgICBfaW50ZXJuYWxfc3RhcnQ6IDAuMjUgLyogQ29uc3RhbnRzLlN0YWdlMVBlcmlvZCAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZDogMC4yNSAvKiBDb25zdGFudHMuU3RhZ2UxUGVyaW9kICovICsgMC4yNzUgLyogQ29uc3RhbnRzLlN0YWdlMlBlcmlvZCAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0UmFkaXVzOiAxMCAvKiBDb25zdGFudHMuU3RhZ2UyU3RhcnRDaXJjbGVSYWRpdXMgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9lbmRSYWRpdXM6IDE0IC8qIENvbnN0YW50cy5TdGFnZTJFbmRDaXJjbGVSYWRpdXMgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9zdGFydEZpbGxBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UyU3RhcnRGaWxsQWxwaGEgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9lbmRGaWxsQWxwaGE6IDAgLyogQ29uc3RhbnRzLlN0YWdlMkVuZEZpbGxBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0U3Ryb2tlQWxwaGE6IDAuOCAvKiBDb25zdGFudHMuU3RhZ2UyU3RhcnRTdHJva2VBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX2VuZFN0cm9rZUFscGhhOiAwIC8qIENvbnN0YW50cy5TdGFnZTJFbmRTdHJva2VBbHBoYSAqLyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0OiAwLjI1IC8qIENvbnN0YW50cy5TdGFnZTFQZXJpb2QgKi8gKyAwLjI3NSAvKiBDb25zdGFudHMuU3RhZ2UyUGVyaW9kICovLFxuICAgICAgICBfaW50ZXJuYWxfZW5kOiAwLjI1IC8qIENvbnN0YW50cy5TdGFnZTFQZXJpb2QgKi8gKyAwLjI3NSAvKiBDb25zdGFudHMuU3RhZ2UyUGVyaW9kICovICsgMC40NzUgLyogQ29uc3RhbnRzLlN0YWdlM1BlcmlvZCAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0UmFkaXVzOiAxNCAvKiBDb25zdGFudHMuU3RhZ2UzU3RhcnRDaXJjbGVSYWRpdXMgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9lbmRSYWRpdXM6IDE0IC8qIENvbnN0YW50cy5TdGFnZTNFbmRDaXJjbGVSYWRpdXMgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9zdGFydEZpbGxBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UzU3RhcnRGaWxsQWxwaGEgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9lbmRGaWxsQWxwaGE6IDAgLyogQ29uc3RhbnRzLlN0YWdlM0VuZEZpbGxBbHBoYSAqLyxcbiAgICAgICAgX2ludGVybmFsX3N0YXJ0U3Ryb2tlQWxwaGE6IDAgLyogQ29uc3RhbnRzLlN0YWdlM1N0YXJ0U3Ryb2tlQWxwaGEgKi8sXG4gICAgICAgIF9pbnRlcm5hbF9lbmRTdHJva2VBbHBoYTogMCAvKiBDb25zdGFudHMuU3RhZ2UzRW5kU3Ryb2tlQWxwaGEgKi8sXG4gICAgfSxcbl07XG5mdW5jdGlvbiByYWRpdXMoc3RhZ2UsIHN0YXJ0UmFkaXVzLCBlbmRSYWRpdXMpIHtcbiAgICByZXR1cm4gc3RhcnRSYWRpdXMgKyAoZW5kUmFkaXVzIC0gc3RhcnRSYWRpdXMpICogc3RhZ2U7XG59XG5jbGFzcyBTZXJpZXNMYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyID0gbmV3IFNlcmllc0xhc3RQcmljZUFuaW1hdGlvblJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbmRUaW1lID0gdGhpcy5fcHJpdmF0ZV9fc3RhcnRUaW1lIC0gMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gc2VyaWVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb25EYXRhQ2xlYXJlZCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZW5kVGltZSA9IHRoaXMuX3ByaXZhdGVfX3N0YXJ0VGltZSAtIDE7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb25OZXdSZWFsdGltZURhdGFSZWNlaXZlZCgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKS5sYXN0UHJpY2VBbmltYXRpb24gPT09IDIgLyogTGFzdFByaWNlQW5pbWF0aW9uTW9kZS5PbkRhdGFVcGRhdGUgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgdGltZVRvQW5pbWF0aW9uRW5kID0gdGhpcy5fcHJpdmF0ZV9fZW5kVGltZSAtIG5vdztcbiAgICAgICAgICAgIGlmICh0aW1lVG9BbmltYXRpb25FbmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVUb0FuaW1hdGlvbkVuZCA8IDI2MDAgLyogQ29uc3RhbnRzLkFuaW1hdGlvblBlcmlvZCAqLyAvIDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZW5kVGltZSArPSAyNjAwIC8qIENvbnN0YW50cy5BbmltYXRpb25QZXJpb2QgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2VuZFRpbWUgPSBub3cgKyAyNjAwIC8qIENvbnN0YW50cy5BbmltYXRpb25QZXJpb2QgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW52YWxpZGF0ZVN0YWdlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFnZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Zpc2libGUoKSB7XG4gICAgICAgIC8vIGNlbnRlciBwb2ludCBpcyBhbHdheXMgdmlzaWJsZSBpZiBsYXN0UHJpY2VBbmltYXRpb24gaXMgbm90IExhc3RQcmljZUFuaW1hdGlvbk1vZGUuRGlzYWJsZWRcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpLmxhc3RQcmljZUFuaW1hdGlvbiAhPT0gMCAvKiBMYXN0UHJpY2VBbmltYXRpb25Nb2RlLkRpc2FibGVkICovO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYW5pbWF0aW9uQWN0aXZlKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpLmxhc3RQcmljZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuRGlzYWJsZWQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAxIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuQ29udGludW91cyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBMYXN0UHJpY2VBbmltYXRpb25Nb2RlLk9uRGF0YVVwZGF0ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCkgPD0gdGhpcy5fcHJpdmF0ZV9fZW5kVGltZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVuZGVyZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlSW1wbCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YWdlSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9wcml2YXRlX19zdGFnZUludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVSZW5kZXJlckRhdGFTdGFnZSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhZ2VJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yZW5kZXJlcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZUltcGwoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKG51bGwpO1xuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBjb25zdCB2aXNpYmxlUmFuZ2UgPSB0aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpO1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmICh2aXNpYmxlUmFuZ2UgPT09IG51bGwgfHwgZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfbGFzdFZhbHVlRGF0YSh0cnVlKTtcbiAgICAgICAgaWYgKGxhc3RWYWx1ZS5faW50ZXJuYWxfbm9EYXRhIHx8ICF2aXNpYmxlUmFuZ2UuX2ludGVybmFsX2NvbnRhaW5zKGxhc3RWYWx1ZS5faW50ZXJuYWxfaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdFZhbHVlUG9pbnQgPSB7XG4gICAgICAgICAgICB4OiB0aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKGxhc3RWYWx1ZS5faW50ZXJuYWxfaW5kZXgpLFxuICAgICAgICAgICAgeTogdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKGxhc3RWYWx1ZS5faW50ZXJuYWxfcHJpY2UsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2VyaWVzTGluZUNvbG9yID0gbGFzdFZhbHVlLl9pbnRlcm5hbF9jb2xvcjtcbiAgICAgICAgY29uc3Qgc2VyaWVzTGluZVdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCkubGluZVdpZHRoO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fcHJpdmF0ZV9fYW5pbWF0aW9uRGF0YSh0aGlzLl9wcml2YXRlX19kdXJhdGlvbigpLCBzZXJpZXNMaW5lQ29sb3IpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh7XG4gICAgICAgICAgICBfaW50ZXJuYWxfc2VyaWVzTGluZUNvbG9yOiBzZXJpZXNMaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfc2VyaWVzTGluZVdpZHRoOiBzZXJpZXNMaW5lV2lkdGgsXG4gICAgICAgICAgICBfaW50ZXJuYWxfZmlsbENvbG9yOiBkYXRhLl9pbnRlcm5hbF9maWxsQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfc3Ryb2tlQ29sb3I6IGRhdGEuX2ludGVybmFsX3N0cm9rZUNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX3JhZGl1czogZGF0YS5faW50ZXJuYWxfcmFkaXVzLFxuICAgICAgICAgICAgX2ludGVybmFsX2NlbnRlcjogbGFzdFZhbHVlUG9pbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlUmVuZGVyZXJEYXRhU3RhZ2UoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyRGF0YSA9IHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyLl9pbnRlcm5hbF9kYXRhKCk7XG4gICAgICAgIGlmIChyZW5kZXJlckRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9wcml2YXRlX19hbmltYXRpb25EYXRhKHRoaXMuX3ByaXZhdGVfX2R1cmF0aW9uKCksIHJlbmRlcmVyRGF0YS5faW50ZXJuYWxfc2VyaWVzTGluZUNvbG9yKTtcbiAgICAgICAgICAgIHJlbmRlcmVyRGF0YS5faW50ZXJuYWxfZmlsbENvbG9yID0gZGF0YS5faW50ZXJuYWxfZmlsbENvbG9yO1xuICAgICAgICAgICAgcmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9zdHJva2VDb2xvciA9IGRhdGEuX2ludGVybmFsX3N0cm9rZUNvbG9yO1xuICAgICAgICAgICAgcmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9yYWRpdXMgPSBkYXRhLl9pbnRlcm5hbF9yYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfYW5pbWF0aW9uQWN0aXZlKCkgPyBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VGltZSA6IDI2MDAgLyogQ29uc3RhbnRzLkFuaW1hdGlvblBlcmlvZCAqLyAtIDE7XG4gICAgfVxuICAgIF9wcml2YXRlX19jb2xvcihzZXJpZXNMaW5lQ29sb3IsIHN0YWdlLCBzdGFydEFscGhhLCBlbmRBbHBoYSkge1xuICAgICAgICBjb25zdCBhbHBoYSA9IHN0YXJ0QWxwaGEgKyAoZW5kQWxwaGEgLSBzdGFydEFscGhhKSAqIHN0YWdlO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9jb2xvclBhcnNlcigpLl9pbnRlcm5hbF9hcHBseUFscGhhKHNlcmllc0xpbmVDb2xvciwgYWxwaGEpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYW5pbWF0aW9uRGF0YShkdXJhdGlvblNpbmNlU3RhcnQsIGxpbmVDb2xvcikge1xuICAgICAgICBjb25zdCBnbG9iYWxTdGFnZSA9IChkdXJhdGlvblNpbmNlU3RhcnQgJSAyNjAwIC8qIENvbnN0YW50cy5BbmltYXRpb25QZXJpb2QgKi8pIC8gMjYwMCAvKiBDb25zdGFudHMuQW5pbWF0aW9uUGVyaW9kICovO1xuICAgICAgICBsZXQgY3VycmVudFN0YWdlRGF0YTtcbiAgICAgICAgZm9yIChjb25zdCBzdGFnZURhdGEgb2YgYW5pbWF0aW9uU3RhZ2VzRGF0YSkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbFN0YWdlID49IHN0YWdlRGF0YS5faW50ZXJuYWxfc3RhcnQgJiYgZ2xvYmFsU3RhZ2UgPD0gc3RhZ2VEYXRhLl9pbnRlcm5hbF9lbmQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhZ2VEYXRhID0gc3RhZ2VEYXRhO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydChjdXJyZW50U3RhZ2VEYXRhICE9PSB1bmRlZmluZWQsICdMYXN0IHByaWNlIGFuaW1hdGlvbiBpbnRlcm5hbCBsb2dpYyBlcnJvcicpO1xuICAgICAgICBjb25zdCBzdWJTdGFnZSA9IChnbG9iYWxTdGFnZSAtIGN1cnJlbnRTdGFnZURhdGEuX2ludGVybmFsX3N0YXJ0KSAvIChjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9lbmQgLSBjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9zdGFydCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfZmlsbENvbG9yOiB0aGlzLl9wcml2YXRlX19jb2xvcihsaW5lQ29sb3IsIHN1YlN0YWdlLCBjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9zdGFydEZpbGxBbHBoYSwgY3VycmVudFN0YWdlRGF0YS5faW50ZXJuYWxfZW5kRmlsbEFscGhhKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zdHJva2VDb2xvcjogdGhpcy5fcHJpdmF0ZV9fY29sb3IobGluZUNvbG9yLCBzdWJTdGFnZSwgY3VycmVudFN0YWdlRGF0YS5faW50ZXJuYWxfc3RhcnRTdHJva2VBbHBoYSwgY3VycmVudFN0YWdlRGF0YS5faW50ZXJuYWxfZW5kU3Ryb2tlQWxwaGEpLFxuICAgICAgICAgICAgX2ludGVybmFsX3JhZGl1czogcmFkaXVzKHN1YlN0YWdlLCBjdXJyZW50U3RhZ2VEYXRhLl9pbnRlcm5hbF9zdGFydFJhZGl1cywgY3VycmVudFN0YWdlRGF0YS5faW50ZXJuYWxfZW5kUmFkaXVzKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc1ByaWNlTGluZVBhbmVWaWV3IGV4dGVuZHMgU2VyaWVzSG9yaXpvbnRhbExpbmVQYW5lVmlldyB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMpIHtcbiAgICAgICAgc3VwZXIoc2VyaWVzKTtcbiAgICB9XG4gICAgX2ludGVybmFsX191cGRhdGVJbXBsKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGE7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc2VyaWVzT3B0aW9ucyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgaWYgKCFzZXJpZXNPcHRpb25zLnByaWNlTGluZVZpc2libGUgfHwgIXRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RWYWx1ZURhdGEgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9sYXN0VmFsdWVEYXRhKHNlcmllc09wdGlvbnMucHJpY2VMaW5lU291cmNlID09PSAwIC8qIFByaWNlTGluZVNvdXJjZS5MYXN0QmFyICovKTtcbiAgICAgICAgaWYgKGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX25vRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF95ID0gbGFzdFZhbHVlRGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfY29sb3IgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZUxpbmVDb2xvcihsYXN0VmFsdWVEYXRhLl9pbnRlcm5hbF9jb2xvcik7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2xpbmVXaWR0aCA9IHNlcmllc09wdGlvbnMucHJpY2VMaW5lV2lkdGg7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2xpbmVTdHlsZSA9IHNlcmllc09wdGlvbnMucHJpY2VMaW5lU3R5bGU7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNQcmljZUF4aXNWaWV3IGV4dGVuZHMgUHJpY2VBeGlzVmlldyB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgX2ludGVybmFsX191cGRhdGVSZW5kZXJlckRhdGEoYXhpc1JlbmRlcmVyRGF0YSwgcGFuZVJlbmRlcmVyRGF0YSwgY29tbW9uUmVuZGVyZXJEYXRhKSB7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLl9wcml2YXRlX19zb3VyY2U7XG4gICAgICAgIGlmICghc291cmNlLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpZXNPcHRpb25zID0gc291cmNlLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IHNob3dTZXJpZXNMYXN0VmFsdWUgPSBzZXJpZXNPcHRpb25zLmxhc3RWYWx1ZVZpc2libGU7XG4gICAgICAgIGNvbnN0IHNob3dTeW1ib2xMYWJlbCA9IHNvdXJjZS5faW50ZXJuYWxfdGl0bGUoKSAhPT0gJyc7XG4gICAgICAgIGNvbnN0IHNob3dQcmljZUFuZFBlcmNlbnRhZ2UgPSBzZXJpZXNPcHRpb25zLnNlcmllc0xhc3RWYWx1ZU1vZGUgPT09IDAgLyogUHJpY2VBeGlzTGFzdFZhbHVlTW9kZS5MYXN0UHJpY2VBbmRQZXJjZW50YWdlVmFsdWUgKi87XG4gICAgICAgIGNvbnN0IGxhc3RWYWx1ZURhdGEgPSBzb3VyY2UuX2ludGVybmFsX2xhc3RWYWx1ZURhdGEoZmFsc2UpO1xuICAgICAgICBpZiAobGFzdFZhbHVlRGF0YS5faW50ZXJuYWxfbm9EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3dTZXJpZXNMYXN0VmFsdWUpIHtcbiAgICAgICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3RleHQgPSB0aGlzLl9pbnRlcm5hbF9fYXhpc1RleHQobGFzdFZhbHVlRGF0YSwgc2hvd1Nlcmllc0xhc3RWYWx1ZSwgc2hvd1ByaWNlQW5kUGVyY2VudGFnZSk7XG4gICAgICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGV4dC5sZW5ndGggIT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3dTeW1ib2xMYWJlbCB8fCBzaG93UHJpY2VBbmRQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90ZXh0ID0gdGhpcy5faW50ZXJuYWxfX3BhbmVUZXh0KGxhc3RWYWx1ZURhdGEsIHNob3dTZXJpZXNMYXN0VmFsdWUsIHNob3dTeW1ib2xMYWJlbCwgc2hvd1ByaWNlQW5kUGVyY2VudGFnZSk7XG4gICAgICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGV4dC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RWYWx1ZUNvbG9yID0gc291cmNlLl9pbnRlcm5hbF9wcmljZUxpbmVDb2xvcihsYXN0VmFsdWVEYXRhLl9pbnRlcm5hbF9jb2xvcik7XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfY29sb3JQYXJzZXIoKS5faW50ZXJuYWxfZ2VuZXJhdGVDb250cmFzdENvbG9ycyhsYXN0VmFsdWVDb2xvcik7XG4gICAgICAgIGNvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfYmFja2dyb3VuZCA9IGNvbG9ycy5faW50ZXJuYWxfYmFja2dyb3VuZDtcbiAgICAgICAgY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlID0gbGFzdFZhbHVlRGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZTtcbiAgICAgICAgcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfYm9yZGVyQ29sb3IgPSBzb3VyY2UuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2JhY2tncm91bmRDb2xvckF0WVBlcmNlbnRGcm9tVG9wKGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGUgLyBzb3VyY2UuX2ludGVybmFsX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfaGVpZ2h0KCkpO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9ib3JkZXJDb2xvciA9IGxhc3RWYWx1ZUNvbG9yO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IGNvbG9ycy5faW50ZXJuYWxfZm9yZWdyb3VuZDtcbiAgICAgICAgcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfY29sb3IgPSBjb2xvcnMuX2ludGVybmFsX2ZvcmVncm91bmQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fcGFuZVRleHQobGFzdFZhbHVlLCBzaG93U2VyaWVzTGFzdFZhbHVlLCBzaG93U3ltYm9sTGFiZWwsIHNob3dQcmljZUFuZFBlcmNlbnRhZ2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBjb25zdCB0aXRsZSA9IHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfdGl0bGUoKTtcbiAgICAgICAgaWYgKHNob3dTeW1ib2xMYWJlbCAmJiB0aXRsZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgJHt0aXRsZX0gYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvd1Nlcmllc0xhc3RWYWx1ZSAmJiBzaG93UHJpY2VBbmRQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5fcHJpdmF0ZV9fc291cmNlLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpID9cbiAgICAgICAgICAgICAgICBsYXN0VmFsdWUuX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlQWJzb2x1dGUgOiBsYXN0VmFsdWUuX2ludGVybmFsX2Zvcm1hdHRlZFByaWNlUGVyY2VudGFnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19heGlzVGV4dChsYXN0VmFsdWVEYXRhLCBzaG93U2VyaWVzTGFzdFZhbHVlLCBzaG93UHJpY2VBbmRQZXJjZW50YWdlKSB7XG4gICAgICAgIGlmICghc2hvd1Nlcmllc0xhc3RWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hvd1ByaWNlQW5kUGVyY2VudGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RWYWx1ZURhdGEuX2ludGVybmFsX3RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3NvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UoKSA/XG4gICAgICAgICAgICBsYXN0VmFsdWVEYXRhLl9pbnRlcm5hbF9mb3JtYXR0ZWRQcmljZVBlcmNlbnRhZ2UgOiBsYXN0VmFsdWVEYXRhLl9pbnRlcm5hbF9mb3JtYXR0ZWRQcmljZUFic29sdXRlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZUZpbml0ZVJlc3VsdChtZXRob2QsIHZhbHVlT25lLCB2YWx1ZVR3bywgZmFsbGJhY2spIHtcbiAgICBjb25zdCBmaXJzdEZpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSh2YWx1ZU9uZSk7XG4gICAgY29uc3Qgc2Vjb25kRmluaXRlID0gTnVtYmVyLmlzRmluaXRlKHZhbHVlVHdvKTtcbiAgICBpZiAoZmlyc3RGaW5pdGUgJiYgc2Vjb25kRmluaXRlKSB7XG4gICAgICAgIHJldHVybiBtZXRob2QodmFsdWVPbmUsIHZhbHVlVHdvKTtcbiAgICB9XG4gICAgcmV0dXJuICFmaXJzdEZpbml0ZSAmJiAhc2Vjb25kRmluaXRlID8gZmFsbGJhY2sgOiAoZmlyc3RGaW5pdGUgPyB2YWx1ZU9uZSA6IHZhbHVlVHdvKTtcbn1cbmNsYXNzIFByaWNlUmFuZ2VJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihtaW5WYWx1ZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUgPSBtaW5WYWx1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUgPSBtYXhWYWx1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VxdWFscyhwcikge1xuICAgICAgICBpZiAocHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUgPT09IHByLl9wcml2YXRlX19taW5WYWx1ZSAmJiB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSA9PT0gcHIuX3ByaXZhdGVfX21heFZhbHVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJpY2VSYW5nZUltcGwodGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUsIHRoaXMuX3ByaXZhdGVfX21heFZhbHVlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX21pblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWluVmFsdWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tYXhWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX21heFZhbHVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUgLSB0aGlzLl9wcml2YXRlX19taW5WYWx1ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSA9PT0gdGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUgfHwgTnVtYmVyLmlzTmFOKHRoaXMuX3ByaXZhdGVfX21heFZhbHVlKSB8fCBOdW1iZXIuaXNOYU4odGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWVyZ2UoYW5vdGhlclJhbmdlKSB7XG4gICAgICAgIGlmIChhbm90aGVyUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJpY2VSYW5nZUltcGwoY29tcHV0ZUZpbml0ZVJlc3VsdChNYXRoLm1pbiwgdGhpcy5faW50ZXJuYWxfbWluVmFsdWUoKSwgYW5vdGhlclJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpLCAtSW5maW5pdHkpLCBjb21wdXRlRmluaXRlUmVzdWx0KE1hdGgubWF4LCB0aGlzLl9pbnRlcm5hbF9tYXhWYWx1ZSgpLCBhbm90aGVyUmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCksIEluZmluaXR5KSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY2FsZUFyb3VuZENlbnRlcihjb2VmZikge1xuICAgICAgICBpZiAoIWlzTnVtYmVyKGNvZWZmKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUgLSB0aGlzLl9wcml2YXRlX19taW5WYWx1ZTtcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VudGVyID0gKHRoaXMuX3ByaXZhdGVfX21heFZhbHVlICsgdGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUpICogMC41O1xuICAgICAgICBsZXQgbWF4RGVsdGEgPSB0aGlzLl9wcml2YXRlX19tYXhWYWx1ZSAtIGNlbnRlcjtcbiAgICAgICAgbGV0IG1pbkRlbHRhID0gdGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUgLSBjZW50ZXI7XG4gICAgICAgIG1heERlbHRhICo9IGNvZWZmO1xuICAgICAgICBtaW5EZWx0YSAqPSBjb2VmZjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUgPSBjZW50ZXIgKyBtYXhEZWx0YTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUgPSBjZW50ZXIgKyBtaW5EZWx0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NoaWZ0KGRlbHRhKSB7XG4gICAgICAgIGlmICghaXNOdW1iZXIoZGVsdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUgKz0gZGVsdGE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21pblZhbHVlICs9IGRlbHRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdG9SYXcoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5WYWx1ZTogdGhpcy5fcHJpdmF0ZV9fbWluVmFsdWUsXG4gICAgICAgICAgICBtYXhWYWx1ZTogdGhpcy5fcHJpdmF0ZV9fbWF4VmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBfaW50ZXJuYWxfZnJvbVJhdyhyYXcpIHtcbiAgICAgICAgcmV0dXJuIChyYXcgPT09IG51bGwpID8gbnVsbCA6IG5ldyBQcmljZVJhbmdlSW1wbChyYXcubWluVmFsdWUsIHJhdy5tYXhWYWx1ZSk7XG4gICAgfVxufVxuXG5jbGFzcyBBdXRvc2NhbGVJbmZvSW1wbCB7XG4gICAgY29uc3RydWN0b3IocHJpY2VSYW5nZSwgbWFyZ2lucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlID0gcHJpY2VSYW5nZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFyZ2lucyA9IG1hcmdpbnMgfHwgbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWFyZ2lucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX21hcmdpbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90b1JhdygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByaWNlUmFuZ2U6IHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZS5faW50ZXJuYWxfdG9SYXcoKSxcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMuX3ByaXZhdGVfX21hcmdpbnMgfHwgdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgX2ludGVybmFsX2Zyb21SYXcocmF3KSB7XG4gICAgICAgIHJldHVybiAocmF3ID09PSBudWxsKSA/IG51bGwgOiBuZXcgQXV0b3NjYWxlSW5mb0ltcGwoUHJpY2VSYW5nZUltcGwuX2ludGVybmFsX2Zyb21SYXcocmF3LnByaWNlUmFuZ2UpLCByYXcubWFyZ2lucyk7XG4gICAgfVxufVxuXG5jbGFzcyBDdXN0b21QcmljZUxpbmVQYW5lVmlldyBleHRlbmRzIFNlcmllc0hvcml6b250YWxMaW5lUGFuZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgcHJpY2VMaW5lKSB7XG4gICAgICAgIHN1cGVyKHNlcmllcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZSA9IHByaWNlTGluZTtcbiAgICB9XG4gICAgX2ludGVybmFsX191cGRhdGVJbXBsKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5faW50ZXJuYWxfX2xpbmVSZW5kZXJlckRhdGE7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbGluZU9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19wcmljZUxpbmUuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF92aXNpYmxlKCkgfHwgIWxpbmVPcHRpb25zLmxpbmVWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZS5faW50ZXJuYWxfeUNvb3JkKCk7XG4gICAgICAgIGlmICh5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX3kgPSB5O1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9jb2xvciA9IGxpbmVPcHRpb25zLmNvbG9yO1xuICAgICAgICBkYXRhLl9pbnRlcm5hbF9saW5lV2lkdGggPSBsaW5lT3B0aW9ucy5saW5lV2lkdGg7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX2xpbmVTdHlsZSA9IGxpbmVPcHRpb25zLmxpbmVTdHlsZTtcbiAgICAgICAgZGF0YS5faW50ZXJuYWxfZXh0ZXJuYWxJZCA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZS5faW50ZXJuYWxfb3B0aW9ucygpLmlkO1xuICAgIH1cbn1cblxuY2xhc3MgQ3VzdG9tUHJpY2VMaW5lUHJpY2VBeGlzVmlldyBleHRlbmRzIFByaWNlQXhpc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgcHJpY2VMaW5lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NlcmllcyA9IHNlcmllcztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lID0gcHJpY2VMaW5lO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3VwZGF0ZVJlbmRlcmVyRGF0YShheGlzUmVuZGVyZXJEYXRhLCBwYW5lUmVuZGVyZXJEYXRhLCBjb21tb25EYXRhKSB7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IGxhYmVsVmlzaWJsZSA9IG9wdGlvbnMuYXhpc0xhYmVsVmlzaWJsZTtcbiAgICAgICAgY29uc3Qgc2hvd1BhbmVMYWJlbCA9IG9wdGlvbnMudGl0bGUgIT09ICcnO1xuICAgICAgICBjb25zdCBzZXJpZXMgPSB0aGlzLl9wcml2YXRlX19zZXJpZXM7XG4gICAgICAgIGlmICghbGFiZWxWaXNpYmxlIHx8ICFzZXJpZXMuX2ludGVybmFsX3Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLl9wcml2YXRlX19wcmljZUxpbmUuX2ludGVybmFsX3lDb29yZCgpO1xuICAgICAgICBpZiAoeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG93UGFuZUxhYmVsKSB7XG4gICAgICAgICAgICBwYW5lUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90ZXh0ID0gb3B0aW9ucy50aXRsZTtcbiAgICAgICAgICAgIHBhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhbmVSZW5kZXJlckRhdGEuX2ludGVybmFsX2JvcmRlckNvbG9yID0gc2VyaWVzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9iYWNrZ3JvdW5kQ29sb3JBdFlQZXJjZW50RnJvbVRvcCh5IC8gc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkuX2ludGVybmFsX2hlaWdodCgpKTtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGV4dCA9IHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFByaWNlKG9wdGlvbnMucHJpY2UpO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY29sb3JzID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9jb2xvclBhcnNlcigpLl9pbnRlcm5hbF9nZW5lcmF0ZUNvbnRyYXN0Q29sb3JzKG9wdGlvbnMuYXhpc0xhYmVsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG4gICAgICAgIGNvbW1vbkRhdGEuX2ludGVybmFsX2JhY2tncm91bmQgPSBjb2xvcnMuX2ludGVybmFsX2JhY2tncm91bmQ7XG4gICAgICAgIGNvbnN0IHRleHRDb2xvciA9IG9wdGlvbnMuYXhpc0xhYmVsVGV4dENvbG9yIHx8IGNvbG9ycy5faW50ZXJuYWxfZm9yZWdyb3VuZDtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfY29sb3IgPSB0ZXh0Q29sb3I7IC8vIHByaWNlIHRleHRcbiAgICAgICAgcGFuZVJlbmRlcmVyRGF0YS5faW50ZXJuYWxfY29sb3IgPSB0ZXh0Q29sb3I7IC8vIHRpdGxlIHRleHRcbiAgICAgICAgY29tbW9uRGF0YS5faW50ZXJuYWxfY29vcmRpbmF0ZSA9IHk7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb3JtYXRQcmljZShwcmljZSkge1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9mb3JtYXRQcmljZShwcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgIH1cbn1cblxuY2xhc3MgQ3VzdG9tUHJpY2VMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lVmlldyA9IG5ldyBDdXN0b21QcmljZUxpbmVQYW5lVmlldyhzZXJpZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3ID0gbmV3IEN1c3RvbVByaWNlTGluZVByaWNlQXhpc1ZpZXcoc2VyaWVzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVByaWNlQXhpc1ZpZXcgPSBuZXcgUGFuZVByaWNlQXhpc1ZpZXcodGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlldywgc2VyaWVzLCBzZXJpZXMuX2ludGVybmFsX21vZGVsKCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2UodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucztcbiAgICB9XG4gICAgX2ludGVybmFsX3BhbmVWaWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lVmlldztcbiAgICB9XG4gICAgX2ludGVybmFsX2xhYmVsUGFuZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lUHJpY2VBeGlzVmlldztcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlQXhpc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUxpbmVWaWV3Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlldy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF95Q29vcmQoKSB7XG4gICAgICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuX3ByaXZhdGVfX3NlcmllcztcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHNlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSBzZXJpZXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICBpZiAodGltZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkgfHwgcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpY2VTY2FsZS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgIH1cbn1cblxuY2xhc3MgUHJpY2VEYXRhU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgX2ludGVybmFsX21vZGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbW9kZWw7XG4gICAgfVxufVxuXG5jb25zdCBiYXJTdHlsZUZuTWFwID0ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBCYXI6IChmaW5kQmFyLCBiYXJTdHlsZSwgYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykgPT4ge1xuICAgICAgICBjb25zdCB1cENvbG9yID0gYmFyU3R5bGUudXBDb2xvcjtcbiAgICAgICAgY29uc3QgZG93bkNvbG9yID0gYmFyU3R5bGUuZG93bkNvbG9yO1xuICAgICAgICBjb25zdCBjdXJyZW50QmFyID0gZW5zdXJlTm90TnVsbChmaW5kQmFyKGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpKTtcbiAgICAgICAgY29uc3QgaXNVcCA9IGVuc3VyZShjdXJyZW50QmFyLl9pbnRlcm5hbF92YWx1ZVswIC8qIFBsb3RSb3dWYWx1ZUluZGV4Lk9wZW4gKi9dKSA8PSBlbnN1cmUoY3VycmVudEJhci5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX2JhckNvbG9yOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9jb2xvciA/PyAoaXNVcCA/IHVwQ29sb3IgOiBkb3duQ29sb3IpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIENhbmRsZXN0aWNrOiAoZmluZEJhciwgY2FuZGxlc3RpY2tTdHlsZSwgYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykgPT4ge1xuICAgICAgICBjb25zdCB1cENvbG9yID0gY2FuZGxlc3RpY2tTdHlsZS51cENvbG9yO1xuICAgICAgICBjb25zdCBkb3duQ29sb3IgPSBjYW5kbGVzdGlja1N0eWxlLmRvd25Db2xvcjtcbiAgICAgICAgY29uc3QgYm9yZGVyVXBDb2xvciA9IGNhbmRsZXN0aWNrU3R5bGUuYm9yZGVyVXBDb2xvcjtcbiAgICAgICAgY29uc3QgYm9yZGVyRG93bkNvbG9yID0gY2FuZGxlc3RpY2tTdHlsZS5ib3JkZXJEb3duQ29sb3I7XG4gICAgICAgIGNvbnN0IHdpY2tVcENvbG9yID0gY2FuZGxlc3RpY2tTdHlsZS53aWNrVXBDb2xvcjtcbiAgICAgICAgY29uc3Qgd2lja0Rvd25Db2xvciA9IGNhbmRsZXN0aWNrU3R5bGUud2lja0Rvd25Db2xvcjtcbiAgICAgICAgY29uc3QgY3VycmVudEJhciA9IGVuc3VyZU5vdE51bGwoZmluZEJhcihiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSk7XG4gICAgICAgIGNvbnN0IGlzVXAgPSBlbnN1cmUoY3VycmVudEJhci5faW50ZXJuYWxfdmFsdWVbMCAvKiBQbG90Um93VmFsdWVJbmRleC5PcGVuICovXSkgPD0gZW5zdXJlKGN1cnJlbnRCYXIuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJDb2xvcjogY3VycmVudEJhci5faW50ZXJuYWxfY29sb3IgPz8gKGlzVXAgPyB1cENvbG9yIDogZG93bkNvbG9yKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJCb3JkZXJDb2xvcjogY3VycmVudEJhci5faW50ZXJuYWxfYm9yZGVyQ29sb3IgPz8gKGlzVXAgPyBib3JkZXJVcENvbG9yIDogYm9yZGVyRG93bkNvbG9yKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJXaWNrQ29sb3I6IGN1cnJlbnRCYXIuX2ludGVybmFsX3dpY2tDb2xvciA/PyAoaXNVcCA/IHdpY2tVcENvbG9yIDogd2lja0Rvd25Db2xvciksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgQ3VzdG9tOiAoZmluZEJhciwgY3VzdG9tU3R5bGUsIGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhciA9IGVuc3VyZU5vdE51bGwoZmluZEJhcihiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyQ29sb3I6IGN1cnJlbnRCYXIuX2ludGVybmFsX2NvbG9yID8/IGN1c3RvbVN0eWxlLmNvbG9yLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIEFyZWE6IChmaW5kQmFyLCBhcmVhU3R5bGUsIGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhciA9IGVuc3VyZU5vdE51bGwoZmluZEJhcihiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyQ29sb3I6IGN1cnJlbnRCYXIuX2ludGVybmFsX2xpbmVDb2xvciA/PyBhcmVhU3R5bGUubGluZUNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVDb2xvcjogY3VycmVudEJhci5faW50ZXJuYWxfbGluZUNvbG9yID8/IGFyZWFTdHlsZS5saW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29sb3I6IGN1cnJlbnRCYXIuX2ludGVybmFsX3RvcENvbG9yID8/IGFyZWFTdHlsZS50b3BDb2xvcixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21Db2xvcjogY3VycmVudEJhci5faW50ZXJuYWxfYm90dG9tQ29sb3IgPz8gYXJlYVN0eWxlLmJvdHRvbUNvbG9yLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIEJhc2VsaW5lOiAoZmluZEJhciwgYmFzZWxpbmVTdHlsZSwgYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50QmFyID0gZW5zdXJlTm90TnVsbChmaW5kQmFyKGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpKTtcbiAgICAgICAgY29uc3QgaXNBYm92ZUJhc2VsaW5lID0gY3VycmVudEJhci5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL10gPj0gYmFzZWxpbmVTdHlsZS5iYXNlVmFsdWUucHJpY2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyQ29sb3I6IGlzQWJvdmVCYXNlbGluZSA/IGJhc2VsaW5lU3R5bGUudG9wTGluZUNvbG9yIDogYmFzZWxpbmVTdHlsZS5ib3R0b21MaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wTGluZUNvbG9yOiBjdXJyZW50QmFyLl9pbnRlcm5hbF90b3BMaW5lQ29sb3IgPz8gYmFzZWxpbmVTdHlsZS50b3BMaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tTGluZUNvbG9yOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9ib3R0b21MaW5lQ29sb3IgPz8gYmFzZWxpbmVTdHlsZS5ib3R0b21MaW5lQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wRmlsbENvbG9yMTogY3VycmVudEJhci5faW50ZXJuYWxfdG9wRmlsbENvbG9yMSA/PyBiYXNlbGluZVN0eWxlLnRvcEZpbGxDb2xvcjEsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wRmlsbENvbG9yMjogY3VycmVudEJhci5faW50ZXJuYWxfdG9wRmlsbENvbG9yMiA/PyBiYXNlbGluZVN0eWxlLnRvcEZpbGxDb2xvcjIsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMTogY3VycmVudEJhci5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMSA/PyBiYXNlbGluZVN0eWxlLmJvdHRvbUZpbGxDb2xvcjEsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMjogY3VycmVudEJhci5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMiA/PyBiYXNlbGluZVN0eWxlLmJvdHRvbUZpbGxDb2xvcjIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgTGluZTogKGZpbmRCYXIsIGxpbmVTdHlsZSwgYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50QmFyID0gZW5zdXJlTm90TnVsbChmaW5kQmFyKGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJDb2xvcjogY3VycmVudEJhci5faW50ZXJuYWxfY29sb3IgPz8gbGluZVN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVDb2xvcjogY3VycmVudEJhci5faW50ZXJuYWxfY29sb3IgPz8gbGluZVN0eWxlLmNvbG9yLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIEhpc3RvZ3JhbTogKGZpbmRCYXIsIGhpc3RvZ3JhbVN0eWxlLCBiYXJJbmRleCwgcHJlY29tcHV0ZWRCYXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXIgPSBlbnN1cmVOb3ROdWxsKGZpbmRCYXIoYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX2JhckNvbG9yOiBjdXJyZW50QmFyLl9pbnRlcm5hbF9jb2xvciA/PyBoaXN0b2dyYW1TdHlsZS5jb2xvcixcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbmNsYXNzIFNlcmllc0JhckNvbG9yZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19maW5kQmFyID0gKGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmVjb21wdXRlZEJhcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVjb21wdXRlZEJhcnMuX2ludGVybmFsX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF92YWx1ZUF0KGJhckluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdHlsZUdldHRlciA9IGJhclN0eWxlRm5NYXBbc2VyaWVzLl9pbnRlcm5hbF9zZXJpZXNUeXBlKCldO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYmFyU3R5bGUoYmFySW5kZXgsIHByZWNvbXB1dGVkQmFycykge1xuICAgICAgICAvLyBwcmVjb21wdXRlZEJhcnM6IHt2YWx1ZTogW0FycmF5IEJhclZhbHVlc10sIHByZXZpb3VzVmFsdWU6IFtBcnJheSBCYXJWYWx1ZXNdIHwgdW5kZWZpbmVkfVxuICAgICAgICAvLyBVc2VkIHRvIGF2b2lkIGJpbmFyeSBzZWFyY2ggaWYgYmFycyBhcmUgYWxyZWFkeSBrbm93blxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc3R5bGVHZXR0ZXIodGhpcy5fcHJpdmF0ZV9fZmluZEJhciwgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCksIGJhckluZGV4LCBwcmVjb21wdXRlZEJhcnMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCaW5hcnkgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHR3byBhcmd1bWVudHMgKHRoZSBmaXJzdCBvZiB0aGUgdHlwZSBvZiBhcnJheSBlbGVtZW50cywgYW5kIHRoZSBzZWNvbmQgaXMgYWx3YXlzIHZhbCksIGFuZCByZXR1cm5zIGEgdmFsdWUgY29udmVydGlibGUgdG8gYm9vbC5cbiAqIFRoZSB2YWx1ZSByZXR1cm5lZCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZmlyc3QgYXJndW1lbnQgaXMgY29uc2lkZXJlZCB0byBnbyBiZWZvcmUgdGhlIHNlY29uZC5cbiAqIFRoZSBmdW5jdGlvbiBzaGFsbCBub3QgbW9kaWZ5IGFueSBvZiBpdHMgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBib3VuZENvbXBhcmUobG93ZXIsIGFyciwgdmFsdWUsIGNvbXBhcmUsIHN0YXJ0ID0gMCwgdG8gPSBhcnIubGVuZ3RoKSB7XG4gICAgbGV0IGNvdW50ID0gdG8gLSBzdGFydDtcbiAgICB3aGlsZSAoMCA8IGNvdW50KSB7XG4gICAgICAgIGNvbnN0IGNvdW50MiA9IChjb3VudCA+PiAxKTtcbiAgICAgICAgY29uc3QgbWlkID0gc3RhcnQgKyBjb3VudDI7XG4gICAgICAgIGlmIChjb21wYXJlKGFyclttaWRdLCB2YWx1ZSkgPT09IGxvd2VyKSB7XG4gICAgICAgICAgICBzdGFydCA9IG1pZCArIDE7XG4gICAgICAgICAgICBjb3VudCAtPSBjb3VudDIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0O1xufVxuY29uc3QgbG93ZXJCb3VuZCA9IGJvdW5kQ29tcGFyZS5iaW5kKG51bGwsIHRydWUpO1xuY29uc3QgdXBwZXJCb3VuZCA9IGJvdW5kQ29tcGFyZS5iaW5kKG51bGwsIGZhbHNlKTtcblxuLyoqXG4gKiBTZWFyY2ggZGlyZWN0aW9uIGlmIG5vIGRhdGEgZm91bmQgYXQgcHJvdmlkZWQgaW5kZXhcbiAqL1xudmFyIE1pc21hdGNoRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChNaXNtYXRjaERpcmVjdGlvbikge1xuICAgIC8qKlxuICAgICAqIFNlYXJjaCB0aGUgbmVhcmVzdCBsZWZ0IGl0ZW1cbiAgICAgKi9cbiAgICBNaXNtYXRjaERpcmVjdGlvbltNaXNtYXRjaERpcmVjdGlvbltcIk5lYXJlc3RMZWZ0XCJdID0gLTFdID0gXCJOZWFyZXN0TGVmdFwiO1xuICAgIC8qKlxuICAgICAqIERvIG5vdCBzZWFyY2hcbiAgICAgKi9cbiAgICBNaXNtYXRjaERpcmVjdGlvbltNaXNtYXRjaERpcmVjdGlvbltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIC8qKlxuICAgICAqIFNlYXJjaCB0aGUgbmVhcmVzdCByaWdodCBpdGVtXG4gICAgICovXG4gICAgTWlzbWF0Y2hEaXJlY3Rpb25bTWlzbWF0Y2hEaXJlY3Rpb25bXCJOZWFyZXN0UmlnaHRcIl0gPSAxXSA9IFwiTmVhcmVzdFJpZ2h0XCI7XG59KShNaXNtYXRjaERpcmVjdGlvbiB8fCAoTWlzbWF0Y2hEaXJlY3Rpb24gPSB7fSkpO1xuLy8gVE9ETzogdGhpbmsgYWJvdXQgY2hhbmdpbmcgaXQgZHluYW1pY2FsbHlcbmNvbnN0IENIVU5LX1NJWkUgPSAzMDtcbi8qKlxuICogUGxvdExpc3QgaXMgYW4gYXJyYXkgb2YgcGxvdCByb3dzXG4gKiBlYWNoIHBsb3Qgcm93IGNvbnNpc3RzIG9mIGtleSAoaW5kZXggaW4gdGltZXNjYWxlKSBhbmQgcGxvdCB2YWx1ZSBtYXBcbiAqL1xuY2xhc3MgUGxvdExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19taW5NYXhDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcm93U2VhcmNoQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGljZXMgPSBbXTtcbiAgICB9XG4gICAgLy8gQHJldHVybnMgTGFzdCByb3dcbiAgICBfaW50ZXJuYWxfbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX3NpemUoKSA+IDAgPyB0aGlzLl9wcml2YXRlX19pdGVtc1t0aGlzLl9wcml2YXRlX19pdGVtcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9maXJzdEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfc2l6ZSgpID4gMCA/IHRoaXMuX3ByaXZhdGVfX2luZGV4QXQoMCkgOiBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGFzdEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfc2l6ZSgpID4gMCA/IHRoaXMuX3ByaXZhdGVfX2luZGV4QXQoKHRoaXMuX3ByaXZhdGVfX2l0ZW1zLmxlbmd0aCAtIDEpKSA6IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faXRlbXMubGVuZ3RoO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX3NpemUoKSA9PT0gMDtcbiAgICB9XG4gICAgX2ludGVybmFsX2NvbnRhaW5zKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zZWFyY2goaW5kZXgsIDAgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTm9uZSAqLykgIT09IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92YWx1ZUF0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9zZWFyY2goaW5kZXgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2VhcmNoKGluZGV4LCBzZWFyY2hNb2RlID0gMCAvKiBNaXNtYXRjaERpcmVjdGlvbi5Ob25lICovKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX3ByaXZhdGVfX3NlYXJjaChpbmRleCwgc2VhcmNoTW9kZSk7XG4gICAgICAgIGlmIChwb3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLl9wcml2YXRlX192YWx1ZUF0KHBvcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfaW5kZXg6IHRoaXMuX3ByaXZhdGVfX2luZGV4QXQocG9zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Jvd3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19pdGVtcztcbiAgICB9XG4gICAgX2ludGVybmFsX21pbk1heE9uUmFuZ2VDYWNoZWQoc3RhcnQsIGVuZCwgcGxvdHMpIHtcbiAgICAgICAgLy8gdGhpcyBjb2RlIHdvcmtzIGZvciBzaW5nbGUgc2VyaWVzIG9ubHlcbiAgICAgICAgLy8gY291bGQgZmFpbCBhZnRlciB3aGl0ZXNwYWNlcyBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBwbG90IG9mIHBsb3RzKSB7XG4gICAgICAgICAgICBjb25zdCBwbG90TWluTWF4ID0gdGhpcy5fcHJpdmF0ZV9fbWluTWF4T25SYW5nZUNhY2hlZEltcGwoc3RhcnQsIGVuZCwgcGxvdCk7XG4gICAgICAgICAgICByZXN1bHQgPSBtZXJnZU1pbk1heChyZXN1bHQsIHBsb3RNaW5NYXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKHBsb3RSb3dzKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jvd1NlYXJjaENhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21pbk1heENhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2l0ZW1zID0gcGxvdFJvd3M7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGljZXMgPSBwbG90Um93cy5tYXAoKHBsb3RSb3cpID0+IHBsb3RSb3cuX2ludGVybmFsX2luZGV4KTtcbiAgICB9XG4gICAgLy8gVGltZVBvaW50SW5kZXggdmFsdWVzIGZvciBmdWxmaWxsZWQgZGF0YSBwb2ludHNcbiAgICBfaW50ZXJuYWxfaW5kaWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2luZGljZXM7XG4gICAgfVxuICAgIF9wcml2YXRlX19pbmRleEF0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faXRlbXNbb2Zmc2V0XS5faW50ZXJuYWxfaW5kZXg7XG4gICAgfVxuICAgIF9wcml2YXRlX192YWx1ZUF0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faXRlbXNbb2Zmc2V0XTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3NlYXJjaChpbmRleCwgc2VhcmNoTW9kZSkge1xuICAgICAgICBjb25zdCBleGFjdFBvcyA9IHRoaXMuX3ByaXZhdGVfX2JzZWFyY2goaW5kZXgpO1xuICAgICAgICBpZiAoZXhhY3RQb3MgPT09IG51bGwgJiYgc2VhcmNoTW9kZSAhPT0gMCAvKiBNaXNtYXRjaERpcmVjdGlvbi5Ob25lICovKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNlYXJjaE1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIC0xIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5lYXJlc3RMZWZ0ICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2VhcmNoTmVhcmVzdExlZnQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBNaXNtYXRjaERpcmVjdGlvbi5OZWFyZXN0UmlnaHQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zZWFyY2hOZWFyZXN0UmlnaHQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gc2VhcmNoIG1vZGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhhY3RQb3M7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZWFyY2hOZWFyZXN0TGVmdChpbmRleCkge1xuICAgICAgICBsZXQgbmVhcmVzdExlZnRQb3MgPSB0aGlzLl9wcml2YXRlX19sb3dlcmJvdW5kKGluZGV4KTtcbiAgICAgICAgaWYgKG5lYXJlc3RMZWZ0UG9zID4gMCkge1xuICAgICAgICAgICAgbmVhcmVzdExlZnRQb3MgPSBuZWFyZXN0TGVmdFBvcyAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuZWFyZXN0TGVmdFBvcyAhPT0gdGhpcy5fcHJpdmF0ZV9faXRlbXMubGVuZ3RoICYmIHRoaXMuX3ByaXZhdGVfX2luZGV4QXQobmVhcmVzdExlZnRQb3MpIDwgaW5kZXgpID8gbmVhcmVzdExlZnRQb3MgOiBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2VhcmNoTmVhcmVzdFJpZ2h0KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG5lYXJlc3RSaWdodFBvcyA9IHRoaXMuX3ByaXZhdGVfX3VwcGVyYm91bmQoaW5kZXgpO1xuICAgICAgICByZXR1cm4gKG5lYXJlc3RSaWdodFBvcyAhPT0gdGhpcy5fcHJpdmF0ZV9faXRlbXMubGVuZ3RoICYmIGluZGV4IDwgdGhpcy5fcHJpdmF0ZV9faW5kZXhBdChuZWFyZXN0UmlnaHRQb3MpKSA/IG5lYXJlc3RSaWdodFBvcyA6IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19ic2VhcmNoKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fcHJpdmF0ZV9fbG93ZXJib3VuZChpbmRleCk7XG4gICAgICAgIGlmIChzdGFydCAhPT0gdGhpcy5fcHJpdmF0ZV9faXRlbXMubGVuZ3RoICYmICEoaW5kZXggPCB0aGlzLl9wcml2YXRlX19pdGVtc1tzdGFydF0uX2ludGVybmFsX2luZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbG93ZXJib3VuZChpbmRleCkge1xuICAgICAgICByZXR1cm4gbG93ZXJCb3VuZCh0aGlzLl9wcml2YXRlX19pdGVtcywgaW5kZXgsIChhLCBiKSA9PiBhLl9pbnRlcm5hbF9pbmRleCA8IGIpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBwZXJib3VuZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdXBwZXJCb3VuZCh0aGlzLl9wcml2YXRlX19pdGVtcywgaW5kZXgsIChhLCBiKSA9PiBhLl9pbnRlcm5hbF9pbmRleCA+IGIpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcGxvdE1pbk1heChzdGFydEluZGV4LCBlbmRJbmRleEV4Y2x1c2l2ZSwgcGxvdEluZGV4KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4RXhjbHVzaXZlOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuX3ByaXZhdGVfX2l0ZW1zW2ldLl9pbnRlcm5hbF92YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZXNbcGxvdEluZGV4XTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4odikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7IF9pbnRlcm5hbF9taW46IHYsIF9pbnRlcm5hbF9tYXg6IHYgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2IDwgcmVzdWx0Ll9pbnRlcm5hbF9taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9pbnRlcm5hbF9taW4gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodiA+IHJlc3VsdC5faW50ZXJuYWxfbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5faW50ZXJuYWxfbWF4ID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21pbk1heE9uUmFuZ2VDYWNoZWRJbXBsKHN0YXJ0LCBlbmQsIHBsb3RJbmRleCkge1xuICAgICAgICAvLyB0aGlzIGNvZGUgd29ya3MgZm9yIHNpbmdsZSBzZXJpZXMgb25seVxuICAgICAgICAvLyBjb3VsZCBmYWlsIGFmdGVyIHdoaXRlc3BhY2VzIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAvLyBhc3N1bWUgdGhhdCBiYXIgaW5kZXhlcyBvbmx5IGluY3JlYXNlXG4gICAgICAgIGNvbnN0IGZpcnN0SW5kZXggPSBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX2ZpcnN0SW5kZXgoKSk7XG4gICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfbGFzdEluZGV4KCkpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5tYXgoc3RhcnQsIGZpcnN0SW5kZXgpO1xuICAgICAgICBjb25zdCBlID0gTWF0aC5taW4oZW5kLCBsYXN0SW5kZXgpO1xuICAgICAgICBjb25zdCBjYWNoZWRMb3cgPSBNYXRoLmNlaWwocyAvIENIVU5LX1NJWkUpICogQ0hVTktfU0laRTtcbiAgICAgICAgY29uc3QgY2FjaGVkSGlnaCA9IE1hdGgubWF4KGNhY2hlZExvdywgTWF0aC5mbG9vcihlIC8gQ0hVTktfU0laRSkgKiBDSFVOS19TSVpFKTtcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHRoaXMuX3ByaXZhdGVfX2xvd2VyYm91bmQocyk7XG4gICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuX3ByaXZhdGVfX3VwcGVyYm91bmQoTWF0aC5taW4oZSwgY2FjaGVkTG93LCBlbmQpKTsgLy8gbm9uLWluY2x1c2l2ZSBlbmRcbiAgICAgICAgICAgIGNvbnN0IHBsb3RNaW5NYXggPSB0aGlzLl9wcml2YXRlX19wbG90TWluTWF4KHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBwbG90SW5kZXgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbWVyZ2VNaW5NYXgocmVzdWx0LCBwbG90TWluTWF4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWluTWF4Q2FjaGUgPSB0aGlzLl9wcml2YXRlX19taW5NYXhDYWNoZS5nZXQocGxvdEluZGV4KTtcbiAgICAgICAgaWYgKG1pbk1heENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1pbk1heENhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWluTWF4Q2FjaGUuc2V0KHBsb3RJbmRleCwgbWluTWF4Q2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBnbyBjYWNoZWRcbiAgICAgICAgZm9yIChsZXQgYyA9IE1hdGgubWF4KGNhY2hlZExvdyArIDEsIHMpOyBjIDwgY2FjaGVkSGlnaDsgYyArPSBDSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVua0luZGV4ID0gTWF0aC5mbG9vcihjIC8gQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBsZXQgY2h1bmtNaW5NYXggPSBtaW5NYXhDYWNoZS5nZXQoY2h1bmtJbmRleCk7XG4gICAgICAgICAgICBpZiAoY2h1bmtNaW5NYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rU3RhcnQgPSB0aGlzLl9wcml2YXRlX19sb3dlcmJvdW5kKGNodW5rSW5kZXggKiBDSFVOS19TSVpFKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua0VuZCA9IHRoaXMuX3ByaXZhdGVfX3VwcGVyYm91bmQoKGNodW5rSW5kZXggKyAxKSAqIENIVU5LX1NJWkUgLSAxKTtcbiAgICAgICAgICAgICAgICBjaHVua01pbk1heCA9IHRoaXMuX3ByaXZhdGVfX3Bsb3RNaW5NYXgoY2h1bmtTdGFydCwgY2h1bmtFbmQsIHBsb3RJbmRleCk7XG4gICAgICAgICAgICAgICAgbWluTWF4Q2FjaGUuc2V0KGNodW5rSW5kZXgsIGNodW5rTWluTWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IG1lcmdlTWluTWF4KHJlc3VsdCwgY2h1bmtNaW5NYXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRhaWxcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHRoaXMuX3ByaXZhdGVfX2xvd2VyYm91bmQoY2FjaGVkSGlnaCk7XG4gICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuX3ByaXZhdGVfX3VwcGVyYm91bmQoZSk7IC8vIG5vbi1pbmNsdXNpdmUgZW5kXG4gICAgICAgICAgICBjb25zdCBwbG90TWluTWF4ID0gdGhpcy5fcHJpdmF0ZV9fcGxvdE1pbk1heChzdGFydEluZGV4LCBlbmRJbmRleCwgcGxvdEluZGV4KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1lcmdlTWluTWF4KHJlc3VsdCwgcGxvdE1pbk1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZU1pbk1heChmaXJzdCwgc2Vjb25kKSB7XG4gICAgaWYgKGZpcnN0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWNvbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2Vjb25kID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBtZXJnZSBNaW5NYXggdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihmaXJzdC5faW50ZXJuYWxfbWluLCBzZWNvbmQuX2ludGVybmFsX21pbik7XG4gICAgICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChmaXJzdC5faW50ZXJuYWxfbWF4LCBzZWNvbmQuX2ludGVybmFsX21heCk7XG4gICAgICAgICAgICByZXR1cm4geyBfaW50ZXJuYWxfbWluOiBtaW4sIF9pbnRlcm5hbF9tYXg6IG1heCB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTZXJpZXNQbG90TGlzdCgpIHtcbiAgICByZXR1cm4gbmV3IFBsb3RMaXN0KCk7XG59XG5cbmNsYXNzIFByaW1pdGl2ZVJlbmRlcmVyV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoYmFzZVJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VSZW5kZXJlciA9IGJhc2VSZW5kZXJlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXcodGFyZ2V0LCBpc0hvdmVyZWQsIGhpdFRlc3REYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VSZW5kZXJlci5kcmF3KHRhcmdldCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3QmFja2dyb3VuZCh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZVJlbmRlcmVyLmRyYXdCYWNrZ3JvdW5kPy4odGFyZ2V0KTtcbiAgICB9XG59XG5jbGFzcyBQcmltaXRpdmVQYW5lVmlld1dyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhbmVWaWV3KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPSBwYW5lVmlldztcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICBjb25zdCBiYXNlUmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5yZW5kZXJlcigpO1xuICAgICAgICBpZiAoYmFzZVJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2FjaGU/Ll9pbnRlcm5hbF9iYXNlID09PSBiYXNlUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYWNoZS5faW50ZXJuYWxfd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVyID0gbmV3IFByaW1pdGl2ZVJlbmRlcmVyV3JhcHBlcihiYXNlUmVuZGVyZXIpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlOiBiYXNlUmVuZGVyZXIsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd3JhcHBlcjogd3JhcHBlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF96T3JkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlldy56T3JkZXI/LigpID8/ICdub3JtYWwnO1xuICAgIH1cbn1cbmNsYXNzIFByaW1pdGl2ZVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaW1pdGl2ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlld3NDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUgPSBwcmltaXRpdmU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmltaXRpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUudXBkYXRlQWxsVmlld3M/LigpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFuZVZpZXdzKCkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS5wYW5lVmlld3M/LigpID8/IFtdO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXdzQ2FjaGU/Ll9pbnRlcm5hbF9iYXNlID09PSBiYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXdzQ2FjaGUuX2ludGVybmFsX3dyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGJhc2UubWFwKChwdykgPT4gbmV3IFByaW1pdGl2ZVBhbmVWaWV3V3JhcHBlcihwdykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlld3NDYWNoZSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlOiBiYXNlLFxuICAgICAgICAgICAgX2ludGVybmFsX3dyYXBwZXI6IHdyYXBwZXIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaGl0VGVzdCh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlLmhpdFRlc3Q/Lih4LCB5KSA/PyBudWxsO1xuICAgIH1cbn1cbmxldCBQYW5lUHJpbWl0aXZlV3JhcHBlciQxID0gY2xhc3MgUGFuZVByaW1pdGl2ZVdyYXBwZXIgZXh0ZW5kcyBQcmltaXRpdmVXcmFwcGVyIHtcbiAgICBfaW50ZXJuYWxfbGFiZWxQYW5lVmlld3MoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuXG5jbGFzcyBTZXJpZXNQcmltaXRpdmVSZW5kZXJlcldyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VSZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlUmVuZGVyZXIgPSBiYXNlUmVuZGVyZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3KHRhcmdldCwgaXNIb3ZlcmVkLCBoaXRUZXN0RGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlUmVuZGVyZXIuZHJhdyh0YXJnZXQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhd0JhY2tncm91bmQodGFyZ2V0LCBpc0hvdmVyZWQsIGhpdFRlc3REYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VSZW5kZXJlci5kcmF3QmFja2dyb3VuZD8uKHRhcmdldCk7XG4gICAgfVxufVxuY2xhc3MgU2VyaWVzUHJpbWl0aXZlUGFuZVZpZXdXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYW5lVmlldykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3ID0gcGFuZVZpZXc7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgY29uc3QgYmFzZVJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcucmVuZGVyZXIoKTtcbiAgICAgICAgaWYgKGJhc2VSZW5kZXJlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NhY2hlPy5faW50ZXJuYWxfYmFzZSA9PT0gYmFzZVJlbmRlcmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2FjaGUuX2ludGVybmFsX3dyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IG5ldyBTZXJpZXNQcmltaXRpdmVSZW5kZXJlcldyYXBwZXIoYmFzZVJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFzZTogYmFzZVJlbmRlcmVyLFxuICAgICAgICAgICAgX2ludGVybmFsX3dyYXBwZXI6IHdyYXBwZXIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfek9yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcuek9yZGVyPy4oKSA/PyAnbm9ybWFsJztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRBeGlzVmlld0RhdGEoYmFzZVZpZXcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZXJuYWxfdGV4dDogYmFzZVZpZXcudGV4dCgpLFxuICAgICAgICBfaW50ZXJuYWxfY29vcmRpbmF0ZTogYmFzZVZpZXcuY29vcmRpbmF0ZSgpLFxuICAgICAgICBfaW50ZXJuYWxfZml4ZWRDb29yZGluYXRlOiBiYXNlVmlldy5maXhlZENvb3JkaW5hdGU/LigpLFxuICAgICAgICBfaW50ZXJuYWxfY29sb3I6IGJhc2VWaWV3LnRleHRDb2xvcigpLFxuICAgICAgICBfaW50ZXJuYWxfYmFja2dyb3VuZDogYmFzZVZpZXcuYmFja0NvbG9yKCksXG4gICAgICAgIF9pbnRlcm5hbF92aXNpYmxlOiBiYXNlVmlldy52aXNpYmxlPy4oKSA/PyB0cnVlLFxuICAgICAgICBfaW50ZXJuYWxfdGlja1Zpc2libGU6IGJhc2VWaWV3LnRpY2tWaXNpYmxlPy4oKSA/PyB0cnVlLFxuICAgIH07XG59XG5jbGFzcyBTZXJpZXNQcmltaXRpdmVUaW1lQXhpc1ZpZXdXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlVmlldywgdGltZVNjYWxlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyID0gbmV3IFRpbWVBeGlzVmlld1JlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2VWaWV3ID0gYmFzZVZpZXc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZSA9IHRpbWVTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh7XG4gICAgICAgICAgICBfaW50ZXJuYWxfd2lkdGg6IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfd2lkdGgoKSxcbiAgICAgICAgICAgIC4uLmdldEF4aXNWaWV3RGF0YSh0aGlzLl9wcml2YXRlX19iYXNlVmlldyksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXI7XG4gICAgfVxufVxuY2xhc3MgU2VyaWVzUHJpbWl0aXZlUHJpY2VBeGlzVmlld1dyYXBwZXIgZXh0ZW5kcyBQcmljZUF4aXNWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlVmlldywgcHJpY2VTY2FsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlVmlldyA9IGJhc2VWaWV3O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID0gcHJpY2VTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX191cGRhdGVSZW5kZXJlckRhdGEoYXhpc1JlbmRlcmVyRGF0YSwgcGFuZVJlbmRlcmVyRGF0YSwgY29tbW9uUmVuZGVyZXJEYXRhKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRBeGlzVmlld0RhdGEodGhpcy5fcHJpdmF0ZV9fYmFzZVZpZXcpO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2JhY2tncm91bmQgPSBkYXRhLl9pbnRlcm5hbF9iYWNrZ3JvdW5kO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9jb2xvciA9IGRhdGEuX2ludGVybmFsX2NvbG9yO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsUGFkZGluZyA9IDIgLyAxMiAqIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2ZvbnRTaXplKCk7XG4gICAgICAgIGNvbW1vblJlbmRlcmVyRGF0YS5faW50ZXJuYWxfYWRkaXRpb25hbFBhZGRpbmdUb3AgPSBhZGRpdGlvbmFsUGFkZGluZztcbiAgICAgICAgY29tbW9uUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF9hZGRpdGlvbmFsUGFkZGluZ0JvdHRvbSA9IGFkZGl0aW9uYWxQYWRkaW5nO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2Nvb3JkaW5hdGUgPSBkYXRhLl9pbnRlcm5hbF9jb29yZGluYXRlO1xuICAgICAgICBjb21tb25SZW5kZXJlckRhdGEuX2ludGVybmFsX2ZpeGVkQ29vcmRpbmF0ZSA9IGRhdGEuX2ludGVybmFsX2ZpeGVkQ29vcmRpbmF0ZTtcbiAgICAgICAgYXhpc1JlbmRlcmVyRGF0YS5faW50ZXJuYWxfdGV4dCA9IGRhdGEuX2ludGVybmFsX3RleHQ7XG4gICAgICAgIGF4aXNSZW5kZXJlckRhdGEuX2ludGVybmFsX3Zpc2libGUgPSBkYXRhLl9pbnRlcm5hbF92aXNpYmxlO1xuICAgICAgICBheGlzUmVuZGVyZXJEYXRhLl9pbnRlcm5hbF90aWNrVmlzaWJsZSA9IGRhdGEuX2ludGVybmFsX3RpY2tWaXNpYmxlO1xuICAgIH1cbn1cbmNsYXNzIFNlcmllc1ByaW1pdGl2ZVdyYXBwZXIgZXh0ZW5kcyBQcmltaXRpdmVXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmltaXRpdmUsIHNlcmllcykge1xuICAgICAgICBzdXBlcihwcmltaXRpdmUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1ZpZXdzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3c0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzUGFuZVZpZXdzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1BhbmVWaWV3c0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gc2VyaWVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGltZUF4aXNWaWV3cygpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUudGltZUF4aXNWaWV3cz8uKCkgPz8gW107XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190aW1lQXhpc1ZpZXdzQ2FjaGU/Ll9pbnRlcm5hbF9iYXNlID09PSBiYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNWaWV3c0NhY2hlLl9pbnRlcm5hbF93cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBiYXNlLm1hcCgoYXcpID0+IG5ldyBTZXJpZXNQcmltaXRpdmVUaW1lQXhpc1ZpZXdXcmFwcGVyKGF3LCB0aW1lU2NhbGUpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNWaWV3c0NhY2hlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2U6IGJhc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd3JhcHBlcjogd3JhcHBlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZUF4aXNWaWV3cygpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUucHJpY2VBeGlzVmlld3M/LigpID8/IFtdO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlld3NDYWNoZT8uX2ludGVybmFsX2Jhc2UgPT09IGJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3c0NhY2hlLl9pbnRlcm5hbF93cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGJhc2UubWFwKChhdykgPT4gbmV3IFNlcmllc1ByaW1pdGl2ZVByaWNlQXhpc1ZpZXdXcmFwcGVyKGF3LCBwcmljZVNjYWxlKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1ZpZXdzQ2FjaGUgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFzZTogYmFzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF93cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlQXhpc1BhbmVWaWV3cygpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUucHJpY2VBeGlzUGFuZVZpZXdzPy4oKSA/PyBbXTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1BhbmVWaWV3c0NhY2hlPy5faW50ZXJuYWxfYmFzZSA9PT0gYmFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlQXhpc1BhbmVWaWV3c0NhY2hlLl9pbnRlcm5hbF93cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBiYXNlLm1hcCgocHcpID0+IG5ldyBTZXJpZXNQcmltaXRpdmVQYW5lVmlld1dyYXBwZXIocHcpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzUGFuZVZpZXdzQ2FjaGUgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFzZTogYmFzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF93cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3RpbWVBeGlzUGFuZVZpZXdzKCkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS50aW1lQXhpc1BhbmVWaWV3cz8uKCkgPz8gW107XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190aW1lQXhpc1BhbmVWaWV3c0NhY2hlPy5faW50ZXJuYWxfYmFzZSA9PT0gYmFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzUGFuZVZpZXdzQ2FjaGUuX2ludGVybmFsX3dyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGJhc2UubWFwKChwdykgPT4gbmV3IFNlcmllc1ByaW1pdGl2ZVBhbmVWaWV3V3JhcHBlcihwdykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1BhbmVWaWV3c0NhY2hlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2U6IGJhc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd3JhcHBlcjogd3JhcHBlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hdXRvc2NhbGVJbmZvKHN0YXJ0VGltZVBvaW50LCBlbmRUaW1lUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlLmF1dG9zY2FsZUluZm8/LihzdGFydFRpbWVQb2ludCwgZW5kVGltZVBvaW50KSA/PyBudWxsKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQcmltaXRpdmVQYW5lVmlld3MocHJpbWl0aXZlcywgZXh0cmFjdG9yLCB6T3JkZXIsIGRlc3RpbmF0aW9uKSB7XG4gICAgcHJpbWl0aXZlcy5mb3JFYWNoKCh3cmFwcGVyKSA9PiB7XG4gICAgICAgIGV4dHJhY3Rvcih3cmFwcGVyKS5mb3JFYWNoKChwYW5lVmlldykgPT4ge1xuICAgICAgICAgICAgaWYgKHBhbmVWaWV3Ll9pbnRlcm5hbF96T3JkZXIoKSAhPT0gek9yZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaChwYW5lVmlldyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJpbWl0aXZlUGFuZVZpZXdzRXh0cmFjdG9yKHdyYXBwZXIpIHtcbiAgICByZXR1cm4gd3JhcHBlci5faW50ZXJuYWxfcGFuZVZpZXdzKCk7XG59XG5mdW5jdGlvbiBwcmltaXRpdmVQcmljZVBhbmVWaWV3c0V4dHJhY3Rvcih3cmFwcGVyKSB7XG4gICAgcmV0dXJuIHdyYXBwZXIuX2ludGVybmFsX3ByaWNlQXhpc1BhbmVWaWV3cygpO1xufVxuZnVuY3Rpb24gcHJpbWl0aXZlVGltZVBhbmVWaWV3c0V4dHJhY3Rvcih3cmFwcGVyKSB7XG4gICAgcmV0dXJuIHdyYXBwZXIuX2ludGVybmFsX3RpbWVBeGlzUGFuZVZpZXdzKCk7XG59XG5jb25zdCBsaW5lQmFzZWRTZXJpZXMgPSBbJ0FyZWEnLCAnTGluZScsICdCYXNlbGluZSddO1xuY2xhc3MgU2VyaWVzIGV4dGVuZHMgUHJpY2VEYXRhU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgc2VyaWVzVHlwZSwgb3B0aW9ucywgY3JlYXRlUGFuZVZpZXcsIGN1c3RvbVBhbmVWaWV3KSB7XG4gICAgICAgIHN1cGVyKG1vZGVsKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGNyZWF0ZVNlcmllc1Bsb3RMaXN0KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZVZpZXcgPSBuZXcgU2VyaWVzUHJpY2VMaW5lUGFuZVZpZXcodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2N1c3RvbVByaWNlTGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZUhvcml6b250YWxMaW5lVmlldyA9IG5ldyBTZXJpZXNIb3Jpem9udGFsQmFzZUxpbmVQYW5lVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJDb2xvcmVyQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlID0gc2VyaWVzVHlwZTtcbiAgICAgICAgY29uc3QgcHJpY2VBeGlzVmlldyA9IG5ldyBTZXJpZXNQcmljZUF4aXNWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3cyA9IFtwcmljZUF4aXNWaWV3XTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVByaWNlQXhpc1ZpZXcgPSBuZXcgUGFuZVByaWNlQXhpc1ZpZXcocHJpY2VBeGlzVmlldywgdGhpcywgbW9kZWwpO1xuICAgICAgICBpZiAobGluZUJhc2VkU2VyaWVzLmluY2x1ZGVzKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldyA9IG5ldyBTZXJpZXNMYXN0UHJpY2VBbmltYXRpb25QYW5lVmlldyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNyZWF0ZUZvcm1hdHRlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldyA9IGNyZWF0ZVBhbmVWaWV3KHRoaXMsIHRoaXMuX2ludGVybmFsX21vZGVsKCksIGN1c3RvbVBhbmVWaWV3KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9wcml2YXRlX19hbmltYXRpb25UaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZUxpbmVDb2xvcihsYXN0QmFyQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucHJpY2VMaW5lQ29sb3IgfHwgbGFzdEJhckNvbG9yO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGFzdFZhbHVlRGF0YShnbG9iYWxMYXN0KSB7XG4gICAgICAgIGNvbnN0IG5vRGF0YVJlcyA9IHsgX2ludGVybmFsX25vRGF0YTogdHJ1ZSB9O1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2lzRW1wdHkoKSB8fCBwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9EYXRhUmVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpc2libGVCYXJzID0gdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpO1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdGhpcy5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAodmlzaWJsZUJhcnMgPT09IG51bGwgfHwgZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vRGF0YVJlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIHJhbmdlIG9mIGJhcnMgaW5zaWRlIHJhbmdlXG4gICAgICAgIC8vIFRPRE86IG1ha2UgaXQgbW9yZSBvcHRpbWFsXG4gICAgICAgIGxldCBiYXI7XG4gICAgICAgIGxldCBsYXN0SW5kZXg7XG4gICAgICAgIGlmIChnbG9iYWxMYXN0KSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0QmFyID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfbGFzdCgpO1xuICAgICAgICAgICAgaWYgKGxhc3RCYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9EYXRhUmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFyID0gbGFzdEJhcjtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IGxhc3RCYXIuX2ludGVybmFsX2luZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZW5kQmFyID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfc2VhcmNoKHZpc2libGVCYXJzLl9pbnRlcm5hbF9yaWdodCgpLCAtMSAvKiBNaXNtYXRjaERpcmVjdGlvbi5OZWFyZXN0TGVmdCAqLyk7XG4gICAgICAgICAgICBpZiAoZW5kQmFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vRGF0YVJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhciA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3ZhbHVlQXQoZW5kQmFyLl9pbnRlcm5hbF9pbmRleCk7XG4gICAgICAgICAgICBpZiAoYmFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vRGF0YVJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IGVuZEJhci5faW50ZXJuYWxfaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpY2UgPSBiYXIuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dO1xuICAgICAgICBjb25zdCBiYXJDb2xvcmVyID0gdGhpcy5faW50ZXJuYWxfYmFyQ29sb3JlcigpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGJhckNvbG9yZXIuX2ludGVybmFsX2JhclN0eWxlKGxhc3RJbmRleCwgeyBfaW50ZXJuYWxfdmFsdWU6IGJhciB9KTtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IHByaWNlU2NhbGUuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKHByaWNlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfbm9EYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wcmljZTogcHJpY2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdGV4dDogcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9ybWF0UHJpY2UocHJpY2UsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9mb3JtYXR0ZWRQcmljZUFic29sdXRlOiBwcmljZVNjYWxlLl9pbnRlcm5hbF9mb3JtYXRQcmljZUFic29sdXRlKHByaWNlKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9mb3JtYXR0ZWRQcmljZVBlcmNlbnRhZ2U6IHByaWNlU2NhbGUuX2ludGVybmFsX2Zvcm1hdFByaWNlUGVyY2VudGFnZShwcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpLFxuICAgICAgICAgICAgX2ludGVybmFsX2NvbG9yOiBzdHlsZS5faW50ZXJuYWxfYmFyQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfY29vcmRpbmF0ZTogY29vcmRpbmF0ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pbmRleDogbGFzdEluZGV4LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYmFyQ29sb3JlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2JhckNvbG9yZXJDYWNoZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2JhckNvbG9yZXJDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJDb2xvcmVyQ2FjaGUgPSBuZXcgU2VyaWVzQmFyQ29sb3Jlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2JhckNvbG9yZXJDYWNoZTtcbiAgICB9XG4gICAgX2ludGVybmFsX29wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0UHJpY2VTY2FsZUlkID0gb3B0aW9ucy5wcmljZVNjYWxlSWQ7XG4gICAgICAgIGlmICh0YXJnZXRQcmljZVNjYWxlSWQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXRQcmljZVNjYWxlSWQgIT09IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucHJpY2VTY2FsZUlkKSB7XG4gICAgICAgICAgICAvLyBzZXJpZXMgY2Fubm90IGRvIGl0IGl0c2VsZiwgYXNrIG1vZGVsXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9tb3ZlU2VyaWVzVG9TY2FsZSh0aGlzLCB0YXJnZXRQcmljZVNjYWxlSWQpO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5wcmljZUZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNyZWF0ZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgLy8gdXBkYXRlZCBmb3JtYXR0ZXIgbWlnaHQgYWZmZWN0IHJlbmRlcmluZyAgYW5kIGFzIGEgY29uc2VxdWVuY2Ugb2YgdGhpcyB0aGUgd2lkdGggb2YgcHJpY2UgYXhpcyBtaWdodCBiZSBjaGFuZ2VkXG4gICAgICAgICAgICAvLyB0aHVzIHdlIG5lZWQgdG8gZm9yY2UgdGhlIGNoYXJ0IHRvIGRvIGEgZnVsbCB1cGRhdGUgdG8gYXBwbHkgY2hhbmdlcyBjb3JyZWN0bHlcbiAgICAgICAgICAgIC8vIGZ1bGwgdXBkYXRlIGlzIHF1aXRlIGhlYXZ5IG9wZXJhdGlvbiBpbiB0ZXJtcyBvZiBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gYnV0IHVwZGF0aW5nIGZvcm1hdHRlciBsb29rcyBsaWtlIHF1aXRlIHJhcmUgc28gZm9yY2luZyBhIGZ1bGwgdXBkYXRlIGhlcmUgc2hvdWxkbid0IGFmZmVjdCB0aGUgcGVyZm9ybWFuY2UgYSBsb3RcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF91cGRhdGVTb3VyY2UodGhpcyk7XG4gICAgICAgIC8vIGEgc2VyaWVzIG1pZ2h0IGFmZmVjdCBjcm9zc2hhaXIgYnkgc29tZSBvcHRpb25zIChsaWtlIGNyb3NzaGFpciBtYXJrZXJzKVxuICAgICAgICAvLyB0aGF0J3Mgd2h5IHdlIG5lZWQgdG8gdXBkYXRlIGNyb3NzaGFpciBhcyB3ZWxsXG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3VwZGF0ZUNyb3NzaGFpcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5faW50ZXJuYWxfdXBkYXRlKCdvcHRpb25zJyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEsIHVwZGF0ZUluZm8pIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfc2V0RGF0YShkYXRhKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcuX2ludGVybmFsX3VwZGF0ZSgnZGF0YScpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGVJbmZvICYmIHVwZGF0ZUluZm8uX2ludGVybmFsX2xhc3RCYXJVcGRhdGVkT3JOZXdCYXJzQWRkZWRUb1RoZVJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXcuX2ludGVybmFsX29uTmV3UmVhbHRpbWVEYXRhUmVjZWl2ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXcuX2ludGVybmFsX29uRGF0YUNsZWFyZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VQYW5lID0gdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcGFuZUZvclNvdXJjZSh0aGlzKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcmVjYWxjdWxhdGVQYW5lKHNvdXJjZVBhbmUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF91cGRhdGVTb3VyY2UodGhpcyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3VwZGF0ZUNyb3NzaGFpcigpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY3JlYXRlUHJpY2VMaW5lKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEN1c3RvbVByaWNlTGluZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3VzdG9tUHJpY2VMaW5lcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3VwZGF0ZVNvdXJjZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbW92ZVByaWNlTGluZShsaW5lKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fY3VzdG9tUHJpY2VMaW5lcy5pbmRleE9mKGxpbmUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jdXN0b21QcmljZUxpbmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdXBkYXRlU291cmNlKHRoaXMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VMaW5lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2N1c3RvbVByaWNlTGluZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXJpZXNUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZpcnN0VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IGJhciA9IHRoaXMuX2ludGVybmFsX2ZpcnN0QmFyKCk7XG4gICAgICAgIGlmIChiYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdmFsdWU6IGJhci5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL10sXG4gICAgICAgICAgICBfaW50ZXJuYWxfdGltZVBvaW50OiBiYXIuX2ludGVybmFsX3RpbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9maXJzdEJhcigpIHtcbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIGlmICh2aXNpYmxlQmFycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lUG9pbnQgPSB2aXNpYmxlQmFycy5faW50ZXJuYWxfbGVmdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfc2VhcmNoKHN0YXJ0VGltZVBvaW50LCAxIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5lYXJlc3RSaWdodCAqLyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9iYXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RhdGFBdCh0aW1lKSB7XG4gICAgICAgIGNvbnN0IHByaWNlcyA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3ZhbHVlQXQodGltZSk7XG4gICAgICAgIGlmIChwcmljZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlID09PSAnQmFyJyB8fCB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlID09PSAnQ2FuZGxlc3RpY2snIHx8IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdDdXN0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9vcGVuOiBwcmljZXMuX2ludGVybmFsX3ZhbHVlWzAgLyogUGxvdFJvd1ZhbHVlSW5kZXguT3BlbiAqL10sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2hpZ2g6IHByaWNlcy5faW50ZXJuYWxfdmFsdWVbMSAvKiBQbG90Um93VmFsdWVJbmRleC5IaWdoICovXSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbG93OiBwcmljZXMuX2ludGVybmFsX3ZhbHVlWzIgLyogUGxvdFJvd1ZhbHVlSW5kZXguTG93ICovXSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfY2xvc2U6IHByaWNlcy5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByaWNlcy5faW50ZXJuYWxfdmFsdWVbMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqL107XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3RvcFBhbmVWaWV3cyhwYW5lKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBleHRyYWN0UHJpbWl0aXZlUGFuZVZpZXdzKHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMsIHByaW1pdGl2ZVBhbmVWaWV3c0V4dHJhY3RvciwgJ3RvcCcsIHJlcyk7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvblBhbmVWaWV3ID0gdGhpcy5fcHJpdmF0ZV9fbGFzdFByaWNlQW5pbWF0aW9uUGFuZVZpZXc7XG4gICAgICAgIGlmIChhbmltYXRpb25QYW5lVmlldyA9PT0gbnVsbCB8fCAhYW5pbWF0aW9uUGFuZVZpZXcuX2ludGVybmFsX3Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYW5pbWF0aW9uVGltZW91dElkID09PSBudWxsICYmIGFuaW1hdGlvblBhbmVWaWV3Ll9pbnRlcm5hbF9hbmltYXRpb25BY3RpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYW5pbWF0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYW5pbWF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9jdXJzb3JVcGRhdGUoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvblBhbmVWaWV3Ll9pbnRlcm5hbF9pbnZhbGlkYXRlU3RhZ2UoKTtcbiAgICAgICAgcmVzLnVuc2hpZnQoYW5pbWF0aW9uUGFuZVZpZXcpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFuZVZpZXdzKCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19pc092ZXJsYXkoKSkge1xuICAgICAgICAgICAgcmVzLnB1c2godGhpcy5fcHJpdmF0ZV9fYmFzZUhvcml6b250YWxMaW5lVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2godGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcsIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZVZpZXcpO1xuICAgICAgICBjb25zdCBwcmljZUxpbmVWaWV3cyA9IHRoaXMuX3ByaXZhdGVfX2N1c3RvbVByaWNlTGluZXMubWFwKChsaW5lKSA9PiBsaW5lLl9pbnRlcm5hbF9wYW5lVmlldygpKTtcbiAgICAgICAgcmVzLnB1c2goLi4ucHJpY2VMaW5lVmlld3MpO1xuICAgICAgICBleHRyYWN0UHJpbWl0aXZlUGFuZVZpZXdzKHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMsIHByaW1pdGl2ZVBhbmVWaWV3c0V4dHJhY3RvciwgJ25vcm1hbCcsIHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9ib3R0b21QYW5lVmlld3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19leHRyYWN0UGFuZVZpZXdzKHByaW1pdGl2ZVBhbmVWaWV3c0V4dHJhY3RvciwgJ2JvdHRvbScpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VQYW5lVmlld3Moek9yZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19leHRyYWN0UGFuZVZpZXdzKHByaW1pdGl2ZVByaWNlUGFuZVZpZXdzRXh0cmFjdG9yLCB6T3JkZXIpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGltZVBhbmVWaWV3cyh6T3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2V4dHJhY3RQYW5lVmlld3MocHJpbWl0aXZlVGltZVBhbmVWaWV3c0V4dHJhY3Rvciwgek9yZGVyKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaW1pdGl2ZUhpdFRlc3QoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlc1xuICAgICAgICAgICAgLm1hcCgocHJpbWl0aXZlKSA9PiBwcmltaXRpdmUuX2ludGVybmFsX2hpdFRlc3QoeCwgeSkpXG4gICAgICAgICAgICAuZmlsdGVyKChyZXN1bHQpID0+IHJlc3VsdCAhPT0gbnVsbCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sYWJlbFBhbmVWaWV3cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVQcmljZUF4aXNWaWV3LFxuICAgICAgICAgICAgLi4udGhpcy5fcHJpdmF0ZV9fY3VzdG9tUHJpY2VMaW5lcy5tYXAoKGxpbmUpID0+IGxpbmUuX2ludGVybmFsX2xhYmVsUGFuZVZpZXcoKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZUF4aXNWaWV3cyhwYW5lLCBwcmljZVNjYWxlKSB7XG4gICAgICAgIGlmIChwcmljZVNjYWxlICE9PSB0aGlzLl9pbnRlcm5hbF9fcHJpY2VTY2FsZSAmJiAhdGhpcy5fcHJpdmF0ZV9faXNPdmVybGF5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4udGhpcy5fcHJpdmF0ZV9fcHJpY2VBeGlzVmlld3NdO1xuICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbVByaWNlTGluZSBvZiB0aGlzLl9wcml2YXRlX19jdXN0b21QcmljZUxpbmVzKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXN0b21QcmljZUxpbmUuX2ludGVybmFsX3ByaWNlQXhpc1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5mb3JFYWNoKCh3cmFwcGVyKSA9PiB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCguLi53cmFwcGVyLl9pbnRlcm5hbF9wcmljZUF4aXNWaWV3cygpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lQXhpc1ZpZXdzKCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5mb3JFYWNoKCh3cmFwcGVyKSA9PiB7XG4gICAgICAgICAgICByZXMucHVzaCguLi53cmFwcGVyLl9pbnRlcm5hbF90aW1lQXhpc1ZpZXdzKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2ludGVybmFsX2F1dG9zY2FsZUluZm8oc3RhcnRUaW1lUG9pbnQsIGVuZFRpbWVQb2ludCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5hdXRvc2NhbGVJbmZvUHJvdmlkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgYXV0b3NjYWxlSW5mbyA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYXV0b3NjYWxlSW5mb1Byb3ZpZGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9wcml2YXRlX19hdXRvc2NhbGVJbmZvSW1wbChzdGFydFRpbWVQb2ludCwgZW5kVGltZVBvaW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlcyA9PT0gbnVsbCkgPyBudWxsIDogcmVzLl9pbnRlcm5hbF90b1JhdygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gQXV0b3NjYWxlSW5mb0ltcGwuX2ludGVybmFsX2Zyb21SYXcoYXV0b3NjYWxlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2F1dG9zY2FsZUluZm9JbXBsKHN0YXJ0VGltZVBvaW50LCBlbmRUaW1lUG9pbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbWluTW92ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucHJpY2VGb3JtYXQubWluTW92ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Zvcm1hdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZUFsbFZpZXdzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIGZvciAoY29uc3QgcHJpY2VBeGlzVmlldyBvZiB0aGlzLl9wcml2YXRlX19wcmljZUF4aXNWaWV3cykge1xuICAgICAgICAgICAgcHJpY2VBeGlzVmlldy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjdXN0b21QcmljZUxpbmUgb2YgdGhpcy5fcHJpdmF0ZV9fY3VzdG9tUHJpY2VMaW5lcykge1xuICAgICAgICAgICAgY3VzdG9tUHJpY2VMaW5lLl9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZUxpbmVWaWV3Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZUhvcml6b250YWxMaW5lVmlldy5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xhc3RQcmljZUFuaW1hdGlvblBhbmVWaWV3Py5faW50ZXJuYWxfdXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMuZm9yRWFjaCgod3JhcHBlcikgPT4gd3JhcHBlci5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gZW5zdXJlTm90TnVsbChzdXBlci5faW50ZXJuYWxfcHJpY2VTY2FsZSgpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX21hcmtlckRhdGFBdEluZGV4KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGdldFZhbHVlID0gKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdMaW5lJyB8fCB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlID09PSAnQXJlYScgfHwgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSA9PT0gJ0Jhc2VsaW5lJykgJiZcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuY3Jvc3NoYWlyTWFya2VyVmlzaWJsZTtcbiAgICAgICAgaWYgKCFnZXRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFyID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmFsdWVBdChpbmRleCk7XG4gICAgICAgIGlmIChiYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlID0gYmFyLl9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gdGhpcy5fcHJpdmF0ZV9fbWFya2VyUmFkaXVzKCk7XG4gICAgICAgIGNvbnN0IGJvcmRlckNvbG9yID0gdGhpcy5fcHJpdmF0ZV9fbWFya2VyQm9yZGVyQ29sb3IoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0aGlzLl9wcml2YXRlX19tYXJrZXJCb3JkZXJXaWR0aCgpO1xuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl9wcml2YXRlX19tYXJrZXJCYWNrZ3JvdW5kQ29sb3IoaW5kZXgpO1xuICAgICAgICByZXR1cm4geyBfaW50ZXJuYWxfcHJpY2U6IHByaWNlLCBfaW50ZXJuYWxfcmFkaXVzOiByYWRpdXMsIF9pbnRlcm5hbF9ib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IsIF9pbnRlcm5hbF9ib3JkZXJXaWR0aDogYm9yZGVyV2lkdGgsIF9pbnRlcm5hbF9iYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvciB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpdGxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudmlzaWJsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2F0dGFjaFByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5wdXNoKG5ldyBTZXJpZXNQcmltaXRpdmVXcmFwcGVyKHByaW1pdGl2ZSwgdGhpcykpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGV0YWNoUHJpbWl0aXZlKHNvdXJjZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzID0gdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5maWx0ZXIoKHdyYXBwZXIpID0+IHdyYXBwZXIuX2ludGVybmFsX3ByaW1pdGl2ZSgpICE9PSBzb3VyY2UpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY3VzdG9tU2VyaWVzUGxvdFZhbHVlc0J1aWxkZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlICE9PSAnQ3VzdG9tJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5faW50ZXJuYWxfcHJpY2VWYWx1ZUJ1aWxkZXIoZGF0YSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jdXN0b21TZXJpZXNXaGl0ZXNwYWNlQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlICE9PSAnQ3VzdG9tJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5faW50ZXJuYWxfaXNXaGl0ZXNwYWNlKGRhdGEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZnVsZmlsbGVkSW5kaWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2luZGljZXMoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2lzT3ZlcmxheSgpIHtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgcmV0dXJuICFpc0RlZmF1bHRQcmljZVNjYWxlKHByaWNlU2NhbGUuX2ludGVybmFsX2lkKCkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYXV0b3NjYWxlSW5mb0ltcGwoc3RhcnRUaW1lUG9pbnQsIGVuZFRpbWVQb2ludCkge1xuICAgICAgICBpZiAoIWlzSW50ZWdlcihzdGFydFRpbWVQb2ludCkgfHwgIWlzSW50ZWdlcihlbmRUaW1lUG9pbnQpIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpc1xuICAgICAgICAvLyBzZXJpZXMgZGF0YSBpcyBzdHJvbmdseSBoYXJkY29kZWQgdG8ga2VlcCBiYXJzXG4gICAgICAgIGNvbnN0IHBsb3RzID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSA9PT0gJ0xpbmUnIHx8IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdBcmVhJyB8fCB0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlID09PSAnQmFzZWxpbmUnIHx8IHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUgPT09ICdIaXN0b2dyYW0nXG4gICAgICAgICAgICA/IFszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXVxuICAgICAgICAgICAgOiBbMiAvKiBQbG90Um93VmFsdWVJbmRleC5Mb3cgKi8sIDEgLyogUGxvdFJvd1ZhbHVlSW5kZXguSGlnaCAqL107XG4gICAgICAgIGNvbnN0IGJhcnNNaW5NYXggPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9taW5NYXhPblJhbmdlQ2FjaGVkKHN0YXJ0VGltZVBvaW50LCBlbmRUaW1lUG9pbnQsIHBsb3RzKTtcbiAgICAgICAgbGV0IHJhbmdlID0gYmFyc01pbk1heCAhPT0gbnVsbCA/IG5ldyBQcmljZVJhbmdlSW1wbChiYXJzTWluTWF4Ll9pbnRlcm5hbF9taW4sIGJhcnNNaW5NYXguX2ludGVybmFsX21heCkgOiBudWxsO1xuICAgICAgICBsZXQgbWFyZ2lucyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9zZXJpZXNUeXBlKCkgPT09ICdIaXN0b2dyYW0nKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5iYXNlO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2VXaXRoQmFzZSA9IG5ldyBQcmljZVJhbmdlSW1wbChiYXNlLCBiYXNlKTtcbiAgICAgICAgICAgIHJhbmdlID0gcmFuZ2UgIT09IG51bGwgPyByYW5nZS5faW50ZXJuYWxfbWVyZ2UocmFuZ2VXaXRoQmFzZSkgOiByYW5nZVdpdGhCYXNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMuZm9yRWFjaCgocHJpbWl0aXZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmltaXRpdmVBdXRvc2NhbGUgPSBwcmltaXRpdmUuX2ludGVybmFsX2F1dG9zY2FsZUluZm8oc3RhcnRUaW1lUG9pbnQsIGVuZFRpbWVQb2ludCk7XG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlQXV0b3NjYWxlPy5wcmljZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpbWl0aXZlUmFuZ2UgPSBuZXcgUHJpY2VSYW5nZUltcGwocHJpbWl0aXZlQXV0b3NjYWxlLnByaWNlUmFuZ2UubWluVmFsdWUsIHByaW1pdGl2ZUF1dG9zY2FsZS5wcmljZVJhbmdlLm1heFZhbHVlKTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHJhbmdlICE9PSBudWxsID8gcmFuZ2UuX2ludGVybmFsX21lcmdlKHByaW1pdGl2ZVJhbmdlKSA6IHByaW1pdGl2ZVJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaW1pdGl2ZUF1dG9zY2FsZT8ubWFyZ2lucykge1xuICAgICAgICAgICAgICAgIG1hcmdpbnMgPSBwcmltaXRpdmVBdXRvc2NhbGUubWFyZ2lucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQXV0b3NjYWxlSW5mb0ltcGwocmFuZ2UsIG1hcmdpbnMpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWFya2VyUmFkaXVzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0xpbmUnOlxuICAgICAgICAgICAgY2FzZSAnQXJlYSc6XG4gICAgICAgICAgICBjYXNlICdCYXNlbGluZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuY3Jvc3NoYWlyTWFya2VyUmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWFya2VyQm9yZGVyQ29sb3IoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTGluZSc6XG4gICAgICAgICAgICBjYXNlICdBcmVhJzpcbiAgICAgICAgICAgIGNhc2UgJ0Jhc2VsaW5lJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNyb3NzaGFpck1hcmtlckJvcmRlckNvbG9yID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5jcm9zc2hhaXJNYXJrZXJCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAoY3Jvc3NoYWlyTWFya2VyQm9yZGVyQ29sb3IubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc2hhaXJNYXJrZXJCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXJrZXJCb3JkZXJXaWR0aCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9wcml2YXRlX19zZXJpZXNUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdMaW5lJzpcbiAgICAgICAgICAgIGNhc2UgJ0FyZWEnOlxuICAgICAgICAgICAgY2FzZSAnQmFzZWxpbmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmNyb3NzaGFpck1hcmtlckJvcmRlcldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWFya2VyQmFja2dyb3VuZENvbG9yKGluZGV4KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTGluZSc6XG4gICAgICAgICAgICBjYXNlICdBcmVhJzpcbiAgICAgICAgICAgIGNhc2UgJ0Jhc2VsaW5lJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvciA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuY3Jvc3NoYWlyTWFya2VyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGlmIChjcm9zc2hhaXJNYXJrZXJCYWNrZ3JvdW5kQ29sb3IubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc2hhaXJNYXJrZXJCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9iYXJDb2xvcmVyKCkuX2ludGVybmFsX2JhclN0eWxlKGluZGV4KS5faW50ZXJuYWxfYmFyQ29sb3I7XG4gICAgfVxuICAgIF9wcml2YXRlX19yZWNyZWF0ZUZvcm1hdHRlcigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9wcml2YXRlX19vcHRpb25zLnByaWNlRm9ybWF0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2N1c3RvbSc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXIgPSB7IGZvcm1hdDogdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZUZvcm1hdC5mb3JtYXR0ZXIgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3ZvbHVtZSc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXIgPSBuZXcgVm9sdW1lRm9ybWF0dGVyKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucHJpY2VGb3JtYXQucHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3BlcmNlbnQnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyID0gbmV3IFBlcmNlbnRhZ2VGb3JtYXR0ZXIodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZUZvcm1hdC5wcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBNYXRoLnBvdygxMCwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wcmljZUZvcm1hdC5wcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlciA9IG5ldyBQcmljZUZvcm1hdHRlcihwcmljZVNjYWxlLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLnByaWNlRm9ybWF0Lm1pbk1vdmUgKiBwcmljZVNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX3ByaWNlU2NhbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19wcmljZVNjYWxlLl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZXh0cmFjdFBhbmVWaWV3cyhleHRyYWN0b3IsIHpPcmRlcikge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZXh0cmFjdFByaW1pdGl2ZVBhbmVWaWV3cyh0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzLCBleHRyYWN0b3IsIHpPcmRlciwgcmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbmNvbnN0IG1hZ25ldFBsb3RSb3dLZXlzID0gW1xuICAgIDMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi8sXG5dO1xuY29uc3QgbWFnbmV0T0hMQ1Bsb3RSb3dLZXlzID0gW1xuICAgIDAgLyogUGxvdFJvd1ZhbHVlSW5kZXguT3BlbiAqLyxcbiAgICAxIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkhpZ2ggKi8sXG4gICAgMiAvKiBQbG90Um93VmFsdWVJbmRleC5Mb3cgKi8sXG4gICAgMyAvKiBQbG90Um93VmFsdWVJbmRleC5DbG9zZSAqLyxcbl07XG5jbGFzcyBNYWduZXQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hbGlnbihwcmljZSwgaW5kZXgsIHBhbmUpIHtcbiAgICAgICAgbGV0IHJlcyA9IHByaWNlO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tb2RlID09PSAwIC8qIENyb3NzaGFpck1vZGUuTm9ybWFsICovKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcmljZVNjYWxlID0gcGFuZS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKTtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IGRlZmF1bHRQcmljZVNjYWxlLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHkgPSBkZWZhdWx0UHJpY2VTY2FsZS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUocHJpY2UsIGZpcnN0VmFsdWUpO1xuICAgICAgICAvLyBnZXQgYWxsIHNlcmllc2VzIGZyb20gdGhlIHBhbmVcbiAgICAgICAgY29uc3Qgc2VyaWVzZXMgPSBwYW5lLl9pbnRlcm5hbF9kYXRhU291cmNlcygpLmZpbHRlcigoKGRzKSA9PiAoZHMgaW5zdGFuY2VvZiBTZXJpZXMpKSk7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBzZXJpZXNlcy5yZWR1Y2UoKGFjYywgc2VyaWVzKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFuZS5faW50ZXJuYWxfaXNPdmVybGF5KHNlcmllcykgfHwgIXNlcmllcy5faW50ZXJuYWxfdmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBzID0gc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgICAgICBjb25zdCBiYXJzID0gc2VyaWVzLl9pbnRlcm5hbF9iYXJzKCk7XG4gICAgICAgICAgICBpZiAocHMuX2ludGVybmFsX2lzRW1wdHkoKSB8fCAhYmFycy5faW50ZXJuYWxfY29udGFpbnMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhciA9IGJhcnMuX2ludGVybmFsX3ZhbHVlQXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGJhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGJhciB0byBwaXhlbHNcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UHJpY2UgPSBlbnN1cmUoc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCkpO1xuICAgICAgICAgICAgY29uc3QgcGxvdFJvd0tleXMgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGUgPT09IDMgLyogQ3Jvc3NoYWlyTW9kZS5NYWduZXRPSExDICovXG4gICAgICAgICAgICAgICAgPyBtYWduZXRPSExDUGxvdFJvd0tleXNcbiAgICAgICAgICAgICAgICA6IG1hZ25ldFBsb3RSb3dLZXlzO1xuICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGxvdFJvd0tleXMubWFwKChrZXkpID0+IHBzLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShiYXIuX2ludGVybmFsX3ZhbHVlW2tleV0sIGZpcnN0UHJpY2UuX2ludGVybmFsX3ZhbHVlKSkpO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYW5kaWRhdGVzLnNvcnQoKHkxLCB5MikgPT4gTWF0aC5hYnMoeTEgLSB5KSAtIE1hdGguYWJzKHkyIC0geSkpO1xuICAgICAgICBjb25zdCBuZWFyZXN0ID0gY2FuZGlkYXRlc1swXTtcbiAgICAgICAgcmVzID0gZGVmYXVsdFByaWNlU2NhbGUuX2ludGVybmFsX2Nvb3JkaW5hdGVUb1ByaWNlKG5lYXJlc3QsIGZpcnN0VmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pblZhbCwgbWF4VmFsKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW5WYWwpLCBtYXhWYWwpO1xufVxuZnVuY3Rpb24gaXNCYXNlRGVjaW1hbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBjdXJyZW50ID0gdmFsdWU7IGN1cnJlbnQgPiAxOyBjdXJyZW50IC89IDEwKSB7XG4gICAgICAgIGlmICgoY3VycmVudCAlIDEwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ3JlYXRlck9yRXF1YWwoeDEsIHgyLCBlcHNpbG9uKSB7XG4gICAgcmV0dXJuICh4MiAtIHgxKSA8PSBlcHNpbG9uO1xufVxuZnVuY3Rpb24gZXF1YWwoeDEsIHgyLCBlcHNpbG9uKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHgxIC0geDIpIDwgZXBzaWxvbjtcbn1cbi8vIFdlIGNhbid0IHVzZSBNYXRoLm1pbiguLi5hcnIpIGJlY2F1c2UgdGhhdCB3b3VsZCBvbmx5IHN1cHBvcnQgYXJyYXlzIHNob3J0ZXIgdGhhbiA2NTUzNiBpdGVtcy5cbmZ1bmN0aW9uIG1pbihhcnIpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2FycmF5IGlzIGVtcHR5Jyk7XG4gICAgfVxuICAgIGxldCBtaW5WYWwgPSBhcnJbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFycltpXSA8IG1pblZhbCkge1xuICAgICAgICAgICAgbWluVmFsID0gYXJyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW5WYWw7XG59XG5mdW5jdGlvbiBjZWlsZWRFdmVuKHgpIHtcbiAgICBjb25zdCBjZWlsZWQgPSBNYXRoLmNlaWwoeCk7XG4gICAgcmV0dXJuIChjZWlsZWQgJSAyICE9PSAwKSA/IGNlaWxlZCAtIDEgOiBjZWlsZWQ7XG59XG5mdW5jdGlvbiBjZWlsZWRPZGQoeCkge1xuICAgIGNvbnN0IGNlaWxlZCA9IE1hdGguY2VpbCh4KTtcbiAgICByZXR1cm4gKGNlaWxlZCAlIDIgPT09IDApID8gY2VpbGVkIC0gMSA6IGNlaWxlZDtcbn1cblxuY2xhc3MgR3JpZFJlbmRlcmVyIGV4dGVuZHMgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgX2ludGVybmFsX19kcmF3SW1wbCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZVdpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbykpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBzdHJva2VJblBpeGVsKGN0eCwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fZGF0YSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5faW50ZXJuYWxfdmVydExpbmVzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGRhdGEuX2ludGVybmFsX3ZlcnRMaW5lc0NvbG9yO1xuICAgICAgICAgICAgICAgIHNldExpbmVTdHlsZShjdHgsIGRhdGEuX2ludGVybmFsX3ZlcnRMaW5lU3R5bGUpO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRpbWVNYXJrIG9mIGRhdGEuX2ludGVybmFsX3RpbWVNYXJrcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZCh0aW1lTWFyay5faW50ZXJuYWxfY29vcmQgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgLWxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgYml0bWFwU2l6ZS5oZWlnaHQgKyBsaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5faW50ZXJuYWxfaG9yekxpbmVzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGRhdGEuX2ludGVybmFsX2hvcnpMaW5lc0NvbG9yO1xuICAgICAgICAgICAgICAgIHNldExpbmVTdHlsZShjdHgsIGRhdGEuX2ludGVybmFsX2hvcnpMaW5lU3R5bGUpO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByaWNlTWFyayBvZiBkYXRhLl9pbnRlcm5hbF9wcmljZU1hcmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKHByaWNlTWFyay5faW50ZXJuYWxfY29vcmQgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKC1saW5lV2lkdGgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGJpdG1hcFNpemUud2lkdGggKyBsaW5lV2lkdGgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgR3JpZFBhbmVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihwYW5lKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyID0gbmV3IEdyaWRSZW5kZXJlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUgPSBwYW5lO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCBncmlkT3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX29wdGlvbnMoKS5ncmlkO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaG9yekxpbmVzVmlzaWJsZTogZ3JpZE9wdGlvbnMuaG9yekxpbmVzLnZpc2libGUsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3ZlcnRMaW5lc1Zpc2libGU6IGdyaWRPcHRpb25zLnZlcnRMaW5lcy52aXNpYmxlLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9ob3J6TGluZXNDb2xvcjogZ3JpZE9wdGlvbnMuaG9yekxpbmVzLmNvbG9yLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF92ZXJ0TGluZXNDb2xvcjogZ3JpZE9wdGlvbnMudmVydExpbmVzLmNvbG9yLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9ob3J6TGluZVN0eWxlOiBncmlkT3B0aW9ucy5ob3J6TGluZXMuc3R5bGUsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3ZlcnRMaW5lU3R5bGU6IGdyaWRPcHRpb25zLnZlcnRMaW5lcy5zdHlsZSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfcHJpY2VNYXJrczogdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKS5faW50ZXJuYWxfbWFya3MoKSxcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRoaXMgY29udmVyc2lvbSBiZWNhdXNlIFRpbWVNYXJrIGlzIGEgcGFydCBvZiBleHRlcm5hbCBpbnRlcmZhY2VcbiAgICAgICAgICAgICAgICAvLyBhbmQgZmllbGRzIGluc2lkZSBUaW1lTWFyayBhcmUgbm90IG1pbmlmaWVkXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RpbWVNYXJrczogKHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9tYXJrcygpIHx8IFtdKS5tYXAoKHRtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IF9pbnRlcm5hbF9jb29yZDogdG0uY29vcmQgfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YShkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyO1xuICAgIH1cbn1cblxuY2xhc3MgR3JpZCB7XG4gICAgY29uc3RydWN0b3IocGFuZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlldyA9IG5ldyBHcmlkUGFuZVZpZXcocGFuZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYW5lVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3O1xuICAgIH1cbn1cblxuY29uc3QgZGVmTG9nRm9ybXVsYSA9IHtcbiAgICBfaW50ZXJuYWxfbG9naWNhbE9mZnNldDogNCxcbiAgICBfaW50ZXJuYWxfY29vcmRPZmZzZXQ6IDAuMDAwMSxcbn07XG5mdW5jdGlvbiBmcm9tUGVyY2VudCh2YWx1ZSwgYmFzZVZhbHVlKSB7XG4gICAgaWYgKGJhc2VWYWx1ZSA8IDApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLyAxMDApICogYmFzZVZhbHVlICsgYmFzZVZhbHVlO1xufVxuZnVuY3Rpb24gdG9QZXJjZW50KHZhbHVlLCBiYXNlVmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSAxMDAgKiAodmFsdWUgLSBiYXNlVmFsdWUpIC8gYmFzZVZhbHVlO1xuICAgIHJldHVybiAoYmFzZVZhbHVlIDwgMCA/IC1yZXN1bHQgOiByZXN1bHQpO1xufVxuZnVuY3Rpb24gdG9QZXJjZW50UmFuZ2UocHJpY2VSYW5nZSwgYmFzZVZhbHVlKSB7XG4gICAgY29uc3QgbWluUGVyY2VudCA9IHRvUGVyY2VudChwcmljZVJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpLCBiYXNlVmFsdWUpO1xuICAgIGNvbnN0IG1heFBlcmNlbnQgPSB0b1BlcmNlbnQocHJpY2VSYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSwgYmFzZVZhbHVlKTtcbiAgICByZXR1cm4gbmV3IFByaWNlUmFuZ2VJbXBsKG1pblBlcmNlbnQsIG1heFBlcmNlbnQpO1xufVxuZnVuY3Rpb24gZnJvbUluZGV4ZWRUbzEwMCh2YWx1ZSwgYmFzZVZhbHVlKSB7XG4gICAgdmFsdWUgLT0gMTAwO1xuICAgIGlmIChiYXNlVmFsdWUgPCAwKSB7XG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlIC8gMTAwKSAqIGJhc2VWYWx1ZSArIGJhc2VWYWx1ZTtcbn1cbmZ1bmN0aW9uIHRvSW5kZXhlZFRvMTAwKHZhbHVlLCBiYXNlVmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSAxMDAgKiAodmFsdWUgLSBiYXNlVmFsdWUpIC8gYmFzZVZhbHVlICsgMTAwO1xuICAgIHJldHVybiAoYmFzZVZhbHVlIDwgMCA/IC1yZXN1bHQgOiByZXN1bHQpO1xufVxuZnVuY3Rpb24gdG9JbmRleGVkVG8xMDBSYW5nZShwcmljZVJhbmdlLCBiYXNlVmFsdWUpIHtcbiAgICBjb25zdCBtaW5QZXJjZW50ID0gdG9JbmRleGVkVG8xMDAocHJpY2VSYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSwgYmFzZVZhbHVlKTtcbiAgICBjb25zdCBtYXhQZXJjZW50ID0gdG9JbmRleGVkVG8xMDAocHJpY2VSYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSwgYmFzZVZhbHVlKTtcbiAgICByZXR1cm4gbmV3IFByaWNlUmFuZ2VJbXBsKG1pblBlcmNlbnQsIG1heFBlcmNlbnQpO1xufVxuZnVuY3Rpb24gdG9Mb2cocHJpY2UsIGxvZ0Zvcm11bGEpIHtcbiAgICBjb25zdCBtID0gTWF0aC5hYnMocHJpY2UpO1xuICAgIGlmIChtIDwgMWUtMTUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IE1hdGgubG9nMTAobSArIGxvZ0Zvcm11bGEuX2ludGVybmFsX2Nvb3JkT2Zmc2V0KSArIGxvZ0Zvcm11bGEuX2ludGVybmFsX2xvZ2ljYWxPZmZzZXQ7XG4gICAgcmV0dXJuICgocHJpY2UgPCAwKSA/IC1yZXMgOiByZXMpO1xufVxuZnVuY3Rpb24gZnJvbUxvZyhsb2dpY2FsLCBsb2dGb3JtdWxhKSB7XG4gICAgY29uc3QgbSA9IE1hdGguYWJzKGxvZ2ljYWwpO1xuICAgIGlmIChtIDwgMWUtMTUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IE1hdGgucG93KDEwLCBtIC0gbG9nRm9ybXVsYS5faW50ZXJuYWxfbG9naWNhbE9mZnNldCkgLSBsb2dGb3JtdWxhLl9pbnRlcm5hbF9jb29yZE9mZnNldDtcbiAgICByZXR1cm4gKGxvZ2ljYWwgPCAwKSA/IC1yZXMgOiByZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0UHJpY2VSYW5nZVRvTG9nKHByaWNlUmFuZ2UsIGxvZ0Zvcm11bGEpIHtcbiAgICBpZiAocHJpY2VSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbWluID0gdG9Mb2cocHJpY2VSYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSwgbG9nRm9ybXVsYSk7XG4gICAgY29uc3QgbWF4ID0gdG9Mb2cocHJpY2VSYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSwgbG9nRm9ybXVsYSk7XG4gICAgcmV0dXJuIG5ldyBQcmljZVJhbmdlSW1wbChtaW4sIG1heCk7XG59XG5mdW5jdGlvbiBjYW5Db252ZXJ0UHJpY2VSYW5nZUZyb21Mb2cocHJpY2VSYW5nZSwgbG9nRm9ybXVsYSkge1xuICAgIGlmIChwcmljZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWluID0gZnJvbUxvZyhwcmljZVJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpLCBsb2dGb3JtdWxhKTtcbiAgICBjb25zdCBtYXggPSBmcm9tTG9nKHByaWNlUmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCksIGxvZ0Zvcm11bGEpO1xuICAgIHJldHVybiBpc0Zpbml0ZShtaW4pICYmIGlzRmluaXRlKG1heCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0UHJpY2VSYW5nZUZyb21Mb2cocHJpY2VSYW5nZSwgbG9nRm9ybXVsYSkge1xuICAgIGlmIChwcmljZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtaW4gPSBmcm9tTG9nKHByaWNlUmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCksIGxvZ0Zvcm11bGEpO1xuICAgIGNvbnN0IG1heCA9IGZyb21Mb2cocHJpY2VSYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSwgbG9nRm9ybXVsYSk7XG4gICAgcmV0dXJuIG5ldyBQcmljZVJhbmdlSW1wbChtaW4sIG1heCk7XG59XG5mdW5jdGlvbiBsb2dGb3JtdWxhRm9yUHJpY2VSYW5nZShyYW5nZSkge1xuICAgIGlmIChyYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVmTG9nRm9ybXVsYTtcbiAgICB9XG4gICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpIC0gcmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCkpO1xuICAgIGlmIChkaWZmID49IDEgfHwgZGlmZiA8IDFlLTE1KSB7XG4gICAgICAgIHJldHVybiBkZWZMb2dGb3JtdWxhO1xuICAgIH1cbiAgICBjb25zdCBkaWdpdHMgPSBNYXRoLmNlaWwoTWF0aC5hYnMoTWF0aC5sb2cxMChkaWZmKSkpO1xuICAgIGNvbnN0IGxvZ2ljYWxPZmZzZXQgPSBkZWZMb2dGb3JtdWxhLl9pbnRlcm5hbF9sb2dpY2FsT2Zmc2V0ICsgZGlnaXRzO1xuICAgIGNvbnN0IGNvb3JkT2Zmc2V0ID0gMSAvIE1hdGgucG93KDEwLCBsb2dpY2FsT2Zmc2V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZXJuYWxfbG9naWNhbE9mZnNldDogbG9naWNhbE9mZnNldCxcbiAgICAgICAgX2ludGVybmFsX2Nvb3JkT2Zmc2V0OiBjb29yZE9mZnNldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gbG9nRm9ybXVsYXNBcmVTYW1lKGYxLCBmMikge1xuICAgIHJldHVybiBmMS5faW50ZXJuYWxfbG9naWNhbE9mZnNldCA9PT0gZjIuX2ludGVybmFsX2xvZ2ljYWxPZmZzZXQgJiYgZjEuX2ludGVybmFsX2Nvb3JkT2Zmc2V0ID09PSBmMi5faW50ZXJuYWxfY29vcmRPZmZzZXQ7XG59XG5cbmNsYXNzIFByaWNlVGlja1NwYW5DYWxjdWxhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBpbnRlZ3JhbERpdmlkZXJzKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnRlZ3JhbERpdmlkZXJzID0gaW50ZWdyYWxEaXZpZGVycztcbiAgICAgICAgaWYgKGlzQmFzZURlY2ltYWwodGhpcy5fcHJpdmF0ZV9fYmFzZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZyYWN0aW9uYWxEaXZpZGVycyA9IFsyLCAyLjUsIDJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZnJhY3Rpb25hbERpdmlkZXJzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBiYXNlUmVzdCA9IHRoaXMuX3ByaXZhdGVfX2Jhc2U7IGJhc2VSZXN0ICE9PSAxOykge1xuICAgICAgICAgICAgICAgIGlmICgoYmFzZVJlc3QgJSAyKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mcmFjdGlvbmFsRGl2aWRlcnMucHVzaCgyKTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVJlc3QgLz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGJhc2VSZXN0ICUgNSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZnJhY3Rpb25hbERpdmlkZXJzLnB1c2goMiwgMi41KTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVJlc3QgLz0gNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBiYXNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19mcmFjdGlvbmFsRGl2aWRlcnMubGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc29tZXRoaW5nIHdyb25nIHdpdGggYmFzZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdGlja1NwYW4oaGlnaCwgbG93LCBtYXhUaWNrU3Bhbikge1xuICAgICAgICBjb25zdCBtaW5Nb3ZlbWVudCA9ICh0aGlzLl9wcml2YXRlX19iYXNlID09PSAwKSA/ICgwKSA6ICgxIC8gdGhpcy5fcHJpdmF0ZV9fYmFzZSk7XG4gICAgICAgIGxldCByZXN1bHRUaWNrU3BhbiA9IE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCBNYXRoLmNlaWwoTWF0aC5sb2cxMChoaWdoIC0gbG93KSkpKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgbGV0IGMgPSB0aGlzLl9wcml2YXRlX19pbnRlZ3JhbERpdmlkZXJzWzBdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAvLyB0aGUgc2Vjb25kIHBhcnQgaXMgYWN0dWFsIGZvciBzbWFsbCB3aXRoIHZlcnkgc21hbGwgdmFsdWVzIGxpa2UgMWUtMTBcbiAgICAgICAgICAgIC8vIGdyZWF0ZXJPckVxdWFsIGZhaWxzIGZvciBzdWNoIHZhbHVlc1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0VGlja1NwYW5MYXJnZXJNaW5Nb3ZlbWVudCA9IGdyZWF0ZXJPckVxdWFsKHJlc3VsdFRpY2tTcGFuLCBtaW5Nb3ZlbWVudCwgMWUtMTQgLyogQ29uc3RhbnRzLlRpY2tTcGFuRXBzaWxvbiAqLykgJiYgcmVzdWx0VGlja1NwYW4gPiAobWluTW92ZW1lbnQgKyAxZS0xNCAvKiBDb25zdGFudHMuVGlja1NwYW5FcHNpbG9uICovKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFRpY2tTcGFuTGFyZ2VyTWF4VGlja1NwYW4gPSBncmVhdGVyT3JFcXVhbChyZXN1bHRUaWNrU3BhbiwgbWF4VGlja1NwYW4gKiBjLCAxZS0xNCAvKiBDb25zdGFudHMuVGlja1NwYW5FcHNpbG9uICovKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFRpY2tTcGFuTGFyZ2VyMSA9IGdyZWF0ZXJPckVxdWFsKHJlc3VsdFRpY2tTcGFuLCAxLCAxZS0xNCAvKiBDb25zdGFudHMuVGlja1NwYW5FcHNpbG9uICovKTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVUb0NvbnRpbnVlID0gcmVzdWx0VGlja1NwYW5MYXJnZXJNaW5Nb3ZlbWVudCAmJiByZXN1bHRUaWNrU3Bhbkxhcmdlck1heFRpY2tTcGFuICYmIHJlc3VsdFRpY2tTcGFuTGFyZ2VyMTtcbiAgICAgICAgICAgIGlmICghaGF2ZVRvQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFRpY2tTcGFuIC89IGM7XG4gICAgICAgICAgICBjID0gdGhpcy5fcHJpdmF0ZV9faW50ZWdyYWxEaXZpZGVyc1srK2luZGV4ICUgdGhpcy5fcHJpdmF0ZV9faW50ZWdyYWxEaXZpZGVycy5sZW5ndGhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRUaWNrU3BhbiA8PSAobWluTW92ZW1lbnQgKyAxZS0xNCAvKiBDb25zdGFudHMuVGlja1NwYW5FcHNpbG9uICovKSkge1xuICAgICAgICAgICAgcmVzdWx0VGlja1NwYW4gPSBtaW5Nb3ZlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRUaWNrU3BhbiA9IE1hdGgubWF4KDEsIHJlc3VsdFRpY2tTcGFuKTtcbiAgICAgICAgaWYgKCh0aGlzLl9wcml2YXRlX19mcmFjdGlvbmFsRGl2aWRlcnMubGVuZ3RoID4gMCkgJiYgZXF1YWwocmVzdWx0VGlja1NwYW4sIDEsIDFlLTE0IC8qIENvbnN0YW50cy5UaWNrU3BhbkVwc2lsb24gKi8pKSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICBjID0gdGhpcy5fcHJpdmF0ZV9fZnJhY3Rpb25hbERpdmlkZXJzWzBdO1xuICAgICAgICAgICAgd2hpbGUgKGdyZWF0ZXJPckVxdWFsKHJlc3VsdFRpY2tTcGFuLCBtYXhUaWNrU3BhbiAqIGMsIDFlLTE0IC8qIENvbnN0YW50cy5UaWNrU3BhbkVwc2lsb24gKi8pICYmIHJlc3VsdFRpY2tTcGFuID4gKG1pbk1vdmVtZW50ICsgMWUtMTQgLyogQ29uc3RhbnRzLlRpY2tTcGFuRXBzaWxvbiAqLykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRUaWNrU3BhbiAvPSBjO1xuICAgICAgICAgICAgICAgIGMgPSB0aGlzLl9wcml2YXRlX19mcmFjdGlvbmFsRGl2aWRlcnNbKytpbmRleCAlIHRoaXMuX3ByaXZhdGVfX2ZyYWN0aW9uYWxEaXZpZGVycy5sZW5ndGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRUaWNrU3BhbjtcbiAgICB9XG59XG5cbmNvbnN0IFRJQ0tfREVOU0lUWSA9IDIuNTtcbmNsYXNzIFByaWNlVGlja01hcmtCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmljZVNjYWxlLCBiYXNlLCBjb29yZGluYXRlVG9Mb2dpY2FsRnVuYywgbG9naWNhbFRvQ29vcmRpbmF0ZUZ1bmMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9IHByaWNlU2NhbGU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Jhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9Mb2dpY2FsRnVuYyA9IGNvb3JkaW5hdGVUb0xvZ2ljYWxGdW5jO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb2dpY2FsVG9Db29yZGluYXRlRnVuYyA9IGxvZ2ljYWxUb0Nvb3JkaW5hdGVGdW5jO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGlja1NwYW4oaGlnaCwgbG93KSB7XG4gICAgICAgIGlmIChoaWdoIDwgbG93KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hpZ2ggPCBsb3cnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2FsZUhlaWdodCA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2hlaWdodCgpO1xuICAgICAgICBjb25zdCBtYXJrSGVpZ2h0ID0gdGhpcy5fcHJpdmF0ZV9fdGlja01hcmtIZWlnaHQoKTtcbiAgICAgICAgY29uc3QgbWF4VGlja1NwYW4gPSAoaGlnaCAtIGxvdykgKiBtYXJrSGVpZ2h0IC8gc2NhbGVIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHNwYW5DYWxjdWxhdG9yMSA9IG5ldyBQcmljZVRpY2tTcGFuQ2FsY3VsYXRvcih0aGlzLl9wcml2YXRlX19iYXNlLCBbMiwgMi41LCAyXSk7XG4gICAgICAgIGNvbnN0IHNwYW5DYWxjdWxhdG9yMiA9IG5ldyBQcmljZVRpY2tTcGFuQ2FsY3VsYXRvcih0aGlzLl9wcml2YXRlX19iYXNlLCBbMiwgMiwgMi41XSk7XG4gICAgICAgIGNvbnN0IHNwYW5DYWxjdWxhdG9yMyA9IG5ldyBQcmljZVRpY2tTcGFuQ2FsY3VsYXRvcih0aGlzLl9wcml2YXRlX19iYXNlLCBbMi41LCAyLCAyXSk7XG4gICAgICAgIGNvbnN0IHNwYW5zID0gW107XG4gICAgICAgIHNwYW5zLnB1c2goc3BhbkNhbGN1bGF0b3IxLl9pbnRlcm5hbF90aWNrU3BhbihoaWdoLCBsb3csIG1heFRpY2tTcGFuKSwgc3BhbkNhbGN1bGF0b3IyLl9pbnRlcm5hbF90aWNrU3BhbihoaWdoLCBsb3csIG1heFRpY2tTcGFuKSwgc3BhbkNhbGN1bGF0b3IzLl9pbnRlcm5hbF90aWNrU3BhbihoaWdoLCBsb3csIG1heFRpY2tTcGFuKSk7XG4gICAgICAgIHJldHVybiBtaW4oc3BhbnMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVidWlsZFRpY2tNYXJrcygpIHtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGU7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBwcmljZVNjYWxlLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjYWxlSGVpZ2h0ID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfaGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWxGdW5jKHNjYWxlSGVpZ2h0IC0gMSwgZmlyc3RWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMuX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWxGdW5jKDAsIGZpcnN0VmFsdWUpO1xuICAgICAgICBjb25zdCBleHRyYVRvcEJvdHRvbU1hcmdpbiA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKS5lbnRpcmVUZXh0T25seSA/IHRoaXMuX3ByaXZhdGVfX2ZvbnRIZWlnaHQoKSAvIDIgOiAwO1xuICAgICAgICBjb25zdCBtaW5Db29yZCA9IGV4dHJhVG9wQm90dG9tTWFyZ2luO1xuICAgICAgICBjb25zdCBtYXhDb29yZCA9IHNjYWxlSGVpZ2h0IC0gMSAtIGV4dHJhVG9wQm90dG9tTWFyZ2luO1xuICAgICAgICBjb25zdCBoaWdoID0gTWF0aC5tYXgoYm90dG9tLCB0b3ApO1xuICAgICAgICBjb25zdCBsb3cgPSBNYXRoLm1pbihib3R0b20sIHRvcCk7XG4gICAgICAgIGlmIChoaWdoID09PSBsb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzID0gW107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuX2ludGVybmFsX3RpY2tTcGFuKGhpZ2gsIGxvdyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZU1hcmtzKGZpcnN0VmFsdWUsIHNwYW4sIGhpZ2gsIGxvdywgbWluQ29vcmQsIG1heENvb3JkKTtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUuX2ludGVybmFsX2hhc1Zpc2libGVFZGdlTWFya3MoKSAmJiB0aGlzLl9wcml2YXRlX19zaG91bGRBcHBseUVkZ2VNYXJrcyhzcGFuLCBsb3csIGhpZ2gpKSB7XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZ2V0RWRnZU1hcmtzUGFkZGluZygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXBwbHlFZGdlTWFya3MoZmlyc3RWYWx1ZSwgc3BhbiwgbWluQ29vcmQsIG1heENvb3JkLCBwYWRkaW5nLCBwYWRkaW5nICogMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX21hcmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWFya3M7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb250SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9udFNpemUoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RpY2tNYXJrSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuX3ByaXZhdGVfX2ZvbnRIZWlnaHQoKSAqIFRJQ0tfREVOU0lUWSk7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVNYXJrcyhmaXJzdFZhbHVlLCBzcGFuLCBoaWdoLCBsb3csIG1pbkNvb3JkLCBtYXhDb29yZCkge1xuICAgICAgICBjb25zdCBtYXJrcyA9IHRoaXMuX3ByaXZhdGVfX21hcmtzO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZTtcbiAgICAgICAgbGV0IG1vZCA9IGhpZ2ggJSBzcGFuO1xuICAgICAgICBtb2QgKz0gbW9kIDwgMCA/IHNwYW4gOiAwO1xuICAgICAgICBjb25zdCBzaWduID0gKGhpZ2ggPj0gbG93KSA/IDEgOiAtMTtcbiAgICAgICAgbGV0IHByZXZDb29yZCA9IG51bGw7XG4gICAgICAgIGxldCB0YXJnZXRJbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IGxvZ2ljYWwgPSBoaWdoIC0gbW9kOyBsb2dpY2FsID4gbG93OyBsb2dpY2FsIC09IHNwYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkID0gdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFRvQ29vcmRpbmF0ZUZ1bmMobG9naWNhbCwgZmlyc3RWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBwbGFjZSBmb3IgaXRcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgcmVxdWlyZWQgZm9yIGxvZyBzY2FsZVxuICAgICAgICAgICAgaWYgKHByZXZDb29yZCAhPT0gbnVsbCAmJiBNYXRoLmFicyhjb29yZCAtIHByZXZDb29yZCkgPCB0aGlzLl9wcml2YXRlX190aWNrTWFya0hlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBhIHRpY2sgbWFyayBpcyBwYXJ0aWFsbHkgdmlzaWJsZSBhbmQgc2tpcCBpdCBpZiBlbnRpcmVUZXh0T25seSBpcyB0cnVlXG4gICAgICAgICAgICBpZiAoY29vcmQgPCBtaW5Db29yZCB8fCBjb29yZCA+IG1heENvb3JkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0SW5kZXggPCBtYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtYXJrc1t0YXJnZXRJbmRleF0uX2ludGVybmFsX2Nvb3JkID0gY29vcmQ7XG4gICAgICAgICAgICAgICAgbWFya3NbdGFyZ2V0SW5kZXhdLl9pbnRlcm5hbF9sYWJlbCA9IHByaWNlU2NhbGUuX2ludGVybmFsX2Zvcm1hdExvZ2ljYWwobG9naWNhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2Nvb3JkOiBjb29yZCxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2xhYmVsOiBwcmljZVNjYWxlLl9pbnRlcm5hbF9mb3JtYXRMb2dpY2FsKGxvZ2ljYWwpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICAgICAgICAgIHByZXZDb29yZCA9IGNvb3JkO1xuICAgICAgICAgICAgaWYgKHByaWNlU2NhbGUuX2ludGVybmFsX2lzTG9nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyByZWNhbGMgc3BhblxuICAgICAgICAgICAgICAgIHNwYW4gPSB0aGlzLl9pbnRlcm5hbF90aWNrU3Bhbihsb2dpY2FsICogc2lnbiwgbG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXJrcy5sZW5ndGggPSB0YXJnZXRJbmRleDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2FwcGx5RWRnZU1hcmtzKGZpcnN0VmFsdWUsIHNwYW4sIG1pbkNvb3JkLCBtYXhDb29yZCwgbWluUGFkZGluZywgbWF4UGFkZGluZykge1xuICAgICAgICBjb25zdCBtYXJrcyA9IHRoaXMuX3ByaXZhdGVfX21hcmtzO1xuICAgICAgICAvLyB0b3AgYm91bmRhcnlcbiAgICAgICAgY29uc3QgdG9wTWFyayA9IHRoaXMuX3ByaXZhdGVfX2NvbXB1dGVCb3VuZGFyeVByaWNlTWFyayhmaXJzdFZhbHVlLCBtaW5Db29yZCwgbWluUGFkZGluZywgbWF4UGFkZGluZyk7XG4gICAgICAgIC8vIGJvdHRvbSBib3VuZGFyeVxuICAgICAgICBjb25zdCBib3R0b21NYXJrID0gdGhpcy5fcHJpdmF0ZV9fY29tcHV0ZUJvdW5kYXJ5UHJpY2VNYXJrKGZpcnN0VmFsdWUsIG1heENvb3JkLCAtbWF4UGFkZGluZywgLW1pblBhZGRpbmcpO1xuICAgICAgICBjb25zdCBzcGFuUHggPSB0aGlzLl9wcml2YXRlX19sb2dpY2FsVG9Db29yZGluYXRlRnVuYygwLCBmaXJzdFZhbHVlLCB0cnVlKVxuICAgICAgICAgICAgLSB0aGlzLl9wcml2YXRlX19sb2dpY2FsVG9Db29yZGluYXRlRnVuYyhzcGFuLCBmaXJzdFZhbHVlLCB0cnVlKTtcbiAgICAgICAgaWYgKG1hcmtzLmxlbmd0aCA+IDAgJiYgbWFya3NbMF0uX2ludGVybmFsX2Nvb3JkIC0gdG9wTWFyay5faW50ZXJuYWxfY29vcmQgPCBzcGFuUHggLyAyKSB7XG4gICAgICAgICAgICBtYXJrcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrcy5sZW5ndGggPiAwICYmIGJvdHRvbU1hcmsuX2ludGVybmFsX2Nvb3JkIC0gbWFya3NbbWFya3MubGVuZ3RoIC0gMV0uX2ludGVybmFsX2Nvb3JkIDwgc3BhblB4IC8gMikge1xuICAgICAgICAgICAgbWFya3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MudW5zaGlmdCh0b3BNYXJrKTtcbiAgICAgICAgbWFya3MucHVzaChib3R0b21NYXJrKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NvbXB1dGVCb3VuZGFyeVByaWNlTWFyayhmaXJzdFZhbHVlLCBjb29yZCwgbWluUGFkZGluZywgbWF4UGFkZGluZykge1xuICAgICAgICBjb25zdCBhdmdQYWRkaW5nID0gKG1pblBhZGRpbmcgKyBtYXhQYWRkaW5nKSAvIDI7XG4gICAgICAgIGNvbnN0IHZhbHVlMSA9IHRoaXMuX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWxGdW5jKGNvb3JkICsgbWluUGFkZGluZywgZmlyc3RWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IHRoaXMuX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWxGdW5jKGNvb3JkICsgbWF4UGFkZGluZywgZmlyc3RWYWx1ZSk7XG4gICAgICAgIGNvbnN0IG1pblZhbHVlID0gTWF0aC5taW4odmFsdWUxLCB2YWx1ZTIpO1xuICAgICAgICBjb25zdCBtYXhWYWx1ZSA9IE1hdGgubWF4KHZhbHVlMSwgdmFsdWUyKTtcbiAgICAgICAgY29uc3QgdmFsdWVTcGFuID0gTWF0aC5tYXgoMC4xLCB0aGlzLl9pbnRlcm5hbF90aWNrU3BhbihtYXhWYWx1ZSwgbWluVmFsdWUpKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9Mb2dpY2FsRnVuYyhjb29yZCArIGF2Z1BhZGRpbmcsIGZpcnN0VmFsdWUpO1xuICAgICAgICBjb25zdCByb3VuZGVkVmFsdWUgPSB2YWx1ZSAtICh2YWx1ZSAlIHZhbHVlU3Bhbik7XG4gICAgICAgIGNvbnN0IHJvdW5kZWRDb29yZCA9IHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxUb0Nvb3JkaW5hdGVGdW5jKHJvdW5kZWRWYWx1ZSwgZmlyc3RWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7IF9pbnRlcm5hbF9sYWJlbDogdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9ybWF0TG9naWNhbChyb3VuZGVkVmFsdWUpLCBfaW50ZXJuYWxfY29vcmQ6IHJvdW5kZWRDb29yZCB9O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2hvdWxkQXBwbHlFZGdlTWFya3Moc3BhbiwgbG93LCBoaWdoKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGVuc3VyZSh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9wcmljZVJhbmdlKCkpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNMb2coKSkge1xuICAgICAgICAgICAgcmFuZ2UgPSBjb252ZXJ0UHJpY2VSYW5nZUZyb21Mb2cocmFuZ2UsIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2dldExvZ0Zvcm11bGEoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChyYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSAtIGxvdyA8IHNwYW4pICYmIChoaWdoIC0gcmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCkgPCBzcGFuKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNvcnRTb3VyY2VzKHNvdXJjZXMpIHtcbiAgICByZXR1cm4gc291cmNlcy5zbGljZSgpLnNvcnQoKHMxLCBzMikgPT4ge1xuICAgICAgICByZXR1cm4gKGVuc3VyZU5vdE51bGwoczEuX2ludGVybmFsX3pvcmRlcigpKSAtIGVuc3VyZU5vdE51bGwoczIuX2ludGVybmFsX3pvcmRlcigpKSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcHJpY2Ugc2NhbGUgbW9kZS5cbiAqL1xudmFyIFByaWNlU2NhbGVNb2RlO1xuKGZ1bmN0aW9uIChQcmljZVNjYWxlTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFByaWNlIHNjYWxlIHNob3dzIHByaWNlcy4gUHJpY2UgcmFuZ2UgY2hhbmdlcyBsaW5lYXJseS5cbiAgICAgKi9cbiAgICBQcmljZVNjYWxlTW9kZVtQcmljZVNjYWxlTW9kZVtcIk5vcm1hbFwiXSA9IDBdID0gXCJOb3JtYWxcIjtcbiAgICAvKipcbiAgICAgKiBQcmljZSBzY2FsZSBzaG93cyBwcmljZXMuIFByaWNlIHJhbmdlIGNoYW5nZXMgbG9nYXJpdGhtaWNhbGx5LlxuICAgICAqL1xuICAgIFByaWNlU2NhbGVNb2RlW1ByaWNlU2NhbGVNb2RlW1wiTG9nYXJpdGhtaWNcIl0gPSAxXSA9IFwiTG9nYXJpdGhtaWNcIjtcbiAgICAvKipcbiAgICAgKiBQcmljZSBzY2FsZSBzaG93cyBwZXJjZW50YWdlIHZhbHVlcyBhY2NvcmRpbmcgdGhlIGZpcnN0IHZpc2libGUgdmFsdWUgb2YgdGhlIHByaWNlIHNjYWxlLlxuICAgICAqIFRoZSBmaXJzdCB2aXNpYmxlIHZhbHVlIGlzIDAlIGluIHRoaXMgbW9kZS5cbiAgICAgKi9cbiAgICBQcmljZVNjYWxlTW9kZVtQcmljZVNjYWxlTW9kZVtcIlBlcmNlbnRhZ2VcIl0gPSAyXSA9IFwiUGVyY2VudGFnZVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIHBlcmNlbnRhZ2UgbW9kZSwgYnV0IHRoZSBmaXJzdCB2YWx1ZSBpcyBtb3ZlZCB0byAxMDAuXG4gICAgICovXG4gICAgUHJpY2VTY2FsZU1vZGVbUHJpY2VTY2FsZU1vZGVbXCJJbmRleGVkVG8xMDBcIl0gPSAzXSA9IFwiSW5kZXhlZFRvMTAwXCI7XG59KShQcmljZVNjYWxlTW9kZSB8fCAoUHJpY2VTY2FsZU1vZGUgPSB7fSkpO1xuY29uc3QgcGVyY2VudGFnZUZvcm1hdHRlciA9IG5ldyBQZXJjZW50YWdlRm9ybWF0dGVyKCk7XG5jb25zdCBkZWZhdWx0UHJpY2VGb3JtYXR0ZXIgPSBuZXcgUHJpY2VGb3JtYXR0ZXIoMTAwLCAxKTtcbmNsYXNzIFByaWNlU2NhbGUge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBvcHRpb25zLCBsYXlvdXRPcHRpb25zLCBsb2NhbGl6YXRpb25PcHRpb25zLCBjb2xvclBhcnNlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnRlcm5hbEhlaWdodENhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkRm9yUmFuZ2UgPSB7IF9pbnRlcm5hbF9pc1ZhbGlkOiBmYWxzZSwgX2ludGVybmFsX3Zpc2libGVCYXJzOiBudWxsIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzQ3VzdG9tUHJpY2VSYW5nZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJnaW5BYm92ZSA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmdpbkJlbG93ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25NYXJrc0NoYW5nZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZUNoYW5nZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyU291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlciA9IGRlZmF1bHRQcmljZUZvcm1hdHRlcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSA9IGxvZ0Zvcm11bGFGb3JQcmljZVJhbmdlKG51bGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pZCA9IGlkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGF5b3V0T3B0aW9ucyA9IGxheW91dE9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvY2FsaXphdGlvbk9wdGlvbnMgPSBsb2NhbGl6YXRpb25PcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb2xvclBhcnNlciA9IGNvbG9yUGFyc2VyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrQnVpbGRlciA9IG5ldyBQcmljZVRpY2tNYXJrQnVpbGRlcih0aGlzLCAxMDAsIHRoaXMuX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWwuYmluZCh0aGlzKSwgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFRvQ29vcmRpbmF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucztcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIG1lcmdlKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRNb2RlKHsgX2ludGVybmFsX21vZGU6IG9wdGlvbnMubW9kZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zY2FsZU1hcmdpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZW5zdXJlRGVmaW5lZChvcHRpb25zLnNjYWxlTWFyZ2lucy50b3ApO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gZW5zdXJlRGVmaW5lZChvcHRpb25zLnNjYWxlTWFyZ2lucy5ib3R0b20pO1xuICAgICAgICAgICAgaWYgKHRvcCA8IDAgfHwgdG9wID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b3AgbWFyZ2luIC0gZXhwZWN0IHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgZ2l2ZW49JHt0b3B9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm90dG9tIDwgMCB8fCBib3R0b20gPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJvdHRvbSBtYXJnaW4gLSBleHBlY3QgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBnaXZlbj0ke2JvdHRvbX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgKyBib3R0b20gPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1hcmdpbnMgLSBzdW0gb2YgbWFyZ2lucyBtdXN0IGJlIGxlc3MgdGhhbiAxLCBnaXZlbj0ke3RvcCArIGJvdHRvbX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVJbnRlcm5hbEhlaWdodENhY2hlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNBdXRvU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmF1dG9TY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzQ3VzdG9tUHJpY2VSYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2lzQ3VzdG9tUHJpY2VSYW5nZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzTG9nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tb2RlID09PSAxIC8qIFByaWNlU2NhbGVNb2RlLkxvZ2FyaXRobWljICovO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaXNQZXJjZW50YWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tb2RlID09PSAyIC8qIFByaWNlU2NhbGVNb2RlLlBlcmNlbnRhZ2UgKi87XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc0luZGV4ZWRUbzEwMCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZSA9PT0gMyAvKiBQcmljZVNjYWxlTW9kZS5JbmRleGVkVG8xMDAgKi87XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRMb2dGb3JtdWxhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYTtcbiAgICB9XG4gICAgX2ludGVybmFsX21vZGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYXV0b1NjYWxlOiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmF1dG9TY2FsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pc0ludmVydGVkOiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmludmVydFNjYWxlLFxuICAgICAgICAgICAgX2ludGVybmFsX21vZGU6IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBfaW50ZXJuYWxfc2V0TW9kZShuZXdNb2RlKSB7XG4gICAgICAgIGNvbnN0IG9sZE1vZGUgPSB0aGlzLl9pbnRlcm5hbF9tb2RlKCk7XG4gICAgICAgIGxldCBwcmljZVJhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKG5ld01vZGUuX2ludGVybmFsX2F1dG9TY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zLmF1dG9TY2FsZSA9IG5ld01vZGUuX2ludGVybmFsX2F1dG9TY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3TW9kZS5faW50ZXJuYWxfbW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGUgPSBuZXdNb2RlLl9pbnRlcm5hbF9tb2RlO1xuICAgICAgICAgICAgaWYgKG5ld01vZGUuX2ludGVybmFsX21vZGUgPT09IDIgLyogUHJpY2VTY2FsZU1vZGUuUGVyY2VudGFnZSAqLyB8fCBuZXdNb2RlLl9pbnRlcm5hbF9tb2RlID09PSAzIC8qIFByaWNlU2NhbGVNb2RlLkluZGV4ZWRUbzEwMCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuYXV0b1NjYWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBhZnRlciBtYWtpbmcgcmVidWlsZFRpY2tNYXJrcyBsYXp5XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZEZvclJhbmdlLl9pbnRlcm5hbF9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmaW5lIHdoaWNoIHNjYWxlIGNvbnZlcnRlZCBmcm9tXG4gICAgICAgIGlmIChvbGRNb2RlLl9pbnRlcm5hbF9tb2RlID09PSAxIC8qIFByaWNlU2NhbGVNb2RlLkxvZ2FyaXRobWljICovICYmIG5ld01vZGUuX2ludGVybmFsX21vZGUgIT09IG9sZE1vZGUuX2ludGVybmFsX21vZGUpIHtcbiAgICAgICAgICAgIGlmIChjYW5Db252ZXJ0UHJpY2VSYW5nZUZyb21Mb2codGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSkpIHtcbiAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gY29udmVydFByaWNlUmFuZ2VGcm9tTG9nKHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2UsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpO1xuICAgICAgICAgICAgICAgIGlmIChwcmljZVJhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFByaWNlUmFuZ2UocHJpY2VSYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5hdXRvU2NhbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmluZSB3aGljaCBzY2FsZSBjb252ZXJ0ZWQgdG9cbiAgICAgICAgaWYgKG5ld01vZGUuX2ludGVybmFsX21vZGUgPT09IDEgLyogUHJpY2VTY2FsZU1vZGUuTG9nYXJpdGhtaWMgKi8gJiYgbmV3TW9kZS5faW50ZXJuYWxfbW9kZSAhPT0gb2xkTW9kZS5faW50ZXJuYWxfbW9kZSkge1xuICAgICAgICAgICAgcHJpY2VSYW5nZSA9IGNvbnZlcnRQcmljZVJhbmdlVG9Mb2codGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSk7XG4gICAgICAgICAgICBpZiAocHJpY2VSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFByaWNlUmFuZ2UocHJpY2VSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZUNoYW5nZWQgPSBvbGRNb2RlLl9pbnRlcm5hbF9tb2RlICE9PSB0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGU7XG4gICAgICAgIGlmIChtb2RlQ2hhbmdlZCAmJiAob2xkTW9kZS5faW50ZXJuYWxfbW9kZSA9PT0gMiAvKiBQcmljZVNjYWxlTW9kZS5QZXJjZW50YWdlICovIHx8IHRoaXMuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpKSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGVDaGFuZ2VkICYmIChvbGRNb2RlLl9pbnRlcm5hbF9tb2RlID09PSAzIC8qIFByaWNlU2NhbGVNb2RlLkluZGV4ZWRUbzEwMCAqLyB8fCB0aGlzLl9pbnRlcm5hbF9pc0luZGV4ZWRUbzEwMCgpKSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld01vZGUuX2ludGVybmFsX2lzSW52ZXJ0ZWQgIT09IHVuZGVmaW5lZCAmJiBvbGRNb2RlLl9pbnRlcm5hbF9pc0ludmVydGVkICE9PSBuZXdNb2RlLl9pbnRlcm5hbF9pc0ludmVydGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zLmludmVydFNjYWxlID0gbmV3TW9kZS5faW50ZXJuYWxfaXNJbnZlcnRlZDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX29uSXNJbnZlcnRlZENoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlQ2hhbmdlZC5faW50ZXJuYWxfZmlyZShvbGRNb2RlLCB0aGlzLl9pbnRlcm5hbF9tb2RlKCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW9kZUNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tb2RlQ2hhbmdlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZvbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGF5b3V0T3B0aW9ucy5mb250U2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2hlaWdodDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEhlaWdodCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGVpZ2h0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlSW50ZXJuYWxIZWlnaHRDYWNoZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2ludGVybmFsSGVpZ2h0KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW50ZXJuYWxIZWlnaHRDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2ludGVybmFsSGVpZ2h0Q2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5faW50ZXJuYWxfaGVpZ2h0KCkgLSB0aGlzLl9wcml2YXRlX190b3BNYXJnaW5QeCgpIC0gdGhpcy5fcHJpdmF0ZV9fYm90dG9tTWFyZ2luUHgoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW50ZXJuYWxIZWlnaHRDYWNoZSA9IHJlcztcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlUmFuZ2UoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ha2VTdXJlSXRJc1ZhbGlkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0UHJpY2VSYW5nZShuZXdQcmljZVJhbmdlLCBpc0ZvcmNlU2V0VmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb2xkUHJpY2VSYW5nZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2U7XG4gICAgICAgIGlmICghaXNGb3JjZVNldFZhbHVlICYmXG4gICAgICAgICAgICAhKG9sZFByaWNlUmFuZ2UgPT09IG51bGwgJiYgbmV3UHJpY2VSYW5nZSAhPT0gbnVsbCkgJiZcbiAgICAgICAgICAgIChvbGRQcmljZVJhbmdlID09PSBudWxsIHx8IG9sZFByaWNlUmFuZ2UuX2ludGVybmFsX2VxdWFscyhuZXdQcmljZVJhbmdlKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZSA9IG5ld1ByaWNlUmFuZ2U7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRDdXN0b21QcmljZVJhbmdlKG5ld1ByaWNlUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UHJpY2VSYW5nZShuZXdQcmljZVJhbmdlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9nZ2xlQ3VzdG9tUHJpY2VSYW5nZShuZXdQcmljZVJhbmdlICE9PSBudWxsKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzRW1wdHkoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ha2VTdXJlSXRJc1ZhbGlkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19oZWlnaHQgPT09IDAgfHwgIXRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2UgfHwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZS5faW50ZXJuYWxfaXNFbXB0eSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW52ZXJ0ZWRDb29yZGluYXRlKGNvb3JkaW5hdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX2lzSW52ZXJ0ZWQoKSA/IGNvb3JkaW5hdGUgOiB0aGlzLl9pbnRlcm5hbF9oZWlnaHQoKSAtIDEgLSBjb29yZGluYXRlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUocHJpY2UsIGJhc2VWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkpIHtcbiAgICAgICAgICAgIHByaWNlID0gdG9QZXJjZW50KHByaWNlLCBiYXNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkpIHtcbiAgICAgICAgICAgIHByaWNlID0gdG9JbmRleGVkVG8xMDAocHJpY2UsIGJhc2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxUb0Nvb3JkaW5hdGUocHJpY2UsIGJhc2VWYWx1ZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wb2ludHNBcnJheVRvQ29vcmRpbmF0ZXMocG9pbnRzLCBiYXNlVmFsdWUsIHZpc2libGVSYW5nZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYWtlU3VyZUl0SXNWYWxpZCgpO1xuICAgICAgICBjb25zdCBiaCA9IHRoaXMuX3ByaXZhdGVfX2JvdHRvbU1hcmdpblB4KCk7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9wcmljZVJhbmdlKCkpO1xuICAgICAgICBjb25zdCBtaW4gPSByYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKTtcbiAgICAgICAgY29uc3QgbWF4ID0gcmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IGloID0gKHRoaXMuX2ludGVybmFsX2ludGVybmFsSGVpZ2h0KCkgLSAxKTtcbiAgICAgICAgY29uc3QgaXNJbnZlcnRlZCA9IHRoaXMuX2ludGVybmFsX2lzSW52ZXJ0ZWQoKTtcbiAgICAgICAgY29uc3QgaG1tID0gaWggLyAobWF4IC0gbWluKTtcbiAgICAgICAgY29uc3QgZnJvbUluZGV4ID0gKHZpc2libGVSYW5nZSA9PT0gdW5kZWZpbmVkKSA/IDAgOiB2aXNpYmxlUmFuZ2UuZnJvbTtcbiAgICAgICAgY29uc3QgdG9JbmRleCA9ICh2aXNpYmxlUmFuZ2UgPT09IHVuZGVmaW5lZCkgPyBwb2ludHMubGVuZ3RoIDogdmlzaWJsZVJhbmdlLnRvO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1GbiA9IHRoaXMuX3ByaXZhdGVfX2dldENvb3JkaW5hdGVUcmFuc2Zvcm1lcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbUluZGV4OyBpIDwgdG9JbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHByaWNlID0gcG9pbnQuX2ludGVybmFsX3ByaWNlO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHByaWNlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxvZ2ljYWwgPSBwcmljZTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1GbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2ljYWwgPSB0cmFuc2Zvcm1Gbihwb2ludC5faW50ZXJuYWxfcHJpY2UsIGJhc2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnZDb29yZGluYXRlID0gYmggKyBobW0gKiAobG9naWNhbCAtIG1pbik7XG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlID0gaXNJbnZlcnRlZCA/IGludkNvb3JkaW5hdGUgOiB0aGlzLl9wcml2YXRlX19oZWlnaHQgLSAxIC0gaW52Q29vcmRpbmF0ZTtcbiAgICAgICAgICAgIHBvaW50Ll9pbnRlcm5hbF95ID0gY29vcmRpbmF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfYmFyUHJpY2VzVG9Db29yZGluYXRlcyhwcmljZXNMaXN0LCBiYXNlVmFsdWUsIHZpc2libGVSYW5nZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYWtlU3VyZUl0SXNWYWxpZCgpO1xuICAgICAgICBjb25zdCBiaCA9IHRoaXMuX3ByaXZhdGVfX2JvdHRvbU1hcmdpblB4KCk7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9wcmljZVJhbmdlKCkpO1xuICAgICAgICBjb25zdCBtaW4gPSByYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKTtcbiAgICAgICAgY29uc3QgbWF4ID0gcmFuZ2UuX2ludGVybmFsX21heFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IGloID0gKHRoaXMuX2ludGVybmFsX2ludGVybmFsSGVpZ2h0KCkgLSAxKTtcbiAgICAgICAgY29uc3QgaXNJbnZlcnRlZCA9IHRoaXMuX2ludGVybmFsX2lzSW52ZXJ0ZWQoKTtcbiAgICAgICAgY29uc3QgaG1tID0gaWggLyAobWF4IC0gbWluKTtcbiAgICAgICAgY29uc3QgZnJvbUluZGV4ID0gKHZpc2libGVSYW5nZSA9PT0gdW5kZWZpbmVkKSA/IDAgOiB2aXNpYmxlUmFuZ2UuZnJvbTtcbiAgICAgICAgY29uc3QgdG9JbmRleCA9ICh2aXNpYmxlUmFuZ2UgPT09IHVuZGVmaW5lZCkgPyBwcmljZXNMaXN0Lmxlbmd0aCA6IHZpc2libGVSYW5nZS50bztcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtRm4gPSB0aGlzLl9wcml2YXRlX19nZXRDb29yZGluYXRlVHJhbnNmb3JtZXIoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb21JbmRleDsgaSA8IHRvSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmFyID0gcHJpY2VzTGlzdFtpXTtcbiAgICAgICAgICAgIGxldCBvcGVuTG9naWNhbCA9IGJhci5faW50ZXJuYWxfb3BlbjtcbiAgICAgICAgICAgIGxldCBoaWdoTG9naWNhbCA9IGJhci5faW50ZXJuYWxfaGlnaDtcbiAgICAgICAgICAgIGxldCBsb3dMb2dpY2FsID0gYmFyLl9pbnRlcm5hbF9sb3c7XG4gICAgICAgICAgICBsZXQgY2xvc2VMb2dpY2FsID0gYmFyLl9pbnRlcm5hbF9jbG9zZTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1GbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wZW5Mb2dpY2FsID0gdHJhbnNmb3JtRm4oYmFyLl9pbnRlcm5hbF9vcGVuLCBiYXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgIGhpZ2hMb2dpY2FsID0gdHJhbnNmb3JtRm4oYmFyLl9pbnRlcm5hbF9oaWdoLCBiYXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgIGxvd0xvZ2ljYWwgPSB0cmFuc2Zvcm1GbihiYXIuX2ludGVybmFsX2xvdywgYmFzZVZhbHVlKTtcbiAgICAgICAgICAgICAgICBjbG9zZUxvZ2ljYWwgPSB0cmFuc2Zvcm1GbihiYXIuX2ludGVybmFsX2Nsb3NlLCBiYXNlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGludkNvb3JkaW5hdGUgPSBiaCArIGhtbSAqIChvcGVuTG9naWNhbCAtIG1pbik7XG4gICAgICAgICAgICBsZXQgY29vcmRpbmF0ZSA9IGlzSW52ZXJ0ZWQgPyBpbnZDb29yZGluYXRlIDogdGhpcy5fcHJpdmF0ZV9faGVpZ2h0IC0gMSAtIGludkNvb3JkaW5hdGU7XG4gICAgICAgICAgICBiYXIuX2ludGVybmFsX29wZW5ZID0gY29vcmRpbmF0ZTtcbiAgICAgICAgICAgIGludkNvb3JkaW5hdGUgPSBiaCArIGhtbSAqIChoaWdoTG9naWNhbCAtIG1pbik7XG4gICAgICAgICAgICBjb29yZGluYXRlID0gaXNJbnZlcnRlZCA/IGludkNvb3JkaW5hdGUgOiB0aGlzLl9wcml2YXRlX19oZWlnaHQgLSAxIC0gaW52Q29vcmRpbmF0ZTtcbiAgICAgICAgICAgIGJhci5faW50ZXJuYWxfaGlnaFkgPSBjb29yZGluYXRlO1xuICAgICAgICAgICAgaW52Q29vcmRpbmF0ZSA9IGJoICsgaG1tICogKGxvd0xvZ2ljYWwgLSBtaW4pO1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9IGlzSW52ZXJ0ZWQgPyBpbnZDb29yZGluYXRlIDogdGhpcy5fcHJpdmF0ZV9faGVpZ2h0IC0gMSAtIGludkNvb3JkaW5hdGU7XG4gICAgICAgICAgICBiYXIuX2ludGVybmFsX2xvd1kgPSBjb29yZGluYXRlO1xuICAgICAgICAgICAgaW52Q29vcmRpbmF0ZSA9IGJoICsgaG1tICogKGNsb3NlTG9naWNhbCAtIG1pbik7XG4gICAgICAgICAgICBjb29yZGluYXRlID0gaXNJbnZlcnRlZCA/IGludkNvb3JkaW5hdGUgOiB0aGlzLl9wcml2YXRlX19oZWlnaHQgLSAxIC0gaW52Q29vcmRpbmF0ZTtcbiAgICAgICAgICAgIGJhci5faW50ZXJuYWxfY2xvc2VZID0gY29vcmRpbmF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfY29vcmRpbmF0ZVRvUHJpY2UoY29vcmRpbmF0ZSwgYmFzZVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxvZ2ljYWwgPSB0aGlzLl9wcml2YXRlX19jb29yZGluYXRlVG9Mb2dpY2FsKGNvb3JkaW5hdGUsIGJhc2VWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9sb2dpY2FsVG9QcmljZShsb2dpY2FsLCBiYXNlVmFsdWUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbG9naWNhbFRvUHJpY2UobG9naWNhbCwgYmFzZVZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGxvZ2ljYWw7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UoKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBmcm9tUGVyY2VudCh2YWx1ZSwgYmFzZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnRlcm5hbF9pc0luZGV4ZWRUbzEwMCgpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZyb21JbmRleGVkVG8xMDAodmFsdWUsIGJhc2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGF0YVNvdXJjZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcztcbiAgICB9XG4gICAgX2ludGVybmFsX29yZGVyZWRTb3VyY2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9IHNvcnRTb3VyY2VzKHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hZGREYXRhU291cmNlKHNvdXJjZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuaW5kZXhPZihzb3VyY2UpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2ludmFsaWRhdGVTb3VyY2VzQ2FjaGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbW92ZURhdGFTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpcyBub3QgYXR0YWNoZWQgdG8gc2NhbGUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRNb2RlKHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfYXV0b1NjYWxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpZiBubyBzb3VyY2VzIG9uIHByaWNlIHNjYWxlIGxldCdzIGNsZWFyIHByaWNlIHJhbmdlIGNhY2hlIGFzIHdlbGwgYXMgZW5hYmxpbmcgYXV0byBzY2FsZVxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UHJpY2VSYW5nZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfaW52YWxpZGF0ZVNvdXJjZXNDYWNoZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZmlyc3RWYWx1ZSgpIHtcbiAgICAgICAgLy8gVE9ETzogY2FjaGUgdGhlIHJlc3VsdFxuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBzb3VyY2UuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IGZpcnN0VmFsdWUuX2ludGVybmFsX3RpbWVQb2ludCA8IHJlc3VsdC5faW50ZXJuYWxfdGltZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3RWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gbnVsbCA6IHJlc3VsdC5faW50ZXJuYWxfdmFsdWU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc0ludmVydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5pbnZlcnRTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX21hcmtzKCkge1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlSXNOdWxsID0gdGhpcy5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpID09PSBudWxsO1xuICAgICAgICAvLyBkbyBub3QgcmVjYWxjdWxhdGUgbWFya3MgaWYgZmlyc3RWYWx1ZUlzTnVsbCBpcyB0cnVlIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHdlJ2xsIGFsd2F5cyBnZXQgZW1wdHkgcmVzdWx0XG4gICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGluIGNhc2Ugd2hlbiBhIHNlcmllcyBoYWQgc29tZSBkYXRhIGFuZCB0aGVuIHlvdSBzZXQgZW1wdHkgZGF0YSB0byBpdCAoaW4gYSBzaW1wbGlmaWVkIGNhc2UpXG4gICAgICAgIC8vIHdlIGNvdWxkIGRpc3BsYXkgYW4gZW1wdHkgcHJpY2Ugc2NhbGUsIGJ1dCB0aGlzIGlzIG5vdCBnb29kIGZyb20gVVhcbiAgICAgICAgLy8gc28gaW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8ga2VlcCBhbiBwcmV2aW91cyBtYXJrcyB0byBkaXNwbGF5IHRoZW0gb24gdGhlIHNjYWxlXG4gICAgICAgIC8vIGFzIG9uZSBvZiBwb3NzaWJsZSBleGFtcGxlcyBmb3IgdGhpcyBzaXR1YXRpb24gY291bGQgYmUgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgLy8gbGV0J3Mgc2F5IHlvdSBoYXZlIGEgc3R1ZHkvaW5kaWNhdG9yIGF0dGFjaGVkIHRvIGEgcHJpY2Ugc2NhbGUgYW5kIHRoZW4geW91IGRlY2lkZSB0byBzdG9wIGl0LCBpLmUuIHJlbW92ZSBpdHMgZGF0YSBiZWNhdXNlIG9mIGl0cyB2aXNpYmlsaXR5XG4gICAgICAgIC8vIGEgdXNlciB3aWxsIHNlZSB0aGUgcHJldmlvdXMgbWFya3Mgb24gdGhlIHNjYWxlIHVudGlsIHlvdSB0dXJuIG9uIHlvdXIgc3R1ZHkgYmFjayBvciByZW1vdmUgaXQgZnJvbSB0aGUgY2hhcnQgY29tcGxldGVseVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbWFya3NDYWNoZSAhPT0gbnVsbCAmJiAoZmlyc3RWYWx1ZUlzTnVsbCB8fCB0aGlzLl9wcml2YXRlX19tYXJrc0NhY2hlLl9pbnRlcm5hbF9maXJzdFZhbHVlSXNOdWxsID09PSBmaXJzdFZhbHVlSXNOdWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUuX2ludGVybmFsX21hcmtzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtCdWlsZGVyLl9pbnRlcm5hbF9yZWJ1aWxkVGlja01hcmtzKCk7XG4gICAgICAgIGNvbnN0IG1hcmtzID0gdGhpcy5fcHJpdmF0ZV9fbWFya0J1aWxkZXIuX2ludGVybmFsX21hcmtzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSB7IF9pbnRlcm5hbF9tYXJrczogbWFya3MsIF9pbnRlcm5hbF9maXJzdFZhbHVlSXNOdWxsOiBmaXJzdFZhbHVlSXNOdWxsIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTWFya3NDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKCk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgX2ludGVybmFsX29uTWFya3NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb25NYXJrc0NoYW5nZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGFydFNjYWxlKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpIHx8IHRoaXMuX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ICE9PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnZlcnQgeFxuICAgICAgICB0aGlzLl9wcml2YXRlX19zY2FsZVN0YXJ0UG9pbnQgPSB0aGlzLl9wcml2YXRlX19oZWlnaHQgLSB4O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3ByaWNlUmFuZ2UoKSkuX2ludGVybmFsX2Nsb25lKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY2FsZVRvKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpIHx8IHRoaXMuX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2NhbGVTdGFydFBvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0TW9kZSh7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYXV0b1NjYWxlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGludmVydCB4XG4gICAgICAgIHggPSB0aGlzLl9wcml2YXRlX19oZWlnaHQgLSB4O1xuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY2FsZUNvZWZmID0gKHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCArICh0aGlzLl9wcml2YXRlX19oZWlnaHQgLSAxKSAqIDAuMikgLyAoeCArICh0aGlzLl9wcml2YXRlX19oZWlnaHQgLSAxKSAqIDAuMik7XG4gICAgICAgIGNvbnN0IG5ld1ByaWNlUmFuZ2UgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCkuX2ludGVybmFsX2Nsb25lKCk7XG4gICAgICAgIHNjYWxlQ29lZmYgPSBNYXRoLm1heChzY2FsZUNvZWZmLCAwLjEpO1xuICAgICAgICBuZXdQcmljZVJhbmdlLl9pbnRlcm5hbF9zY2FsZUFyb3VuZENlbnRlcihzY2FsZUNvZWZmKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0UHJpY2VSYW5nZShuZXdQcmljZVJhbmdlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjYWxlKCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNQZXJjZW50YWdlKCkgfHwgdGhpcy5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGFydFNjcm9sbCh4KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0F1dG9TY2FsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgIT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgPSB4O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3ByaWNlUmFuZ2UoKSkuX2ludGVybmFsX2Nsb25lKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY3JvbGxUbyh4KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0F1dG9TY2FsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmljZVVuaXRzUGVyUGl4ZWwgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3ByaWNlUmFuZ2UoKSkuX2ludGVybmFsX2xlbmd0aCgpIC8gKHRoaXMuX2ludGVybmFsX2ludGVybmFsSGVpZ2h0KCkgLSAxKTtcbiAgICAgICAgbGV0IHBpeGVsRGVsdGEgPSB4IC0gdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludDtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzSW52ZXJ0ZWQoKSkge1xuICAgICAgICAgICAgcGl4ZWxEZWx0YSAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmljZURlbHRhID0gcGl4ZWxEZWx0YSAqIHByaWNlVW5pdHNQZXJQaXhlbDtcbiAgICAgICAgY29uc3QgbmV3UHJpY2VSYW5nZSA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90KS5faW50ZXJuYWxfY2xvbmUoKTtcbiAgICAgICAgbmV3UHJpY2VSYW5nZS5faW50ZXJuYWxfc2hpZnQocHJpY2VEZWx0YSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3NldFByaWNlUmFuZ2UobmV3UHJpY2VSYW5nZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZW5kU2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNBdXRvU2NhbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2VTbmFwc2hvdCA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXR0ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0UHJpY2UocHJpY2UsIGZpcnN0VmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBQcmljZVNjYWxlTW9kZS5QZXJjZW50YWdlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRQZXJjZW50YWdlKHRvUGVyY2VudChwcmljZSwgZmlyc3RWYWx1ZSkpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFByaWNlU2NhbGVNb2RlLkluZGV4ZWRUbzEwMCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfZm9ybWF0dGVyKCkuZm9ybWF0KHRvSW5kZXhlZFRvMTAwKHByaWNlLCBmaXJzdFZhbHVlKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRQcmljZShwcmljZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2Zvcm1hdExvZ2ljYWwobG9naWNhbCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSAyIC8qIFByaWNlU2NhbGVNb2RlLlBlcmNlbnRhZ2UgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdFBlcmNlbnRhZ2UobG9naWNhbCk7XG4gICAgICAgICAgICBjYXNlIDMgLyogUHJpY2VTY2FsZU1vZGUuSW5kZXhlZFRvMTAwICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9mb3JtYXR0ZXIoKS5mb3JtYXQobG9naWNhbCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRQcmljZShsb2dpY2FsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0UHJpY2VBYnNvbHV0ZShwcmljZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0UHJpY2UocHJpY2UsIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyU291cmNlKS5faW50ZXJuYWxfZm9ybWF0dGVyKCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0UHJpY2VQZXJjZW50YWdlKHByaWNlLCBiYXNlVmFsdWUpIHtcbiAgICAgICAgcHJpY2UgPSB0b1BlcmNlbnQocHJpY2UsIGJhc2VWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRQZXJjZW50YWdlKHByaWNlLCBwZXJjZW50YWdlRm9ybWF0dGVyKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NvdXJjZXNGb3JBdXRvU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcztcbiAgICB9XG4gICAgX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VSYW5nZSh2aXNpYmxlQmFycykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZEZvclJhbmdlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGVCYXJzOiB2aXNpYmxlQmFycyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZUFsbFZpZXdzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5mb3JFYWNoKChzKSA9PiBzLl9pbnRlcm5hbF91cGRhdGVBbGxWaWV3cygpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hhc1Zpc2libGVFZGdlTWFya3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmVuc3VyZUVkZ2VUaWNrTWFya3NWaXNpYmxlICYmIHRoaXMuX2ludGVybmFsX2lzQXV0b1NjYWxlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRFZGdlTWFya3NQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfZm9udFNpemUoKSAvIDI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICBsZXQgek9yZGVyID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlclNvdXJjZSA9IG51bGw7XG4gICAgICAgIC8vIGNob29zZSBzb3VyY2Ugd2l0aCB0aGUgbG93ZXN0IHpvcmRlclxuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcykge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5faW50ZXJuYWxfem9yZGVyKCkgPCB6T3JkZXIpIHtcbiAgICAgICAgICAgICAgICB6T3JkZXIgPSBzb3VyY2UuX2ludGVybmFsX3pvcmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlclNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYmFzZSA9IDEwMDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlclNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYmFzZSA9IE1hdGgucm91bmQoMSAvIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlclNvdXJjZS5faW50ZXJuYWxfbWluTW92ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXIgPSBkZWZhdWx0UHJpY2VGb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyID0gcGVyY2VudGFnZUZvcm1hdHRlcjtcbiAgICAgICAgICAgIGJhc2UgPSAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVyID0gbmV3IFByaWNlRm9ybWF0dGVyKDEwMCwgMSk7XG4gICAgICAgICAgICBiYXNlID0gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlclNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHVzZXJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXIgPSB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZXJTb3VyY2UuX2ludGVybmFsX2Zvcm1hdHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtCdWlsZGVyID0gbmV3IFByaWNlVGlja01hcmtCdWlsZGVyKHRoaXMsIGJhc2UsIHRoaXMuX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWwuYmluZCh0aGlzKSwgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFRvQ29vcmRpbmF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya0J1aWxkZXIuX2ludGVybmFsX3JlYnVpbGRUaWNrTWFya3MoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2ludmFsaWRhdGVTb3VyY2VzQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2NvbG9yUGFyc2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY29sb3JQYXJzZXI7XG4gICAgfVxuICAgIF9wcml2YXRlX190b2dnbGVDdXN0b21QcmljZVJhbmdlKHYpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNDdXN0b21QcmljZVJhbmdlID0gdjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RvcE1hcmdpblB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfaXNJbnZlcnRlZCgpXG4gICAgICAgICAgICA/IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuc2NhbGVNYXJnaW5zLmJvdHRvbSAqIHRoaXMuX2ludGVybmFsX2hlaWdodCgpICsgdGhpcy5fcHJpdmF0ZV9fbWFyZ2luQmVsb3dcbiAgICAgICAgICAgIDogdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5zY2FsZU1hcmdpbnMudG9wICogdGhpcy5faW50ZXJuYWxfaGVpZ2h0KCkgKyB0aGlzLl9wcml2YXRlX19tYXJnaW5BYm92ZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2JvdHRvbU1hcmdpblB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfaXNJbnZlcnRlZCgpXG4gICAgICAgICAgICA/IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuc2NhbGVNYXJnaW5zLnRvcCAqIHRoaXMuX2ludGVybmFsX2hlaWdodCgpICsgdGhpcy5fcHJpdmF0ZV9fbWFyZ2luQWJvdmVcbiAgICAgICAgICAgIDogdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5zY2FsZU1hcmdpbnMuYm90dG9tICogdGhpcy5faW50ZXJuYWxfaGVpZ2h0KCkgKyB0aGlzLl9wcml2YXRlX19tYXJnaW5CZWxvdztcbiAgICB9XG4gICAgX3ByaXZhdGVfX21ha2VTdXJlSXRJc1ZhbGlkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkRm9yUmFuZ2UuX2ludGVybmFsX2lzVmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkRm9yUmFuZ2UuX2ludGVybmFsX2lzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjYWxjdWxhdGVQcmljZVJhbmdlSW1wbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19pbnZhbGlkYXRlSW50ZXJuYWxIZWlnaHRDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW50ZXJuYWxIZWlnaHRDYWNoZSA9IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19sb2dpY2FsVG9Db29yZGluYXRlKGxvZ2ljYWwsIGJhc2VWYWx1ZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYWtlU3VyZUl0SXNWYWxpZCgpO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBsb2dpY2FsID0gdGhpcy5faW50ZXJuYWxfaXNMb2coKSAmJiBsb2dpY2FsID8gdG9Mb2cobG9naWNhbCwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSkgOiBsb2dpY2FsO1xuICAgICAgICBjb25zdCByYW5nZSA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcHJpY2VSYW5nZSgpKTtcbiAgICAgICAgY29uc3QgaW52Q29vcmRpbmF0ZSA9IHRoaXMuX3ByaXZhdGVfX2JvdHRvbU1hcmdpblB4KCkgK1xuICAgICAgICAgICAgKHRoaXMuX2ludGVybmFsX2ludGVybmFsSGVpZ2h0KCkgLSAxKSAqIChsb2dpY2FsIC0gcmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCkpIC8gcmFuZ2UuX2ludGVybmFsX2xlbmd0aCgpO1xuICAgICAgICBjb25zdCBjb29yZGluYXRlID0gdGhpcy5faW50ZXJuYWxfaW52ZXJ0ZWRDb29yZGluYXRlKGludkNvb3JkaW5hdGUpO1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0xvZ2ljYWwoY29vcmRpbmF0ZSwgYmFzZVZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ha2VTdXJlSXRJc1ZhbGlkKCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludkNvb3JkaW5hdGUgPSB0aGlzLl9pbnRlcm5hbF9pbnZlcnRlZENvb3JkaW5hdGUoY29vcmRpbmF0ZSk7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9wcmljZVJhbmdlKCkpO1xuICAgICAgICBjb25zdCBsb2dpY2FsID0gcmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCkgKyByYW5nZS5faW50ZXJuYWxfbGVuZ3RoKCkgKlxuICAgICAgICAgICAgKChpbnZDb29yZGluYXRlIC0gdGhpcy5fcHJpdmF0ZV9fYm90dG9tTWFyZ2luUHgoKSkgLyAodGhpcy5faW50ZXJuYWxfaW50ZXJuYWxIZWlnaHQoKSAtIDEpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX2lzTG9nKCkgPyBmcm9tTG9nKGxvZ2ljYWwsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpIDogbG9naWNhbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX29uSXNJbnZlcnRlZENoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrQnVpbGRlci5faW50ZXJuYWxfcmVidWlsZFRpY2tNYXJrcygpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIF9wcml2YXRlX19yZWNhbGN1bGF0ZVByaWNlUmFuZ2VJbXBsKCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNDdXN0b21QcmljZVJhbmdlKCkgJiYgIXRoaXMuX2ludGVybmFsX2lzQXV0b1NjYWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkRm9yUmFuZ2UuX2ludGVybmFsX3Zpc2libGVCYXJzO1xuICAgICAgICBpZiAodmlzaWJsZUJhcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJpY2VSYW5nZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLl9pbnRlcm5hbF9zb3VyY2VzRm9yQXV0b1NjYWxlKCk7XG4gICAgICAgIGxldCBtYXJnaW5BYm92ZSA9IDA7XG4gICAgICAgIGxldCBtYXJnaW5CZWxvdyA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBzb3VyY2UuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdXRvU2NhbGVJbmZvID0gc291cmNlLl9pbnRlcm5hbF9hdXRvc2NhbGVJbmZvKHZpc2libGVCYXJzLl9pbnRlcm5hbF9sZWZ0KCksIHZpc2libGVCYXJzLl9pbnRlcm5hbF9yaWdodCgpKTtcbiAgICAgICAgICAgIGxldCBzb3VyY2VSYW5nZSA9IGF1dG9TY2FsZUluZm8gJiYgYXV0b1NjYWxlSW5mby5faW50ZXJuYWxfcHJpY2VSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZVJhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wcml2YXRlX19vcHRpb25zLm1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIFByaWNlU2NhbGVNb2RlLkxvZ2FyaXRobWljICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlUmFuZ2UgPSBjb252ZXJ0UHJpY2VSYW5nZVRvTG9nKHNvdXJjZVJhbmdlLCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogUHJpY2VTY2FsZU1vZGUuUGVyY2VudGFnZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVJhbmdlID0gdG9QZXJjZW50UmFuZ2Uoc291cmNlUmFuZ2UsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDMgLyogUHJpY2VTY2FsZU1vZGUuSW5kZXhlZFRvMTAwICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlUmFuZ2UgPSB0b0luZGV4ZWRUbzEwMFJhbmdlKHNvdXJjZVJhbmdlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByaWNlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpY2VSYW5nZSA9IHNvdXJjZVJhbmdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpY2VSYW5nZSA9IHByaWNlUmFuZ2UuX2ludGVybmFsX21lcmdlKGVuc3VyZU5vdE51bGwoc291cmNlUmFuZ2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9TY2FsZUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyZ2lucyA9IGF1dG9TY2FsZUluZm8uX2ludGVybmFsX21hcmdpbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmdpbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkFib3ZlID0gTWF0aC5tYXgobWFyZ2luQWJvdmUsIG1hcmdpbnMuYWJvdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luQmVsb3cgPSBNYXRoLm1heChtYXJnaW5CZWxvdywgbWFyZ2lucy5iZWxvdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2hhc1Zpc2libGVFZGdlTWFya3MoKSkge1xuICAgICAgICAgICAgbWFyZ2luQWJvdmUgPSBNYXRoLm1heChtYXJnaW5BYm92ZSwgdGhpcy5faW50ZXJuYWxfZ2V0RWRnZU1hcmtzUGFkZGluZygpKTtcbiAgICAgICAgICAgIG1hcmdpbkJlbG93ID0gTWF0aC5tYXgobWFyZ2luQmVsb3csIHRoaXMuX2ludGVybmFsX2dldEVkZ2VNYXJrc1BhZGRpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmdpbkFib3ZlICE9PSB0aGlzLl9wcml2YXRlX19tYXJnaW5BYm92ZSB8fCBtYXJnaW5CZWxvdyAhPT0gdGhpcy5fcHJpdmF0ZV9fbWFyZ2luQmVsb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmdpbkFib3ZlID0gbWFyZ2luQWJvdmU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJnaW5CZWxvdyA9IG1hcmdpbkJlbG93O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NDYWNoZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlSW50ZXJuYWxIZWlnaHRDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmljZVJhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBrZWVwIGN1cnJlbnQgcmFuZ2UgaXMgbmV3IGlzIGVtcHR5XG4gICAgICAgICAgICBpZiAocHJpY2VSYW5nZS5faW50ZXJuYWxfbWluVmFsdWUoKSA9PT0gcHJpY2VSYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlclNvdXJjZSA9IHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlclNvdXJjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5Nb3ZlID0gZm9ybWF0dGVyU291cmNlID09PSBudWxsIHx8IHRoaXMuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpIHx8IHRoaXMuX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkgPyAxIDogZm9ybWF0dGVyU291cmNlLl9pbnRlcm5hbF9taW5Nb3ZlKCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgcHJpY2UgcmFuZ2UgaXMgZGVnZW5lcmF0ZWQgdG8gMSBwb2ludCBsZXQncyBleHRlbmQgaXQgYnkgMTAgbWluIG1vdmUgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgaW5jb3JyZWN0IHJhbmdlIGFuZCBlbXB0eSAoYmxhbmspIHNjYWxlIChpbiBjYXNlIG9mIG1pbiB0aWNrIG11Y2ggZ3JlYXRlciB0aGFuIDEpXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5kVmFsdWUgPSA1ICogbWluTW92ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNMb2coKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gY29udmVydFByaWNlUmFuZ2VGcm9tTG9nKHByaWNlUmFuZ2UsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gbmV3IFByaWNlUmFuZ2VJbXBsKHByaWNlUmFuZ2UuX2ludGVybmFsX21pblZhbHVlKCkgLSBleHRlbmRWYWx1ZSwgcHJpY2VSYW5nZS5faW50ZXJuYWxfbWF4VmFsdWUoKSArIGV4dGVuZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNMb2coKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gY29udmVydFByaWNlUmFuZ2VUb0xvZyhwcmljZVJhbmdlLCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNMb2coKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1JhbmdlID0gY29udmVydFByaWNlUmFuZ2VGcm9tTG9nKHByaWNlUmFuZ2UsIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xvZ0Zvcm11bGEgPSBsb2dGb3JtdWxhRm9yUHJpY2VSYW5nZShyYXdSYW5nZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2dGb3JtdWxhc0FyZVNhbWUobmV3TG9nRm9ybXVsYSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3U25hcHNob3QgPSB0aGlzLl9wcml2YXRlX19wcmljZVJhbmdlU25hcHNob3QgIT09IG51bGwgPyBjb252ZXJ0UHJpY2VSYW5nZUZyb21Mb2codGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90LCB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ0Zvcm11bGEgPSBuZXdMb2dGb3JtdWxhO1xuICAgICAgICAgICAgICAgICAgICBwcmljZVJhbmdlID0gY29udmVydFByaWNlUmFuZ2VUb0xvZyhyYXdSYW5nZSwgbmV3TG9nRm9ybXVsYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdTbmFwc2hvdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VSYW5nZVNuYXBzaG90ID0gY29udmVydFByaWNlUmFuZ2VUb0xvZyhyYXdTbmFwc2hvdCwgbmV3TG9nRm9ybXVsYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRQcmljZVJhbmdlKHByaWNlUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVzZXQgZW1wdHkgdG8gZGVmYXVsdFxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRQcmljZVJhbmdlKG5ldyBQcmljZVJhbmdlSW1wbCgtMC41LCAwLjUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sb2dGb3JtdWxhID0gbG9nRm9ybXVsYUZvclByaWNlUmFuZ2UobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldENvb3JkaW5hdGVUcmFuc2Zvcm1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzUGVyY2VudGFnZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9QZXJjZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVybmFsX2lzSW5kZXhlZFRvMTAwKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0b0luZGV4ZWRUbzEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnRlcm5hbF9pc0xvZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gKHByaWNlKSA9PiB0b0xvZyhwcmljZSwgdGhpcy5fcHJpdmF0ZV9fbG9nRm9ybXVsYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb3JtYXRWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyLCBmYWxsYmFja0Zvcm1hdHRlcikge1xuICAgICAgICBpZiAoZm9ybWF0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChmYWxsYmFja0Zvcm1hdHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmFsbGJhY2tGb3JtYXR0ZXIgPSB0aGlzLl9pbnRlcm5hbF9mb3JtYXR0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFja0Zvcm1hdHRlci5mb3JtYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZm9ybWF0UHJpY2UocHJpY2UsIGZhbGxiYWNrRm9ybWF0dGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRWYWx1ZShwcmljZSwgdGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucy5wcmljZUZvcm1hdHRlciwgZmFsbGJhY2tGb3JtYXR0ZXIpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZm9ybWF0UGVyY2VudGFnZShwZXJjZW50YWdlLCBmYWxsYmFja0Zvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0VmFsdWUocGVyY2VudGFnZSwgdGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucy5wZXJjZW50YWdlRm9ybWF0dGVyLCBmYWxsYmFja0Zvcm1hdHRlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1Nlcmllcyhzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlIGluc3RhbmNlb2YgU2VyaWVzO1xufVxuY29uc3QgREVGQVVMVF9TVFJFVENIX0ZBQ1RPUiA9IDEwMDA7XG5jb25zdCBNSU5fUEFORV9IRUlHSFQgPSAzMDtcbmNsYXNzIFBhbmUge1xuICAgIGNvbnN0cnVjdG9yKHRpbWVTY2FsZSwgbW9kZWwpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3ZlcmxheVNvdXJjZXNCeVNjYWxlSWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RyZXRjaEZhY3RvciA9IERFRkFVTFRfU1RSRVRDSF9GQUNUT1I7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGVzdHJveWVkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlID0gdGltZVNjYWxlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ncmlkID0gbmV3IEdyaWQodGhpcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX2NyZWF0ZVByaWNlU2NhbGUoXCJsZWZ0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5MZWZ0ICovLCBvcHRpb25zLmxlZnRQcmljZVNjYWxlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fY3JlYXRlUHJpY2VTY2FsZShcInJpZ2h0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5SaWdodCAqLywgb3B0aW9ucy5yaWdodFByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZS5faW50ZXJuYWxfbW9kZUNoYW5nZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX29uUHJpY2VTY2FsZU1vZGVDaGFuZ2VkLmJpbmQodGhpcywgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUpLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlLl9pbnRlcm5hbF9tb2RlQ2hhbmdlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fb25QcmljZVNjYWxlTW9kZUNoYW5nZWQuYmluZCh0aGlzLCB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUpLCB0aGlzKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfYXBwbHlTY2FsZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseVNjYWxlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZnRQcmljZVNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZS5faW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMubGVmdFByaWNlU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJpZ2h0UHJpY2VTY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucy5yaWdodFByaWNlU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmxvY2FsaXphdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlLl9pbnRlcm5hbF91cGRhdGVGb3JtYXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vdmVybGF5UHJpY2VTY2FsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUFycmF5cyA9IEFycmF5LmZyb20odGhpcy5fcHJpdmF0ZV9fb3ZlcmxheVNvdXJjZXNCeVNjYWxlSWQudmFsdWVzKCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcnIgb2Ygc291cmNlQXJyYXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IGVuc3VyZU5vdE51bGwoYXJyWzBdLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkpO1xuICAgICAgICAgICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zLm92ZXJsYXlQcmljZVNjYWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3VwZGF0ZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VTY2FsZUJ5SWQoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuTGVmdCAqLzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5SaWdodCAqLzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX292ZXJsYXlTb3VyY2VzQnlTY2FsZUlkLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX292ZXJsYXlTb3VyY2VzQnlTY2FsZUlkLmdldChpZCkpWzBdLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZS5faW50ZXJuYWxfbW9kZUNoYW5nZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZS5faW50ZXJuYWxfbW9kZUNoYW5nZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5faW50ZXJuYWxfZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcyA9IHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZXMuZmlsdGVyKChwcmltaXRpdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwcmltaXRpdmUuX2ludGVybmFsX3ByaW1pdGl2ZSgpO1xuICAgICAgICAgICAgaWYgKHAuZGV0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBwLmRldGFjaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kZXN0cm95ZWQuX2ludGVybmFsX2ZpcmUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0cmV0Y2hGYWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zdHJldGNoRmFjdG9yO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U3RyZXRjaEZhY3RvcihmYWN0b3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RyZXRjaEZhY3RvciA9IGZhY3RvcjtcbiAgICB9XG4gICAgX2ludGVybmFsX21vZGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbW9kZWw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF93aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3dpZHRoO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faGVpZ2h0O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0V2lkdGgod2lkdGgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlQWxsU291cmNlcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlLl9pbnRlcm5hbF9zZXRIZWlnaHQoaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlLl9pbnRlcm5hbF9zZXRIZWlnaHQoaGVpZ2h0KTtcbiAgICAgICAgLy8gcHJvY2VzcyBvdmVybGF5c1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5mb3JFYWNoKChkcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzT3ZlcmxheShkcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gZHMuX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJpY2VTY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9zZXRIZWlnaHQoaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVBbGxTb3VyY2VzKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXJpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5maWx0ZXIoaXNTZXJpZXMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGF0YVNvdXJjZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcztcbiAgICB9XG4gICAgX2ludGVybmFsX2lzT3ZlcmxheShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlICE9PSBwcmljZVNjYWxlICYmIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZSAhPT0gcHJpY2VTY2FsZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2FkZERhdGFTb3VyY2Uoc291cmNlLCB0YXJnZXRTY2FsZUlkLCBrZWVwU291cmNlc09yZGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luc2VydERhdGFTb3VyY2Uoc291cmNlLCB0YXJnZXRTY2FsZUlkLCBrZWVwU291cmNlc09yZGVyID8gc291cmNlLl9pbnRlcm5hbF96b3JkZXIoKSA6IHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLmxlbmd0aCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW1vdmVEYXRhU291cmNlKHNvdXJjZSwga2VlcFNvdXJjZU9yZGVyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuICAgICAgICBhc3NlcnQoaW5kZXggIT09IC0xLCAncmVtb3ZlRGF0YVNvdXJjZTogaW52YWxpZCBkYXRhIHNvdXJjZScpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAoIWtlZXBTb3VyY2VPcmRlcikge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuZm9yRWFjaCgoZHMsIGkpID0+IGRzLl9pbnRlcm5hbF9zZXRab3JkZXIoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGVJZCA9IGVuc3VyZU5vdE51bGwoc291cmNlLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkpLl9pbnRlcm5hbF9pZCgpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3ZlcmxheVNvdXJjZXNCeVNjYWxlSWQuaGFzKHByaWNlU2NhbGVJZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlTb3VyY2VzID0gZW5zdXJlRGVmaW5lZCh0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC5nZXQocHJpY2VTY2FsZUlkKSk7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5SW5kZXggPSBvdmVybGF5U291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAob3ZlcmxheUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlTb3VyY2VzLnNwbGljZShvdmVybGF5SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5U291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3ZlcmxheVNvdXJjZXNCeVNjYWxlSWQuZGVsZXRlKHByaWNlU2NhbGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBzb3VyY2UuX2ludGVybmFsX3ByaWNlU2NhbGUoKTtcbiAgICAgICAgLy8gaWYgc291cmNlIGhhcyBvd25lciwgaXQgcmV0dXJucyBvd25lcidzIHByaWNlIHNjYWxlXG4gICAgICAgIC8vIGFuZCBpdCBkb2VzIG5vdCBoYXZlIHNvdXJjZSBpbiB0aGVpciBsaXN0XG4gICAgICAgIGlmIChwcmljZVNjYWxlICYmIHByaWNlU2NhbGUuX2ludGVybmFsX2RhdGFTb3VyY2VzKCkuaW5kZXhPZihzb3VyY2UpID49IDApIHtcbiAgICAgICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3JlbW92ZURhdGFTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZShwcmljZVNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVNjYWxlUG9zaXRpb24ocHJpY2VTY2FsZSkge1xuICAgICAgICBpZiAocHJpY2VTY2FsZSA9PT0gdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaWNlU2NhbGUgPT09IHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdvdmVybGF5JztcbiAgICB9XG4gICAgX2ludGVybmFsX2xlZnRQcmljZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yaWdodFByaWNlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGFydFNjYWxlUHJpY2UocHJpY2VTY2FsZSwgeCkge1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9zdGFydFNjYWxlKHgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2NhbGVQcmljZVRvKHByaWNlU2NhbGUsIHgpIHtcbiAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfc2NhbGVUbyh4KTtcbiAgICAgICAgLy8gVE9ETzogYmUgbW9yZSBzbWFydCBhbmQgdXBkYXRlIG9ubHkgYWZmZWN0ZWQgdmlld3NcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlQWxsU291cmNlcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZW5kU2NhbGVQcmljZShwcmljZVNjYWxlKSB7XG4gICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX2VuZFNjYWxlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGFydFNjcm9sbFByaWNlKHByaWNlU2NhbGUsIHgpIHtcbiAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfc3RhcnRTY3JvbGwoeCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY3JvbGxQcmljZVRvKHByaWNlU2NhbGUsIHgpIHtcbiAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfc2Nyb2xsVG8oeCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUFsbFNvdXJjZXMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjcm9sbFByaWNlKHByaWNlU2NhbGUpIHtcbiAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfZW5kU2Nyb2xsKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVBbGxTb3VyY2VzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgICAgICAgIHNvdXJjZS5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpIHtcbiAgICAgICAgbGV0IHByaWNlU2NhbGUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKS5yaWdodFByaWNlU2NhbGUudmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlU2NhbGUuX2ludGVybmFsX2RhdGFTb3VyY2VzKCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9vcHRpb25zKCkubGVmdFByaWNlU2NhbGUudmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZS5faW50ZXJuYWxfZGF0YVNvdXJjZXMoKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlc1swXS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmljZVNjYWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmljZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVmYXVsdFZpc2libGVQcmljZVNjYWxlKCkge1xuICAgICAgICBsZXQgcHJpY2VTY2FsZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLnJpZ2h0UHJpY2VTY2FsZS52aXNpYmxlKSB7XG4gICAgICAgICAgICBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9vcHRpb25zKCkubGVmdFByaWNlU2NhbGUudmlzaWJsZSkge1xuICAgICAgICAgICAgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZVNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmljZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKHByaWNlU2NhbGUpIHtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUgPT09IG51bGwgfHwgIXByaWNlU2NhbGUuX2ludGVybmFsX2lzQXV0b1NjYWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0ZVByaWNlU2NhbGVJbXBsKHByaWNlU2NhbGUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVzZXRQcmljZVNjYWxlKHByaWNlU2NhbGUpIHtcbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpO1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9zZXRNb2RlKHsgX2ludGVybmFsX2F1dG9TY2FsZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKHZpc2libGVCYXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlUmFuZ2UodmlzaWJsZUJhcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUFsbFNvdXJjZXMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX21vbWVudGFyeUF1dG9TY2FsZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjYWxjdWxhdGVQcmljZVNjYWxlSW1wbCh0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VTY2FsZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY2FsY3VsYXRlUHJpY2VTY2FsZUltcGwodGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlY2FsY3VsYXRlKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlU2NhbGUodGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlU2NhbGUodGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZVNjYWxlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuZm9yRWFjaCgoZHMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc092ZXJsYXkoZHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKGRzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlQWxsU291cmNlcygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX29yZGVyZWRTb3VyY2VzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2FjaGVkT3JkZXJlZFNvdXJjZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzID0gc29ydFNvdXJjZXModGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcztcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFNlcmllc09yZGVyKHNlcmllcywgb3JkZXIpIHtcbiAgICAgICAgb3JkZXIgPSBjbGFtcChvcmRlciwgMCwgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuaW5kZXhPZihzZXJpZXMpO1xuICAgICAgICBhc3NlcnQoaW5kZXggIT09IC0xLCAnc2V0U2VyaWVzT3JkZXI6IGludmFsaWQgZGF0YSBzb3VyY2UnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YVNvdXJjZXMuc3BsaWNlKG9yZGVyLCAwLCBzZXJpZXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhU291cmNlcy5mb3JFYWNoKChwcywgaSkgPT4gcHMuX2ludGVybmFsX3NldFpvcmRlcihpKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlZE9yZGVyZWRTb3VyY2VzID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBwcyBvZiBbdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlU2NhbGUsIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VTY2FsZV0pIHtcbiAgICAgICAgICAgIHBzLl9pbnRlcm5hbF9pbnZhbGlkYXRlU291cmNlc0NhY2hlKCk7XG4gICAgICAgICAgICBwcy5faW50ZXJuYWxfdXBkYXRlRm9ybWF0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcmRlcmVkU2VyaWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKS5maWx0ZXIoaXNTZXJpZXMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb25EZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19kZXN0cm95ZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9ncmlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZ3JpZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2F0dGFjaFByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5wdXNoKG5ldyBQYW5lUHJpbWl0aXZlV3JhcHBlciQxKHByaW1pdGl2ZSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGV0YWNoUHJpbWl0aXZlKHNvdXJjZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzID0gdGhpcy5fcHJpdmF0ZV9fcHJpbWl0aXZlcy5maWx0ZXIoKHdyYXBwZXIpID0+IHdyYXBwZXIuX2ludGVybmFsX3ByaW1pdGl2ZSgpICE9PSBzb3VyY2UpO1xuICAgICAgICBpZiAoc291cmNlLmRldGFjaGVkKSB7XG4gICAgICAgICAgICBzb3VyY2UuZGV0YWNoZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaW1pdGl2ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpbWl0aXZlSGl0VGVzdCh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmltaXRpdmVzXG4gICAgICAgICAgICAubWFwKChwcmltaXRpdmUpID0+IHByaW1pdGl2ZS5faW50ZXJuYWxfaGl0VGVzdCh4LCB5KSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHJlc3VsdCkgPT4gcmVzdWx0ICE9PSBudWxsKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3JlY2FsY3VsYXRlUHJpY2VTY2FsZUltcGwocHJpY2VTY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBjYW4gdXNlIHRoaXMgY2hlY2tzXG4gICAgICAgIGNvbnN0IHNvdXJjZUZvckF1dG9TY2FsZSA9IHByaWNlU2NhbGUuX2ludGVybmFsX3NvdXJjZXNGb3JBdXRvU2NhbGUoKTtcbiAgICAgICAgaWYgKHNvdXJjZUZvckF1dG9TY2FsZSAmJiBzb3VyY2VGb3JBdXRvU2NhbGUubGVuZ3RoID4gMCAmJiAhdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVCYXJzID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgICAgIGlmICh2aXNpYmxlQmFycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByaWNlU2NhbGUuX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VSYW5nZSh2aXNpYmxlQmFycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2luc2VydERhdGFTb3VyY2Uoc291cmNlLCBwcmljZVNjYWxlSWQsIG9yZGVyKSB7XG4gICAgICAgIGxldCBwcmljZVNjYWxlID0gdGhpcy5faW50ZXJuYWxfcHJpY2VTY2FsZUJ5SWQocHJpY2VTY2FsZUlkKTtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19jcmVhdGVQcmljZVNjYWxlKHByaWNlU2NhbGVJZCwgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKS5vdmVybGF5UHJpY2VTY2FsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFTb3VyY2VzLnNwbGljZShvcmRlciwgMCwgc291cmNlKTtcbiAgICAgICAgaWYgKCFpc0RlZmF1bHRQcmljZVNjYWxlKHByaWNlU2NhbGVJZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlTb3VyY2VzID0gdGhpcy5fcHJpdmF0ZV9fb3ZlcmxheVNvdXJjZXNCeVNjYWxlSWQuZ2V0KHByaWNlU2NhbGVJZCkgfHwgW107XG4gICAgICAgICAgICBvdmVybGF5U291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vdmVybGF5U291cmNlc0J5U2NhbGVJZC5zZXQocHJpY2VTY2FsZUlkLCBvdmVybGF5U291cmNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlLl9pbnRlcm5hbF9zZXRab3JkZXIob3JkZXIpO1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9hZGREYXRhU291cmNlKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZS5faW50ZXJuYWxfc2V0UHJpY2VTY2FsZShwcmljZVNjYWxlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKHByaWNlU2NhbGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRPcmRlcmVkU291cmNlcyA9IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19vblByaWNlU2NhbGVNb2RlQ2hhbmdlZChwcmljZVNjYWxlLCBvbGRNb2RlLCBuZXdNb2RlKSB7XG4gICAgICAgIGlmIChvbGRNb2RlLl9pbnRlcm5hbF9tb2RlID09PSBuZXdNb2RlLl9pbnRlcm5hbF9tb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW9tZW50YXJ5IGF1dG8gc2NhbGUgaWYgd2UgdG9nZ2xlIHBlcmNlbnRhZ2UvaW5kZXhlZFRvMTAwIG1vZGVcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjYWxjdWxhdGVQcmljZVNjYWxlSW1wbChwcmljZVNjYWxlKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NyZWF0ZVByaWNlU2NhbGUoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IHsgdmlzaWJsZTogdHJ1ZSwgYXV0b1NjYWxlOiB0cnVlLCAuLi5jbG9uZShvcHRpb25zKSB9O1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gbmV3IFByaWNlU2NhbGUoaWQsIGFjdHVhbE9wdGlvbnMsIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9vcHRpb25zKClbJ2xheW91dCddLCB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpLmxvY2FsaXphdGlvbiwgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2NvbG9yUGFyc2VyKCkpO1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9zZXRIZWlnaHQodGhpcy5faW50ZXJuYWxfaGVpZ2h0KCkpO1xuICAgICAgICByZXR1cm4gcHJpY2VTY2FsZTtcbiAgICB9XG59XG5cbi8vIHJldHVybnMgdHJ1ZSBpZiBpdGVtIGlzIGFib3ZlIHJlZmVyZW5jZVxuZnVuY3Rpb24gY29tcGFyZVByaW1pdGl2ZVpPcmRlcihpdGVtLCByZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gKCFyZWZlcmVuY2UgfHxcbiAgICAgICAgKGl0ZW0gPT09ICd0b3AnICYmIHJlZmVyZW5jZSAhPT0gJ3RvcCcpIHx8XG4gICAgICAgIChpdGVtID09PSAnbm9ybWFsJyAmJiByZWZlcmVuY2UgPT09ICdib3R0b20nKSk7XG59XG5mdW5jdGlvbiBmaW5kQmVzdFByaW1pdGl2ZUhpdFRlc3Qoc291cmNlcywgeCwgeSkge1xuICAgIGxldCBiZXN0UHJpbWl0aXZlSGl0O1xuICAgIGxldCBiZXN0SGl0U291cmNlO1xuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlSGl0UmVzdWx0cyA9IHNvdXJjZS5faW50ZXJuYWxfcHJpbWl0aXZlSGl0VGVzdD8uKHgsIHkpID8/IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGhpdFJlc3VsdCBvZiBwcmltaXRpdmVIaXRSZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZVByaW1pdGl2ZVpPcmRlcihoaXRSZXN1bHQuek9yZGVyLCBiZXN0UHJpbWl0aXZlSGl0Py56T3JkZXIpKSB7XG4gICAgICAgICAgICAgICAgYmVzdFByaW1pdGl2ZUhpdCA9IGhpdFJlc3VsdDtcbiAgICAgICAgICAgICAgICBiZXN0SGl0U291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghYmVzdFByaW1pdGl2ZUhpdCB8fCAhYmVzdEhpdFNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX2hpdDogYmVzdFByaW1pdGl2ZUhpdCxcbiAgICAgICAgX2ludGVybmFsX3NvdXJjZTogYmVzdEhpdFNvdXJjZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydFByaW1pdGl2ZUhpdFJlc3VsdChwcmltaXRpdmVIaXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZXJuYWxfc291cmNlOiBwcmltaXRpdmVIaXQuX2ludGVybmFsX3NvdXJjZSxcbiAgICAgICAgX2ludGVybmFsX29iamVjdDoge1xuICAgICAgICAgICAgX2ludGVybmFsX2V4dGVybmFsSWQ6IHByaW1pdGl2ZUhpdC5faW50ZXJuYWxfaGl0LmV4dGVybmFsSWQsXG4gICAgICAgIH0sXG4gICAgICAgIF9pbnRlcm5hbF9jdXJzb3JTdHlsZTogcHJpbWl0aXZlSGl0Ll9pbnRlcm5hbF9oaXQuY3Vyc29yU3R5bGUsXG4gICAgfTtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBoaXQgdGVzdCBvbiBhIGNvbGxlY3Rpb24gb2YgcGFuZSB2aWV3cyB0byBkZXRlcm1pbmUgd2hpY2ggdmlldyBhbmQgb2JqZWN0XG4gKiBpcyBsb2NhdGVkIGF0IGEgZ2l2ZW4gY29vcmRpbmF0ZSAoeCwgeSkgYW5kIHJldHVybnMgdGhlIG1hdGNoaW5nIHBhbmUgdmlldyBhbmRcbiAqIGhpdC10ZXN0ZWQgcmVzdWx0IG9iamVjdCwgb3IgbnVsbCBpZiBubyBtYXRjaCBpcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gaGl0VGVzdFBhbmVWaWV3KHBhbmVWaWV3cywgeCwgeSwgcGFuZSkge1xuICAgIGZvciAoY29uc3QgcGFuZVZpZXcgb2YgcGFuZVZpZXdzKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gcGFuZVZpZXcuX2ludGVybmFsX3JlbmRlcmVyKHBhbmUpO1xuICAgICAgICBpZiAocmVuZGVyZXIgIT09IG51bGwgJiYgcmVuZGVyZXIuX2ludGVybmFsX2hpdFRlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlbmRlcmVyLl9pbnRlcm5hbF9oaXRUZXN0KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF92aWV3OiBwYW5lVmlldyxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX29iamVjdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0RhdGFTb3VyY2Uoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5faW50ZXJuYWxfcGFuZVZpZXdzICE9PSB1bmRlZmluZWQ7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gaGl0VGVzdFBhbmUocGFuZSwgeCwgeSkge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbcGFuZSwgLi4ucGFuZS5faW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKV07XG4gICAgY29uc3QgYmVzdFByaW1pdGl2ZUhpdCA9IGZpbmRCZXN0UHJpbWl0aXZlSGl0VGVzdChzb3VyY2VzLCB4LCB5KTtcbiAgICBpZiAoYmVzdFByaW1pdGl2ZUhpdD8uX2ludGVybmFsX2hpdC56T3JkZXIgPT09ICd0b3AnKSB7XG4gICAgICAgIC8vIGEgcHJpbWl0aXZlIGhpdCBvbiB0aGUgJ3RvcCcgbGF5ZXIgd2lsbCBhbHdheXMgYmVhdCB0aGUgYnVpbHQtaW4gaGl0IHRlc3RzXG4gICAgICAgIC8vIChvbiBub3JtYWwgbGF5ZXIpIHNvIHdlIGNhbiByZXR1cm4gZWFybHkgaGVyZS5cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRQcmltaXRpdmVIaXRSZXN1bHQoYmVzdFByaW1pdGl2ZUhpdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKGJlc3RQcmltaXRpdmVIaXQgJiYgYmVzdFByaW1pdGl2ZUhpdC5faW50ZXJuYWxfc291cmNlID09PSBzb3VyY2UgJiYgYmVzdFByaW1pdGl2ZUhpdC5faW50ZXJuYWxfaGl0LnpPcmRlciAhPT0gJ2JvdHRvbScgJiYgIWJlc3RQcmltaXRpdmVIaXQuX2ludGVybmFsX2hpdC5pc0JhY2tncm91bmQpIHtcbiAgICAgICAgICAgIC8vIGEgcHJpbWl0aXZlIHdpbGwgYmUgZHJhd24gYWJvdmUgYSBidWlsdC1pbiBpdGVtIGxpa2UgYSBzZXJpZXMgbWFya2VyXG4gICAgICAgICAgICAvLyB0aGVyZWZvcmUgaXQgdGFrZXMgcHJlY2VkZW5jZSBoZXJlLlxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRQcmltaXRpdmVIaXRSZXN1bHQoYmVzdFByaW1pdGl2ZUhpdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGF0YVNvdXJjZShzb3VyY2UpKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VSZXN1bHQgPSBoaXRUZXN0UGFuZVZpZXcoc291cmNlLl9pbnRlcm5hbF9wYW5lVmlld3MocGFuZSksIHgsIHksIHBhbmUpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZVJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9zb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX3ZpZXc6IHNvdXJjZVJlc3VsdC5faW50ZXJuYWxfdmlldyxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX29iamVjdDogc291cmNlUmVzdWx0Ll9pbnRlcm5hbF9vYmplY3QsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdFByaW1pdGl2ZUhpdCAmJiBiZXN0UHJpbWl0aXZlSGl0Ll9pbnRlcm5hbF9zb3VyY2UgPT09IHNvdXJjZSAmJiBiZXN0UHJpbWl0aXZlSGl0Ll9pbnRlcm5hbF9oaXQuek9yZGVyICE9PSAnYm90dG9tJyAmJiBiZXN0UHJpbWl0aXZlSGl0Ll9pbnRlcm5hbF9oaXQuaXNCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFByaW1pdGl2ZUhpdFJlc3VsdChiZXN0UHJpbWl0aXZlSGl0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVzdFByaW1pdGl2ZUhpdD8uX2ludGVybmFsX2hpdCkge1xuICAgICAgICAvLyByZXR1cm4gcHJpbWl0aXZlIGhpdHMgZm9yIHRoZSAnYm90dG9tJyBsYXllclxuICAgICAgICByZXR1cm4gY29udmVydFByaW1pdGl2ZUhpdFJlc3VsdChiZXN0UHJpbWl0aXZlSGl0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIEZvcm1hdHRlZExhYmVsc0NhY2hlIHtcbiAgICBjb25zdHJ1Y3Rvcihmb3JtYXQsIGhvcnpTY2FsZUJlaGF2aW9yLCBzaXplID0gNTApIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWN0dWFsU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VzYWdlVGljayA9IDE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29sZGVzdFRpY2sgPSAxO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IgPSBob3J6U2NhbGVCZWhhdmlvcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWF4U2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXQodGlja01hcmspIHtcbiAgICAgICAgY29uc3QgdGltZSA9IHRpY2tNYXJrLnRpbWU7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuY2FjaGVLZXkodGltZSk7XG4gICAgICAgIGNvbnN0IHRpY2sgPSB0aGlzLl9wcml2YXRlX19jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAodGljayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGljay5faW50ZXJuYWxfc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19hY3R1YWxTaXplID09PSB0aGlzLl9wcml2YXRlX19tYXhTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRlc3RWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3RpY2syTGFiZWxzLmdldCh0aGlzLl9wcml2YXRlX19vbGRlc3RUaWNrKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpY2syTGFiZWxzLmRlbGV0ZSh0aGlzLl9wcml2YXRlX19vbGRlc3RUaWNrKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlLmRlbGV0ZShlbnN1cmVEZWZpbmVkKG9sZGVzdFZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vbGRlc3RUaWNrKys7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hY3R1YWxTaXplLS07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyID0gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0KHRpY2tNYXJrKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUuc2V0KGNhY2hlS2V5LCB7IF9pbnRlcm5hbF9zdHJpbmc6IHN0ciwgX2ludGVybmFsX3RpY2s6IHRoaXMuX3ByaXZhdGVfX3VzYWdlVGljayB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGljazJMYWJlbHMuc2V0KHRoaXMuX3ByaXZhdGVfX3VzYWdlVGljaywgY2FjaGVLZXkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hY3R1YWxTaXplKys7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VzYWdlVGljaysrO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn1cblxuY2xhc3MgUmFuZ2VJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCkge1xuICAgICAgICBhc3NlcnQobGVmdCA8PSByaWdodCwgJ3JpZ2h0IHNob3VsZCBiZSA+PSBsZWZ0Jyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xlZnQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JpZ2h0O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19yaWdodCAtIHRoaXMuX3ByaXZhdGVfX2xlZnQgKyAxO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY29udGFpbnMoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xlZnQgPD0gaW5kZXggJiYgaW5kZXggPD0gdGhpcy5fcHJpdmF0ZV9fcmlnaHQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xlZnQgPT09IG90aGVyLl9pbnRlcm5hbF9sZWZ0KCkgJiYgdGhpcy5fcHJpdmF0ZV9fcmlnaHQgPT09IG90aGVyLl9pbnRlcm5hbF9yaWdodCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFyZVJhbmdlc0VxdWFsKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoZmlyc3QgPT09IG51bGwgfHwgc2Vjb25kID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmaXJzdCA9PT0gc2Vjb25kO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3QuX2ludGVybmFsX2VxdWFscyhzZWNvbmQpO1xufVxuXG5jbGFzcyBUaWNrTWFya3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0J5V2VpZ2h0ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VuaWZvcm1EaXN0cmlidXRpb24gPSBmYWxzZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFVuaWZvcm1EaXN0cmlidXRpb24odmFsKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VuaWZvcm1EaXN0cmlidXRpb24gPSB2YWw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhY2hlID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFRpbWVTY2FsZVBvaW50cyhuZXdQb2ludHMsIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVtb3ZlTWFya3NTaW5jZUluZGV4KGZpcnN0Q2hhbmdlZFBvaW50SW5kZXgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZSA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gZmlyc3RDaGFuZ2VkUG9pbnRJbmRleDsgaW5kZXggPCBuZXdQb2ludHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IG5ld1BvaW50c1tpbmRleF07XG4gICAgICAgICAgICBsZXQgbWFya3NGb3JXZWlnaHQgPSB0aGlzLl9wcml2YXRlX19tYXJrc0J5V2VpZ2h0LmdldChwb2ludC50aW1lV2VpZ2h0KTtcbiAgICAgICAgICAgIGlmIChtYXJrc0ZvcldlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWFya3NGb3JXZWlnaHQgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0J5V2VpZ2h0LnNldChwb2ludC50aW1lV2VpZ2h0LCBtYXJrc0ZvcldlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJrc0ZvcldlaWdodC5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdGltZTogcG9pbnQudGltZSxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IHBvaW50LnRpbWVXZWlnaHQsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxUaW1lOiBwb2ludC5vcmlnaW5hbFRpbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfYnVpbGQoc3BhY2luZywgbWF4V2lkdGgsIGNoZWNrSW5kaWNlc0ZvckRhdGEsIGluZGljZXNXaXRoRGF0YU1hcCwgaW5kaWNlc1dpdGhEYXRhSWQpIHtcbiAgICAgICAgY29uc3QgbWF4SW5kZXhlc1Blck1hcmsgPSBNYXRoLmNlaWwobWF4V2lkdGggLyBzcGFjaW5nKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NhY2hlID09PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZS5faW50ZXJuYWxfbWF4SW5kZXhlc1Blck1hcmsgIT09IG1heEluZGV4ZXNQZXJNYXJrIHx8XG4gICAgICAgICAgICBpbmRpY2VzV2l0aERhdGFJZCAhPT0gdGhpcy5fcHJpdmF0ZV9fY2FjaGUuX2ludGVybmFsX2luZGljZXNXaXRoRGF0YUlkIHx8XG4gICAgICAgICAgICBjaGVja0luZGljZXNGb3JEYXRhICE9PSB0aGlzLl9wcml2YXRlX19jYWNoZS5faW50ZXJuYWxfY2hlY2tJbmRpY2VzRm9yRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2luZGljZXNXaXRoRGF0YUlkOiBpbmRpY2VzV2l0aERhdGFJZCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfY2hlY2tJbmRpY2VzRm9yRGF0YTogY2hlY2tJbmRpY2VzRm9yRGF0YSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbWFya3M6IHRoaXMuX3ByaXZhdGVfX2J1aWxkTWFya3NJbXBsKG1heEluZGV4ZXNQZXJNYXJrLCBjaGVja0luZGljZXNGb3JEYXRhLCBpbmRpY2VzV2l0aERhdGFNYXApLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9tYXhJbmRleGVzUGVyTWFyazogbWF4SW5kZXhlc1Blck1hcmssXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYWNoZS5faW50ZXJuYWxfbWFya3M7XG4gICAgfVxuICAgIF9wcml2YXRlX19yZW1vdmVNYXJrc1NpbmNlSW5kZXgoc2luY2VJbmRleCkge1xuICAgICAgICBpZiAoc2luY2VJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya3NCeVdlaWdodC5jbGVhcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdlaWdodHNUb0NsZWFyID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtzQnlXZWlnaHQuZm9yRWFjaCgobWFya3MsIHRpbWVXZWlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChzaW5jZUluZGV4IDw9IG1hcmtzWzBdLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0c1RvQ2xlYXIucHVzaCh0aW1lV2VpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcmtzLnNwbGljZShsb3dlckJvdW5kKG1hcmtzLCBzaW5jZUluZGV4LCAodG0pID0+IHRtLmluZGV4IDwgc2luY2VJbmRleCksIEluZmluaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3Qgd2VpZ2h0IG9mIHdlaWdodHNUb0NsZWFyKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrc0J5V2VpZ2h0LmRlbGV0ZSh3ZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19idWlsZE1hcmtzSW1wbChtYXhJbmRleGVzUGVyTWFyaywgY2hlY2tJbmRpY2VzRm9yRGF0YSwgaW5kaWNlc1dpdGhEYXRhTWFwKSB7XG4gICAgICAgIGxldCBtYXJrcyA9IFtdO1xuICAgICAgICBjb25zdCBjYW5CZUluY2x1ZGVkID0gKG1hcmspID0+ICFjaGVja0luZGljZXNGb3JEYXRhIHx8IGluZGljZXNXaXRoRGF0YU1hcC5oYXMobWFyay5pbmRleCk7XG4gICAgICAgIGZvciAoY29uc3Qgd2VpZ2h0IG9mIEFycmF5LmZyb20odGhpcy5fcHJpdmF0ZV9fbWFya3NCeVdlaWdodC5rZXlzKCkpLnNvcnQoKGEsIGIpID0+IGIgLSBhKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19tYXJrc0J5V2VpZ2h0LmdldCh3ZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsdCB0aWNrTWFya3MgYXJlIG5vdyBwcmV2TWFya3MsIGFuZCBtYXJrcyBpdCBhcyBuZXcgYXJyYXlcbiAgICAgICAgICAgIGNvbnN0IHByZXZNYXJrcyA9IG1hcmtzO1xuICAgICAgICAgICAgbWFya3MgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZNYXJrc0xlbmd0aCA9IHByZXZNYXJrcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcHJldk1hcmtzUG9pbnRlciA9IDA7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50V2VpZ2h0ID0gZW5zdXJlRGVmaW5lZCh0aGlzLl9wcml2YXRlX19tYXJrc0J5V2VpZ2h0LmdldCh3ZWlnaHQpKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRXZWlnaHRMZW5ndGggPSBjdXJyZW50V2VpZ2h0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCByaWdodEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgbGVmdEluZGV4ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50V2VpZ2h0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrID0gY3VycmVudFdlaWdodFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBtYXJrLmluZGV4O1xuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBpbmRleGVzIHdpdGggd2hpY2ggY3VycmVudCBpbmRleCB3aWxsIGJlIGNvbXBhcmVkXG4gICAgICAgICAgICAgICAgLy8gQWxsIG1hcmtzIHRvIHRoZSByaWdodCBpcyBtb3ZlZCB0byBuZXcgYXJyYXlcbiAgICAgICAgICAgICAgICB3aGlsZSAocHJldk1hcmtzUG9pbnRlciA8IHByZXZNYXJrc0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0TWFyayA9IHByZXZNYXJrc1twcmV2TWFya3NQb2ludGVyXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gbGFzdE1hcmsuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPCBjdXJyZW50SW5kZXggJiYgY2FuQmVJbmNsdWRlZChsYXN0TWFyaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZNYXJrc1BvaW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtzLnB1c2gobGFzdE1hcmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodEluZGV4IC0gY3VycmVudEluZGV4ID49IG1heEluZGV4ZXNQZXJNYXJrICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCAtIGxlZnRJbmRleCA+PSBtYXhJbmRleGVzUGVyTWFyayAmJlxuICAgICAgICAgICAgICAgICAgICBjYW5CZUluY2x1ZGVkKG1hcmspKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRpY2tNYXJrIGZpdHMuIFBsYWNlIGl0IGludG8gbmV3IGFycmF5XG4gICAgICAgICAgICAgICAgICAgIG1hcmtzLnB1c2gobWFyayk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191bmlmb3JtRGlzdHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldk1hcmtzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGxhY2UgYWxsIHVudXNlZCB0aWNrTWFya3MgaW50byBuZXcgYXJyYXk7XG4gICAgICAgICAgICBmb3IgKDsgcHJldk1hcmtzUG9pbnRlciA8IHByZXZNYXJrc0xlbmd0aDsgcHJldk1hcmtzUG9pbnRlcisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbkJlSW5jbHVkZWQocHJldk1hcmtzW3ByZXZNYXJrc1BvaW50ZXJdKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHByZXZNYXJrc1twcmV2TWFya3NQb2ludGVyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG59XG5cbmNsYXNzIFRpbWVTY2FsZVZpc2libGVSYW5nZSB7XG4gICAgY29uc3RydWN0b3IobG9naWNhbFJhbmdlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZSA9IGxvZ2ljYWxSYW5nZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0cmljdFJhbmdlKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlSW1wbChNYXRoLmZsb29yKHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZS5faW50ZXJuYWxfbGVmdCgpKSwgTWF0aC5jZWlsKHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZS5faW50ZXJuYWxfcmlnaHQoKSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbG9naWNhbFJhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlO1xuICAgIH1cbiAgICBzdGF0aWMgX2ludGVybmFsX2ludmFsaWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZVNjYWxlVmlzaWJsZVJhbmdlKG51bGwpO1xuICAgIH1cbn1cblxuY29uc3QgZGVmYXVsdFRpY2tNYXJrTWF4Q2hhcmFjdGVyTGVuZ3RoID0gODtcbmZ1bmN0aW9uIG1hcmtXaXRoR3JlYXRlcldlaWdodCQyKGEsIGIpIHtcbiAgICByZXR1cm4gYS53ZWlnaHQgPiBiLndlaWdodCA/IGEgOiBiO1xufVxuY2xhc3MgVGltZVNjYWxlIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgb3B0aW9ucywgbG9jYWxpemF0aW9uT3B0aW9ucywgaG9yelNjYWxlQmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlSW5kZXhPck51bGwgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpY2tNYXJrcyA9IG5ldyBUaWNrTWFya3MoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVkQnlXZWlnaHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZSA9IFRpbWVTY2FsZVZpc2libGVSYW5nZS5faW50ZXJuYWxfaW52YWxpZCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVCYXJzQ2hhbmdlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb2dpY2FsUmFuZ2VDaGFuZ2VkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnNBcHBsaWVkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZU1hcmtzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbmRpY2VzV2l0aERhdGEgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGljZXNXaXRoRGF0YVVwZGF0ZUlkID0gLTE7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xhYmVscyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucyA9IGxvY2FsaXphdGlvbk9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0ID0gb3B0aW9ucy5yaWdodE9mZnNldDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyA9IG9wdGlvbnMuYmFyU3BhY2luZztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IgPSBob3J6U2NhbGVCZWhhdmlvcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlRGF0ZVRpbWVGb3JtYXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGlja01hcmtzLl9pbnRlcm5hbF9zZXRVbmlmb3JtRGlzdHJpYnV0aW9uKG9wdGlvbnMudW5pZm9ybURpc3RyaWJ1dGlvbik7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlY2FsY3VsYXRlSW5kaWNlc1dpdGhEYXRhKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucztcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGx5TG9jYWxpemF0aW9uT3B0aW9ucyhsb2NhbGl6YXRpb25PcHRpb25zKSB7XG4gICAgICAgIG1lcmdlKHRoaXMuX3ByaXZhdGVfX2xvY2FsaXphdGlvbk9wdGlvbnMsIGxvY2FsaXphdGlvbk9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlVGlja01hcmtzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZURhdGVUaW1lRm9ybWF0dGVyKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucywgbG9jYWxpemF0aW9uT3B0aW9ucykge1xuICAgICAgICBtZXJnZSh0aGlzLl9wcml2YXRlX19vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZml4TGVmdEVkZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RvRml4TGVmdEVkZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhSaWdodEVkZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RvRml4UmlnaHRFZGdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90ZSB0aGF0IGJhciBzcGFjaW5nIHNob3VsZCBiZSBhcHBsaWVkIGJlZm9yZSByaWdodCBvZmZzZXRcbiAgICAgICAgLy8gYmVjYXVzZSByaWdodCBvZmZzZXQgZGVwZW5kcyBvbiBiYXIgc3BhY2luZ1xuICAgICAgICBpZiAob3B0aW9ucy5iYXJTcGFjaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9zZXRCYXJTcGFjaW5nKG9wdGlvbnMuYmFyU3BhY2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmlnaHRPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KG9wdGlvbnMucmlnaHRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1pbkJhclNwYWNpbmcgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1heEJhclNwYWNpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8geWVzLCBpZiB3ZSBhcHBseSBiYXIgc3BhY2luZyBjb25zdHJhaW5zIHRoZW4gd2UgbmVlZCB0byBjb3JyZWN0IGJhciBzcGFjaW5nXG4gICAgICAgICAgICAvLyB0aGUgZWFzaWVzdCB3YXkgaXMgdG8gYXBwbHkgaXQgb25jZSBhZ2FpblxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3NldEJhclNwYWNpbmcob3B0aW9ucy5iYXJTcGFjaW5nID8/IHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlnbm9yZVdoaXRlc3BhY2VJbmRpY2VzICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlSW5kaWNlcyAhPT0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlSW5kaWNlcykge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVJbmRpY2VzV2l0aERhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlVGlja01hcmtzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZURhdGVUaW1lRm9ybWF0dGVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnNBcHBsaWVkLl9pbnRlcm5hbF9maXJlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pbmRleFRvVGltZShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcG9pbnRzW2luZGV4XT8udGltZSA/PyBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW5kZXhUb1RpbWVTY2FsZVBvaW50KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wb2ludHNbaW5kZXhdID8/IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lVG9JbmRleCh0aW1lLCBmaW5kTmVhcmVzdCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcG9pbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIC8vIG5vIHRpbWUgcG9pbnRzIGF2YWlsYWJsZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0aW1lKSA+IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0aGlzLl9wcml2YXRlX19wb2ludHNbdGhpcy5fcHJpdmF0ZV9fcG9pbnRzLmxlbmd0aCAtIDFdLnRpbWUpKSB7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2VcbiAgICAgICAgICAgIHJldHVybiBmaW5kTmVhcmVzdCA/IHRoaXMuX3ByaXZhdGVfX3BvaW50cy5sZW5ndGggLSAxIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IGxvd2VyQm91bmQodGhpcy5fcHJpdmF0ZV9fcG9pbnRzLCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkodGltZSksIChhLCBiKSA9PiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkoYS50aW1lKSA8IGIpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHRpbWUpIDwgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHRoaXMuX3ByaXZhdGVfX3BvaW50c1tpbmRleF0udGltZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kTmVhcmVzdCA/IGluZGV4IDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fd2lkdGggPT09IDAgfHwgdGhpcy5fcHJpdmF0ZV9fcG9pbnRzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9wcml2YXRlX19iYXNlSW5kZXhPck51bGwgPT09IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oYXNQb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLy8gc3RyaWN0IHJhbmdlOiBpbnRlZ2VyIGluZGljZXMgb2YgdGhlIGJhcnMgaW4gdGhlIHZpc2libGUgcmFuZ2Ugcm91bmRlZCBpbiBtb3JlIHdpZGUgZGlyZWN0aW9uXG4gICAgX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlVmlzaWJsZVJhbmdlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2UuX2ludGVybmFsX3N0cmljdFJhbmdlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92aXNpYmxlTG9naWNhbFJhbmdlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVWaXNpYmxlUmFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZS5faW50ZXJuYWxfbG9naWNhbFJhbmdlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF92aXNpYmxlVGltZVJhbmdlKCkge1xuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IHRoaXMuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpO1xuICAgICAgICBpZiAodmlzaWJsZUJhcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICAgICAgZnJvbTogdmlzaWJsZUJhcnMuX2ludGVybmFsX2xlZnQoKSxcbiAgICAgICAgICAgIHRvOiB2aXNpYmxlQmFycy5faW50ZXJuYWxfcmlnaHQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX3RpbWVSYW5nZUZvckxvZ2ljYWxSYW5nZShyYW5nZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lUmFuZ2VGb3JMb2dpY2FsUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgucm91bmQocmFuZ2UuZnJvbSk7XG4gICAgICAgIGNvbnN0IHRvID0gTWF0aC5yb3VuZChyYW5nZS50byk7XG4gICAgICAgIGNvbnN0IGZpcnN0SW5kZXggPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2ZpcnN0SW5kZXgoKSk7XG4gICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fbGFzdEluZGV4KCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9pbmRleFRvVGltZVNjYWxlUG9pbnQoTWF0aC5tYXgoZmlyc3RJbmRleCwgZnJvbSkpKSxcbiAgICAgICAgICAgIHRvOiBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX2luZGV4VG9UaW1lU2NhbGVQb2ludChNYXRoLm1pbihsYXN0SW5kZXgsIHRvKSkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbG9naWNhbFJhbmdlRm9yVGltZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3RpbWVUb0luZGV4KHJhbmdlLmZyb20sIHRydWUpKSxcbiAgICAgICAgICAgIHRvOiBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3RpbWVUb0luZGV4KHJhbmdlLnRvLCB0cnVlKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF93aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3dpZHRoO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0V2lkdGgobmV3V2lkdGgpIHtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShuZXdXaWR0aCkgfHwgbmV3V2lkdGggPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX193aWR0aCA9PT0gbmV3V2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIHdlIGNoYW5nZSB0aGUgd2lkdGggYW5kIHdlIG5lZWQgdG8gY29ycmVjdCB2aXNpYmxlIHJhbmdlIGJlY2F1c2Ugb2YgZml4aW5nIGxlZnQgZWRnZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBwcmV2aW91cyB2aXNpYmxlIHJhbmdlIHJhdGhlciB0aGFuIHRoZSBuZXcgb25lXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgbWlnaHQgYmUgdXBkYXRlZCBieSBjaGFuZ2luZyB3aWR0aCwgYmFyIHNwYWNpbmcsIGV0Y1xuICAgICAgICAvLyBidXQgd2UgbmVlZCB0byB0cnkgdG8ga2VlcCB0aGUgc2FtZSByYW5nZVxuICAgICAgICBjb25zdCBwcmV2aW91c1Zpc2libGVSYW5nZSA9IHRoaXMuX2ludGVybmFsX3Zpc2libGVMb2dpY2FsUmFuZ2UoKTtcbiAgICAgICAgY29uc3Qgb2xkV2lkdGggPSB0aGlzLl9wcml2YXRlX193aWR0aDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sb2NrVmlzaWJsZVRpbWVSYW5nZU9uUmVzaXplICYmIG9sZFdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBiYXIgc3BhY2luZ1xuICAgICAgICAgICAgY29uc3QgbmV3QmFyU3BhY2luZyA9IHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcgKiBuZXdXaWR0aCAvIG9sZFdpZHRoO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyA9IG5ld0JhclNwYWNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGltZSBzY2FsZSBpcyBzY3JvbGxlZCB0byB0aGUgZW5kIG9mIGRhdGEgYW5kIHdlIGhhdmUgZml4ZWQgcmlnaHQgZWRnZVxuICAgICAgICAvLyBrZWVwIGxlZnQgZWRnZSBpbnN0ZWFkIG9mIHJpZ2h0XG4gICAgICAgIC8vIHdlIG5lZWQgaXQgdG8gYXZvaWQgXCJzaGFraW5nXCIgaWYgdGhlIGxhc3QgYmFyIHZpc2liaWxpdHkgYWZmZWN0cyB0aW1lIHNjYWxlIHdpZHRoXG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19vcHRpb25zLmZpeExlZnRFZGdlKSB7XG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgbG9naWNhbCBsZWZ0IHJhbmdlIG1lYW5zIG5vdCB0aGUgbWlkZGxlIG9mIGEgYmFyIChpdCdzIHRoZSBsZWZ0IGJvcmRlcilcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1Zpc2libGVSYW5nZSAhPT0gbnVsbCAmJiBwcmV2aW91c1Zpc2libGVSYW5nZS5faW50ZXJuYWxfbGVmdCgpIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IG9sZFdpZHRoIC0gbmV3V2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gcmVkdWNlICBfcmlnaHRPZmZzZXQgbWVhbnMgbW92ZSByaWdodFxuICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkIG1vdmUgbW9yZSB0aGFuIHJlcXVpcmVkIC0gdGhpcyB3aWxsIGJlIGZpeGVkIGJ5IF9jb3JyZWN0T2Zmc2V0KClcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldCAtPSBNYXRoLnJvdW5kKGRlbHRhIC8gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZykgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGluZyBiYXIgc3BhY2luZyBzaG91bGQgYmUgZmlyc3QgYmVjYXVzZSByaWdodCBvZmZzZXQgZGVwZW5kcyBvbiBpdFxuICAgICAgICB0aGlzLl9wcml2YXRlX19jb3JyZWN0QmFyU3BhY2luZygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb3JyZWN0T2Zmc2V0KCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9pbmRleFRvQ29vcmRpbmF0ZShpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpIHx8ICFpc0ludGVnZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9pbnRlcm5hbF9iYXNlSW5kZXgoKTtcbiAgICAgICAgY29uc3QgZGVsdGFGcm9tUmlnaHQgPSBiYXNlSW5kZXggKyB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldCAtIGluZGV4O1xuICAgICAgICBjb25zdCBjb29yZGluYXRlID0gdGhpcy5fcHJpdmF0ZV9fd2lkdGggLSAoZGVsdGFGcm9tUmlnaHQgKyAwLjUpICogdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyAtIDE7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfaW5kZXhlc1RvQ29vcmRpbmF0ZXMocG9pbnRzLCB2aXNpYmxlUmFuZ2UpIHtcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5faW50ZXJuYWxfYmFzZUluZGV4KCk7XG4gICAgICAgIGNvbnN0IGluZGV4RnJvbSA9ICh2aXNpYmxlUmFuZ2UgPT09IHVuZGVmaW5lZCkgPyAwIDogdmlzaWJsZVJhbmdlLmZyb207XG4gICAgICAgIGNvbnN0IGluZGV4VG8gPSAodmlzaWJsZVJhbmdlID09PSB1bmRlZmluZWQpID8gcG9pbnRzLmxlbmd0aCA6IHZpc2libGVSYW5nZS50bztcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4RnJvbTsgaSA8IGluZGV4VG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwb2ludHNbaV0uX2ludGVybmFsX3RpbWU7XG4gICAgICAgICAgICBjb25zdCBkZWx0YUZyb21SaWdodCA9IGJhc2VJbmRleCArIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0IC0gaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlID0gdGhpcy5fcHJpdmF0ZV9fd2lkdGggLSAoZGVsdGFGcm9tUmlnaHQgKyAwLjUpICogdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZyAtIDE7XG4gICAgICAgICAgICBwb2ludHNbaV0uX2ludGVybmFsX3ggPSBjb29yZGluYXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jb29yZGluYXRlVG9JbmRleCh4LCBjb25zaWRlcklnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmNlaWwodGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvRmxvYXRJbmRleCh4KSk7XG4gICAgICAgIGlmICghY29uc2lkZXJJZ25vcmVXaGl0ZXNwYWNlIHx8XG4gICAgICAgICAgICAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlSW5kaWNlcyB8fFxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2hvdWxkQ29uc2lkZXJJbmRleChpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZmluZE5lYXJlc3RJbmRleFdpdGhEYXRhKGluZGV4KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb3JyZWN0T2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYmFyU3BhY2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmc7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRCYXJTcGFjaW5nKG5ld0JhclNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0QmFyU3BhY2luZyhuZXdCYXJTcGFjaW5nKTtcbiAgICAgICAgLy8gZG8gbm90IGFsbG93IHNjcm9sbCBvdXQgb2YgdmlzaWJsZSBiYXJzXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3JlY2FsY3VsYXRlQWxsUGFuZXMoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yaWdodE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIF9pbnRlcm5hbF9tYXJrcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3RpbWVNYXJrc0NhY2hlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZU1hcmtzQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmc7XG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10uZm9udFNpemU7XG4gICAgICAgIGNvbnN0IHBpeGVsc1BlcjhDaGFyYWN0ZXJzID0gKGZvbnRTaXplICsgNCkgKiA1O1xuICAgICAgICBjb25zdCBwaXhlbHNQZXJDaGFyYWN0ZXIgPSBwaXhlbHNQZXI4Q2hhcmFjdGVycyAvIGRlZmF1bHRUaWNrTWFya01heENoYXJhY3Rlckxlbmd0aDtcbiAgICAgICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IHBpeGVsc1BlckNoYXJhY3RlciAqICh0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpY2tNYXJrTWF4Q2hhcmFjdGVyTGVuZ3RoIHx8IGRlZmF1bHRUaWNrTWFya01heENoYXJhY3Rlckxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGluZGV4UGVyTGFiZWwgPSBNYXRoLnJvdW5kKG1heExhYmVsV2lkdGggLyBzcGFjaW5nKTtcbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpKTtcbiAgICAgICAgY29uc3QgZmlyc3RCYXIgPSBNYXRoLm1heCh2aXNpYmxlQmFycy5faW50ZXJuYWxfbGVmdCgpLCB2aXNpYmxlQmFycy5faW50ZXJuYWxfbGVmdCgpIC0gaW5kZXhQZXJMYWJlbCk7XG4gICAgICAgIGNvbnN0IGxhc3RCYXIgPSBNYXRoLm1heCh2aXNpYmxlQmFycy5faW50ZXJuYWxfcmlnaHQoKSwgdmlzaWJsZUJhcnMuX2ludGVybmFsX3JpZ2h0KCkgLSBpbmRleFBlckxhYmVsKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9wcml2YXRlX190aWNrTWFya3MuX2ludGVybmFsX2J1aWxkKHNwYWNpbmcsIG1heExhYmVsV2lkdGgsIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuaWdub3JlV2hpdGVzcGFjZUluZGljZXMsIHRoaXMuX3ByaXZhdGVfX2luZGljZXNXaXRoRGF0YSwgdGhpcy5fcHJpdmF0ZV9faW5kaWNlc1dpdGhEYXRhVXBkYXRlSWQpO1xuICAgICAgICAvLyBhY2NvcmRpbmcgdG8gaW5kZXhQZXJMYWJlbCB2YWx1ZSB0aGlzIHZhbHVlIG1lYW5zIFwiZWFybGllc3QgaW5kZXggd2hpY2ggX21pZ2h0IGJlXyB1c2VkIGFzIHRoZSBzZWNvbmQgbGFiZWwgb24gdGltZSBzY2FsZVwiXG4gICAgICAgIGNvbnN0IGVhcmxpZXN0SW5kZXhPZlNlY29uZExhYmVsID0gdGhpcy5fcHJpdmF0ZV9fZmlyc3RJbmRleCgpICsgaW5kZXhQZXJMYWJlbDtcbiAgICAgICAgLy8gYWNjb3JkaW5nIHRvIGluZGV4UGVyTGFiZWwgdmFsdWUgdGhpcyB2YWx1ZSBtZWFucyBcImVhcmxpZXN0IGluZGV4IHdoaWNoIF9taWdodCBiZV8gdXNlZCBhcyB0aGUgc2Vjb25kIGxhc3QgbGFiZWwgb24gdGltZSBzY2FsZVwiXG4gICAgICAgIGNvbnN0IGluZGV4T2ZTZWNvbmRMYXN0TGFiZWwgPSB0aGlzLl9wcml2YXRlX19sYXN0SW5kZXgoKSAtIGluZGV4UGVyTGFiZWw7XG4gICAgICAgIGNvbnN0IGlzQWxsU2NhbGluZ0FuZFNjcm9sbGluZ0Rpc2FibGVkID0gdGhpcy5fcHJpdmF0ZV9faXNBbGxTY2FsaW5nQW5kU2Nyb2xsaW5nRGlzYWJsZWQoKTtcbiAgICAgICAgY29uc3QgaXNMZWZ0RWRnZUZpeGVkID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhMZWZ0RWRnZSB8fCBpc0FsbFNjYWxpbmdBbmRTY3JvbGxpbmdEaXNhYmxlZDtcbiAgICAgICAgY29uc3QgaXNSaWdodEVkZ2VGaXhlZCA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZml4UmlnaHRFZGdlIHx8IGlzQWxsU2NhbGluZ0FuZFNjcm9sbGluZ0Rpc2FibGVkO1xuICAgICAgICBsZXQgdGFyZ2V0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHRtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoIShmaXJzdEJhciA8PSB0bS5pbmRleCAmJiB0bS5pbmRleCA8PSBsYXN0QmFyKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxhYmVsO1xuICAgICAgICAgICAgaWYgKHRhcmdldEluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fbGFiZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gdGhpcy5fcHJpdmF0ZV9fbGFiZWxzW3RhcmdldEluZGV4XTtcbiAgICAgICAgICAgICAgICBsYWJlbC5jb29yZCA9IHRoaXMuX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKHRtLmluZGV4KTtcbiAgICAgICAgICAgICAgICBsYWJlbC5sYWJlbCA9IHRoaXMuX3ByaXZhdGVfX2Zvcm1hdExhYmVsKHRtKTtcbiAgICAgICAgICAgICAgICBsYWJlbC53ZWlnaHQgPSB0bS53ZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZEFsaWduQ29vcmRpbmF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkOiB0aGlzLl9pbnRlcm5hbF9pbmRleFRvQ29vcmRpbmF0ZSh0bS5pbmRleCksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLl9wcml2YXRlX19mb3JtYXRMYWJlbCh0bSksXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogdG0ud2VpZ2h0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2JhclNwYWNpbmcgPiAobWF4TGFiZWxXaWR0aCAvIDIpICYmICFpc0FsbFNjYWxpbmdBbmRTY3JvbGxpbmdEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSB0aGVuIGxldCdzIHNob3cgYWxsIHRpY2sgbWFya3MgYXMgdXN1YWxcbiAgICAgICAgICAgICAgICBsYWJlbC5uZWVkQWxpZ25Db29yZGluYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHVzZXIgaXMgYWJsZSB0byBzY3JvbGwgYWZ0ZXIgYSB0aWNrIG1hcmsgdGhlbiBzaG93IGl0IGFzIHVzdWFsLCBvdGhlcndpc2UgdGhlIGNvb3JkaW5hdGUgbWlnaHQgYmUgYWxpZ25lZFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpbmRleCBpcyBmb3IgdGhlIHNlY29uZCAobGFzdCkgbGFiZWwgb3IgbGF0ZXIgKGVhcmxpZXIpIHRoZW4gbW9zdCBsaWtlbHkgdGhpcyBsYWJlbCBtaWdodCBiZSBkaXNwbGF5ZWQgd2l0aG91dCBjb3JyZWN0aW5nIHRoZSBjb29yZGluYXRlXG4gICAgICAgICAgICAgICAgbGFiZWwubmVlZEFsaWduQ29vcmRpbmF0ZSA9IChpc0xlZnRFZGdlRml4ZWQgJiYgdG0uaW5kZXggPD0gZWFybGllc3RJbmRleE9mU2Vjb25kTGFiZWwpIHx8IChpc1JpZ2h0RWRnZUZpeGVkICYmIHRtLmluZGV4ID49IGluZGV4T2ZTZWNvbmRMYXN0TGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19sYWJlbHMubGVuZ3RoID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVNYXJrc0NhY2hlID0gdGhpcy5fcHJpdmF0ZV9fbGFiZWxzO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGFiZWxzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVzdG9yZURlZmF1bHQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0QmFyU3BhY2luZyh0aGlzLl9wcml2YXRlX19vcHRpb25zLmJhclNwYWNpbmcpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRSaWdodE9mZnNldCh0aGlzLl9wcml2YXRlX19vcHRpb25zLnJpZ2h0T2Zmc2V0KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEJhc2VJbmRleChiYXNlSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlSW5kZXhPck51bGwgPSBiYXNlSW5kZXg7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZG9GaXhMZWZ0RWRnZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBab29tIGluL291dCB0aGUgc2NhbGUgYXJvdW5kIGEgYHpvb21Qb2ludGAgb24gYHNjYWxlYCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB6b29tUG9pbnQgLSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGFwcGx5IHRoZSB6b29tLlxuICAgICAqIElmIGByaWdodEJhclN0YXlzT25TY3JvbGxgIG9wdGlvbiBpcyBkaXNhYmxlZCwgdGhlbiB3aWxsIGJlIHVzZWQgdG8gcmVzdG9yZSByaWdodCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHNjYWxlIC0gWm9vbSB2YWx1ZSAoaW4gMS8xMCBwYXJ0cyBvZiBjdXJyZW50IGJhciBzcGFjaW5nKS5cbiAgICAgKiBOZWdhdGl2ZSB2YWx1ZSBtZWFucyB6b29tIG91dCwgcG9zaXRpdmUgLSB6b29tIGluLlxuICAgICAqL1xuICAgIF9pbnRlcm5hbF96b29tKHpvb21Qb2ludCwgc2NhbGUpIHtcbiAgICAgICAgY29uc3QgZmxvYXRJbmRleEF0Wm9vbVBvaW50ID0gdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvRmxvYXRJbmRleCh6b29tUG9pbnQpO1xuICAgICAgICBjb25zdCBiYXJTcGFjaW5nID0gdGhpcy5faW50ZXJuYWxfYmFyU3BhY2luZygpO1xuICAgICAgICBjb25zdCBuZXdCYXJTcGFjaW5nID0gYmFyU3BhY2luZyArIHNjYWxlICogKGJhclNwYWNpbmcgLyAxMCk7XG4gICAgICAgIC8vIHpvb20gaW4vb3V0IGJhciBzcGFjaW5nXG4gICAgICAgIHRoaXMuX2ludGVybmFsX3NldEJhclNwYWNpbmcobmV3QmFyU3BhY2luZyk7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5yaWdodEJhclN0YXlzT25TY3JvbGwpIHtcbiAgICAgICAgICAgIC8vIGFuZCB0aGVuIGNvcnJlY3QgcmlnaHQgb2Zmc2V0IHRvIG1vdmUgaW5kZXggdW5kZXIgem9vbVBvaW50IGJhY2sgdG8gaXRzIGNvb3JkaW5hdGVcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KHRoaXMuX2ludGVybmFsX3JpZ2h0T2Zmc2V0KCkgKyAoZmxvYXRJbmRleEF0Wm9vbVBvaW50IC0gdGhpcy5fcHJpdmF0ZV9fY29vcmRpbmF0ZVRvRmxvYXRJbmRleCh6b29tUG9pbnQpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2NhbGUoeCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfZW5kU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCAhPT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19jb21tb25UcmFuc2l0aW9uU3RhcnRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zY2FsZVN0YXJ0UG9pbnQgPSB4O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zYXZlQ29tbW9uVHJhbnNpdGlvbnNTdGFydFN0YXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY2FsZVRvKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRMZW5ndGhGcm9tUmlnaHQgPSBjbGFtcCh0aGlzLl9wcml2YXRlX193aWR0aCAtIHgsIDAsIHRoaXMuX3ByaXZhdGVfX3dpZHRoKTtcbiAgICAgICAgY29uc3QgY3VycmVudExlbmd0aEZyb21SaWdodCA9IGNsYW1wKHRoaXMuX3ByaXZhdGVfX3dpZHRoIC0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19zY2FsZVN0YXJ0UG9pbnQpLCAwLCB0aGlzLl9wcml2YXRlX193aWR0aCk7XG4gICAgICAgIGlmIChzdGFydExlbmd0aEZyb21SaWdodCA9PT0gMCB8fCBjdXJyZW50TGVuZ3RoRnJvbVJpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0QmFyU3BhY2luZyh0aGlzLl9wcml2YXRlX19jb21tb25UcmFuc2l0aW9uU3RhcnRTdGF0ZS5faW50ZXJuYWxfYmFyU3BhY2luZyAqIHN0YXJ0TGVuZ3RoRnJvbVJpZ2h0IC8gY3VycmVudExlbmd0aEZyb21SaWdodCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbmRTY2FsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NjYWxlU3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsZWFyQ29tbW9uVHJhbnNpdGlvbnNTdGFydFN0YXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGFydFNjcm9sbCh4KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ICE9PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Njcm9sbFN0YXJ0UG9pbnQgPSB4O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zYXZlQ29tbW9uVHJhbnNpdGlvbnNTdGFydFN0YXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY3JvbGxUbyh4KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hpZnRJbkxvZ2ljYWwgPSAodGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCAtIHgpIC8gdGhpcy5faW50ZXJuYWxfYmFyU3BhY2luZygpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldCA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fY29tbW9uVHJhbnNpdGlvblN0YXJ0U3RhdGUpLl9pbnRlcm5hbF9yaWdodE9mZnNldCArIHNoaWZ0SW5Mb2dpY2FsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIC8vIGRvIG5vdCBhbGxvdyBzY3JvbGwgb3V0IG9mIHZpc2libGUgYmFyc1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb3JyZWN0T2Zmc2V0KCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9lbmRTY3JvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zY3JvbGxTdGFydFBvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsU3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsZWFyQ29tbW9uVHJhbnNpdGlvbnNTdGFydFN0YXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zY3JvbGxUb1JlYWxUaW1lKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zY3JvbGxUb09mZnNldEFuaW1hdGVkKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucmlnaHRPZmZzZXQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2Nyb2xsVG9PZmZzZXRBbmltYXRlZChvZmZzZXQsIGFuaW1hdGlvbkR1cmF0aW9uID0gNDAwIC8qIENvbnN0YW50cy5EZWZhdWx0QW5pbWF0aW9uRHVyYXRpb24gKi8pIHtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGZpbml0ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRmluaXRlKGFuaW1hdGlvbkR1cmF0aW9uKSB8fCBhbmltYXRpb25EdXJhdGlvbiA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYW5pbWF0aW9uRHVyYXRpb24gKG9wdGlvbmFsKSBtdXN0IGJlIGZpbml0ZSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldDtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3NldFRpbWVTY2FsZUFuaW1hdGlvbih7XG4gICAgICAgICAgICBfaW50ZXJuYWxfZmluaXNoZWQ6ICh0aW1lKSA9PiAodGltZSAtIGFuaW1hdGlvblN0YXJ0KSAvIGFuaW1hdGlvbkR1cmF0aW9uID49IDEsXG4gICAgICAgICAgICBfaW50ZXJuYWxfZ2V0UG9zaXRpb246ICh0aW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uUHJvZ3Jlc3MgPSAodGltZSAtIGFuaW1hdGlvblN0YXJ0KSAvIGFuaW1hdGlvbkR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmlzaEFuaW1hdGlvbiA9IGFuaW1hdGlvblByb2dyZXNzID49IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaEFuaW1hdGlvbiA/IG9mZnNldCA6IHNvdXJjZSArIChvZmZzZXQgLSBzb3VyY2UpICogYW5pbWF0aW9uUHJvZ3Jlc3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZShuZXdQb2ludHMsIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludHMgPSBuZXdQb2ludHM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpY2tNYXJrcy5faW50ZXJuYWxfc2V0VGltZVNjYWxlUG9pbnRzKG5ld1BvaW50cywgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RPZmZzZXQoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Zpc2libGVCYXJzQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVCYXJzQ2hhbmdlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2xvZ2ljYWxSYW5nZUNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19sb2dpY2FsUmFuZ2VDaGFuZ2VkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW9uc0FwcGxpZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zQXBwbGllZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2Jhc2VJbmRleCgpIHtcbiAgICAgICAgLy8gbnVsbCBpcyB1c2VkIHRvIGtub3duIHRoYXQgYmFzZUluZGV4IGlzIG5vdCBzZXQgeWV0XG4gICAgICAgIC8vIHNvIGluIG1ldGhvZHMgd2hpY2ggc2hvdWxkIGtub3duIHdoZXRoZXIgaXQgaXMgc2V0IG9yIG5vdFxuICAgICAgICAvLyB3ZSBzaG91bGQgY2hlY2sgZmllbGQgYF9iYXNlSW5kZXhPck51bGxgIGluc3RlYWQgb2YgZ2V0dGVyIGBiYXNlSW5kZXgoKWBcbiAgICAgICAgLy8gc2VlIG1pblJpZ2h0T2Zmc2V0IGZvciBleGFtcGxlXG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19iYXNlSW5kZXhPck51bGwgfHwgMDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFZpc2libGVSYW5nZShyYW5nZSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSByYW5nZS5faW50ZXJuYWxfY291bnQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0QmFyU3BhY2luZyh0aGlzLl9wcml2YXRlX193aWR0aCAvIGxlbmd0aCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0ID0gcmFuZ2UuX2ludGVybmFsX3JpZ2h0KCkgLSB0aGlzLl9pbnRlcm5hbF9iYXNlSW5kZXgoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUFsbFBhbmVzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZml0Q29udGVudCgpIHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLl9wcml2YXRlX19maXJzdEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLl9wcml2YXRlX19sYXN0SW5kZXgoKTtcbiAgICAgICAgaWYgKGZpcnN0ID09PSBudWxsIHx8IGxhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRWaXNpYmxlUmFuZ2UobmV3IFJhbmdlSW1wbChmaXJzdCwgbGFzdCArIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucmlnaHRPZmZzZXQpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldExvZ2ljYWxSYW5nZShyYW5nZSkge1xuICAgICAgICBjb25zdCBiYXJSYW5nZSA9IG5ldyBSYW5nZUltcGwocmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRWaXNpYmxlUmFuZ2UoYmFyUmFuZ2UpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0RGF0ZVRpbWUodGltZVNjYWxlUG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xvY2FsaXphdGlvbk9wdGlvbnMudGltZUZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbG9jYWxpemF0aW9uT3B0aW9ucy50aW1lRm9ybWF0dGVyKHRpbWVTY2FsZVBvaW50Lm9yaWdpbmFsVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmZvcm1hdEhvcnpJdGVtKHRpbWVTY2FsZVBvaW50LnRpbWUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVjYWxjdWxhdGVJbmRpY2VzV2l0aERhdGEoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlSW5kaWNlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGljZXNXaXRoRGF0YS5jbGVhcigpO1xuICAgICAgICBjb25zdCBzZXJpZXMgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2VyaWVzZXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHNlcmllcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBzLl9pbnRlcm5hbF9mdWxmaWxsZWRJbmRpY2VzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbmRpY2VzV2l0aERhdGEuc2V0KGluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19pbmRpY2VzV2l0aERhdGFVcGRhdGVJZCsrO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9faXNBbGxTY2FsaW5nQW5kU2Nyb2xsaW5nRGlzYWJsZWQoKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVNjcm9sbCA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9vcHRpb25zKClbJ2hhbmRsZVNjcm9sbCddO1xuICAgICAgICBjb25zdCBoYW5kbGVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9vcHRpb25zKClbJ2hhbmRsZVNjYWxlJ107XG4gICAgICAgIHJldHVybiAhaGFuZGxlU2Nyb2xsLmhvcnpUb3VjaERyYWdcbiAgICAgICAgICAgICYmICFoYW5kbGVTY3JvbGwubW91c2VXaGVlbFxuICAgICAgICAgICAgJiYgIWhhbmRsZVNjcm9sbC5wcmVzc2VkTW91c2VNb3ZlXG4gICAgICAgICAgICAmJiAhaGFuZGxlU2Nyb2xsLnZlcnRUb3VjaERyYWdcbiAgICAgICAgICAgICYmICFoYW5kbGVTY2FsZS5heGlzRG91YmxlQ2xpY2tSZXNldC50aW1lXG4gICAgICAgICAgICAmJiAhaGFuZGxlU2NhbGUuYXhpc1ByZXNzZWRNb3VzZU1vdmUudGltZVxuICAgICAgICAgICAgJiYgIWhhbmRsZVNjYWxlLm1vdXNlV2hlZWxcbiAgICAgICAgICAgICYmICFoYW5kbGVTY2FsZS5waW5jaDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZpcnN0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoID09PSAwID8gbnVsbCA6IDA7XG4gICAgfVxuICAgIF9wcml2YXRlX19sYXN0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoID09PSAwID8gbnVsbCA6ICh0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19yaWdodE9mZnNldEZvckNvb3JkaW5hdGUoeCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3ByaXZhdGVfX3dpZHRoIC0gMSAtIHgpIC8gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZztcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Nvb3JkaW5hdGVUb0Zsb2F0SW5kZXgoeCkge1xuICAgICAgICBjb25zdCBkZWx0YUZyb21SaWdodCA9IHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0Rm9yQ29vcmRpbmF0ZSh4KTtcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5faW50ZXJuYWxfYmFzZUluZGV4KCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYmFzZUluZGV4ICsgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgLSBkZWx0YUZyb21SaWdodDtcbiAgICAgICAgLy8gSmF2YVNjcmlwdCB1c2VzIHZlcnkgc3RyYW5nZSByb3VuZGluZ1xuICAgICAgICAvLyB3ZSBuZWVkIHJvdW5kaW5nIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggY2FsY3VsYXRpb24gZXJyb3JzXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGluZGV4ICogMTAwMDAwMCkgLyAxMDAwMDAwO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2V0QmFyU3BhY2luZyhuZXdCYXJTcGFjaW5nKSB7XG4gICAgICAgIGNvbnN0IG9sZEJhclNwYWNpbmcgPSB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nID0gbmV3QmFyU3BhY2luZztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdEJhclNwYWNpbmcoKTtcbiAgICAgICAgLy8gdGhpcy5fYmFyU3BhY2luZyBtaWdodCBiZSBjaGFuZ2VkIGluIF9jb3JyZWN0QmFyU3BhY2luZ1xuICAgICAgICBpZiAob2xkQmFyU3BhY2luZyAhPT0gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzZXRUaW1lTWFya3NDYWNoZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVWaXNpYmxlUmFuZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRWaXNpYmxlUmFuZ2UoVGltZVNjYWxlVmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9pbnZhbGlkKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2ludGVybmFsX2Jhc2VJbmRleCgpO1xuICAgICAgICBjb25zdCBuZXdCYXJzTGVuZ3RoID0gdGhpcy5fcHJpdmF0ZV9fd2lkdGggLyB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nO1xuICAgICAgICBjb25zdCByaWdodEJvcmRlciA9IHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0ICsgYmFzZUluZGV4O1xuICAgICAgICBjb25zdCBsZWZ0Qm9yZGVyID0gcmlnaHRCb3JkZXIgLSBuZXdCYXJzTGVuZ3RoICsgMTtcbiAgICAgICAgY29uc3QgbG9naWNhbFJhbmdlID0gbmV3IFJhbmdlSW1wbChsZWZ0Qm9yZGVyLCByaWdodEJvcmRlcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldFZpc2libGVSYW5nZShuZXcgVGltZVNjYWxlVmlzaWJsZVJhbmdlKGxvZ2ljYWxSYW5nZSkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY29ycmVjdEJhclNwYWNpbmcoKSB7XG4gICAgICAgIGNvbnN0IGJhclNwYWNpbmcgPSBjbGFtcCh0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nLCB0aGlzLl9wcml2YXRlX19taW5CYXJTcGFjaW5nKCksIHRoaXMuX3ByaXZhdGVfX21heEJhclNwYWNpbmcoKSk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nICE9PSBiYXJTcGFjaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJTcGFjaW5nID0gYmFyU3BhY2luZztcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWF4QmFyU3BhY2luZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubWF4QmFyU3BhY2luZyA+IDApIHtcbiAgICAgICAgICAgIC8vIG9wdGlvbiB0YWtlcyBwcmVjZWRhbmNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5tYXhCYXJTcGFjaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFsZiBvZiB0aGUgd2lkdGggaXMgZGVmYXVsdCB2YWx1ZSBmb3IgbWF4aW11bSBiYXIgc3BhY2luZ1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3dpZHRoICogMC41O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19taW5CYXJTcGFjaW5nKCkge1xuICAgICAgICAvLyBpZiBib3RoIG9wdGlvbnMgYXJlIGVuYWJsZWQgdGhlbiBsaW1pdCBiYXIgc3BhY2luZyBzbyB0aGF0IHpvb21pbmctb3V0IGlzIG5vdCBwb3NzaWJsZVxuICAgICAgICAvLyBpZiBpdCB3b3VsZCBjYXVzZSBlaXRoZXIgdGhlIGZpcnN0IG9yIGxhc3QgcG9pbnRzIHRvIG1vdmUgdG9vIGZhciBmcm9tIGFuIGVkZ2VcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZml4TGVmdEVkZ2UgJiYgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhSaWdodEVkZ2UgJiYgdGhpcy5fcHJpdmF0ZV9fcG9pbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3dpZHRoIC8gdGhpcy5fcHJpdmF0ZV9fcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5taW5CYXJTcGFjaW5nO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fY29ycmVjdE9mZnNldCgpIHtcbiAgICAgICAgLy8gYmxvY2sgc2Nyb2xsaW5nIG9mIHRvIHBhc3RcbiAgICAgICAgY29uc3QgbWluUmlnaHRPZmZzZXQgPSB0aGlzLl9wcml2YXRlX19taW5SaWdodE9mZnNldCgpO1xuICAgICAgICBpZiAobWluUmlnaHRPZmZzZXQgIT09IG51bGwgJiYgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPCBtaW5SaWdodE9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRPZmZzZXQgPSBtaW5SaWdodE9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBibG9jayBzY3JvbGxpbmcgb2YgdG8gZnV0dXJlXG4gICAgICAgIGNvbnN0IG1heFJpZ2h0T2Zmc2V0ID0gdGhpcy5fcHJpdmF0ZV9fbWF4UmlnaHRPZmZzZXQoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0ID4gbWF4UmlnaHRPZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0T2Zmc2V0ID0gbWF4UmlnaHRPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2VJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21pblJpZ2h0T2Zmc2V0KCkge1xuICAgICAgICBjb25zdCBmaXJzdEluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fZmlyc3RJbmRleCgpO1xuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9wcml2YXRlX19iYXNlSW5kZXhPck51bGw7XG4gICAgICAgIGlmIChmaXJzdEluZGV4ID09PSBudWxsIHx8IGJhc2VJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFyc0VzdGltYXRpb24gPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLmZpeExlZnRFZGdlXG4gICAgICAgICAgICA/IHRoaXMuX3ByaXZhdGVfX3dpZHRoIC8gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZ1xuICAgICAgICAgICAgOiBNYXRoLm1pbigyIC8qIENvbnN0YW50cy5NaW5WaXNpYmxlQmFyc0NvdW50ICovLCB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0SW5kZXggLSBiYXNlSW5kZXggLSAxICsgYmFyc0VzdGltYXRpb247XG4gICAgfVxuICAgIF9wcml2YXRlX19tYXhSaWdodE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZml4UmlnaHRFZGdlXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogKHRoaXMuX3ByaXZhdGVfX3dpZHRoIC8gdGhpcy5fcHJpdmF0ZV9fYmFyU3BhY2luZykgLSBNYXRoLm1pbigyIC8qIENvbnN0YW50cy5NaW5WaXNpYmxlQmFyc0NvdW50ICovLCB0aGlzLl9wcml2YXRlX19wb2ludHMubGVuZ3RoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3NhdmVDb21tb25UcmFuc2l0aW9uc1N0YXJ0U3RhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbW1vblRyYW5zaXRpb25TdGFydFN0YXRlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2JhclNwYWNpbmc6IHRoaXMuX2ludGVybmFsX2JhclNwYWNpbmcoKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9yaWdodE9mZnNldDogdGhpcy5faW50ZXJuYWxfcmlnaHRPZmZzZXQoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NsZWFyQ29tbW9uVHJhbnNpdGlvbnNTdGFydFN0YXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb21tb25UcmFuc2l0aW9uU3RhcnRTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb3JtYXRMYWJlbCh0aWNrTWFyaykge1xuICAgICAgICBsZXQgZm9ybWF0dGVyID0gdGhpcy5fcHJpdmF0ZV9fZm9ybWF0dGVkQnlXZWlnaHQuZ2V0KHRpY2tNYXJrLndlaWdodCk7XG4gICAgICAgIGlmIChmb3JtYXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlZExhYmVsc0NhY2hlKChtYXJrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdExhYmVsSW1wbChtYXJrKTtcbiAgICAgICAgICAgIH0sIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Zvcm1hdHRlZEJ5V2VpZ2h0LnNldCh0aWNrTWFyay53ZWlnaHQsIGZvcm1hdHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5faW50ZXJuYWxfZm9ybWF0KHRpY2tNYXJrKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2Zvcm1hdExhYmVsSW1wbCh0aWNrTWFyaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuZm9ybWF0VGlja21hcmsodGlja01hcmssIHRoaXMuX3ByaXZhdGVfX2xvY2FsaXphdGlvbk9wdGlvbnMpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2V0VmlzaWJsZVJhbmdlKG5ld1Zpc2libGVSYW5nZSkge1xuICAgICAgICBjb25zdCBvbGRWaXNpYmxlUmFuZ2UgPSB0aGlzLl9wcml2YXRlX192aXNpYmxlUmFuZ2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZSA9IG5ld1Zpc2libGVSYW5nZTtcbiAgICAgICAgaWYgKCFhcmVSYW5nZXNFcXVhbChvbGRWaXNpYmxlUmFuZ2UuX2ludGVybmFsX3N0cmljdFJhbmdlKCksIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVSYW5nZS5faW50ZXJuYWxfc3RyaWN0UmFuZ2UoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGVCYXJzQ2hhbmdlZC5faW50ZXJuYWxfZmlyZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlUmFuZ2VzRXF1YWwob2xkVmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9sb2dpY2FsUmFuZ2UoKSwgdGhpcy5fcHJpdmF0ZV9fdmlzaWJsZVJhbmdlLl9pbnRlcm5hbF9sb2dpY2FsUmFuZ2UoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZUNoYW5nZWQuX2ludGVybmFsX2ZpcmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZXNldCBvbmx5IGNvb3JkcyBpbiBjYXNlIHdoZW4gdGhpcy5fdmlzaWJsZUJhcnMgaGFzIG5vdCBiZWVuIGNoYW5nZWRcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzZXRUaW1lTWFya3NDYWNoZSgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcmVzZXRUaW1lTWFya3NDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZU1hcmtzQ2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9faW52YWxpZGF0ZVRpY2tNYXJrcygpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzZXRUaW1lTWFya3NDYWNoZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXR0ZWRCeVdlaWdodC5jbGVhcigpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlRGF0ZVRpbWVGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLnVwZGF0ZUZvcm1hdHRlcih0aGlzLl9wcml2YXRlX19sb2NhbGl6YXRpb25PcHRpb25zKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RvRml4TGVmdEVkZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5maXhMZWZ0RWRnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0SW5kZXggPSB0aGlzLl9wcml2YXRlX19maXJzdEluZGV4KCk7XG4gICAgICAgIGlmIChmaXJzdEluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZVJhbmdlID0gdGhpcy5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIGlmICh2aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IHZpc2libGVSYW5nZS5faW50ZXJuYWxfbGVmdCgpIC0gZmlyc3RJbmRleDtcbiAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgY29uc3QgbGVmdEVkZ2VPZmZzZXQgPSB0aGlzLl9wcml2YXRlX19yaWdodE9mZnNldCAtIGRlbHRhIC0gMTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KGxlZnRFZGdlT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jb3JyZWN0QmFyU3BhY2luZygpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZG9GaXhSaWdodEVkZ2UoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29ycmVjdEJhclNwYWNpbmcoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3Nob3VsZENvbnNpZGVySW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2VJbmRpY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9faW5kaWNlc1dpdGhEYXRhLmdldChpbmRleCkgfHwgZmFsc2U7XG4gICAgfVxuICAgIF9wcml2YXRlX19maW5kTmVhcmVzdEluZGV4V2l0aERhdGEoeCkge1xuICAgICAgICBjb25zdCBnZW4gPSB0ZXN0TmVhcmVzdEludGVnZXJzKHgpO1xuICAgICAgICBjb25zdCBtYXhJbmRleCA9IHRoaXMuX3ByaXZhdGVfX2xhc3RJbmRleCgpO1xuICAgICAgICB3aGlsZSAobWF4SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2VuLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbmRpY2VzV2l0aERhdGEuZ2V0KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBtYXhJbmRleCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4OyAvLyBmYWxsYmFjayB0byBvcmlnaW5hbCBpbmRleFxuICAgIH1cbn1cbmZ1bmN0aW9uKiB0ZXN0TmVhcmVzdEludGVnZXJzKG51bSkge1xuICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKG51bSk7XG4gICAgY29uc3QgaXNSb3VuZGVkRG93biA9IHJvdW5kZWQgPCBudW07XG4gICAgbGV0IG9mZnNldCA9IDE7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGlzUm91bmRlZERvd24pIHtcbiAgICAgICAgICAgIHlpZWxkIHJvdW5kZWQgKyBvZmZzZXQ7XG4gICAgICAgICAgICB5aWVsZCByb3VuZGVkIC0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgcm91bmRlZCAtIG9mZnNldDtcbiAgICAgICAgICAgIHlpZWxkIHJvdW5kZWQgKyBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgfVxufVxuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIl9idWlsZC10aW1lLWNvbnN0YW50c1wiIC8+XG4vKipcbiAqIERldGVybWluZSBob3cgdG8gZXhpdCB0aGUgdHJhY2tpbmcgbW9kZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCBtb2JpbGUgdXNlcnMgd2lsbCBsb25nIHByZXNzIHRvIGRlYWN0aXZhdGUgdGhlIHNjcm9sbCBhbmQgaGF2ZSB0aGUgYWJpbGl0eSB0byBjaGVjayB2YWx1ZXMgYW5kIGRhdGVzLlxuICogQW5vdGhlciBwcmVzcyBpcyByZXF1aXJlZCB0byBhY3RpdmF0ZSB0aGUgc2Nyb2xsLCBiZSBhYmxlIHRvIG1vdmUgbGVmdC9yaWdodCwgem9vbSwgZXRjLlxuICovXG52YXIgVHJhY2tpbmdNb2RlRXhpdE1vZGU7XG4oZnVuY3Rpb24gKFRyYWNraW5nTW9kZUV4aXRNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVHJhY2tpbmcgTW9kZSB3aWxsIGJlIGRlYWN0aXZhdGVkIG9uIHRvdWNoIGVuZCBldmVudC5cbiAgICAgKi9cbiAgICBUcmFja2luZ01vZGVFeGl0TW9kZVtUcmFja2luZ01vZGVFeGl0TW9kZVtcIk9uVG91Y2hFbmRcIl0gPSAwXSA9IFwiT25Ub3VjaEVuZFwiO1xuICAgIC8qKlxuICAgICAqIFRyYWNraW5nIE1vZGUgd2lsbCBiZSBkZWFjdGl2YXRlZCBvbiB0aGUgbmV4dCB0YXAgZXZlbnQuXG4gICAgICovXG4gICAgVHJhY2tpbmdNb2RlRXhpdE1vZGVbVHJhY2tpbmdNb2RlRXhpdE1vZGVbXCJPbk5leHRUYXBcIl0gPSAxXSA9IFwiT25OZXh0VGFwXCI7XG59KShUcmFja2luZ01vZGVFeGl0TW9kZSB8fCAoVHJhY2tpbmdNb2RlRXhpdE1vZGUgPSB7fSkpO1xuZnVuY3Rpb24gaXNQYW5lUHJpbWl0aXZlKHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UgaW5zdGFuY2VvZiBQYW5lO1xufVxuY2xhc3MgQ2hhcnRNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoaW52YWxpZGF0ZUhhbmRsZXIsIG9wdGlvbnMsIGhvcnpTY2FsZUJlaGF2aW9yKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc2VzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG92ZXJlZFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZ3JhZGllbnRDb2xvcnNDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVIYW5kbGVyID0gaW52YWxpZGF0ZUhhbmRsZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jb2xvclBhcnNlciA9IG5ldyBDb2xvclBhcnNlcih0aGlzLl9wcml2YXRlX19vcHRpb25zLmxheW91dC5jb2xvclBhcnNlcnMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnNQcm92aWRlciA9IG5ldyBQcmljZUF4aXNSZW5kZXJlck9wdGlvbnNQcm92aWRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlID0gbmV3IFRpbWVTY2FsZSh0aGlzLCBvcHRpb25zLnRpbWVTY2FsZSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sb2NhbGl6YXRpb24sIGhvcnpTY2FsZUJlaGF2aW9yKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyID0gbmV3IENyb3NzaGFpcih0aGlzLCBvcHRpb25zLmNyb3NzaGFpcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hZ25ldCA9IG5ldyBNYWduZXQob3B0aW9ucy5jcm9zc2hhaXIpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19nZXRPckNyZWF0ZVBhbmUoMCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzWzBdLl9pbnRlcm5hbF9zZXRTdHJldGNoRmFjdG9yKERFRkFVTFRfU1RSRVRDSF9GQUNUT1IgKiAyKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFja2dyb3VuZFRvcENvbG9yID0gdGhpcy5fcHJpdmF0ZV9fZ2V0QmFja2dyb3VuZENvbG9yKDAgLyogQmFja2dyb3VuZENvbG9yU2lkZS5Ub3AgKi8pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYWNrZ3JvdW5kQm90dG9tQ29sb3IgPSB0aGlzLl9wcml2YXRlX19nZXRCYWNrZ3JvdW5kQ29sb3IoMSAvKiBCYWNrZ3JvdW5kQ29sb3JTaWRlLkJvdHRvbSAqLyk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mdWxsVXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKEludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9mdWxsKCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbGlnaHRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUoSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY3Vyc29yVXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKG5ldyBJbnZhbGlkYXRlTWFzaygxIC8qIEludmFsaWRhdGlvbkxldmVsLkN1cnNvciAqLykpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlU291cmNlKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBpbnYgPSB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRpb25NYXNrRm9yU291cmNlKHNvdXJjZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUoaW52KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2hvdmVyZWRTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19ob3ZlcmVkU291cmNlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0SG92ZXJlZFNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2hvdmVyZWRTb3VyY2U/Ll9pbnRlcm5hbF9zb3VyY2UgPT09IHNvdXJjZT8uX2ludGVybmFsX3NvdXJjZSAmJiB0aGlzLl9wcml2YXRlX19ob3ZlcmVkU291cmNlPy5faW50ZXJuYWxfb2JqZWN0Py5faW50ZXJuYWxfZXh0ZXJuYWxJZCA9PT0gc291cmNlPy5faW50ZXJuYWxfb2JqZWN0Py5faW50ZXJuYWxfZXh0ZXJuYWxJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZTb3VyY2UgPSB0aGlzLl9wcml2YXRlX19ob3ZlcmVkU291cmNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3ZlcmVkU291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAocHJldlNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlU291cmNlKHByZXZTb3VyY2UuX2ludGVybmFsX3NvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkaXRpb25hbCBjaGVjayB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHVwZGF0ZXMgb2Ygc2FtZSBzb3VyY2VcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCAmJiBzb3VyY2UuX2ludGVybmFsX3NvdXJjZSAhPT0gcHJldlNvdXJjZT8uX2ludGVybmFsX3NvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlU291cmNlKHNvdXJjZS5faW50ZXJuYWxfc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBtZXJnZSh0aGlzLl9wcml2YXRlX19vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMuZm9yRWFjaCgocCkgPT4gcC5faW50ZXJuYWxfYXBwbHlTY2FsZU9wdGlvbnMob3B0aW9ucykpO1xuICAgICAgICBpZiAob3B0aW9ucy50aW1lU2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucy50aW1lU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmxvY2FsaXphdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2FwcGx5TG9jYWxpemF0aW9uT3B0aW9ucyhvcHRpb25zLmxvY2FsaXphdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubGVmdFByaWNlU2NhbGUgfHwgb3B0aW9ucy5yaWdodFByaWNlU2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQuX2ludGVybmFsX2ZpcmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19iYWNrZ3JvdW5kVG9wQ29sb3IgPSB0aGlzLl9wcml2YXRlX19nZXRCYWNrZ3JvdW5kQ29sb3IoMCAvKiBCYWNrZ3JvdW5kQ29sb3JTaWRlLlRvcCAqLyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JhY2tncm91bmRCb3R0b21Db2xvciA9IHRoaXMuX3ByaXZhdGVfX2dldEJhY2tncm91bmRDb2xvcigxIC8qIEJhY2tncm91bmRDb2xvclNpZGUuQm90dG9tICovKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlQcmljZVNjYWxlT3B0aW9ucyhwcmljZVNjYWxlSWQsIG9wdGlvbnMsIHBhbmVJbmRleCA9IDApIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmVzW3BhbmVJbmRleF07XG4gICAgICAgIGlmIChwYW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyeWluZyB0byBhcHBseSBwcmljZSBzY2FsZSBvcHRpb25zIHdpdGggaW5jb3JyZWN0IHBhbmUgaW5kZXg6ICR7cGFuZUluZGV4fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgICAgICBpZiAocHJpY2VTY2FsZUlkID09PSBcImxlZnRcIiAvKiBEZWZhdWx0UHJpY2VTY2FsZUlkLkxlZnQgKi8pIHtcbiAgICAgICAgICAgIG1lcmdlKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBsZWZ0UHJpY2VTY2FsZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFuZS5faW50ZXJuYWxfYXBwbHlTY2FsZU9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGxlZnRQcmljZVNjYWxlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9mdWxsVXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmljZVNjYWxlSWQgPT09IFwicmlnaHRcIiAvKiBEZWZhdWx0UHJpY2VTY2FsZUlkLlJpZ2h0ICovKSB7XG4gICAgICAgICAgICBtZXJnZSh0aGlzLl9wcml2YXRlX19vcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgcmlnaHRQcmljZVNjYWxlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYW5lLl9pbnRlcm5hbF9hcHBseVNjYWxlT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgcmlnaHRQcmljZVNjYWxlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9mdWxsVXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5faW50ZXJuYWxfZmluZFByaWNlU2NhbGUocHJpY2VTY2FsZUlkLCBwYW5lSW5kZXgpO1xuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcnlpbmcgdG8gYXBwbHkgcHJpY2Ugc2NhbGUgb3B0aW9ucyB3aXRoIGluY29ycmVjdCBJRDogJHtwcmljZVNjYWxlSWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzLl9pbnRlcm5hbF9wcmljZVNjYWxlLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQuX2ludGVybmFsX2ZpcmUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZpbmRQcmljZVNjYWxlKHByaWNlU2NhbGVJZCwgcGFuZUluZGV4KSB7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lc1twYW5lSW5kZXhdO1xuICAgICAgICBpZiAocGFuZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gcGFuZS5faW50ZXJuYWxfcHJpY2VTY2FsZUJ5SWQocHJpY2VTY2FsZUlkKTtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3BhbmU6IHBhbmUsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3ByaWNlU2NhbGU6IHByaWNlU2NhbGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGltZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFuZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lcztcbiAgICB9XG4gICAgX2ludGVybmFsX2Nyb3NzaGFpclNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpcjtcbiAgICB9XG4gICAgX2ludGVybmFsX2Nyb3NzaGFpck1vdmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQYW5lSGVpZ2h0KHBhbmUsIGhlaWdodCkge1xuICAgICAgICBwYW5lLl9pbnRlcm5hbF9zZXRIZWlnaHQoaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0V2lkdGgod2lkdGgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9zZXRXaWR0aCh0aGlzLl9wcml2YXRlX193aWR0aCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzLmZvckVhY2goKHBhbmUpID0+IHBhbmUuX2ludGVybmFsX3NldFdpZHRoKHdpZHRoKSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlY2FsY3VsYXRlQWxsUGFuZXMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbW92ZVBhbmUoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BhbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fcGFuZXMubGVuZ3RoLCAnSW52YWxpZCBwYW5lIGluZGV4Jyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2NoYW5nZVBhbmVzSGVpZ2h0KHBhbmVJbmRleCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wYW5lcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KHBhbmVJbmRleCA+PSAwICYmIHBhbmVJbmRleCA8IHRoaXMuX3ByaXZhdGVfX3BhbmVzLmxlbmd0aCwgJ0ludmFsaWQgcGFuZSBpbmRleCcpO1xuICAgICAgICBjb25zdCB0YXJnZXRQYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXNbcGFuZUluZGV4XTtcbiAgICAgICAgY29uc3QgdG90YWxTdHJldGNoID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXMucmVkdWNlKChwcmV2VmFsdWUsIHBhbmUpID0+IHByZXZWYWx1ZSArIHBhbmUuX2ludGVybmFsX3N0cmV0Y2hGYWN0b3IoKSwgMCk7XG4gICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXMucmVkdWNlKChwcmV2VmFsdWUsIHBhbmUpID0+IHByZXZWYWx1ZSArIHBhbmUuX2ludGVybmFsX2hlaWdodCgpLCAwKTtcbiAgICAgICAgY29uc3QgbWF4UGFuZUhlaWdodCA9IHRvdGFsSGVpZ2h0IC0gTUlOX1BBTkVfSEVJR0hUICogKHRoaXMuX3ByaXZhdGVfX3BhbmVzLmxlbmd0aCAtIDEpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLm1pbihtYXhQYW5lSGVpZ2h0LCBNYXRoLm1heChNSU5fUEFORV9IRUlHSFQsIGhlaWdodCkpO1xuICAgICAgICBjb25zdCBwaXhlbFN0cmV0Y2hGYWN0b3IgPSB0b3RhbFN0cmV0Y2ggLyB0b3RhbEhlaWdodDtcbiAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gdGFyZ2V0UGFuZS5faW50ZXJuYWxfaGVpZ2h0KCk7XG4gICAgICAgIHRhcmdldFBhbmUuX2ludGVybmFsX3NldFN0cmV0Y2hGYWN0b3IoaGVpZ2h0ICogcGl4ZWxTdHJldGNoRmFjdG9yKTtcbiAgICAgICAgbGV0IG90aGVyUGFuZXNDaGFuZ2UgPSBoZWlnaHQgLSBvbGRIZWlnaHQ7XG4gICAgICAgIGxldCBwYW5lc0NvdW50ID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yIChjb25zdCBwYW5lIG9mIHRoaXMuX3ByaXZhdGVfX3BhbmVzKSB7XG4gICAgICAgICAgICBpZiAocGFuZSAhPT0gdGFyZ2V0UGFuZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhbmVIZWlnaHQgPSBNYXRoLm1pbihtYXhQYW5lSGVpZ2h0LCBNYXRoLm1heCgzMCwgcGFuZS5faW50ZXJuYWxfaGVpZ2h0KCkgLSBvdGhlclBhbmVzQ2hhbmdlIC8gcGFuZXNDb3VudCkpO1xuICAgICAgICAgICAgICAgIG90aGVyUGFuZXNDaGFuZ2UgLT0gKHBhbmUuX2ludGVybmFsX2hlaWdodCgpIC0gbmV3UGFuZUhlaWdodCk7XG4gICAgICAgICAgICAgICAgcGFuZXNDb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0cmV0Y2hGYWN0b3IgPSBuZXdQYW5lSGVpZ2h0ICogcGl4ZWxTdHJldGNoRmFjdG9yO1xuICAgICAgICAgICAgICAgIHBhbmUuX2ludGVybmFsX3NldFN0cmV0Y2hGYWN0b3IobmV3U3RyZXRjaEZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3dhcFBhbmVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgYXNzZXJ0KGZpcnN0ID49IDAgJiYgZmlyc3QgPCB0aGlzLl9wcml2YXRlX19wYW5lcy5sZW5ndGggJiYgc2Vjb25kID49IDAgJiYgc2Vjb25kIDwgdGhpcy5fcHJpdmF0ZV9fcGFuZXMubGVuZ3RoLCAnSW52YWxpZCBwYW5lIGluZGV4Jyk7XG4gICAgICAgIGNvbnN0IGZpcnN0UGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmVzW2ZpcnN0XTtcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmVzW3NlY29uZF07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzW2ZpcnN0XSA9IHNlY29uZFBhbmU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzW3NlY29uZF0gPSBmaXJzdFBhbmU7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXJ0U2NhbGVQcmljZShwYW5lLCBwcmljZVNjYWxlLCB4KSB7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX3N0YXJ0U2NhbGVQcmljZShwcmljZVNjYWxlLCB4KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NjYWxlUHJpY2VUbyhwYW5lLCBwcmljZVNjYWxlLCB4KSB7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX3NjYWxlUHJpY2VUbyhwcmljZVNjYWxlLCB4KTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfdXBkYXRlQ3Jvc3NoYWlyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUodGhpcy5fcHJpdmF0ZV9fcGFuZUludmFsaWRhdGlvbk1hc2socGFuZSwgMiAvKiBJbnZhbGlkYXRpb25MZXZlbC5MaWdodCAqLykpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZW5kU2NhbGVQcmljZShwYW5lLCBwcmljZVNjYWxlKSB7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX2VuZFNjYWxlUHJpY2UocHJpY2VTY2FsZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUodGhpcy5fcHJpdmF0ZV9fcGFuZUludmFsaWRhdGlvbk1hc2socGFuZSwgMiAvKiBJbnZhbGlkYXRpb25MZXZlbC5MaWdodCAqLykpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RhcnRTY3JvbGxQcmljZShwYW5lLCBwcmljZVNjYWxlLCB4KSB7XG4gICAgICAgIGlmIChwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0F1dG9TY2FsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFuZS5faW50ZXJuYWxfc3RhcnRTY3JvbGxQcmljZShwcmljZVNjYWxlLCB4KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Njcm9sbFByaWNlVG8ocGFuZSwgcHJpY2VTY2FsZSwgeCkge1xuICAgICAgICBpZiAocHJpY2VTY2FsZS5faW50ZXJuYWxfaXNBdXRvU2NhbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhbmUuX2ludGVybmFsX3Njcm9sbFByaWNlVG8ocHJpY2VTY2FsZSwgeCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUNyb3NzaGFpcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKHRoaXMuX3ByaXZhdGVfX3BhbmVJbnZhbGlkYXRpb25NYXNrKHBhbmUsIDIgLyogSW52YWxpZGF0aW9uTGV2ZWwuTGlnaHQgKi8pKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjcm9sbFByaWNlKHBhbmUsIHByaWNlU2NhbGUpIHtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUuX2ludGVybmFsX2lzQXV0b1NjYWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYW5lLl9pbnRlcm5hbF9lbmRTY3JvbGxQcmljZShwcmljZVNjYWxlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZSh0aGlzLl9wcml2YXRlX19wYW5lSW52YWxpZGF0aW9uTWFzayhwYW5lLCAyIC8qIEludmFsaWRhdGlvbkxldmVsLkxpZ2h0ICovKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZXNldFByaWNlU2NhbGUocGFuZSwgcHJpY2VTY2FsZSkge1xuICAgICAgICBwYW5lLl9pbnRlcm5hbF9yZXNldFByaWNlU2NhbGUocHJpY2VTY2FsZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUodGhpcy5fcHJpdmF0ZV9fcGFuZUludmFsaWRhdGlvbk1hc2socGFuZSwgMiAvKiBJbnZhbGlkYXRpb25MZXZlbC5MaWdodCAqLykpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RhcnRTY2FsZVRpbWUocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9zdGFydFNjYWxlKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogWm9vbSBpbi9vdXQgdGhlIGNoYXJ0IChkZXBlbmRzIG9uIHNjYWxlIHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2ludFggLSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGFwcGx5IHRoZSB6b29tICh0aGUgcG9pbnQgd2hpY2ggc2hvdWxkIHN0YXkgb24gaXRzIHBsYWNlKVxuICAgICAqIEBwYXJhbSBzY2FsZSAtIFpvb20gdmFsdWUuIE5lZ2F0aXZlIHZhbHVlIG1lYW5zIHpvb20gb3V0LCBwb3NpdGl2ZSAtIHpvb20gaW4uXG4gICAgICovXG4gICAgX2ludGVybmFsX3pvb21UaW1lKHBvaW50WCwgc2NhbGUpIHtcbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIGlmICh0aW1lU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSB8fCBzY2FsZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZVdpZHRoID0gdGltZVNjYWxlLl9pbnRlcm5hbF93aWR0aCgpO1xuICAgICAgICBwb2ludFggPSBNYXRoLm1heCgxLCBNYXRoLm1pbihwb2ludFgsIHRpbWVTY2FsZVdpZHRoKSk7XG4gICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfem9vbShwb2ludFgsIHNjYWxlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2Nyb2xsQ2hhcnQoeCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zdGFydFNjcm9sbFRpbWUoMCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3Njcm9sbFRpbWVUbyh4KTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfZW5kU2Nyb2xsVGltZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2NhbGVUaW1lVG8oeCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3NjYWxlVG8oeCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlY2FsY3VsYXRlQWxsUGFuZXMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjYWxlVGltZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9lbmRTY2FsZSgpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RhcnRTY3JvbGxUaW1lKHgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9zdGFydFNjcm9sbCh4KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Njcm9sbFRpbWVUbyh4KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfc2Nyb2xsVG8oeCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3JlY2FsY3VsYXRlQWxsUGFuZXMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2VuZFNjcm9sbFRpbWUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfZW5kU2Nyb2xsKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXJpZXNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Nlcmllc2VzO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0QW5kU2F2ZUN1cnJlbnRQb3NpdGlvbih4LCB5LCBldmVudCwgcGFuZSwgc2tpcEV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfc2F2ZU9yaWdpbkNvb3JkKHgsIHkpO1xuICAgICAgICBsZXQgcHJpY2UgPSBOYU47XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfY29vcmRpbmF0ZVRvSW5kZXgoeCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHZpc2libGVCYXJzID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF92aXNpYmxlU3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgaWYgKHZpc2libGVCYXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmRleCA9IE1hdGgubWluKE1hdGgubWF4KHZpc2libGVCYXJzLl9pbnRlcm5hbF9sZWZ0KCksIGluZGV4KSwgdmlzaWJsZUJhcnMuX2ludGVybmFsX3JpZ2h0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSBwYW5lLl9pbnRlcm5hbF9kZWZhdWx0UHJpY2VTY2FsZSgpO1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gcHJpY2VTY2FsZS5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJpY2UgPSBwcmljZVNjYWxlLl9pbnRlcm5hbF9jb29yZGluYXRlVG9QcmljZSh5LCBmaXJzdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwcmljZSA9IHRoaXMuX3ByaXZhdGVfX21hZ25ldC5faW50ZXJuYWxfYWxpZ24ocHJpY2UsIGluZGV4LCBwYW5lKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyLl9pbnRlcm5hbF9zZXRQb3NpdGlvbihpbmRleCwgcHJpY2UsIHBhbmUpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9jdXJzb3JVcGRhdGUoKTtcbiAgICAgICAgaWYgKCFza2lwRXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhpdFRlc3QgPSBoaXRUZXN0UGFuZShwYW5lLCB4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3NldEhvdmVyZWRTb3VyY2UoaGl0VGVzdCAmJiB7IF9pbnRlcm5hbF9zb3VyY2U6IGhpdFRlc3QuX2ludGVybmFsX3NvdXJjZSwgX2ludGVybmFsX29iamVjdDogaGl0VGVzdC5faW50ZXJuYWxfb2JqZWN0LCBfaW50ZXJuYWxfY3Vyc29yU3R5bGU6IGhpdFRlc3QuX2ludGVybmFsX2N1cnNvclN0eWxlIHx8IG51bGwgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZC5faW50ZXJuYWxfZmlyZSh0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX2FwcGxpZWRJbmRleCgpLCB7IHgsIHkgfSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEEgcG9zaXRpb24gcHJvdmlkZWQgZXh0ZXJuYWwgKG5vdCBmcm9tIGFuIGludGVybmFsIGV2ZW50IGxpc3RlbmVyKVxuICAgIF9pbnRlcm5hbF9zZXRBbmRTYXZlU3ludGhldGljUG9zaXRpb24ocHJpY2UsIGhvcml6b250YWxQb3NpdGlvbiwgcGFuZSkge1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gcGFuZS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKTtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgeSA9IHByaWNlU2NhbGUuX2ludGVybmFsX3ByaWNlVG9Db29yZGluYXRlKHByaWNlLCBlbnN1cmVOb3ROdWxsKGZpcnN0VmFsdWUpKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3RpbWVUb0luZGV4KGhvcml6b250YWxQb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKGVuc3VyZU5vdE51bGwoaW5kZXgpKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfc2V0QW5kU2F2ZUN1cnJlbnRQb3NpdGlvbih4LCB5LCBudWxsLCBwYW5lLCB0cnVlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2NsZWFyQ3VycmVudFBvc2l0aW9uKHNraXBFdmVudCkge1xuICAgICAgICBjb25zdCBjcm9zc2hhaXIgPSB0aGlzLl9pbnRlcm5hbF9jcm9zc2hhaXJTb3VyY2UoKTtcbiAgICAgICAgY3Jvc3NoYWlyLl9pbnRlcm5hbF9jbGVhclBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX2N1cnNvclVwZGF0ZSgpO1xuICAgICAgICBpZiAoIXNraXBFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWQuX2ludGVybmFsX2ZpcmUobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZUNyb3NzaGFpcigpIHtcbiAgICAgICAgLy8gYXBwbHkgbWFnbmV0XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX3BhbmUoKTtcbiAgICAgICAgaWYgKHBhbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXIuX2ludGVybmFsX29yaWdpbkNvb3JkWCgpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfb3JpZ2luQ29vcmRZKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRBbmRTYXZlQ3VycmVudFBvc2l0aW9uKHgsIHksIG51bGwsIHBhbmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpci5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZVRpbWVTY2FsZShuZXdCYXNlSW5kZXgsIG5ld1BvaW50cywgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCkge1xuICAgICAgICBjb25zdCBvbGRGaXJzdFRpbWUgPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9UaW1lKDApO1xuICAgICAgICBpZiAobmV3UG9pbnRzICE9PSB1bmRlZmluZWQgJiYgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3VwZGF0ZShuZXdQb2ludHMsIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0ZpcnN0VGltZSA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfaW5kZXhUb1RpbWUoMCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXNlSW5kZXggPSB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2Jhc2VJbmRleCgpO1xuICAgICAgICBjb25zdCB2aXNpYmxlQmFycyA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfdmlzaWJsZVN0cmljdFJhbmdlKCk7XG4gICAgICAgIC8vIGlmIHRpbWUgc2NhbGUgY2Fubm90IHJldHVybiBjdXJyZW50IHZpc2libGUgYmFycyByYW5nZSAoZS5nLiB0aW1lIHNjYWxlIGhhcyB6ZXJvLXdpZHRoKVxuICAgICAgICAvLyB0aGVuIHdlIGRvIG5vdCBuZWVkIHRvIHVwZGF0ZSByaWdodCBvZmZzZXQgdG8gc2hpZnQgdmlzaWJsZSBiYXJzIHJhbmdlIHRvIGhhdmUgdGhlIHNhbWUgcmlnaHQgb2Zmc2V0IGFzIHdlIGhhdmUgYmVmb3JlIG5ldyBiYXJcbiAgICAgICAgLy8gKGFuZCBhY3R1YWxseSB3ZSBjYW5ub3QpXG4gICAgICAgIGlmICh2aXNpYmxlQmFycyAhPT0gbnVsbCAmJiBvbGRGaXJzdFRpbWUgIT09IG51bGwgJiYgbmV3Rmlyc3RUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpc0xhc3RTZXJpZXNCYXJWaXNpYmxlID0gdmlzaWJsZUJhcnMuX2ludGVybmFsX2NvbnRhaW5zKGN1cnJlbnRCYXNlSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgaXNMZWZ0QmFyU2hpZnRUb0xlZnQgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkob2xkRmlyc3RUaW1lKSA+IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShuZXdGaXJzdFRpbWUpO1xuICAgICAgICAgICAgY29uc3QgaXNTZXJpZXNQb2ludHNBZGRlZCA9IG5ld0Jhc2VJbmRleCAhPT0gbnVsbCAmJiBuZXdCYXNlSW5kZXggPiBjdXJyZW50QmFzZUluZGV4O1xuICAgICAgICAgICAgY29uc3QgaXNTZXJpZXNQb2ludHNBZGRlZFRvUmlnaHQgPSBpc1Nlcmllc1BvaW50c0FkZGVkICYmICFpc0xlZnRCYXJTaGlmdFRvTGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93U2hpZnRXaGVuUmVwbGFjaW5nV2hpdGVzcGFjZSA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfb3B0aW9ucygpLmFsbG93U2hpZnRWaXNpYmxlUmFuZ2VPbldoaXRlc3BhY2VSZXBsYWNlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VkRXhpc3RpbmdXaGl0ZXNwYWNlID0gZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgbmVlZFNoaWZ0VmlzaWJsZVJhbmdlT25OZXdCYXIgPSBpc0xhc3RTZXJpZXNCYXJWaXNpYmxlICYmICghcmVwbGFjZWRFeGlzdGluZ1doaXRlc3BhY2UgfHwgYWxsb3dTaGlmdFdoZW5SZXBsYWNpbmdXaGl0ZXNwYWNlKSAmJiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKS5zaGlmdFZpc2libGVSYW5nZU9uTmV3QmFyO1xuICAgICAgICAgICAgaWYgKGlzU2VyaWVzUG9pbnRzQWRkZWRUb1JpZ2h0ICYmICFuZWVkU2hpZnRWaXNpYmxlUmFuZ2VPbk5ld0Jhcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBlbnNhdGlvblNoaWZ0ID0gbmV3QmFzZUluZGV4IC0gY3VycmVudEJhc2VJbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfcmlnaHRPZmZzZXQoKSAtIGNvbXBlbnNhdGlvblNoaWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3NldEJhc2VJbmRleChuZXdCYXNlSW5kZXgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVjYWxjdWxhdGVQYW5lKHBhbmUpIHtcbiAgICAgICAgaWYgKHBhbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhbmUuX2ludGVybmFsX3JlY2FsY3VsYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3BhbmVGb3JTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIGlmIChpc1BhbmVQcmltaXRpdmUoc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXMuZmluZCgocCkgPT4gcC5faW50ZXJuYWxfb3JkZXJlZFNvdXJjZXMoKS5pbmNsdWRlcyhzb3VyY2UpKTtcbiAgICAgICAgcmV0dXJuIHBhbmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBwYW5lO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcygpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMuZm9yRWFjaCgocCkgPT4gcC5faW50ZXJuYWxfcmVjYWxjdWxhdGUoKSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZUNyb3NzaGFpcigpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMuZm9yRWFjaCgocCkgPT4gcC5faW50ZXJuYWxfZGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gdG8gYXZvaWQgbWVtbGVha3NcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sb2NhbGl6YXRpb24ucHJpY2VGb3JtYXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubG9jYWxpemF0aW9uLnBlcmNlbnRhZ2VGb3JtYXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubG9jYWxpemF0aW9uLnRpbWVGb3JtYXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnNQcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VBeGlzUmVuZGVyZXJPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYWRkU2VyaWVzVG9QYW5lKHNlcmllcywgcGFuZUluZGV4KSB7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19nZXRPckNyZWF0ZVBhbmUocGFuZUluZGV4KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWRkU2VyaWVzVG9QYW5lKHNlcmllcywgcGFuZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc2VzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Nlcmllc2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gY2FsbCBmdWxsVXBkYXRlIHRvIHJlY2FsY3VsYXRlIGNoYXJ0J3MgcGFydHMgZ2VvbWV0cnlcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3JlbW92ZVNlcmllcyhzZXJpZXMpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX2ludGVybmFsX3BhbmVGb3JTb3VyY2Uoc2VyaWVzKTtcbiAgICAgICAgY29uc3Qgc2VyaWVzSW5kZXggPSB0aGlzLl9wcml2YXRlX19zZXJpZXNlcy5pbmRleE9mKHNlcmllcyk7XG4gICAgICAgIGFzc2VydChzZXJpZXNJbmRleCAhPT0gLTEsICdTZXJpZXMgbm90IGZvdW5kJyk7XG4gICAgICAgIGNvbnN0IHBhbmVJbXBsID0gZW5zdXJlTm90TnVsbChwYW5lKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzZXMuc3BsaWNlKHNlcmllc0luZGV4LCAxKTtcbiAgICAgICAgcGFuZUltcGwuX2ludGVybmFsX3JlbW92ZURhdGFTb3VyY2Uoc2VyaWVzKTtcbiAgICAgICAgaWYgKHNlcmllcy5faW50ZXJuYWxfZGVzdHJveSkge1xuICAgICAgICAgICAgc2VyaWVzLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUluZGljZXNXaXRoRGF0YSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGVhbnVwSWZQYW5lSXNFbXB0eShwYW5lSW1wbCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3ZlU2VyaWVzVG9TY2FsZShzZXJpZXMsIHRhcmdldFNjYWxlSWQpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfcGFuZUZvclNvdXJjZShzZXJpZXMpKTtcbiAgICAgICAgcGFuZS5faW50ZXJuYWxfcmVtb3ZlRGF0YVNvdXJjZShzZXJpZXMsIHRydWUpO1xuICAgICAgICBwYW5lLl9pbnRlcm5hbF9hZGREYXRhU291cmNlKHNlcmllcywgdGFyZ2V0U2NhbGVJZCwgdHJ1ZSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9maXRDb250ZW50KCkge1xuICAgICAgICBjb25zdCBtYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX3NldEZpdENvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShtYXNrKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFRhcmdldExvZ2ljYWxSYW5nZShyYW5nZSkge1xuICAgICAgICBjb25zdCBtYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX2FwcGx5UmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKG1hc2spO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmVzZXRUaW1lU2NhbGUoKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfbGlnaHQoKTtcbiAgICAgICAgbWFzay5faW50ZXJuYWxfcmVzZXRUaW1lU2NhbGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShtYXNrKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldEJhclNwYWNpbmcoc3BhY2luZykge1xuICAgICAgICBjb25zdCBtYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX3NldEJhclNwYWNpbmcoc3BhY2luZyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUobWFzayk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRSaWdodE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IEludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9saWdodCgpO1xuICAgICAgICBtYXNrLl9pbnRlcm5hbF9zZXRSaWdodE9mZnNldChvZmZzZXQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKG1hc2spO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0VGltZVNjYWxlQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICAgICAgICBjb25zdCBtYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2xpZ2h0KCk7XG4gICAgICAgIG1hc2suX2ludGVybmFsX3NldFRpbWVTY2FsZUFuaW1hdGlvbihhbmltYXRpb24pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlKG1hc2spO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RvcFRpbWVTY2FsZUFuaW1hdGlvbigpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IEludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9saWdodCgpO1xuICAgICAgICBtYXNrLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGUobWFzayk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZWZhdWx0VmlzaWJsZVByaWNlU2NhbGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMucmlnaHRQcmljZVNjYWxlLnZpc2libGUgPyBcInJpZ2h0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5SaWdodCAqLyA6IFwibGVmdFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuTGVmdCAqLztcbiAgICB9XG4gICAgX2ludGVybmFsX21vdmVTZXJpZXNUb1BhbmUoc2VyaWVzLCBuZXdQYW5lSW5kZXgpIHtcbiAgICAgICAgYXNzZXJ0KG5ld1BhbmVJbmRleCA+PSAwLCAnSW5kZXggc2hvdWxkIGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMCcpO1xuICAgICAgICBjb25zdCBmcm9tUGFuZUluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUGFuZUluZGV4KHNlcmllcyk7XG4gICAgICAgIGlmIChuZXdQYW5lSW5kZXggPT09IGZyb21QYW5lSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c1BhbmUgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3BhbmVGb3JTb3VyY2Uoc2VyaWVzKSk7XG4gICAgICAgIHByZXZpb3VzUGFuZS5faW50ZXJuYWxfcmVtb3ZlRGF0YVNvdXJjZShzZXJpZXMpO1xuICAgICAgICBjb25zdCBuZXdQYW5lID0gdGhpcy5fcHJpdmF0ZV9fZ2V0T3JDcmVhdGVQYW5lKG5ld1BhbmVJbmRleCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FkZFNlcmllc1RvUGFuZShzZXJpZXMsIG5ld1BhbmUpO1xuICAgICAgICBpZiAocHJldmlvdXNQYW5lLl9pbnRlcm5hbF9kYXRhU291cmNlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYW51cElmUGFuZUlzRW1wdHkocHJldmlvdXNQYW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfYmFja2dyb3VuZEJvdHRvbUNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYmFja2dyb3VuZEJvdHRvbUNvbG9yO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYmFja2dyb3VuZFRvcENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYmFja2dyb3VuZFRvcENvbG9yO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYmFja2dyb3VuZENvbG9yQXRZUGVyY2VudEZyb21Ub3AocGVyY2VudCkge1xuICAgICAgICBjb25zdCBib3R0b21Db2xvciA9IHRoaXMuX3ByaXZhdGVfX2JhY2tncm91bmRCb3R0b21Db2xvcjtcbiAgICAgICAgY29uc3QgdG9wQ29sb3IgPSB0aGlzLl9wcml2YXRlX19iYWNrZ3JvdW5kVG9wQ29sb3I7XG4gICAgICAgIGlmIChib3R0b21Db2xvciA9PT0gdG9wQ29sb3IpIHtcbiAgICAgICAgICAgIC8vIHNvbGlkIGJhY2tncm91bmRcbiAgICAgICAgICAgIHJldHVybiBib3R0b21Db2xvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBncmFkaWVudCBiYWNrZ3JvdW5kXG4gICAgICAgIC8vIHBlcmNlbnQgc2hvdWxkIGJlIGZyb20gMCB0byAxMDAgKHdlJ3JlIHVzaW5nIG9ubHkgaW50ZWdlciB2YWx1ZXMgdG8gbWFrZSBjYWNoZSBtb3JlIGVmZmljaWVudClcbiAgICAgICAgcGVyY2VudCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgTWF0aC5yb3VuZChwZXJjZW50ICogMTAwKSkpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZ3JhZGllbnRDb2xvcnNDYWNoZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZ3JhZGllbnRDb2xvcnNDYWNoZS5faW50ZXJuYWxfdG9wQ29sb3IgIT09IHRvcENvbG9yIHx8IHRoaXMuX3ByaXZhdGVfX2dyYWRpZW50Q29sb3JzQ2FjaGUuX2ludGVybmFsX2JvdHRvbUNvbG9yICE9PSBib3R0b21Db2xvcikge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZ3JhZGllbnRDb2xvcnNDYWNoZSA9IHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29sb3I6IHRvcENvbG9yLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21Db2xvcjogYm90dG9tQ29sb3IsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2NvbG9yczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZhbHVlID0gdGhpcy5fcHJpdmF0ZV9fZ3JhZGllbnRDb2xvcnNDYWNoZS5faW50ZXJuYWxfY29sb3JzLmdldChwZXJjZW50KTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3ByaXZhdGVfX2NvbG9yUGFyc2VyLl9pbnRlcm5hbF9ncmFkaWVudENvbG9yQXRQZXJjZW50KHRvcENvbG9yLCBib3R0b21Db2xvciwgcGVyY2VudCAvIDEwMCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2dyYWRpZW50Q29sb3JzQ2FjaGUuX2ludGVybmFsX2NvbG9ycy5zZXQocGVyY2VudCwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldFBhbmVJbmRleChwYW5lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lcy5pbmRleE9mKHBhbmUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY29sb3JQYXJzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jb2xvclBhcnNlcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldE9yQ3JlYXRlUGFuZShpbmRleCkge1xuICAgICAgICBhc3NlcnQoaW5kZXggPj0gMCwgJ0luZGV4IHNob3VsZCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIDAnKTtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1pbih0aGlzLl9wcml2YXRlX19wYW5lcy5sZW5ndGgsIGluZGV4KTtcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fcGFuZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZXNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhbmUgPSBuZXcgUGFuZSh0aGlzLl9wcml2YXRlX190aW1lU2NhbGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lcy5wdXNoKHBhbmUpO1xuICAgICAgICAvLyB3ZSBhbHdheXMgZG8gYXV0b3NjYWxpbmcgb24gdGhlIGNyZWF0aW9uXG4gICAgICAgIC8vIGlmIGF1dG9zY2FsZSBvcHRpb24gaXMgdHJ1ZSwgaXQgaXMgb2ssIGp1c3QgcmVjYWxjdWxhdGUgYnkgaW52YWxpZGF0aW9uIG1hc2tcbiAgICAgICAgLy8gaWYgYXV0b3NjYWxlIG9wdGlvbiBpcyBmYWxzZSwgYXV0b3NjYWxlIGFueXdheSBvbiB0aGUgZmlyc3QgZHJhd1xuICAgICAgICAvLyBhbHNvIHRoZXJlIGlzIGEgc2NlbmFyaW8gd2hlbiBhdXRvc2NhbGUgaXMgdHJ1ZSBpbiBjb25zdHJ1Y3RvciBhbmQgZmFsc2UgbGF0ZXIgb24gYXBwbHlPcHRpb25zXG4gICAgICAgIGNvbnN0IG1hc2sgPSBJbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfZnVsbCgpO1xuICAgICAgICBtYXNrLl9pbnRlcm5hbF9pbnZhbGlkYXRlUGFuZShpbmRleCwge1xuICAgICAgICAgICAgX2ludGVybmFsX2xldmVsOiAwIC8qIEludmFsaWRhdGlvbkxldmVsLk5vbmUgKi8sXG4gICAgICAgICAgICBfaW50ZXJuYWxfYXV0b1NjYWxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZShtYXNrKTtcbiAgICAgICAgcmV0dXJuIHBhbmU7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXJpZXNQYW5lSW5kZXgoc2VyaWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lcy5maW5kSW5kZXgoKHBhbmUpID0+IHBhbmUuX2ludGVybmFsX3NlcmllcygpLmluY2x1ZGVzKHNlcmllcykpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcGFuZUludmFsaWRhdGlvbk1hc2socGFuZSwgbGV2ZWwpIHtcbiAgICAgICAgY29uc3QgaW52ID0gbmV3IEludmFsaWRhdGVNYXNrKGxldmVsKTtcbiAgICAgICAgaWYgKHBhbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXMuaW5kZXhPZihwYW5lKTtcbiAgICAgICAgICAgIGludi5faW50ZXJuYWxfaW52YWxpZGF0ZVBhbmUoaW5kZXgsIHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ludmFsaWRhdGlvbk1hc2tGb3JTb3VyY2Uoc291cmNlLCBpbnZhbGlkYXRlVHlwZSkge1xuICAgICAgICBpZiAoaW52YWxpZGF0ZVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW52YWxpZGF0ZVR5cGUgPSAyIC8qIEludmFsaWRhdGlvbkxldmVsLkxpZ2h0ICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lSW52YWxpZGF0aW9uTWFzayh0aGlzLl9pbnRlcm5hbF9wYW5lRm9yU291cmNlKHNvdXJjZSksIGludmFsaWRhdGVUeXBlKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ludmFsaWRhdGUobWFzaykge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVIYW5kbGVyKG1hc2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzLmZvckVhY2goKHBhbmUpID0+IHBhbmUuX2ludGVybmFsX2dyaWQoKS5faW50ZXJuYWxfcGFuZVZpZXcoKS5faW50ZXJuYWxfdXBkYXRlKCkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYWRkU2VyaWVzVG9QYW5lKHNlcmllcywgcGFuZSkge1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlSWQgPSBzZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKS5wcmljZVNjYWxlSWQ7XG4gICAgICAgIGNvbnN0IHRhcmdldFNjYWxlSWQgPSBwcmljZVNjYWxlSWQgIT09IHVuZGVmaW5lZCA/IHByaWNlU2NhbGVJZCA6IHRoaXMuX2ludGVybmFsX2RlZmF1bHRWaXNpYmxlUHJpY2VTY2FsZUlkKCk7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX2FkZERhdGFTb3VyY2Uoc2VyaWVzLCB0YXJnZXRTY2FsZUlkKTtcbiAgICAgICAgaWYgKCFpc0RlZmF1bHRQcmljZVNjYWxlKHRhcmdldFNjYWxlSWQpKSB7XG4gICAgICAgICAgICAvLyBsZXQncyBhcHBseSB0aGF0IG9wdGlvbnMgYWdhaW4gdG8gYXBwbHkgbWFyZ2luc1xuICAgICAgICAgICAgc2VyaWVzLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMoc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19nZXRCYWNrZ3JvdW5kQ29sb3Ioc2lkZSkge1xuICAgICAgICBjb25zdCBsYXlvdXRPcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc1snbGF5b3V0J107XG4gICAgICAgIGlmIChsYXlvdXRPcHRpb25zLmJhY2tncm91bmQudHlwZSA9PT0gXCJncmFkaWVudFwiIC8qIENvbG9yVHlwZS5WZXJ0aWNhbEdyYWRpZW50ICovKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lkZSA9PT0gMCAvKiBCYWNrZ3JvdW5kQ29sb3JTaWRlLlRvcCAqLyA/XG4gICAgICAgICAgICAgICAgbGF5b3V0T3B0aW9ucy5iYWNrZ3JvdW5kLnRvcENvbG9yIDpcbiAgICAgICAgICAgICAgICBsYXlvdXRPcHRpb25zLmJhY2tncm91bmQuYm90dG9tQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxheW91dE9wdGlvbnMuYmFja2dyb3VuZC5jb2xvcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NsZWFudXBJZlBhbmVJc0VtcHR5KHBhbmUpIHtcbiAgICAgICAgaWYgKHBhbmUuX2ludGVybmFsX2RhdGFTb3VyY2VzKCkubGVuZ3RoID09PSAwICYmIHRoaXMuX3ByaXZhdGVfX3BhbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVzLnNwbGljZSh0aGlzLl9pbnRlcm5hbF9nZXRQYW5lSW5kZXgocGFuZSksIDEpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWxsVXBEb3duQ2FuZGxlc3RpY2tzQ29sb3JzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5ib3JkZXJDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyVXBDb2xvciA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyRG93bkNvbG9yID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud2lja0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy53aWNrVXBDb2xvciA9IG9wdGlvbnMud2lja0NvbG9yO1xuICAgICAgICBvcHRpb25zLndpY2tEb3duQ29sb3IgPSBvcHRpb25zLndpY2tDb2xvcjtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHR5cGUgb2YgdGhlIGxhc3QgcHJpY2UgYW5pbWF0aW9uIGZvciBzZXJpZXMgc3VjaCBhcyBhcmVhIG9yIGxpbmUuXG4gKi9cbnZhciBMYXN0UHJpY2VBbmltYXRpb25Nb2RlO1xuKGZ1bmN0aW9uIChMYXN0UHJpY2VBbmltYXRpb25Nb2RlKSB7XG4gICAgLyoqXG4gICAgICogQW5pbWF0aW9uIGlzIGFsd2F5cyBkaXNhYmxlZFxuICAgICAqL1xuICAgIExhc3RQcmljZUFuaW1hdGlvbk1vZGVbTGFzdFByaWNlQW5pbWF0aW9uTW9kZVtcIkRpc2FibGVkXCJdID0gMF0gPSBcIkRpc2FibGVkXCI7XG4gICAgLyoqXG4gICAgICogQW5pbWF0aW9uIGlzIGFsd2F5cyBlbmFibGVkLlxuICAgICAqL1xuICAgIExhc3RQcmljZUFuaW1hdGlvbk1vZGVbTGFzdFByaWNlQW5pbWF0aW9uTW9kZVtcIkNvbnRpbnVvdXNcIl0gPSAxXSA9IFwiQ29udGludW91c1wiO1xuICAgIC8qKlxuICAgICAqIEFuaW1hdGlvbiBpcyBhY3RpdmUgYWZ0ZXIgbmV3IGRhdGEuXG4gICAgICovXG4gICAgTGFzdFByaWNlQW5pbWF0aW9uTW9kZVtMYXN0UHJpY2VBbmltYXRpb25Nb2RlW1wiT25EYXRhVXBkYXRlXCJdID0gMl0gPSBcIk9uRGF0YVVwZGF0ZVwiO1xufSkoTGFzdFByaWNlQW5pbWF0aW9uTW9kZSB8fCAoTGFzdFByaWNlQW5pbWF0aW9uTW9kZSA9IHt9KSk7XG5mdW5jdGlvbiBwcmVjaXNpb25CeU1pbk1vdmUobWluTW92ZSkge1xuICAgIGlmIChtaW5Nb3ZlID49IDEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IDg7IGkrKykge1xuICAgICAgICBjb25zdCBpbnRQYXJ0ID0gTWF0aC5yb3VuZChtaW5Nb3ZlKTtcbiAgICAgICAgY29uc3QgZnJhY3RQYXJ0ID0gTWF0aC5hYnMoaW50UGFydCAtIG1pbk1vdmUpO1xuICAgICAgICBpZiAoZnJhY3RQYXJ0IDwgMWUtOCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgbWluTW92ZSA9IG1pbk1vdmUgKiAxMDtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHNvdXJjZSBvZiBkYXRhIHRvIGJlIHVzZWQgZm9yIHRoZSBob3Jpem9udGFsIHByaWNlIGxpbmUuXG4gKi9cbnZhciBQcmljZUxpbmVTb3VyY2U7XG4oZnVuY3Rpb24gKFByaWNlTGluZVNvdXJjZSkge1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGUgbGFzdCBiYXIgZGF0YS5cbiAgICAgKi9cbiAgICBQcmljZUxpbmVTb3VyY2VbUHJpY2VMaW5lU291cmNlW1wiTGFzdEJhclwiXSA9IDBdID0gXCJMYXN0QmFyXCI7XG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBsYXN0IHZpc2libGUgZGF0YSBvZiB0aGUgY2hhcnQgdmlld3BvcnQuXG4gICAgICovXG4gICAgUHJpY2VMaW5lU291cmNlW1ByaWNlTGluZVNvdXJjZVtcIkxhc3RWaXNpYmxlXCJdID0gMV0gPSBcIkxhc3RWaXNpYmxlXCI7XG59KShQcmljZUxpbmVTb3VyY2UgfHwgKFByaWNlTGluZVNvdXJjZSA9IHt9KSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHR5cGUgb2YgY29sb3IuXG4gKi9cbnZhciBDb2xvclR5cGU7XG4oZnVuY3Rpb24gKENvbG9yVHlwZSkge1xuICAgIC8qKiBTb2xpZCBjb2xvciAqL1xuICAgIENvbG9yVHlwZVtcIlNvbGlkXCJdID0gXCJzb2xpZFwiO1xuICAgIC8qKiBWZXJ0aWNhbCBncmFkaWVudCBjb2xvciAqL1xuICAgIENvbG9yVHlwZVtcIlZlcnRpY2FsR3JhZGllbnRcIl0gPSBcImdyYWRpZW50XCI7XG59KShDb2xvclR5cGUgfHwgKENvbG9yVHlwZSA9IHt9KSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0aW1lIHZhbHVlIGlzIGEgYnVzaW5lc3MgZGF5IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdGltZSAtIFRoZSB0aW1lIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIGB0aW1lYCBpcyBhIHtAbGluayBCdXNpbmVzc0RheX0gb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzQnVzaW5lc3NEYXkodGltZSkge1xuICAgIHJldHVybiAhaXNOdW1iZXIodGltZSkgJiYgIWlzU3RyaW5nKHRpbWUpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHRpbWUgdmFsdWUgaXMgYSBVVEMgdGltZXN0YW1wIG51bWJlci5cbiAqXG4gKiBAcGFyYW0gdGltZSAtIFRoZSB0aW1lIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIGB0aW1lYCBpcyBhIHtAbGluayBVVENUaW1lc3RhbXB9IG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1VUQ1RpbWVzdGFtcCh0aW1lKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRpbWUpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0eXBlIG9mIGEgdGljayBtYXJrIG9uIHRoZSB0aW1lIGF4aXMuXG4gKi9cbnZhciBUaWNrTWFya1R5cGU7XG4oZnVuY3Rpb24gKFRpY2tNYXJrVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCBvZiB0aGUgeWVhciAoZS5nLiBpdCdzIHRoZSBmaXJzdCB0aWNrIG1hcmsgaW4gYSB5ZWFyKS5cbiAgICAgKi9cbiAgICBUaWNrTWFya1R5cGVbVGlja01hcmtUeXBlW1wiWWVhclwiXSA9IDBdID0gXCJZZWFyXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHN0YXJ0IG9mIHRoZSBtb250aCAoZS5nLiBpdCdzIHRoZSBmaXJzdCB0aWNrIG1hcmsgaW4gYSBtb250aCkuXG4gICAgICovXG4gICAgVGlja01hcmtUeXBlW1RpY2tNYXJrVHlwZVtcIk1vbnRoXCJdID0gMV0gPSBcIk1vbnRoXCI7XG4gICAgLyoqXG4gICAgICogQSBkYXkgb2YgdGhlIG1vbnRoLlxuICAgICAqL1xuICAgIFRpY2tNYXJrVHlwZVtUaWNrTWFya1R5cGVbXCJEYXlPZk1vbnRoXCJdID0gMl0gPSBcIkRheU9mTW9udGhcIjtcbiAgICAvKipcbiAgICAgKiBBIHRpbWUgd2l0aG91dCBzZWNvbmRzLlxuICAgICAqL1xuICAgIFRpY2tNYXJrVHlwZVtUaWNrTWFya1R5cGVbXCJUaW1lXCJdID0gM10gPSBcIlRpbWVcIjtcbiAgICAvKipcbiAgICAgKiBBIHRpbWUgd2l0aCBzZWNvbmRzLlxuICAgICAqL1xuICAgIFRpY2tNYXJrVHlwZVtUaWNrTWFya1R5cGVbXCJUaW1lV2l0aFNlY29uZHNcIl0gPSA0XSA9IFwiVGltZVdpdGhTZWNvbmRzXCI7XG59KShUaWNrTWFya1R5cGUgfHwgKFRpY2tNYXJrVHlwZSA9IHt9KSk7XG5cbmNvbnN0IGdldE1vbnRoID0gKGRhdGUpID0+IGRhdGUuZ2V0VVRDTW9udGgoKSArIDE7XG5jb25zdCBnZXREYXkgPSAoZGF0ZSkgPT4gZGF0ZS5nZXRVVENEYXRlKCk7XG5jb25zdCBnZXRZZWFyID0gKGRhdGUpID0+IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbmNvbnN0IGRkID0gKGRhdGUpID0+IG51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvKGdldERheShkYXRlKSwgMik7XG5jb25zdCBNTU1NID0gKGRhdGUsIGxvY2FsZSkgPT4gbmV3IERhdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCBkYXRlLmdldFVUQ01vbnRoKCksIDEpXG4gICAgLnRvTG9jYWxlU3RyaW5nKGxvY2FsZSwgeyBtb250aDogJ2xvbmcnIH0pO1xuY29uc3QgTU1NID0gKGRhdGUsIGxvY2FsZSkgPT4gbmV3IERhdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCBkYXRlLmdldFVUQ01vbnRoKCksIDEpXG4gICAgLnRvTG9jYWxlU3RyaW5nKGxvY2FsZSwgeyBtb250aDogJ3Nob3J0JyB9KTtcbmNvbnN0IE1NID0gKGRhdGUpID0+IG51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvKGdldE1vbnRoKGRhdGUpLCAyKTtcbmNvbnN0IHl5ID0gKGRhdGUpID0+IG51bWJlclRvU3RyaW5nV2l0aExlYWRpbmdaZXJvKGdldFllYXIoZGF0ZSkgJSAxMDAsIDIpO1xuY29uc3QgeXl5eSA9IChkYXRlKSA9PiBudW1iZXJUb1N0cmluZ1dpdGhMZWFkaW5nWmVybyhnZXRZZWFyKGRhdGUpLCA0KTtcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gZm9ybWF0XG4gICAgICAgIC5yZXBsYWNlKC95eXl5L2csIHl5eXkoZGF0ZSkpXG4gICAgICAgIC5yZXBsYWNlKC95eS9nLCB5eShkYXRlKSlcbiAgICAgICAgLnJlcGxhY2UoL01NTU0vZywgTU1NTShkYXRlLCBsb2NhbGUpKVxuICAgICAgICAucmVwbGFjZSgvTU1NL2csIE1NTShkYXRlLCBsb2NhbGUpKVxuICAgICAgICAucmVwbGFjZSgvTU0vZywgTU0oZGF0ZSkpXG4gICAgICAgIC5yZXBsYWNlKC9kZC9nLCBkZChkYXRlKSk7XG59XG5cbmNsYXNzIERhdGVGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVGb3JtYXQgPSAneXl5eS1NTS1kZCcsIGxvY2FsZSA9ICdkZWZhdWx0Jykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRlRm9ybWF0ID0gZGF0ZUZvcm1hdDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9jYWxlID0gbG9jYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZm9ybWF0KGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUoZGF0ZSwgdGhpcy5fcHJpdmF0ZV9fZGF0ZUZvcm1hdCwgdGhpcy5fcHJpdmF0ZV9fbG9jYWxlKTtcbiAgICB9XG59XG5cbmNsYXNzIFRpbWVGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZvcm1hdCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19mb3JtYXRTdHIgPSBmb3JtYXQgfHwgJyVoOiVtOiVzJztcbiAgICB9XG4gICAgX2ludGVybmFsX2Zvcm1hdChkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRTdHIucmVwbGFjZSgnJWgnLCBudW1iZXJUb1N0cmluZ1dpdGhMZWFkaW5nWmVybyhkYXRlLmdldFVUQ0hvdXJzKCksIDIpKS5cbiAgICAgICAgICAgIHJlcGxhY2UoJyVtJywgbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8oZGF0ZS5nZXRVVENNaW51dGVzKCksIDIpKS5cbiAgICAgICAgICAgIHJlcGxhY2UoJyVzJywgbnVtYmVyVG9TdHJpbmdXaXRoTGVhZGluZ1plcm8oZGF0ZS5nZXRVVENTZWNvbmRzKCksIDIpKTtcbiAgICB9XG59XG5cbmNvbnN0IGRlZmF1bHRQYXJhbXMgPSB7XG4gICAgX2ludGVybmFsX2RhdGVGb3JtYXQ6ICd5eXl5LU1NLWRkJyxcbiAgICBfaW50ZXJuYWxfdGltZUZvcm1hdDogJyVoOiVtOiVzJyxcbiAgICBfaW50ZXJuYWxfZGF0ZVRpbWVTZXBhcmF0b3I6ICcgJyxcbiAgICBfaW50ZXJuYWxfbG9jYWxlOiAnZGVmYXVsdCcsXG59O1xuY2xhc3MgRGF0ZVRpbWVGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlclBhcmFtcyA9IHsgLi4uZGVmYXVsdFBhcmFtcywgLi4ucGFyYW1zIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGVGb3JtYXR0ZXIgPSBuZXcgRGF0ZUZvcm1hdHRlcihmb3JtYXR0ZXJQYXJhbXMuX2ludGVybmFsX2RhdGVGb3JtYXQsIGZvcm1hdHRlclBhcmFtcy5faW50ZXJuYWxfbG9jYWxlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUZvcm1hdHRlciA9IG5ldyBUaW1lRm9ybWF0dGVyKGZvcm1hdHRlclBhcmFtcy5faW50ZXJuYWxfdGltZUZvcm1hdCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NlcGFyYXRvciA9IGZvcm1hdHRlclBhcmFtcy5faW50ZXJuYWxfZGF0ZVRpbWVTZXBhcmF0b3I7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9mb3JtYXQoZGF0ZVRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuX3ByaXZhdGVfX2RhdGVGb3JtYXR0ZXIuX2ludGVybmFsX2Zvcm1hdChkYXRlVGltZSl9JHt0aGlzLl9wcml2YXRlX19zZXBhcmF0b3J9JHt0aGlzLl9wcml2YXRlX190aW1lRm9ybWF0dGVyLl9pbnRlcm5hbF9mb3JtYXQoZGF0ZVRpbWUpfWA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0VGlja01hcmtGb3JtYXR0ZXIodGltZVBvaW50LCB0aWNrTWFya1R5cGUsIGxvY2FsZSkge1xuICAgIGNvbnN0IGZvcm1hdE9wdGlvbnMgPSB7fTtcbiAgICBzd2l0Y2ggKHRpY2tNYXJrVHlwZSkge1xuICAgICAgICBjYXNlIDAgLyogVGlja01hcmtUeXBlLlllYXIgKi86XG4gICAgICAgICAgICBmb3JtYXRPcHRpb25zLnllYXIgPSAnbnVtZXJpYyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIFRpY2tNYXJrVHlwZS5Nb250aCAqLzpcbiAgICAgICAgICAgIGZvcm1hdE9wdGlvbnMubW9udGggPSAnc2hvcnQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBUaWNrTWFya1R5cGUuRGF5T2ZNb250aCAqLzpcbiAgICAgICAgICAgIGZvcm1hdE9wdGlvbnMuZGF5ID0gJ251bWVyaWMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMyAvKiBUaWNrTWFya1R5cGUuVGltZSAqLzpcbiAgICAgICAgICAgIGZvcm1hdE9wdGlvbnMuaG91cjEyID0gZmFsc2U7XG4gICAgICAgICAgICBmb3JtYXRPcHRpb25zLmhvdXIgPSAnMi1kaWdpdCc7XG4gICAgICAgICAgICBmb3JtYXRPcHRpb25zLm1pbnV0ZSA9ICcyLWRpZ2l0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQgLyogVGlja01hcmtUeXBlLlRpbWVXaXRoU2Vjb25kcyAqLzpcbiAgICAgICAgICAgIGZvcm1hdE9wdGlvbnMuaG91cjEyID0gZmFsc2U7XG4gICAgICAgICAgICBmb3JtYXRPcHRpb25zLmhvdXIgPSAnMi1kaWdpdCc7XG4gICAgICAgICAgICBmb3JtYXRPcHRpb25zLm1pbnV0ZSA9ICcyLWRpZ2l0JztcbiAgICAgICAgICAgIGZvcm1hdE9wdGlvbnMuc2Vjb25kID0gJzItZGlnaXQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGRhdGUgPSB0aW1lUG9pbnQuX2ludGVybmFsX2J1c2luZXNzRGF5ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBuZXcgRGF0ZSh0aW1lUG9pbnQuX2ludGVybmFsX3RpbWVzdGFtcCAqIDEwMDApXG4gICAgICAgIDogbmV3IERhdGUoRGF0ZS5VVEModGltZVBvaW50Ll9pbnRlcm5hbF9idXNpbmVzc0RheS55ZWFyLCB0aW1lUG9pbnQuX2ludGVybmFsX2J1c2luZXNzRGF5Lm1vbnRoIC0gMSwgdGltZVBvaW50Ll9pbnRlcm5hbF9idXNpbmVzc0RheS5kYXkpKTtcbiAgICAvLyBmcm9tIGdpdmVuIGRhdGUgd2Ugc2hvdWxkIHVzZSBvbmx5IGFzIFVUQyBkYXRlIG9yIHRpbWVzdGFtcFxuICAgIC8vIGJ1dCB0byBmb3JtYXQgYXMgbG9jYWxlIGRhdGUgd2UgY2FuIGNvbnZlcnQgVVRDIGRhdGUgdG8gbG9jYWwgZGF0ZVxuICAgIGNvbnN0IGxvY2FsRGF0ZUZyb21VdGMgPSBuZXcgRGF0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCksIGRhdGUuZ2V0VVRDSG91cnMoKSwgZGF0ZS5nZXRVVENNaW51dGVzKCksIGRhdGUuZ2V0VVRDU2Vjb25kcygpLCBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpKTtcbiAgICByZXR1cm4gbG9jYWxEYXRlRnJvbVV0Yy50b0xvY2FsZVN0cmluZyhsb2NhbGUsIGZvcm1hdE9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBob3Vycyhjb3VudCkge1xuICAgIHJldHVybiBjb3VudCAqIDYwICogNjAgKiAxMDAwO1xufVxuZnVuY3Rpb24gbWludXRlcyhjb3VudCkge1xuICAgIHJldHVybiBjb3VudCAqIDYwICogMTAwMDtcbn1cbmZ1bmN0aW9uIHNlY29uZHMoY291bnQpIHtcbiAgICByZXR1cm4gY291bnQgKiAxMDAwO1xufVxuY29uc3QgaW50cmFkYXlXZWlnaHREaXZpc29ycyA9IFtcbiAgICB7IF9pbnRlcm5hbF9kaXZpc29yOiBzZWNvbmRzKDEpLCBfaW50ZXJuYWxfd2VpZ2h0OiAxMCAvKiBUaWNrTWFya1dlaWdodC5TZWNvbmQgKi8gfSxcbiAgICB7IF9pbnRlcm5hbF9kaXZpc29yOiBtaW51dGVzKDEpLCBfaW50ZXJuYWxfd2VpZ2h0OiAyMCAvKiBUaWNrTWFya1dlaWdodC5NaW51dGUxICovIH0sXG4gICAgeyBfaW50ZXJuYWxfZGl2aXNvcjogbWludXRlcyg1KSwgX2ludGVybmFsX3dlaWdodDogMjEgLyogVGlja01hcmtXZWlnaHQuTWludXRlNSAqLyB9LFxuICAgIHsgX2ludGVybmFsX2Rpdmlzb3I6IG1pbnV0ZXMoMzApLCBfaW50ZXJuYWxfd2VpZ2h0OiAyMiAvKiBUaWNrTWFya1dlaWdodC5NaW51dGUzMCAqLyB9LFxuICAgIHsgX2ludGVybmFsX2Rpdmlzb3I6IGhvdXJzKDEpLCBfaW50ZXJuYWxfd2VpZ2h0OiAzMCAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMSAqLyB9LFxuICAgIHsgX2ludGVybmFsX2Rpdmlzb3I6IGhvdXJzKDMpLCBfaW50ZXJuYWxfd2VpZ2h0OiAzMSAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMyAqLyB9LFxuICAgIHsgX2ludGVybmFsX2Rpdmlzb3I6IGhvdXJzKDYpLCBfaW50ZXJuYWxfd2VpZ2h0OiAzMiAvKiBUaWNrTWFya1dlaWdodC5Ib3VyNiAqLyB9LFxuICAgIHsgX2ludGVybmFsX2Rpdmlzb3I6IGhvdXJzKDEyKSwgX2ludGVybmFsX3dlaWdodDogMzMgLyogVGlja01hcmtXZWlnaHQuSG91cjEyICovIH0sXG5dO1xuZnVuY3Rpb24gd2VpZ2h0QnlUaW1lKGN1cnJlbnREYXRlLCBwcmV2RGF0ZSkge1xuICAgIGlmIChjdXJyZW50RGF0ZS5nZXRVVENGdWxsWWVhcigpICE9PSBwcmV2RGF0ZS5nZXRVVENGdWxsWWVhcigpKSB7XG4gICAgICAgIHJldHVybiA3MCAvKiBUaWNrTWFya1dlaWdodC5ZZWFyICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJyZW50RGF0ZS5nZXRVVENNb250aCgpICE9PSBwcmV2RGF0ZS5nZXRVVENNb250aCgpKSB7XG4gICAgICAgIHJldHVybiA2MCAvKiBUaWNrTWFya1dlaWdodC5Nb250aCAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VycmVudERhdGUuZ2V0VVRDRGF0ZSgpICE9PSBwcmV2RGF0ZS5nZXRVVENEYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIDUwIC8qIFRpY2tNYXJrV2VpZ2h0LkRheSAqLztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGludHJhZGF5V2VpZ2h0RGl2aXNvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKE1hdGguZmxvb3IocHJldkRhdGUuZ2V0VGltZSgpIC8gaW50cmFkYXlXZWlnaHREaXZpc29yc1tpXS5faW50ZXJuYWxfZGl2aXNvcikgIT09IE1hdGguZmxvb3IoY3VycmVudERhdGUuZ2V0VGltZSgpIC8gaW50cmFkYXlXZWlnaHREaXZpc29yc1tpXS5faW50ZXJuYWxfZGl2aXNvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRyYWRheVdlaWdodERpdmlzb3JzW2ldLl9pbnRlcm5hbF93ZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDAgLyogVGlja01hcmtXZWlnaHQuTGVzc1RoYW5TZWNvbmQgKi87XG59XG5mdW5jdGlvbiBjYXN0KHQpIHtcbiAgICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGZpbGxXZWlnaHRzRm9yUG9pbnRzKHNvcnRlZFRpbWVQb2ludHMsIHN0YXJ0SW5kZXggPSAwKSB7XG4gICAgaWYgKHNvcnRlZFRpbWVQb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByZXZUaW1lID0gc3RhcnRJbmRleCA9PT0gMCA/IG51bGwgOiBjYXN0KHNvcnRlZFRpbWVQb2ludHNbc3RhcnRJbmRleCAtIDFdLnRpbWUpLl9pbnRlcm5hbF90aW1lc3RhbXA7XG4gICAgbGV0IHByZXZEYXRlID0gcHJldlRpbWUgIT09IG51bGwgPyBuZXcgRGF0ZShwcmV2VGltZSAqIDEwMDApIDogbnVsbDtcbiAgICBsZXQgdG90YWxUaW1lRGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8IHNvcnRlZFRpbWVQb2ludHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludCA9IHNvcnRlZFRpbWVQb2ludHNbaW5kZXhdO1xuICAgICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKGNhc3QoY3VycmVudFBvaW50LnRpbWUpLl9pbnRlcm5hbF90aW1lc3RhbXAgKiAxMDAwKTtcbiAgICAgICAgaWYgKHByZXZEYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQudGltZVdlaWdodCA9IHdlaWdodEJ5VGltZShjdXJyZW50RGF0ZSwgcHJldkRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvdGFsVGltZURpZmYgKz0gY2FzdChjdXJyZW50UG9pbnQudGltZSkuX2ludGVybmFsX3RpbWVzdGFtcCAtIChwcmV2VGltZSB8fCBjYXN0KGN1cnJlbnRQb2ludC50aW1lKS5faW50ZXJuYWxfdGltZXN0YW1wKTtcbiAgICAgICAgcHJldlRpbWUgPSBjYXN0KGN1cnJlbnRQb2ludC50aW1lKS5faW50ZXJuYWxfdGltZXN0YW1wO1xuICAgICAgICBwcmV2RGF0ZSA9IGN1cnJlbnREYXRlO1xuICAgIH1cbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCAmJiBzb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gbGV0J3MgZ3Vlc3MgYSB3ZWlnaHQgZm9yIHRoZSBmaXJzdCBwb2ludFxuICAgICAgICAvLyBsZXQncyBzYXkgdGhlIHByZXZpb3VzIHBvaW50IHdhcyBhdmVyYWdlIHRpbWUgYmFjayBpbiB0aGUgaGlzdG9yeVxuICAgICAgICBjb25zdCBhdmVyYWdlVGltZURpZmYgPSBNYXRoLmNlaWwodG90YWxUaW1lRGlmZiAvIChzb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgY29uc3QgYXBwcm94UHJldkRhdGUgPSBuZXcgRGF0ZSgoY2FzdChzb3J0ZWRUaW1lUG9pbnRzWzBdLnRpbWUpLl9pbnRlcm5hbF90aW1lc3RhbXAgLSBhdmVyYWdlVGltZURpZmYpICogMTAwMCk7XG4gICAgICAgIHNvcnRlZFRpbWVQb2ludHNbMF0udGltZVdlaWdodCA9IHdlaWdodEJ5VGltZShuZXcgRGF0ZShjYXN0KHNvcnRlZFRpbWVQb2ludHNbMF0udGltZSkuX2ludGVybmFsX3RpbWVzdGFtcCAqIDEwMDApLCBhcHByb3hQcmV2RGF0ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBidXNpbmVzc0RheUNvbnZlcnRlcih0aW1lKSB7XG4gICAgbGV0IGJ1c2luZXNzRGF5ID0gdGltZTtcbiAgICBpZiAoaXNTdHJpbmcodGltZSkpIHtcbiAgICAgICAgYnVzaW5lc3NEYXkgPSBzdHJpbmdUb0J1c2luZXNzRGF5KHRpbWUpO1xuICAgIH1cbiAgICBpZiAoIWlzQnVzaW5lc3NEYXkoYnVzaW5lc3NEYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGltZSBtdXN0IGJlIG9mIHR5cGUgQnVzaW5lc3NEYXknKTtcbiAgICB9XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKGJ1c2luZXNzRGF5LnllYXIsIGJ1c2luZXNzRGF5Lm1vbnRoIC0gMSwgYnVzaW5lc3NEYXkuZGF5LCAwLCAwLCAwLCAwKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2ludGVybmFsX3RpbWVzdGFtcDogTWF0aC5yb3VuZChkYXRlLmdldFRpbWUoKSAvIDEwMDApLFxuICAgICAgICBfaW50ZXJuYWxfYnVzaW5lc3NEYXk6IGJ1c2luZXNzRGF5LFxuICAgIH07XG59XG5mdW5jdGlvbiB0aW1lc3RhbXBDb252ZXJ0ZXIodGltZSkge1xuICAgIGlmICghaXNVVENUaW1lc3RhbXAodGltZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aW1lIG11c3QgYmUgb2YgdHlwZSBpc1VUQ1RpbWVzdGFtcCcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZXJuYWxfdGltZXN0YW1wOiB0aW1lLFxuICAgIH07XG59XG5mdW5jdGlvbiBzZWxlY3RUaW1lQ29udmVydGVyKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0J1c2luZXNzRGF5KGRhdGFbMF0udGltZSkgfHwgaXNTdHJpbmcoZGF0YVswXS50aW1lKSkge1xuICAgICAgICByZXR1cm4gYnVzaW5lc3NEYXlDb252ZXJ0ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aW1lc3RhbXBDb252ZXJ0ZXI7XG59XG5jb25zdCB2YWxpZERhdGVSZWdleCA9IC9eXFxkXFxkXFxkXFxkLVxcZFxcZC1cXGRcXGQkLztcbmZ1bmN0aW9uIGNvbnZlcnRUaW1lKHRpbWUpIHtcbiAgICBpZiAoaXNVVENUaW1lc3RhbXAodGltZSkpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVzdGFtcENvbnZlcnRlcih0aW1lKTtcbiAgICB9XG4gICAgaWYgKCFpc0J1c2luZXNzRGF5KHRpbWUpKSB7XG4gICAgICAgIHJldHVybiBidXNpbmVzc0RheUNvbnZlcnRlcihzdHJpbmdUb0J1c2luZXNzRGF5KHRpbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1c2luZXNzRGF5Q29udmVydGVyKHRpbWUpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9CdXNpbmVzc0RheSh2YWx1ZSkge1xuICAgIHtcbiAgICAgICAgLy8gaW4gc29tZSBicm93c2VycyAoSSBsb29rIGF0IHlvdXIgQ2hyb21lKSB0aGUgRGF0ZSBjb25zdHJ1Y3RvciBtYXkgYWNjZXB0IGludmFsaWQgZGF0ZSBzdHJpbmdcbiAgICAgICAgLy8gYnV0IHBhcnNlcyB0aGVtIGluICdpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYycgd2F5XG4gICAgICAgIC8vIGZvciBleGFtcGxlIDIwMTktMS0xIGlzbid0IHRoZSBzYW1lIGFzIDIwMTktMDEtMDEgKGZvciBDaHJvbWUgYm90aCBhcmUgJ3ZhbGlkJyBkYXRlIHN0cmluZ3MpXG4gICAgICAgIC8vIHNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05Njg5MzlcbiAgICAgICAgLy8gc28sIHdlIG5lZWQgdG8gYmUgc3VyZSB0aGF0IGRhdGUgaGFzIHZhbGlkIGZvcm1hdCB0byBhdm9pZCBzdHJhbmdlIGJlaGF2aW9yIGFuZCBob3VycyBvZiBkZWJ1Z2dpbmdcbiAgICAgICAgLy8gYnV0IGxldCdzIGRvIHRoaXMgaW4gZGV2ZWxvcG1lbnQgYnVpbGQgb25seSBiZWNhdXNlIG9mIHBlcmZcbiAgICAgICAgaWYgKCF2YWxpZERhdGVSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGUgc3RyaW5nPSR7dmFsdWV9LCBleHBlY3RlZCBmb3JtYXQ9eXl5eS1tbS1kZGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgaWYgKGlzTmFOKGQuZ2V0VGltZSgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmc9JHt2YWx1ZX0sIGV4cGVjdGVkIGZvcm1hdD15eXl5LW1tLWRkYCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgICAgIG1vbnRoOiBkLmdldFVUQ01vbnRoKCkgKyAxLFxuICAgICAgICB5ZWFyOiBkLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTdHJpbmdUb0J1c2luZXNzRGF5KHZhbHVlKSB7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlLnRpbWUpKSB7XG4gICAgICAgIHZhbHVlLnRpbWUgPSBzdHJpbmdUb0J1c2luZXNzRGF5KHZhbHVlLnRpbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRTdHJpbmdzVG9CdXNpbmVzc0RheXMoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLmZvckVhY2goY29udmVydFN0cmluZ1RvQnVzaW5lc3NEYXkpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gd2VpZ2h0VG9UaWNrTWFya1R5cGUod2VpZ2h0LCB0aW1lVmlzaWJsZSwgc2Vjb25kc1Zpc2libGUpIHtcbiAgICBzd2l0Y2ggKHdlaWdodCkge1xuICAgICAgICBjYXNlIDAgLyogVGlja01hcmtXZWlnaHQuTGVzc1RoYW5TZWNvbmQgKi86XG4gICAgICAgIGNhc2UgMTAgLyogVGlja01hcmtXZWlnaHQuU2Vjb25kICovOlxuICAgICAgICAgICAgcmV0dXJuIHRpbWVWaXNpYmxlXG4gICAgICAgICAgICAgICAgPyAoc2Vjb25kc1Zpc2libGUgPyA0IC8qIFRpY2tNYXJrVHlwZS5UaW1lV2l0aFNlY29uZHMgKi8gOiAzIC8qIFRpY2tNYXJrVHlwZS5UaW1lICovKVxuICAgICAgICAgICAgICAgIDogMiAvKiBUaWNrTWFya1R5cGUuRGF5T2ZNb250aCAqLztcbiAgICAgICAgY2FzZSAyMCAvKiBUaWNrTWFya1dlaWdodC5NaW51dGUxICovOlxuICAgICAgICBjYXNlIDIxIC8qIFRpY2tNYXJrV2VpZ2h0Lk1pbnV0ZTUgKi86XG4gICAgICAgIGNhc2UgMjIgLyogVGlja01hcmtXZWlnaHQuTWludXRlMzAgKi86XG4gICAgICAgIGNhc2UgMzAgLyogVGlja01hcmtXZWlnaHQuSG91cjEgKi86XG4gICAgICAgIGNhc2UgMzEgLyogVGlja01hcmtXZWlnaHQuSG91cjMgKi86XG4gICAgICAgIGNhc2UgMzIgLyogVGlja01hcmtXZWlnaHQuSG91cjYgKi86XG4gICAgICAgIGNhc2UgMzMgLyogVGlja01hcmtXZWlnaHQuSG91cjEyICovOlxuICAgICAgICAgICAgcmV0dXJuIHRpbWVWaXNpYmxlID8gMyAvKiBUaWNrTWFya1R5cGUuVGltZSAqLyA6IDIgLyogVGlja01hcmtUeXBlLkRheU9mTW9udGggKi87XG4gICAgICAgIGNhc2UgNTAgLyogVGlja01hcmtXZWlnaHQuRGF5ICovOlxuICAgICAgICAgICAgcmV0dXJuIDIgLyogVGlja01hcmtUeXBlLkRheU9mTW9udGggKi87XG4gICAgICAgIGNhc2UgNjAgLyogVGlja01hcmtXZWlnaHQuTW9udGggKi86XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBUaWNrTWFya1R5cGUuTW9udGggKi87XG4gICAgICAgIGNhc2UgNzAgLyogVGlja01hcmtXZWlnaHQuWWVhciAqLzpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFRpY2tNYXJrVHlwZS5ZZWFyICovO1xuICAgIH1cbn1cbmNsYXNzIEhvcnpTY2FsZUJlaGF2aW9yVGltZSB7XG4gICAgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnM7XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51cGRhdGVGb3JtYXR0ZXIob3B0aW9ucy5sb2NhbGl6YXRpb24pO1xuICAgIH1cbiAgICBwcmVwcm9jZXNzRGF0YShkYXRhKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBjb252ZXJ0U3RyaW5nc1RvQnVzaW5lc3NEYXlzKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udmVydFN0cmluZ1RvQnVzaW5lc3NEYXkoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlQ29udmVydGVyVG9JbnRlcm5hbE9iaihkYXRhKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVOb3ROdWxsKHNlbGVjdFRpbWVDb252ZXJ0ZXIoZGF0YSkpO1xuICAgIH1cbiAgICBrZXkoaXRlbSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiBcIl9pbnRlcm5hbF90aW1lc3RhbXBcIiBpbiBpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5faW50ZXJuYWxfdGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5KHRoaXMuY29udmVydEhvcnpJdGVtVG9JbnRlcm5hbChpdGVtKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FjaGVLZXkoaXRlbSkge1xuICAgICAgICBjb25zdCB0aW1lID0gaXRlbTtcbiAgICAgICAgcmV0dXJuIHRpbWUuX2ludGVybmFsX2J1c2luZXNzRGF5ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IERhdGUodGltZS5faW50ZXJuYWxfdGltZXN0YW1wICogMTAwMCkuZ2V0VGltZSgpXG4gICAgICAgICAgICA6IG5ldyBEYXRlKERhdGUuVVRDKHRpbWUuX2ludGVybmFsX2J1c2luZXNzRGF5LnllYXIsIHRpbWUuX2ludGVybmFsX2J1c2luZXNzRGF5Lm1vbnRoIC0gMSwgdGltZS5faW50ZXJuYWxfYnVzaW5lc3NEYXkuZGF5KSkuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBjb252ZXJ0SG9yekl0ZW1Ub0ludGVybmFsKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUaW1lKGl0ZW0pO1xuICAgIH1cbiAgICB1cGRhdGVGb3JtYXR0ZXIob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX29wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRlRm9ybWF0ID0gb3B0aW9ucy5kYXRlRm9ybWF0O1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUudGltZVZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGVUaW1lRm9ybWF0dGVyID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyKHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZUZvcm1hdDogdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUuc2Vjb25kc1Zpc2libGUgPyAnJWg6JW06JXMnIDogJyVoOiVtJyxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfZGF0ZVRpbWVTZXBhcmF0b3I6ICcgICAnLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sb2NhbGU6IG9wdGlvbnMubG9jYWxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRlVGltZUZvcm1hdHRlciA9IG5ldyBEYXRlRm9ybWF0dGVyKGRhdGVGb3JtYXQsIG9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JtYXRIb3J6SXRlbShpdGVtKSB7XG4gICAgICAgIGNvbnN0IHRwID0gaXRlbTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2RhdGVUaW1lRm9ybWF0dGVyLl9pbnRlcm5hbF9mb3JtYXQobmV3IERhdGUodHAuX2ludGVybmFsX3RpbWVzdGFtcCAqIDEwMDApKTtcbiAgICB9XG4gICAgZm9ybWF0VGlja21hcmsodGlja01hcmssIGxvY2FsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdGlja01hcmtUeXBlID0gd2VpZ2h0VG9UaWNrTWFya1R5cGUodGlja01hcmsud2VpZ2h0LCB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS50aW1lVmlzaWJsZSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUuc2Vjb25kc1Zpc2libGUpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGU7XG4gICAgICAgIGlmIChvcHRpb25zLnRpY2tNYXJrRm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpY2tNYXJrU3RyaW5nID0gb3B0aW9ucy50aWNrTWFya0Zvcm1hdHRlcih0aWNrTWFyay5vcmlnaW5hbFRpbWUsIHRpY2tNYXJrVHlwZSwgbG9jYWxpemF0aW9uT3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICAgICAgaWYgKHRpY2tNYXJrU3RyaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpY2tNYXJrU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0VGlja01hcmtGb3JtYXR0ZXIodGlja01hcmsudGltZSwgdGlja01hcmtUeXBlLCBsb2NhbGl6YXRpb25PcHRpb25zLmxvY2FsZSk7XG4gICAgfVxuICAgIG1heFRpY2tNYXJrV2VpZ2h0KHRpY2tNYXJrcykge1xuICAgICAgICBsZXQgbWF4V2VpZ2h0ID0gdGlja01hcmtzLnJlZHVjZShtYXJrV2l0aEdyZWF0ZXJXZWlnaHQkMiwgdGlja01hcmtzWzBdKS53ZWlnaHQ7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZTogaXQgbG9va3Mgc3RyYW5nZSBpZiAxNTowMCBpcyBib2xkIGJ1dCAxNDowMCBpcyBub3RcbiAgICAgICAgLy8gc28gaWYgbWF4V2VpZ2h0ID4gVGlja01hcmtXZWlnaHQuSG91cjEgYW5kIDwgVGlja01hcmtXZWlnaHQuRGF5IHJlZHVjZSBpdCB0byBUaWNrTWFya1dlaWdodC5Ib3VyMVxuICAgICAgICBpZiAobWF4V2VpZ2h0ID4gMzAgLyogVGlja01hcmtXZWlnaHQuSG91cjEgKi8gJiYgbWF4V2VpZ2h0IDwgNTAgLyogVGlja01hcmtXZWlnaHQuRGF5ICovKSB7XG4gICAgICAgICAgICBtYXhXZWlnaHQgPSAzMCAvKiBUaWNrTWFya1dlaWdodC5Ib3VyMSAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4V2VpZ2h0O1xuICAgIH1cbiAgICBmaWxsV2VpZ2h0c0ZvclBvaW50cyhzb3J0ZWRUaW1lUG9pbnRzLCBzdGFydEluZGV4KSB7XG4gICAgICAgIGZpbGxXZWlnaHRzRm9yUG9pbnRzKHNvcnRlZFRpbWVQb2ludHMsIHN0YXJ0SW5kZXgpO1xuICAgIH1cbiAgICBzdGF0aWMgX2ludGVybmFsX2FwcGx5RGVmYXVsdHMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbWVyZ2UoeyBsb2NhbGl6YXRpb246IHsgZGF0ZUZvcm1hdDogJ2RkIE1NTSBcXCd5eScgfSB9LCBvcHRpb25zID8/IHt9KTtcbiAgICB9XG59XG5cbi8qKlxuICogV2hlbiB5b3UncmUgdHJ5aW5nIHRvIHVzZSB0aGUgbGlicmFyeSBpbiBzZXJ2ZXItc2lkZSBjb250ZXh0IChmb3IgaW5zdGFuY2UgaW4gU1NSKVxuICogeW91IGRvbid0IGhhdmUgc29tZSBicm93c2VyLXNwZWNpZmljIHZhcmlhYmxlcyBsaWtlIG5hdmlnYXRvciBvciB3aW5kb3dcbiAqIGFuZCBpZiB0aGUgbGlicmFyeSB3aWxsIHVzZSB0aGVtIG9uIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIGxpYnJhcnlcbiAqIHRoZSBpbXBvcnQgd2lsbCBmYWlsIGR1ZSBSZWZlcmVuY2VFcnJvclxuICogdGh1cywgdGhpcyBhbGxvd3MgdXNlIHRoZSBuYXZpZ2F0b3Igb24gdGhlIHRvcCBsZXZlbCBhbmQgYmVpbmcgaW1wb3J0ZWQgaW4gc2VydmVyLXNpZGUgY29udGV4dCBhcyB3ZWxsXG4gKiBTZWUgaXNzdWUgIzQ0NlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3RzbGludC9jb25maWdcbmNvbnN0IGlzUnVubmluZ09uQ2xpZW50U2lkZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBpc0ZGKCkge1xuICAgIGlmICghaXNSdW5uaW5nT25DbGllbnRTaWRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTE7XG59XG5mdW5jdGlvbiBpc0lPUygpIHtcbiAgICBpZiAoIWlzUnVubmluZ09uQ2xpZW50U2lkZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIHJldHVybiAvaVBob25lfGlQYWR8aVBvZC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKTtcbn1cbmZ1bmN0aW9uIGlzQ2hyb21lKCkge1xuICAgIGlmICghaXNSdW5uaW5nT25DbGllbnRTaWRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5jaHJvbWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgb24gd2luZG93cy5cbmZ1bmN0aW9uIGlzV2luZG93cygpIHtcbiAgICBpZiAoIWlzUnVubmluZ09uQ2xpZW50U2lkZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG1vcmUgYWNjdXJhdGUgaWYgYXZhaWxhYmxlXG4gICAgaWYgKG5hdmlnYXRvcj8udXNlckFnZW50RGF0YT8ucGxhdGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLnBsYXRmb3JtID09PSAnV2luZG93cyc7XG4gICAgfVxuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2luJykgPj0gMDtcbn1cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBicm93c2VyIGlzIENocm9taXVtIGJhc2VkLlxuZnVuY3Rpb24gaXNDaHJvbWl1bUJhc2VkKCkge1xuICAgIGlmICghaXNSdW5uaW5nT25DbGllbnRTaWRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5icmFuZHMuc29tZSgoYnJhbmQpID0+IHtcbiAgICAgICAgcmV0dXJuIGJyYW5kLmJyYW5kLmluY2x1ZGVzKCdDaHJvbWl1bScpO1xuICAgIH0pO1xufVxuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIl9idWlsZC10aW1lLWNvbnN0YW50c1wiIC8+XG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgfVxufVxuXG4vLyBvbiBIaS1EUEkgQ1NTIHNpemUgKiBEZXZpY2UgUGl4ZWwgUmF0aW8gc2hvdWxkIGJlIGludGVnZXIgdG8gYXZvaWQgc21vb3RoaW5nXG4vLyBGb3IgY2hhcnQgd2lkZ2V0IHdlIGRlY3JlYXNlIHRoZSBzaXplIGJlY2F1c2Ugd2UgbXVzdCBiZSBpbnNpZGUgY29udGFpbmVyLlxuLy8gRm9yIHRpbWUgYXhpcyB0aGlzIGlzIG5vdCBpbXBvcnRhbnQsIHNpbmNlIGl0IGp1c3QgYWZmZWN0cyBzcGFjZSBmb3IgcGFuZSB3aWRnZXRzXG5mdW5jdGlvbiBzdWdnZXN0Q2hhcnRTaXplKG9yaWdpbmFsU2l6ZSkge1xuICAgIGNvbnN0IGludGVnZXJXaWR0aCA9IE1hdGguZmxvb3Iob3JpZ2luYWxTaXplLndpZHRoKTtcbiAgICBjb25zdCBpbnRlZ2VySGVpZ2h0ID0gTWF0aC5mbG9vcihvcmlnaW5hbFNpemUuaGVpZ2h0KTtcbiAgICBjb25zdCB3aWR0aCA9IGludGVnZXJXaWR0aCAtIChpbnRlZ2VyV2lkdGggJSAyKTtcbiAgICBjb25zdCBoZWlnaHQgPSBpbnRlZ2VySGVpZ2h0IC0gKGludGVnZXJIZWlnaHQgJSAyKTtcbiAgICByZXR1cm4gc2l6ZSQxKHsgd2lkdGgsIGhlaWdodCB9KTtcbn1cbmZ1bmN0aW9uIHN1Z2dlc3RUaW1lU2NhbGVIZWlnaHQob3JpZ2luYWxIZWlnaHQpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxIZWlnaHQgKyAob3JpZ2luYWxIZWlnaHQgJSAyKTtcbn1cbmZ1bmN0aW9uIHN1Z2dlc3RQcmljZVNjYWxlV2lkdGgob3JpZ2luYWxXaWR0aCkge1xuICAgIHJldHVybiBvcmlnaW5hbFdpZHRoICsgKG9yaWdpbmFsV2lkdGggJSAyKTtcbn1cblxuZnVuY3Rpb24gcHJldmVudFNjcm9sbEJ5V2hlZWxDbGljayhlbCkge1xuICAgIGlmICghaXNDaHJvbWUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgICAgICBpZiAoZS5idXR0b24gPT09IDEgLyogTW91c2VFdmVudEJ1dHRvbi5NaWRkbGUgKi8pIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgaW5jb3JyZWN0IHNjcm9sbGluZyBldmVudFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5cbi8vIFRPRE86IGdldCByaWQgb2YgYSBsb3Qgb2YgYm9vbGVhbiBmbGFncywgcHJvYmFibHkgd2Ugc2hvdWxkIHJlcGxhY2UgaXQgd2l0aCBzb21lIGVudW1cbmNsYXNzIE1vdXNlRXZlbnRIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tQb3NpdGlvbiA9IHsgX2ludGVybmFsX3g6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgX2ludGVybmFsX3k6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXBDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcFBvc2l0aW9uID0geyBfaW50ZXJuYWxfeDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBfaW50ZXJuYWxfeTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb25nVGFwQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlTW92ZVN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVTdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3ZlRXhjZWVkZWRNYW5oYXR0YW5EaXN0YW5jZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW5jZWxDbGljayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW5jZWxUYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlTW91c2VFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVUb3VjaEV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW9iaWxlU2FmYXJpRXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb3VzZW1vdmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRQaW5jaE1pZGRsZVBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRQaW5jaERpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGluY2hQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJldmVudFRvdWNoRHJhZ1Byb2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xhc3RUb3VjaEV2ZW50VGltZVN0YW1wID0gMDtcbiAgICAgICAgLy8gZm9yIHRvdWNoc3RhcnQvdG91Y2htb3ZlL3RvdWNoZW5kIGV2ZW50cyB3ZSBoYW5kbGUgb25seSBmaXJzdCB0b3VjaFxuICAgICAgICAvLyBpLmUuIHdlIGRvbid0IHN1cHBvcnQgc2V2ZXJhbCBhY3RpdmUgdG91Y2hlcyBhdCB0aGUgc2FtZSB0aW1lIChleGNlcHQgcGluY2ggZXZlbnQpXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjdGl2ZVRvdWNoSWQgPSBudWxsO1xuICAgICAgICAvLyBhY2NlcHQgYWxsIG1vdXNlIGxlYXZlIGV2ZW50cyBpZiBpdCdzIG5vdCBhbiBpT1MgZGV2aWNlXG4gICAgICAgIC8vIHNlZSBfbW91c2VFbnRlckhhbmRsZXIsIF9tb3VzZU1vdmVIYW5kbGVyLCBfbW91c2VMZWF2ZUhhbmRsZXJcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWNjZXB0TW91c2VMZWF2ZSA9ICFpc0lPUygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4gRmlyZWZveCBtb3VzZSBldmVudHMgZG9udCd0IGZpcmUgaWYgdGhlIG1vdXNlIHBvc2l0aW9uIGlzIG91dHNpZGUgb2YgdGhlIGJyb3dzZXIncyBib3JkZXIuXG4gICAgICAgICAqIFRvIHByZXZlbnQgdGhlIG1vdXNlIGZyb20gaGFuZ2luZyB3aGlsZSBwcmVzc2VkIHdlJ3JlIHN1YnNjcmliaW5nIG9uIHRoZSBtb3VzZWxlYXZlIGV2ZW50IG9mIHRoZSBkb2N1bWVudCBlbGVtZW50LlxuICAgICAgICAgKiBXZSdyZSBzdWJzY3JpYmluZyBvbiBtb3VzZWxlYXZlLCBidXQgdGhpcyBldmVudCBpcyBhY3R1YWxseSBmaXJlZCBvbiBtb3VzZXVwIG91dHNpZGUgb2YgdGhlIGJyb3dzZXIncyBib3JkZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbkZpcmVmb3hPdXRzaWRlTW91c2VVcCA9IChtb3VzZVVwRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlVXBIYW5kbGVyKG1vdXNlVXBFdmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYWZhcmkgZG9lc24ndCBmaXJlIHRvdWNoc3RhcnQvbW91c2Vkb3duIGV2ZW50cyBvbiBkb3VibGUgdGFwIHNpbmNlIGlPUyAxMy5cbiAgICAgICAgICogVGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgICAgICAqIDEpIENhbGwgcHJldmVudERlZmF1bHQgaW4gdG91Y2hFbmQgaGFuZGxlci4gQnV0IGl0IGFsc28gcHJldmVudHMgY2xpY2sgZXZlbnQgZnJvbSBmaXJpbmcuXG4gICAgICAgICAqIDIpIEFkZCBsaXN0ZW5lciBvbiBkYmxjbGljayBldmVudCB0aGF0IGZpcmVzIHdpdGggdGhlIHByZWNlZGluZyBtb3VzZWRvd24vbW91c2V1cC5cbiAgICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvcnVtcy90aHJlYWQvMTI1MDczXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbk1vYmlsZVNhZmFyaURvdWJsZUNsaWNrID0gKGRibENsaWNrRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19maXJlc1RvdWNoRXZlbnRzKGRibENsaWNrRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQoZGJsQ2xpY2tFdmVudCk7XG4gICAgICAgICAgICAgICAgKyt0aGlzLl9wcml2YXRlX190YXBDb3VudDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdGFwVGltZW91dElkICYmIHRoaXMuX3ByaXZhdGVfX3RhcENvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IF9pbnRlcm5hbF9tYW5oYXR0YW5EaXN0YW5jZTogbWFuaGF0dGFuRGlzdGFuY2UgfSA9IHRoaXMuX3ByaXZhdGVfX3RvdWNoTW91c2VNb3ZlV2l0aERvd25JbmZvKGdldFBvc2l0aW9uKGRibENsaWNrRXZlbnQpLCB0aGlzLl9wcml2YXRlX190YXBQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgICAgICAgICAgICAgICAgICBpZiAobWFuaGF0dGFuRGlzdGFuY2UgPCAzMCAvKiBDb25zdGFudHMuRG91YmxlVGFwTWFuaGF0dGFuRGlzdGFuY2UgKi8gJiYgIXRoaXMuX3ByaXZhdGVfX2NhbmNlbFRhcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc1RvdWNoRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX2RvdWJsZVRhcEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldFRhcFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChkYmxDbGlja0V2ZW50KTtcbiAgICAgICAgICAgICAgICArK3RoaXMuX3ByaXZhdGVfX2NsaWNrQ291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NsaWNrVGltZW91dElkICYmIHRoaXMuX3ByaXZhdGVfX2NsaWNrQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgX2ludGVybmFsX21hbmhhdHRhbkRpc3RhbmNlOiBtYW5oYXR0YW5EaXN0YW5jZSB9ID0gdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8oZ2V0UG9zaXRpb24oZGJsQ2xpY2tFdmVudCksIHRoaXMuX3ByaXZhdGVfX2NsaWNrUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlIDwgNSAvKiBDb25zdGFudHMuRG91YmxlQ2xpY2tNYW5oYXR0YW5EaXN0YW5jZSAqLyAmJiAhdGhpcy5fcHJpdmF0ZV9fY2FuY2VsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZURvdWJsZUNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2V0Q2xpY2tUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5pdCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlT3V0c2lkZU1vdXNlRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlTW91c2VFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVUb3VjaEV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVPdXRzaWRlVG91Y2hFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb3VzZW1vdmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW9iaWxlU2FmYXJpRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vYmlsZVNhZmFyaUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldENsaWNrVGltZW91dCgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VFbnRlckhhbmRsZXIoZW50ZXJFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVNb3VzZW1vdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm91bmRNb3VzZU1vdmVIYW5kbGVyID0gdGhpcy5fcHJpdmF0ZV9fbW91c2VNb3ZlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vdXNlbW92ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZUhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgYm91bmRNb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ZpcmVzVG91Y2hFdmVudHMoZW50ZXJFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChlbnRlckV2ZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX21vdXNlRW50ZXJFdmVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FjY2VwdE1vdXNlTGVhdmUgPSB0cnVlO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcmVzZXRDbGlja1RpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jbGlja1RpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3ByaXZhdGVfX2NsaWNrVGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja1Bvc2l0aW9uID0geyBfaW50ZXJuYWxfeDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBfaW50ZXJuYWxfeTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgfVxuICAgIF9wcml2YXRlX19yZXNldFRhcFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX190YXBUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9wcml2YXRlX190YXBUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFwUG9zaXRpb24gPSB7IF9pbnRlcm5hbF94OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIF9pbnRlcm5hbF95OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlTW92ZUhhbmRsZXIobW92ZUV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19tb3VzZVByZXNzZWQgfHwgdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3ZlU3RhcnRQb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19maXJlc1RvdWNoRXZlbnRzKG1vdmVFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChtb3ZlRXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzTW91c2VFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfbW91c2VNb3ZlRXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hY2NlcHRNb3VzZUxlYXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RvdWNoTW92ZUhhbmRsZXIobW92ZUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gdG91Y2hXaXRoSWQobW92ZUV2ZW50LmNoYW5nZWRUb3VjaGVzLCBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2FjdGl2ZVRvdWNoSWQpKTtcbiAgICAgICAgaWYgKHRvdWNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgPSBldmVudFRpbWVTdGFtcChtb3ZlRXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhcnRQaW5jaE1pZGRsZVBvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByZXZlbnRUb3VjaERyYWdQcm9jZXNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldmVudCBwaW5jaCBpZiBtb3ZlIGV2ZW50IGNvbWVzIGZhc3RlciB0aGFuIHRoZSBzZWNvbmQgdG91Y2hcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGluY2hQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBtb3ZlSW5mbyA9IHRoaXMuX3ByaXZhdGVfX3RvdWNoTW91c2VNb3ZlV2l0aERvd25JbmZvKGdldFBvc2l0aW9uKHRvdWNoKSwgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX190b3VjaE1vdmVTdGFydFBvc2l0aW9uKSk7XG4gICAgICAgIGNvbnN0IHsgX2ludGVybmFsX3hPZmZzZXQ6IHhPZmZzZXQsIF9pbnRlcm5hbF95T2Zmc2V0OiB5T2Zmc2V0LCBfaW50ZXJuYWxfbWFuaGF0dGFuRGlzdGFuY2U6IG1hbmhhdHRhbkRpc3RhbmNlIH0gPSBtb3ZlSW5mbztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3ZlRXhjZWVkZWRNYW5oYXR0YW5EaXN0YW5jZSAmJiBtYW5oYXR0YW5EaXN0YW5jZSA8IDUgLyogQ29uc3RhbnRzLkNhbmNlbFRhcE1hbmhhdHRhbkRpc3RhbmNlICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX190b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCB0aW1lIHdoZW4gY3VycmVudCBwb3NpdGlvbiBleGNlZWRlZCBtYW5oYXR0YW4gZGlzdGFuY2VcbiAgICAgICAgICAgIC8vIHZlcnRpY2FsIGRyYWcgaXMgbW9yZSBpbXBvcnRhbnQgdGhhbiBob3Jpem9udGFsIGRyYWdcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2Ugc2Nyb2xsIHRoZSBwYWdlIHZlcnRpY2FsbHkgb2Z0ZW4gdGhhbiBob3Jpem9udGFsbHlcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RlZFhPZmZzZXQgPSB4T2Zmc2V0ICogMC41O1xuICAgICAgICAgICAgLy8gYSBkcmFnIGNhbiBiZSBvbmx5IGlmIHRvdWNoIHBhZ2Ugc2Nyb2xsIGlzbid0IGFsbG93ZWRcbiAgICAgICAgICAgIGNvbnN0IGlzVmVydERyYWcgPSB5T2Zmc2V0ID49IGNvcnJlY3RlZFhPZmZzZXQgJiYgIXRoaXMuX3ByaXZhdGVfX29wdGlvbnMuX2ludGVybmFsX3RyZWF0VmVydFRvdWNoRHJhZ0FzUGFnZVNjcm9sbCgpO1xuICAgICAgICAgICAgY29uc3QgaXNIb3J6RHJhZyA9IGNvcnJlY3RlZFhPZmZzZXQgPiB5T2Zmc2V0ICYmICF0aGlzLl9wcml2YXRlX19vcHRpb25zLl9pbnRlcm5hbF90cmVhdEhvcnpUb3VjaERyYWdBc1BhZ2VTY3JvbGwoKTtcbiAgICAgICAgICAgIC8vIGlmIGRyYWcgZXZlbnQgaGFwcGVuZWQgdGhlbiB3ZSBzaG91bGQgcmV2ZXJ0IHByZXZlbnREZWZhdWx0IHN0YXRlIHRvIG9yaWdpbmFsIG9uZVxuICAgICAgICAgICAgLy8gYW5kIHRyeSB0byBwcm9jZXNzIHRoZSBkcmFnIGV2ZW50XG4gICAgICAgICAgICAvLyBlbHNlIHdlIHNob3VsZG4ndCBwcmV2ZW50IGRlZmF1bHQgb2YgdGhlIGV2ZW50IGFuZCBpZ25vcmUgcHJvY2Vzc2luZyB0aGUgZHJhZyBldmVudFxuICAgICAgICAgICAgaWYgKCFpc1ZlcnREcmFnICYmICFpc0hvcnpEcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJldmVudFRvdWNoRHJhZ1Byb2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3ZlRXhjZWVkZWRNYW5oYXR0YW5EaXN0YW5jZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBpZiBtYW5oYXR0YW4gZGlzdGFuY2UgaXMgbW9yZSB0aGF0IDUgLSB3ZSBzaG91bGQgY2FuY2VsIHRhcCBldmVudFxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FuY2VsVGFwID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsZWFyTG9uZ1RhcFRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2V0VGFwVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fcHJldmVudFRvdWNoRHJhZ1Byb2Nlc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KG1vdmVFdmVudCwgdG91Y2gpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc1RvdWNoRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3RvdWNoTW92ZUV2ZW50KTtcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBwcmV2ZW50IGRlZmF1bHQgaW4gY2FzZSBvZiB0b3VjaCBvbmx5XG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IHNjcm9sbCBvZiB0aGUgcGFnZVxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQobW92ZUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VNb3ZlV2l0aERvd25IYW5kbGVyKG1vdmVFdmVudCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICAgICAgaWYgKG1vdmVFdmVudC5idXR0b24gIT09IDAgLyogTW91c2VFdmVudEJ1dHRvbi5MZWZ0ICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW92ZUluZm8gPSB0aGlzLl9wcml2YXRlX190b3VjaE1vdXNlTW92ZVdpdGhEb3duSW5mbyhnZXRQb3NpdGlvbihtb3ZlRXZlbnQpLCBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX21vdXNlTW92ZVN0YXJ0UG9zaXRpb24pKTtcbiAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfbWFuaGF0dGFuRGlzdGFuY2U6IG1hbmhhdHRhbkRpc3RhbmNlIH0gPSBtb3ZlSW5mbztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgICAgIGlmIChtYW5oYXR0YW5EaXN0YW5jZSA+PSA1IC8qIENvbnN0YW50cy5DYW5jZWxDbGlja01hbmhhdHRhbkRpc3RhbmNlICovKSB7XG4gICAgICAgICAgICAvLyBpZiBtYW5oYXR0YW4gZGlzdGFuY2UgaXMgbW9yZSB0aGF0IDUgLSB3ZSBzaG91bGQgY2FuY2VsIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYW5jZWxDbGljayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNldENsaWNrVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jYW5jZWxDbGljaykge1xuICAgICAgICAgICAgLy8gaWYgdGhpcy5fY2FuY2VsQ2xpY2sgaXMgdHJ1ZSwgdGhhdCBtZWFucyB0aGF0IG1pbmltdW0gbWFuaGF0dGFuIGRpc3RhbmNlIGlzIGFscmVhZHkgZXhjZWVkZWRcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KG1vdmVFdmVudCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzTW91c2VFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcHJlc3NlZE1vdXNlTW92ZUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8oY3VycmVudFBvc2l0aW9uLCBzdGFydFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHhPZmZzZXQgPSBNYXRoLmFicyhzdGFydFBvc2l0aW9uLl9pbnRlcm5hbF94IC0gY3VycmVudFBvc2l0aW9uLl9pbnRlcm5hbF94KTtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IE1hdGguYWJzKHN0YXJ0UG9zaXRpb24uX2ludGVybmFsX3kgLSBjdXJyZW50UG9zaXRpb24uX2ludGVybmFsX3kpO1xuICAgICAgICBjb25zdCBtYW5oYXR0YW5EaXN0YW5jZSA9IHhPZmZzZXQgKyB5T2Zmc2V0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX3hPZmZzZXQ6IHhPZmZzZXQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfeU9mZnNldDogeU9mZnNldCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tYW5oYXR0YW5EaXN0YW5jZTogbWFuaGF0dGFuRGlzdGFuY2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgX3ByaXZhdGVfX3RvdWNoRW5kSGFuZGxlcih0b3VjaEVuZEV2ZW50KSB7XG4gICAgICAgIGxldCB0b3VjaCA9IHRvdWNoV2l0aElkKHRvdWNoRW5kRXZlbnQuY2hhbmdlZFRvdWNoZXMsIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fYWN0aXZlVG91Y2hJZCkpO1xuICAgICAgICBpZiAodG91Y2ggPT09IG51bGwgJiYgdG91Y2hFbmRFdmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmcsIHNvbWVob3cgd2UgbWlzc2VkIHRoZSByZXF1aXJlZCB0b3VjaGVuZCBldmVudFxuICAgICAgICAgICAgLy8gcHJvYmFibHkgdGhlIGJyb3dzZXIgaGFzIG5vdCBzZW50IHRoaXMgZXZlbnRcbiAgICAgICAgICAgIHRvdWNoID0gdG91Y2hFbmRFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19hY3RpdmVUb3VjaElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgPSBldmVudFRpbWVTdGFtcCh0b3VjaEVuZEV2ZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3VjaE1vdmVTdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KHRvdWNoRW5kRXZlbnQsIHRvdWNoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc1RvdWNoRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3RvdWNoRW5kRXZlbnQpO1xuICAgICAgICArK3RoaXMuX3ByaXZhdGVfX3RhcENvdW50O1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdGFwVGltZW91dElkICYmIHRoaXMuX3ByaXZhdGVfX3RhcENvdW50ID4gMSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCBib3RoIGNsaWNrcyBhcmUgbmVhciBlbm91Z2hcbiAgICAgICAgICAgIGNvbnN0IHsgX2ludGVybmFsX21hbmhhdHRhbkRpc3RhbmNlOiBtYW5oYXR0YW5EaXN0YW5jZSB9ID0gdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3VzZU1vdmVXaXRoRG93bkluZm8oZ2V0UG9zaXRpb24odG91Y2gpLCB0aGlzLl9wcml2YXRlX190YXBQb3NpdGlvbik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICAgICAgICAgIGlmIChtYW5oYXR0YW5EaXN0YW5jZSA8IDMwIC8qIENvbnN0YW50cy5Eb3VibGVUYXBNYW5oYXR0YW5EaXN0YW5jZSAqLyAmJiAhdGhpcy5fcHJpdmF0ZV9fY2FuY2VsVGFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc1RvdWNoRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX2RvdWJsZVRhcEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2V0VGFwVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19jYW5jZWxUYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzVG91Y2hFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfdGFwRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBmaXJlIG1vdXNlIGV2ZW50cyBpZiB0YXAgaGFuZGxlciB3YXMgZXhlY3V0ZWRcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGNsaWNrIGV2ZW50IG9uIG5ldyBkb20gZWxlbWVudCAod2hvIGFwcGVhcmVkIGFmdGVyIHRhcClcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfdGFwRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQodG91Y2hFbmRFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQsIGZvciBleGFtcGxlLCBzYWZhcmkncyBkYmxjbGljay10by16b29tIG9yIGZhc3QtY2xpY2sgYWZ0ZXIgbG9uZy10YXBcbiAgICAgICAgLy8gd2UgaGFuZGxlIG1vdXNlRG91YmxlQ2xpY2tFdmVudCBoZXJlIG91cnNlbHZlc1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KHRvdWNoRW5kRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaEVuZEV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcEFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IG5hdGl2ZSBjbGljayBldmVudFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KHRvdWNoRW5kRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZVVwSGFuZGxlcihtb3VzZVVwRXZlbnQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgICAgIGlmIChtb3VzZVVwRXZlbnQuYnV0dG9uICE9PSAwIC8qIE1vdXNlRXZlbnRCdXR0b24uTGVmdCAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KG1vdXNlVXBFdmVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlTW92ZVN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZGKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX3ByaXZhdGVfX29uRmlyZWZveE91dHNpZGVNb3VzZVVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZmlyZXNUb3VjaEV2ZW50cyhtb3VzZVVwRXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX21vdXNlVXBFdmVudCk7XG4gICAgICAgICsrdGhpcy5fcHJpdmF0ZV9fY2xpY2tDb3VudDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NsaWNrVGltZW91dElkICYmIHRoaXMuX3ByaXZhdGVfX2NsaWNrQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IGJvdGggY2xpY2tzIGFyZSBuZWFyIGVub3VnaFxuICAgICAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfbWFuaGF0dGFuRGlzdGFuY2U6IG1hbmhhdHRhbkRpc3RhbmNlIH0gPSB0aGlzLl9wcml2YXRlX190b3VjaE1vdXNlTW92ZVdpdGhEb3duSW5mbyhnZXRQb3NpdGlvbihtb3VzZVVwRXZlbnQpLCB0aGlzLl9wcml2YXRlX19jbGlja1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgICAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlIDwgNSAvKiBDb25zdGFudHMuRG91YmxlQ2xpY2tNYW5oYXR0YW5EaXN0YW5jZSAqLyAmJiAhdGhpcy5fcHJpdmF0ZV9fY2FuY2VsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzTW91c2VFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2V0Q2xpY2tUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2NhbmNlbENsaWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc01vdXNlRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX21vdXNlQ2xpY2tFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2NsZWFyTG9uZ1RhcFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sb25nVGFwVGltZW91dElkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb25nVGFwVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3RvdWNoU3RhcnRIYW5kbGVyKGRvd25FdmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYWN0aXZlVG91Y2hJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdWNoID0gZG93bkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hY3RpdmVUb3VjaElkID0gdG91Y2guaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgPSBldmVudFRpbWVTdGFtcChkb3duRXZlbnQpO1xuICAgICAgICBjb25zdCByb290RWxlbWVudCA9IHRoaXMuX3ByaXZhdGVfX3RhcmdldC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FuY2VsVGFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvdWNoTW92ZUV4Y2VlZGVkTWFuaGF0dGFuRGlzdGFuY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJldmVudFRvdWNoRHJhZ1Byb2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3ZlU3RhcnRQb3NpdGlvbiA9IGdldFBvc2l0aW9uKHRvdWNoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kVG91Y2hNb3ZlV2l0aERvd25IYW5kbGVyID0gdGhpcy5fcHJpdmF0ZV9fdG91Y2hNb3ZlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRUb3VjaEVuZEhhbmRsZXIgPSB0aGlzLl9wcml2YXRlX190b3VjaEVuZEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGJvdW5kVG91Y2hNb3ZlV2l0aERvd25IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGJvdW5kVG91Y2hFbmRIYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBib3VuZFRvdWNoTW92ZVdpdGhEb3duSGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgYm91bmRUb3VjaEVuZEhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jbGVhckxvbmdUYXBUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sb25nVGFwVGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9wcml2YXRlX19sb25nVGFwSGFuZGxlci5iaW5kKHRoaXMsIGRvd25FdmVudCksIDI0MCAvKiBEZWxheS5Mb25nVGFwICovKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChkb3duRXZlbnQsIHRvdWNoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJvY2Vzc1RvdWNoRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3RvdWNoU3RhcnRFdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fdGFwVGltZW91dElkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190YXBDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190YXBUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3ByaXZhdGVfX3Jlc2V0VGFwVGltZW91dC5iaW5kKHRoaXMpLCA1MDAgLyogRGVsYXkuUmVzZXRDbGljayAqLyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190YXBQb3NpdGlvbiA9IGdldFBvc2l0aW9uKHRvdWNoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VEb3duSGFuZGxlcihkb3duRXZlbnQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgICAgIGlmIChkb3duRXZlbnQuYnV0dG9uICE9PSAwIC8qIE1vdXNlRXZlbnRCdXR0b24uTGVmdCAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBpZiAoaXNGRigpKSB7XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fcHJpdmF0ZV9fb25GaXJlZm94T3V0c2lkZU1vdXNlVXApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbmNlbENsaWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlTW92ZVN0YXJ0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihkb3duRXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgYm91bmRNb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIgPSB0aGlzLl9wcml2YXRlX19tb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kTW91c2VVcEhhbmRsZXIgPSB0aGlzLl9wcml2YXRlX19tb3VzZVVwSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgYm91bmRNb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBib3VuZE1vdXNlVXBIYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZVdpdGhEb3duSGFuZGxlcik7XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgYm91bmRNb3VzZVVwSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ZpcmVzVG91Y2hFdmVudHMoZG93bkV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhdEV2ZW50ID0gdGhpcy5fcHJpdmF0ZV9fbWFrZUNvbXBhdEV2ZW50KGRvd25FdmVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZURvd25FdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3ByaXZhdGVfX3Jlc2V0Q2xpY2tUaW1lb3V0LmJpbmQodGhpcyksIDUwMCAvKiBEZWxheS5SZXNldENsaWNrICovKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrUG9zaXRpb24gPSBnZXRQb3NpdGlvbihkb3duRXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19pbml0KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMuX3ByaXZhdGVfX21vdXNlRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBEbyBub3Qgc2hvdyBjb250ZXh0IG1lbnUgd2hlbiBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9wcml2YXRlX19jbGVhckxvbmdUYXBUaW1lb3V0LmJpbmQodGhpcykpO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLl9wcml2YXRlX190YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIGNvbnN0IG91dHNpZGVIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZURvd25PdXRzaWRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29tcG9zZWQgJiYgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmNvbnRhaW5zKGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgJiYgdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9tb3VzZURvd25PdXRzaWRlRXZlbnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVUb3VjaEV2ZW50cyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG91dHNpZGVIYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb3V0c2lkZUhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvdXRzaWRlSGFuZGxlcik7XG4gICAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG91dHNpZGVIYW5kbGVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSU9TKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW9iaWxlU2FmYXJpRXZlbnRzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuX3ByaXZhdGVfX29uTW9iaWxlU2FmYXJpRG91YmxlQ2xpY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuX3ByaXZhdGVfX29uTW9iaWxlU2FmYXJpRG91YmxlQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fcHJpdmF0ZV9fbW91c2VMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fcHJpdmF0ZV9fdG91Y2hTdGFydEhhbmRsZXIuYmluZCh0aGlzKSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBwcmV2ZW50U2Nyb2xsQnlXaGVlbENsaWNrKHRoaXMuX3ByaXZhdGVfX3RhcmdldCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9wcml2YXRlX19tb3VzZURvd25IYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbml0UGluY2goKTtcbiAgICAgICAgLy8gSGV5IG1vYmlsZSBTYWZhcmksIHdoYXQncyB1cD9cbiAgICAgICAgLy8gSWYgbW9iaWxlIFNhZmFyaSBkb2Vzbid0IGhhdmUgYW55IHRvdWNobW92ZSBoYW5kbGVyIHdpdGggcGFzc2l2ZT1mYWxzZVxuICAgICAgICAvLyBpdCB0cmVhdHMgYSB0b3VjaHN0YXJ0IGFuZCB0aGUgZm9sbG93aW5nIHRvdWNobW92ZSBldmVudHMgYXMgY2FuY2VsYWJsZT1mYWxzZSxcbiAgICAgICAgLy8gc28gd2UgY2FuJ3QgcHJldmVudCB0aGVtIChhcyBzb29uIHdlIHN1YnNjcmliZSBvbiB0b3VjaG1vdmUgaW5zaWRlIHRvdWNoc3RhcnQncyBoYW5kbGVyKS5cbiAgICAgICAgLy8gQW5kIHdlJ2xsIGdldCBzY3JvbGwgb2YgdGhlIHBhZ2UgYWxvbmcgd2l0aCBjaGFydCdzIG9uZSBpbnN0ZWFkIG9mIG9ubHkgY2hhcnQncyBzY3JvbGwuXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAoKSA9PiB7IH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19pbml0UGluY2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9waW5jaFN0YXJ0RXZlbnQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcGluY2hFdmVudCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9waW5jaEVuZEV2ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIChldmVudCkgPT4gdGhpcy5fcHJpdmF0ZV9fY2hlY2tQaW5jaFN0YXRlKGV2ZW50LnRvdWNoZXMpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCB0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoTWlkZGxlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcGluY2hFdmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudERpc3RhbmNlID0gZ2V0RGlzdGFuY2UoZXZlbnQudG91Y2hlc1swXSwgZXZlbnQudG91Y2hlc1sxXSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBjdXJyZW50RGlzdGFuY2UgLyB0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcGluY2hFdmVudCh0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoTWlkZGxlUG9pbnQsIHNjYWxlKTtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hlY2tQaW5jaFN0YXRlKGV2ZW50LnRvdWNoZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NoZWNrUGluY2hTdGF0ZSh0b3VjaGVzKSB7XG4gICAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGluY2hQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2hlcy5sZW5ndGggIT09IDIgfHwgdGhpcy5fcHJpdmF0ZV9fcGluY2hQcmV2ZW50ZWQgfHwgdGhpcy5fcHJpdmF0ZV9fbG9uZ1RhcEFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RvcFBpbmNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFBpbmNoKHRvdWNoZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19zdGFydFBpbmNoKHRvdWNoZXMpIHtcbiAgICAgICAgY29uc3QgYm94ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuX3ByaXZhdGVfX3RhcmdldCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hNaWRkbGVQb2ludCA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF94OiAoKHRvdWNoZXNbMF0uY2xpZW50WCAtIGJveC5sZWZ0KSArICh0b3VjaGVzWzFdLmNsaWVudFggLSBib3gubGVmdCkpIC8gMixcbiAgICAgICAgICAgIF9pbnRlcm5hbF95OiAoKHRvdWNoZXNbMF0uY2xpZW50WSAtIGJveC50b3ApICsgKHRvdWNoZXNbMV0uY2xpZW50WSAtIGJveC50b3ApKSAvIDIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hEaXN0YW5jZSA9IGdldERpc3RhbmNlKHRvdWNoZXNbMF0sIHRvdWNoZXNbMV0pO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfcGluY2hTdGFydEV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3BpbmNoU3RhcnRFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsZWFyTG9uZ1RhcFRpbWVvdXQoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3N0b3BQaW5jaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hNaWRkbGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0UGluY2hNaWRkbGVQb2ludCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oYW5kbGVyLl9pbnRlcm5hbF9waW5jaEVuZEV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZXIuX2ludGVybmFsX3BpbmNoRW5kRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VMZWF2ZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX191bnN1YnNjcmliZU1vdXNlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19maXJlc1RvdWNoRXZlbnRzKGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fYWNjZXB0TW91c2VMZWF2ZSkge1xuICAgICAgICAgICAgLy8gbW9iaWxlIFNhZmFyaSBzb21ldGltZXMgZW1pdHMgbW91c2UgbGVhdmUgZXZlbnQgZm9yIG5vIHJlYXNvbiwgdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSBpdCBpbiBvdGhlciB3YXlcbiAgICAgICAgICAgIC8vIGp1c3QgaWdub3JlIHRoaXMgZXZlbnQgaWYgdGhlcmUgd2FzIG5vIG1vdXNlIG1vdmUgb3IgbW91c2UgZW50ZXIgZXZlbnRzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGF0RXZlbnQgPSB0aGlzLl9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzTW91c2VFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfbW91c2VMZWF2ZUV2ZW50KTtcbiAgICAgICAgLy8gYWNjZXB0IGFsbCBtb3VzZSBsZWF2ZSBldmVudHMgaWYgaXQncyBub3QgYW4gaU9TIGRldmljZVxuICAgICAgICB0aGlzLl9wcml2YXRlX19hY2NlcHRNb3VzZUxlYXZlID0gIWlzSU9TKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19sb25nVGFwSGFuZGxlcihldmVudCkge1xuICAgICAgICBjb25zdCB0b3VjaCA9IHRvdWNoV2l0aElkKGV2ZW50LnRvdWNoZXMsIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fYWN0aXZlVG91Y2hJZCkpO1xuICAgICAgICBpZiAodG91Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wYXRFdmVudCA9IHRoaXMuX3ByaXZhdGVfX21ha2VDb21wYXRFdmVudChldmVudCwgdG91Y2gpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcm9jZXNzVG91Y2hFdmVudChjb21wYXRFdmVudCwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlci5faW50ZXJuYWxfbG9uZ1RhcEV2ZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FuY2VsVGFwID0gdHJ1ZTtcbiAgICAgICAgLy8gbG9uZyB0YXAgaXMgYWN0aXZlIHVudGlsIHRvdWNoZW5kIGV2ZW50IHdpdGggMCB0b3VjaGVzIG9jY3VycmVkXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXBBY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZmlyZXNUb3VjaEV2ZW50cyhlKSB7XG4gICAgICAgIGlmIChlLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudFRpbWVTdGFtcChlKSA8IHRoaXMuX3ByaXZhdGVfX2xhc3RUb3VjaEV2ZW50VGltZVN0YW1wICsgNTAwIC8qIERlbGF5LlByZXZlbnRGaXJlc1RvdWNoRXZlbnRzICovO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJvY2Vzc1RvdWNoRXZlbnQoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLl9wcml2YXRlX19oYW5kbGVyLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3Byb2Nlc3NNb3VzZUV2ZW50KGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLl9wcml2YXRlX19oYW5kbGVyLCBldmVudCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tYWtlQ29tcGF0RXZlbnQoZXZlbnQsIHRvdWNoKSB7XG4gICAgICAgIC8vIFRvdWNoRXZlbnQgaGFzIG5vIGNsaWVudFgvWSBjb29yZGluYXRlczpcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB1c2UgdGhlIGxhc3QgVG91Y2ggaW5zdGVhZFxuICAgICAgICBjb25zdCBldmVudExpa2UgPSB0b3VjaCB8fCBldmVudDtcbiAgICAgICAgY29uc3QgYm94ID0gdGhpcy5fcHJpdmF0ZV9fdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRYOiBldmVudExpa2UuY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50TGlrZS5jbGllbnRZLFxuICAgICAgICAgICAgcGFnZVg6IGV2ZW50TGlrZS5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBldmVudExpa2UucGFnZVksXG4gICAgICAgICAgICBzY3JlZW5YOiBldmVudExpa2Uuc2NyZWVuWCxcbiAgICAgICAgICAgIHNjcmVlblk6IGV2ZW50TGlrZS5zY3JlZW5ZLFxuICAgICAgICAgICAgbG9jYWxYOiAoZXZlbnRMaWtlLmNsaWVudFggLSBib3gubGVmdCksXG4gICAgICAgICAgICBsb2NhbFk6IChldmVudExpa2UuY2xpZW50WSAtIGJveC50b3ApLFxuICAgICAgICAgICAgY3RybEtleTogZXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgIGFsdEtleTogZXZlbnQuYWx0S2V5LFxuICAgICAgICAgICAgc2hpZnRLZXk6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgbWV0YUtleTogZXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pc1RvdWNoOiAhZXZlbnQudHlwZS5zdGFydHNXaXRoKCdtb3VzZScpICYmIGV2ZW50LnR5cGUgIT09ICdjb250ZXh0bWVudScgJiYgZXZlbnQudHlwZSAhPT0gJ2NsaWNrJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9zcmNUeXBlOiBldmVudC50eXBlLFxuICAgICAgICAgICAgX2ludGVybmFsX3RhcmdldDogZXZlbnRMaWtlLnRhcmdldCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aWV3OiBldmVudC52aWV3LFxuICAgICAgICAgICAgX2ludGVybmFsX3ByZXZlbnREZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgIT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b3VjaHN0YXJ0IGlzIHBhc3NpdmUgYW5kIGNhbm5vdCBiZSBwcmV2ZW50ZWRcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCB7IGxlZnQ6IDAsIHRvcDogMCB9O1xufVxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyKSB7XG4gICAgY29uc3QgeERpZmYgPSBwMS5jbGllbnRYIC0gcDIuY2xpZW50WDtcbiAgICBjb25zdCB5RGlmZiA9IHAxLmNsaWVudFkgLSBwMi5jbGllbnRZO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpO1xufVxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGV2ZW50TGlrZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF94OiBldmVudExpa2UucGFnZVgsXG4gICAgICAgIF9pbnRlcm5hbF95OiBldmVudExpa2UucGFnZVksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV2ZW50VGltZVN0YW1wKGUpIHtcbiAgICAvLyBmb3Igc29tZSByZWFzb24gZS50aW1lc3RhbXAgaXMgYWx3YXlzIDAgb24gaVBhZCB3aXRoIG1hZ2ljIG1vdXNlLCBzbyB3ZSB1c2UgcGVyZm9ybWFuY2Uubm93KCkgYXMgYSBmYWxsYmFja1xuICAgIHJldHVybiBlLnRpbWVTdGFtcCB8fCBwZXJmb3JtYW5jZS5ub3coKTtcbn1cbmZ1bmN0aW9uIHRvdWNoV2l0aElkKHRvdWNoZXMsIGlkKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0b3VjaGVzW2ldLmlkZW50aWZpZXIgPT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdG91Y2hlc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgUGFuZVNlcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoY2hhcnRXaWRnZXQsIHRvcFBhbmVJbmRleCwgYm90dG9tUGFuZUluZGV4KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzaXplRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2l6ZUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldCA9IGNoYXJ0V2lkZ2V0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BQYW5lID0gY2hhcnRXaWRnZXQuX2ludGVybmFsX3BhbmVXaWRnZXRzKClbdG9wUGFuZUluZGV4XTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYm90dG9tUGFuZSA9IGNoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9wYW5lV2lkZ2V0cygpW2JvdHRvbVBhbmVJbmRleF07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jvd0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yb3dFbGVtZW50LnN0eWxlLmhlaWdodCA9IDEgLyogU2VwYXJhdG9yQ29uc3RhbnRzLlNlcGFyYXRvckhlaWdodCAqLyArICdweCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLm1hcmdpbiA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nLCAnMycpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVCb3JkZXJDb2xvcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yb3dFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX2NlbGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNpemVFbmFibGVkID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10ucGFuZXMuZW5hYmxlUmVzaXplO1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3Jlc2l6ZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hZGRSZXNpemFibGVIYW5kbGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlci5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcm93RWxlbWVudDtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldFNpemUoKSB7XG4gICAgICAgIHJldHVybiBzaXplJDEoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuX3ByaXZhdGVfX3RvcFBhbmUuX2ludGVybmFsX2dldFNpemUoKS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogMSAvKiBTZXBhcmF0b3JDb25zdGFudHMuU2VwYXJhdG9ySGVpZ2h0ICovLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldEJpdG1hcFNpemUoKSB7XG4gICAgICAgIHJldHVybiBzaXplJDEoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuX3ByaXZhdGVfX3RvcFBhbmUuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogMSAvKiBTZXBhcmF0b3JDb25zdGFudHMuU2VwYXJhdG9ySGVpZ2h0ICovICogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhd0JpdG1hcChjdHgsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgYml0bWFwU2l6ZSA9IHRoaXMuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9vcHRpb25zKClbJ2xheW91dCddLnBhbmVzLnNlcGFyYXRvckNvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgYml0bWFwU2l6ZS53aWR0aCwgYml0bWFwU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVCb3JkZXJDb2xvcigpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10ucGFuZXMuZW5hYmxlUmVzaXplICE9PSB0aGlzLl9wcml2YXRlX19yZXNpemVFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZXNpemVFbmFibGVkID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10ucGFuZXMuZW5hYmxlUmVzaXplO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Jlc2l6ZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hZGRSZXNpemFibGVIYW5kbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19oYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5yZW1vdmVDaGlsZCh0aGlzLl9wcml2YXRlX19oYW5kbGUuX2ludGVybmFsX2JhY2tncm91bmRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5yZW1vdmVDaGlsZCh0aGlzLl9wcml2YXRlX19oYW5kbGUuX2ludGVybmFsX2VsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19oYW5kbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fYWRkUmVzaXphYmxlSGFuZGxlKCkge1xuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBiZ1N0eWxlID0gYmFja2dyb3VuZEVsZW1lbnQuc3R5bGU7XG4gICAgICAgIGJnU3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICBiZ1N0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGJnU3R5bGUuekluZGV4ID0gJzQ5JztcbiAgICAgICAgYmdTdHlsZS50b3AgPSAnMCc7XG4gICAgICAgIGJnU3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgYmdTdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgYmdTdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIGJnU3R5bGUuY3Vyc29yID0gJ3Jvdy1yZXNpemUnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLmFwcGVuZENoaWxkKGJhY2tncm91bmRFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc3R5bGUuekluZGV4ID0gJzUwJztcbiAgICAgICAgc3R5bGUudG9wID0gJy00cHgnO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSAnOXB4JztcbiAgICAgICAgc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcnO1xuICAgICAgICBzdHlsZS5jdXJzb3IgPSAncm93LXJlc2l6ZSc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX21vdXNlRW50ZXJFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VPdmVyRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tb3VzZUxlYXZlRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlTGVhdmVFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX21vdXNlRG93bkV2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZURvd25FdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvdWNoU3RhcnRFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3duRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wcmVzc2VkTW91c2VNb3ZlRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX3ByZXNzZWRNb3VzZU1vdmVFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvdWNoTW92ZUV2ZW50OiB0aGlzLl9wcml2YXRlX19wcmVzc2VkTW91c2VNb3ZlRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tb3VzZVVwRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlVXBFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvdWNoRW5kRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlVXBFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlciA9IG5ldyBNb3VzZUV2ZW50SGFuZGxlcihlbGVtZW50LCBoYW5kbGVycywge1xuICAgICAgICAgICAgX2ludGVybmFsX3RyZWF0VmVydFRvdWNoRHJhZ0FzUGFnZVNjcm9sbDogKCkgPT4gZmFsc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdHJlYXRIb3J6VG91Y2hEcmFnQXNQYWdlU2Nyb2xsOiAoKSA9PiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlID0geyBfaW50ZXJuYWxfZWxlbWVudDogZWxlbWVudCwgX2ludGVybmFsX2JhY2tncm91bmRFbGVtZW50OiBiYWNrZ3JvdW5kRWxlbWVudCB9O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlQm9yZGVyQ29sb3IoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUuYmFja2dyb3VuZCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9vcHRpb25zKClbJ2xheW91dCddLnBhbmVzLnNlcGFyYXRvckNvbG9yO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VPdmVyRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2hhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faGFuZGxlLl9pbnRlcm5hbF9lbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9vcHRpb25zKClbJ2xheW91dCddLnBhbmVzLnNlcGFyYXRvckhvdmVyQ29sb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlTGVhdmVFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGFuZGxlICE9PSBudWxsICYmIHRoaXMuX3ByaXZhdGVfX3Jlc2l6ZUluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZS5faW50ZXJuYWxfZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VEb3duRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2hhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsU3RyZXRjaCA9IHRoaXMuX3ByaXZhdGVfX3RvcFBhbmUuX2ludGVybmFsX3N0YXRlKCkuX2ludGVybmFsX3N0cmV0Y2hGYWN0b3IoKSArIHRoaXMuX3ByaXZhdGVfX2JvdHRvbVBhbmUuX2ludGVybmFsX3N0YXRlKCkuX2ludGVybmFsX3N0cmV0Y2hGYWN0b3IoKTtcbiAgICAgICAgY29uc3QgdG90YWxIZWlnaHQgPSB0aGlzLl9wcml2YXRlX190b3BQYW5lLl9pbnRlcm5hbF9nZXRTaXplKCkuaGVpZ2h0ICsgdGhpcy5fcHJpdmF0ZV9fYm90dG9tUGFuZS5faW50ZXJuYWxfZ2V0U2l6ZSgpLmhlaWdodDtcbiAgICAgICAgY29uc3QgcGl4ZWxTdHJldGNoRmFjdG9yID0gdG90YWxTdHJldGNoIC8gdG90YWxIZWlnaHQ7XG4gICAgICAgIGNvbnN0IG1pblBhbmVTdHJldGNoID0gMzAgLyogU2VwYXJhdG9yQ29uc3RhbnRzLk1pblBhbmVIZWlnaHQgKi8gKiBwaXhlbFN0cmV0Y2hGYWN0b3I7XG4gICAgICAgIGlmICh0b3RhbFN0cmV0Y2ggPD0gbWluUGFuZVN0cmV0Y2ggKiAyKSB7XG4gICAgICAgICAgICAvLyBjYW5ub3QgcmVzaXplIHBhbmVzIHRoYXQgYWxyZWFkeSBoYXZlIGxlc3MgdGhhbiBtaW5pbWFsIGhlaWdodFxuICAgICAgICAgICAgLy8gdGhhdCdzIHBvc3NpYmxlIGlmIHRoZXJlIGFyZSBtYW55IHBhbmVzIG9uIHRoZSBjaGFydFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jlc2l6ZUluZm8gPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfc3RhcnRZOiBldmVudC5wYWdlWSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wcmV2U3RyZXRjaFRvcFBhbmU6IHRoaXMuX3ByaXZhdGVfX3RvcFBhbmUuX2ludGVybmFsX3N0YXRlKCkuX2ludGVybmFsX3N0cmV0Y2hGYWN0b3IoKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tYXhQYW5lU3RyZXRjaDogdG90YWxTdHJldGNoIC0gbWluUGFuZVN0cmV0Y2gsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG90YWxTdHJldGNoOiB0b3RhbFN0cmV0Y2gsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcGl4ZWxTdHJldGNoRmFjdG9yOiBwaXhlbFN0cmV0Y2hGYWN0b3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbWluUGFuZVN0cmV0Y2g6IG1pblBhbmVTdHJldGNoLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19oYW5kbGUuX2ludGVybmFsX2JhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJlc3NlZE1vdXNlTW92ZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHJlc2l6ZUluZm8gPSB0aGlzLl9wcml2YXRlX19yZXNpemVJbmZvO1xuICAgICAgICBpZiAocmVzaXplSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhWSA9IGV2ZW50LnBhZ2VZIC0gcmVzaXplSW5mby5faW50ZXJuYWxfc3RhcnRZO1xuICAgICAgICBjb25zdCBkZWx0YVN0cmV0Y2hGYWN0b3IgPSBkZWx0YVkgKiByZXNpemVJbmZvLl9pbnRlcm5hbF9waXhlbFN0cmV0Y2hGYWN0b3I7XG4gICAgICAgIGNvbnN0IHVwcGVyUGFuZU5ld1N0cmV0Y2ggPSBjbGFtcChyZXNpemVJbmZvLl9pbnRlcm5hbF9wcmV2U3RyZXRjaFRvcFBhbmUgKyBkZWx0YVN0cmV0Y2hGYWN0b3IsIHJlc2l6ZUluZm8uX2ludGVybmFsX21pblBhbmVTdHJldGNoLCByZXNpemVJbmZvLl9pbnRlcm5hbF9tYXhQYW5lU3RyZXRjaCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcFBhbmUuX2ludGVybmFsX3N0YXRlKCkuX2ludGVybmFsX3NldFN0cmV0Y2hGYWN0b3IodXBwZXJQYW5lTmV3U3RyZXRjaCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JvdHRvbVBhbmUuX2ludGVybmFsX3N0YXRlKCkuX2ludGVybmFsX3NldFN0cmV0Y2hGYWN0b3IocmVzaXplSW5mby5faW50ZXJuYWxfdG90YWxTdHJldGNoIC0gdXBwZXJQYW5lTmV3U3RyZXRjaCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9mdWxsVXBkYXRlKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZVVwRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Jlc2l6ZUluZm8gPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9faGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVzaXplSW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hhbmRsZS5faW50ZXJuYWxfYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlblBvaW50cyhwb3MxLCBwb3MyKSB7XG4gICAgcmV0dXJuIHBvczEuX2ludGVybmFsX3Bvc2l0aW9uIC0gcG9zMi5faW50ZXJuYWxfcG9zaXRpb247XG59XG5mdW5jdGlvbiBzcGVlZFB4UGVyTVNlYyhwb3MxLCBwb3MyLCBtYXhTcGVlZCkge1xuICAgIGNvbnN0IHNwZWVkID0gKHBvczEuX2ludGVybmFsX3Bvc2l0aW9uIC0gcG9zMi5faW50ZXJuYWxfcG9zaXRpb24pIC8gKHBvczEuX2ludGVybmFsX3RpbWUgLSBwb3MyLl9pbnRlcm5hbF90aW1lKTtcbiAgICByZXR1cm4gTWF0aC5zaWduKHNwZWVkKSAqIE1hdGgubWluKE1hdGguYWJzKHNwZWVkKSwgbWF4U3BlZWQpO1xufVxuZnVuY3Rpb24gZHVyYXRpb25NU2VjKHNwZWVkLCBkdW1waW5nQ29lZmYpIHtcbiAgICBjb25zdCBsbkR1bXBpbmdDb2VmZiA9IE1hdGgubG9nKGR1bXBpbmdDb2VmZik7XG4gICAgcmV0dXJuIE1hdGgubG9nKCgxIC8qIENvbnN0YW50cy5FcHNpbG9uRGlzdGFuY2UgKi8gKiBsbkR1bXBpbmdDb2VmZikgLyAtc3BlZWQpIC8gKGxuRHVtcGluZ0NvZWZmKTtcbn1cbmNsYXNzIEtpbmV0aWNBbmltYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1pblNwZWVkLCBtYXhTcGVlZCwgZHVtcGluZ0NvZWZmLCBtaW5Nb3ZlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uNCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kdXJhdGlvbk1zZWNzID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3BlZWRQeFBlck1zZWMgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19taW5TcGVlZCA9IG1pblNwZWVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXhTcGVlZCA9IG1heFNwZWVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kdW1waW5nQ29lZmYgPSBkdW1waW5nQ29lZmY7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21pbk1vdmUgPSBtaW5Nb3ZlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYWRkUG9zaXRpb24ocG9zaXRpb24sIHRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMS5faW50ZXJuYWxfdGltZSA9PT0gdGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMS5faW50ZXJuYWxfcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24xLl9pbnRlcm5hbF9wb3NpdGlvbiAtIHBvc2l0aW9uKSA8IHRoaXMuX3ByaXZhdGVfX21pbk1vdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb240ID0gdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24zO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjMgPSB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMiA9IHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24xID0geyBfaW50ZXJuYWxfdGltZTogdGltZSwgX2ludGVybmFsX3Bvc2l0aW9uOiBwb3NpdGlvbiB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc3RhcnQocG9zaXRpb24sIHRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICAgICAgaWYgKHRpbWUgLSB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEuX2ludGVybmFsX3RpbWUgPiA1MCAvKiBDb25zdGFudHMuTWF4U3RhcnREZWxheSAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBhbGwgdGhlIHJlc3QgcGFyYW1ldGVycyB3ZSBzaG91bGQgY2FsY3VsYXRlIHRoZSBzcGVlZCBhZiBmaXJzdFxuICAgICAgICBsZXQgdG90YWxEaXN0YW5jZSA9IDA7XG4gICAgICAgIGNvbnN0IHNwZWVkMSA9IHNwZWVkUHhQZXJNU2VjKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMSwgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24yLCB0aGlzLl9wcml2YXRlX19tYXhTcGVlZCk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyh0aGlzLl9wcml2YXRlX19wb3NpdGlvbjEsIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMik7XG4gICAgICAgIC8vIFdlJ3JlIGNhbGN1bGF0aW5nIHdlaWdodGVkIGF2ZXJhZ2Ugc3BlZWRcbiAgICAgICAgLy8gVGhhbiBtb3JlIGRpc3RhbmNlIGZvciBhIHNlZ21lbnQsIHRoYW4gbW9yZSBpdHMgd2VpZ2h0XG4gICAgICAgIGNvbnN0IHNwZWVkSXRlbXMgPSBbc3BlZWQxXTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VJdGVtcyA9IFtkaXN0YW5jZTFdO1xuICAgICAgICB0b3RhbERpc3RhbmNlICs9IGRpc3RhbmNlMTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc3BlZWQyID0gc3BlZWRQeFBlck1TZWModGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24yLCB0aGlzLl9wcml2YXRlX19wb3NpdGlvbjMsIHRoaXMuX3ByaXZhdGVfX21heFNwZWVkKTtcbiAgICAgICAgICAgIC8vIHN0b3AgYXQgdGhpcyBtb21lbnQgaWYgZGlyZWN0aW9uIG9mIHRoZSBzZWdtZW50IGlzIG9wcG9zaXRlXG4gICAgICAgICAgICBpZiAoTWF0aC5zaWduKHNwZWVkMikgPT09IE1hdGguc2lnbihzcGVlZDEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMiwgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb24zKTtcbiAgICAgICAgICAgICAgICBzcGVlZEl0ZW1zLnB1c2goc3BlZWQyKTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZUl0ZW1zLnB1c2goZGlzdGFuY2UyKTtcbiAgICAgICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IGRpc3RhbmNlMjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcG9zaXRpb240ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwZWVkMyA9IHNwZWVkUHhQZXJNU2VjKHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uMywgdGhpcy5fcHJpdmF0ZV9fcG9zaXRpb240LCB0aGlzLl9wcml2YXRlX19tYXhTcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLnNpZ24oc3BlZWQzKSA9PT0gTWF0aC5zaWduKHNwZWVkMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlMyA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyh0aGlzLl9wcml2YXRlX19wb3NpdGlvbjMsIHRoaXMuX3ByaXZhdGVfX3Bvc2l0aW9uNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVlZEl0ZW1zLnB1c2goc3BlZWQzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlSXRlbXMucHVzaChkaXN0YW5jZTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkaXN0YW5jZTM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdFNwZWVkID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVlZEl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRTcGVlZCArPSBkaXN0YW5jZUl0ZW1zW2ldIC8gdG90YWxEaXN0YW5jZSAqIHNwZWVkSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKHJlc3VsdFNwZWVkKSA8IHRoaXMuX3ByaXZhdGVfX21pblNwZWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYW5pbWF0aW9uU3RhcnRQb3NpdGlvbiA9IHsgX2ludGVybmFsX3Bvc2l0aW9uOiBwb3NpdGlvbiwgX2ludGVybmFsX3RpbWU6IHRpbWUgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3BlZWRQeFBlck1zZWMgPSByZXN1bHRTcGVlZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHVyYXRpb25Nc2VjcyA9IGR1cmF0aW9uTVNlYyhNYXRoLmFicyhyZXN1bHRTcGVlZCksIHRoaXMuX3ByaXZhdGVfX2R1bXBpbmdDb2VmZik7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRQb3NpdGlvbih0aW1lKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblN0YXJ0UG9zaXRpb24pO1xuICAgICAgICBjb25zdCBkdXJhdGlvbk1zZWNzID0gdGltZSAtIHN0YXJ0UG9zaXRpb24uX2ludGVybmFsX3RpbWU7XG4gICAgICAgIHJldHVybiBzdGFydFBvc2l0aW9uLl9pbnRlcm5hbF9wb3NpdGlvbiArIHRoaXMuX3ByaXZhdGVfX3NwZWVkUHhQZXJNc2VjICogKE1hdGgucG93KHRoaXMuX3ByaXZhdGVfX2R1bXBpbmdDb2VmZiwgZHVyYXRpb25Nc2VjcykgLSAxKSAvIChNYXRoLmxvZyh0aGlzLl9wcml2YXRlX19kdW1waW5nQ29lZmYpKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZpbmlzaGVkKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2FuaW1hdGlvblN0YXJ0UG9zaXRpb24gPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fcHJvZ3Jlc3NEdXJhdGlvbih0aW1lKSA9PT0gdGhpcy5fcHJpdmF0ZV9fZHVyYXRpb25Nc2VjcztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3Byb2dyZXNzRHVyYXRpb24odGltZSkge1xuICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19hbmltYXRpb25TdGFydFBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aW1lIC0gc3RhcnRQb3NpdGlvbi5faW50ZXJuYWxfdGltZTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHByb2dyZXNzLCB0aGlzLl9wcml2YXRlX19kdXJhdGlvbk1zZWNzKTtcbiAgICB9XG59XG5cbmNvbnN0IHN2ZyA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjM1XCIgaGVpZ2h0PVwiMTlcIiBmaWxsPVwibm9uZVwiPjxnIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBjbGlwLXBhdGg9XCJ1cmwoI2EpXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiPjxwYXRoIGZpbGw9XCJ2YXIoLS1zdHJva2UpXCIgZD1cIk0yIDBIMHYxMGg2djloMjEuNGwuNS0xLjMgNi0xNSAxLTIuN0gyMy43bC0uNSAxLjMtLjIuNmE1IDUgMCAwIDAtNy0uOVYwSDJabTIwIDE3aDRsNS4yLTEzIC44LTJoLTdsLTEgMi41LS4yLjUtMS41IDMuOC0uMy43VjE3Wm0tLjgtMTBhMyAzIDAgMCAwIC43LTIuN0EzIDMgMCAxIDAgMTYuOCA3aDQuNFpNMTQgN1YySDJ2Nmg2djloNFY3aDJaXCIvPjxwYXRoIGZpbGw9XCJ2YXIoLS1maWxsKVwiIGQ9XCJNMTQgMkgydjZoNnY5aDZWMlptMTIgMTVoLTdsNi0xNWg3bC02IDE1Wm0tNy05YTMgMyAwIDEgMCAwLTYgMyAzIDAgMCAwIDAgNlpcIi8+PC9nPjxkZWZzPjxjbGlwUGF0aCBpZD1cImFcIj48cGF0aCBmaWxsPVwidmFyKC0tc3Ryb2tlKVwiIGQ9XCJNMCAwaDM1djE5SDB6XCIvPjwvY2xpcFBhdGg+PC9kZWZzPjwvc3ZnPmA7XG5jb25zdCBjc3MgPSBgYSN0di1hdHRyLWxvZ297LS1maWxsOiMxMzE3MjI7LS1zdHJva2U6I2ZmZjtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjEwcHg7Ym90dG9tOjEwcHg7aGVpZ2h0OjE5cHg7d2lkdGg6MzVweDttYXJnaW46MDtwYWRkaW5nOjA7Ym9yZGVyOjA7ei1pbmRleDozO31hI3R2LWF0dHItbG9nb1tkYXRhLWRhcmtdey0tZmlsbDojRDFENERDOy0tc3Ryb2tlOiMxMzE3MjI7fWA7XG4vLyBUaGlzIHdpZGdldCBkb2Vzbid0IHN1cHBvcnQgZHluYW1pY2FsbHkgcmVzcG9uZGluZyB0byBvcHRpb25zIGNoYW5nZXNcbi8vIGJlY2F1c2UgaXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgYGF0dHJpYnV0aW9uTG9nb2Agb3B0aW9uIHdvbid0IGJlIGNoYW5nZWRcbi8vIGFuZCB0aGlzIHNhdmVzIHNvbWUgYnVuZGxlIHNpemUuXG5jbGFzcyBBdHRyaWJ1dGlvbkxvZ29XaWRnZXQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgY2hhcnQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3NzRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGhlbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydCA9IGNoYXJ0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXIoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW1vdmVFbGVtZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jc3NFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fcHJpdmF0ZV9fY3NzRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3NzRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3Nob3VsZFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3Zpc2libGUgIT09IHRoaXMuX3ByaXZhdGVfX3Nob3VsZEJlVmlzaWJsZSgpIHx8IHRoaXMuX3ByaXZhdGVfX3RoZW1lICE9PSB0aGlzLl9wcml2YXRlX190aGVtZVRvVXNlKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX190aGVtZVRvVXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2NvbG9yUGFyc2VyKCkuX2ludGVybmFsX2NvbG9yU3RyaW5nVG9HcmF5c2NhbGUodGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J10udGV4dENvbG9yKSA+IDE2MFxuICAgICAgICAgICAgPyAnZGFyaydcbiAgICAgICAgICAgIDogJ2xpZ2h0JztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3Nob3VsZEJlVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKClbJ2xheW91dCddLmF0dHJpYnV0aW9uTG9nbztcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldFVUTVNvdXJjZSgpIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKCF1cmwuaG9zdG5hbWUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBsb2NhbCB0ZXN0aW5nXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcmdXRtX3NvdXJjZT0nICsgdXJsLmhvc3RuYW1lICsgdXJsLnBhdGhuYW1lO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3Nob3VsZFVwZGF0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVtb3ZlRWxlbWVudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX192aXNpYmxlID0gdGhpcy5fcHJpdmF0ZV9fc2hvdWxkQmVWaXNpYmxlKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX192aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aGVtZSA9IHRoaXMuX3ByaXZhdGVfX3RoZW1lVG9Vc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nzc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3NzRWxlbWVudC5pbm5lclRleHQgPSBjc3M7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5ocmVmID0gYGh0dHBzOi8vd3d3LnRyYWRpbmd2aWV3LmNvbS8/dXRtX21lZGl1bT1sd2MtbGluayZ1dG1fY2FtcGFpZ249bHdjLWNoYXJ0JHt0aGlzLl9wcml2YXRlX19nZXRVVE1Tb3VyY2UoKX1gO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC50aXRsZSA9ICdDaGFydGluZyBieSBUcmFkaW5nVmlldyc7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LmlkID0gJ3R2LWF0dHItbG9nbyc7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5pbm5lckhUTUwgPSBzdmc7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LnRvZ2dsZUF0dHJpYnV0ZSgnZGF0YS1kYXJrJywgdGhpcy5fcHJpdmF0ZV9fdGhlbWUgPT09ICdkYXJrJyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fY3NzRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJvdW5kQ2FudmFzKHBhcmVudEVsZW1lbnQsIHNpemUpIHtcbiAgICBjb25zdCBkb2MgPSBlbnN1cmVOb3ROdWxsKHBhcmVudEVsZW1lbnQub3duZXJEb2N1bWVudCk7XG4gICAgY29uc3QgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICBjb25zdCBiaW5kaW5nID0gYmluZENhbnZhc0VsZW1lbnRCaXRtYXBTaXplVG8oY2FudmFzLCB7XG4gICAgICAgIHR5cGU6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBhbGxvd1Jlc2l6ZU9ic2VydmVyOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm06IChiaXRtYXBTaXplLCBjYW52YXNFbGVtZW50Q2xpZW50U2l6ZSkgPT4gKHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heChiaXRtYXBTaXplLndpZHRoLCBjYW52YXNFbGVtZW50Q2xpZW50U2l6ZS53aWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KGJpdG1hcFNpemUuaGVpZ2h0LCBjYW52YXNFbGVtZW50Q2xpZW50U2l6ZS5oZWlnaHQpLFxuICAgICAgICB9KSxcbiAgICB9KTtcbiAgICBiaW5kaW5nLnJlc2l6ZUNhbnZhc0VsZW1lbnQoc2l6ZSk7XG4gICAgcmV0dXJuIGJpbmRpbmc7XG59XG5mdW5jdGlvbiByZWxlYXNlQ2FudmFzKGNhbnZhcykge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gZml4ZXMgdGhlIGlPUyBTYWZhcmkgZXJyb3IgXCJUb3RhbCBjYW52YXMgbWVtb3J5IHVzZSBleGNlZWRzIHRoZSBtYXhpbXVtIGxpbWl0XCIuXG4gICAgLy8gU2VlbXMgdGhhdCBpT1MgU2FmYXJpIHN0b3JlcyBjYW52YXMgZWxlbWVudHMgZm9yIHNvbWUgYWRkaXRpb25hbCB0aW1lIGludGVybmFsbHkuXG4gICAgLy8gU28gaWYgd2UgY3JlYXRlL2Rlc3Ryb3kgYSBsb3Qgb2YgY2FudmFzIGVsZW1lbnRzIGluIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgd2UgY2FuIGdldCB0aGlzIGVycm9yLlxuICAgIC8vIFdlIHJlc2l6ZSB0aGUgY2FudmFzIHRvIDF4MSBwaXhlbHMgdG8gZm9yY2UgaXQgdG8gcmVsZWFzZSBtZW1tb3J5IHJlc291cmNlcy5cbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpPy5jbGVhclJlY3QoMCwgMCwgMSwgMSk7XG59XG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKHJlbmRlcmVyLCB0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICBpZiAocmVuZGVyZXIuX2ludGVybmFsX2RyYXdCYWNrZ3JvdW5kKSB7XG4gICAgICAgIHJlbmRlcmVyLl9pbnRlcm5hbF9kcmF3QmFja2dyb3VuZCh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRyYXdGb3JlZ3JvdW5kKHJlbmRlcmVyLCB0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICByZW5kZXJlci5faW50ZXJuYWxfZHJhdyh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpO1xufVxuZnVuY3Rpb24gZHJhd1NvdXJjZVZpZXdzKHBhbmVWaWV3c0dldHRlciwgZHJhd1JlbmRlcmVyRm4sIHNvdXJjZSwgcGFuZSkge1xuICAgIGNvbnN0IHZpZXdzID0gcGFuZVZpZXdzR2V0dGVyKHNvdXJjZSwgcGFuZSk7XG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHZpZXdzKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdmlldy5faW50ZXJuYWxfcmVuZGVyZXIocGFuZSk7XG4gICAgICAgIGlmIChyZW5kZXJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZHJhd1JlbmRlcmVyRm4ocmVuZGVyZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNQcmljZVNjYWxlKHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UuX2ludGVybmFsX3ByaWNlU2NhbGUgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkUHJpY2VBeGlzVmlld3NHZXR0ZXIoek9yZGVyLCBwcmljZVNjYWxlSWQpIHtcbiAgICByZXR1cm4gKHNvdXJjZSkgPT4ge1xuICAgICAgICBpZiAoIWhhc1ByaWNlU2NhbGUoc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBzSWQgPSBzb3VyY2UuX2ludGVybmFsX3ByaWNlU2NhbGUoKT8uX2ludGVybmFsX2lkKCkgPz8gJyc7XG4gICAgICAgIGlmIChwc0lkICE9PSBwcmljZVNjYWxlSWQpIHtcbiAgICAgICAgICAgIC8vIGV4Y2x1ZGUgaWYgc291cmNlIGlzIHVzaW5nIGEgZGlmZmVyZW50IHByaWNlIHNjYWxlLlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UuX2ludGVybmFsX3ByaWNlUGFuZVZpZXdzPy4oek9yZGVyKSA/PyBbXTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVjYWxjdWxhdGVPdmVybGFwcGluZyh2aWV3cywgZGlyZWN0aW9uLCBzY2FsZUhlaWdodCwgcmVuZGVyZXJPcHRpb25zKSB7XG4gICAgaWYgKCF2aWV3cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY3VycmVudEdyb3VwU3RhcnQgPSAwO1xuICAgIGNvbnN0IGluaXRMYWJlbEhlaWdodCA9IHZpZXdzWzBdLl9pbnRlcm5hbF9oZWlnaHQocmVuZGVyZXJPcHRpb25zLCB0cnVlKTtcbiAgICBsZXQgc3BhY2VCZWZvcmVDdXJyZW50R3JvdXAgPSBkaXJlY3Rpb24gPT09IDFcbiAgICAgICAgPyBzY2FsZUhlaWdodCAvIDIgLSAodmlld3NbMF0uX2ludGVybmFsX2dldEZpeGVkQ29vcmRpbmF0ZSgpIC0gaW5pdExhYmVsSGVpZ2h0IC8gMilcbiAgICAgICAgOiB2aWV3c1swXS5faW50ZXJuYWxfZ2V0Rml4ZWRDb29yZGluYXRlKCkgLSBpbml0TGFiZWxIZWlnaHQgLyAyIC0gc2NhbGVIZWlnaHQgLyAyO1xuICAgIHNwYWNlQmVmb3JlQ3VycmVudEdyb3VwID0gTWF0aC5tYXgoMCwgc3BhY2VCZWZvcmVDdXJyZW50R3JvdXApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmlldyA9IHZpZXdzW2ldO1xuICAgICAgICBjb25zdCBwcmV2ID0gdmlld3NbaSAtIDFdO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBwcmV2Ll9pbnRlcm5hbF9oZWlnaHQocmVuZGVyZXJPcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB2aWV3Ll9pbnRlcm5hbF9nZXRGaXhlZENvb3JkaW5hdGUoKTtcbiAgICAgICAgY29uc3QgcHJldkZpeGVkQ29vcmRpbmF0ZSA9IHByZXYuX2ludGVybmFsX2dldEZpeGVkQ29vcmRpbmF0ZSgpO1xuICAgICAgICBjb25zdCBvdmVybGFwID0gZGlyZWN0aW9uID09PSAxXG4gICAgICAgICAgICA/IGNvb3JkaW5hdGUgPiBwcmV2Rml4ZWRDb29yZGluYXRlIC0gaGVpZ2h0XG4gICAgICAgICAgICA6IGNvb3JkaW5hdGUgPCBwcmV2Rml4ZWRDb29yZGluYXRlICsgaGVpZ2h0O1xuICAgICAgICBpZiAob3ZlcmxhcCkge1xuICAgICAgICAgICAgY29uc3QgZml4ZWRDb29yZGluYXRlID0gcHJldkZpeGVkQ29vcmRpbmF0ZSAtIGhlaWdodCAqIGRpcmVjdGlvbjtcbiAgICAgICAgICAgIHZpZXcuX2ludGVybmFsX3NldEZpeGVkQ29vcmRpbmF0ZShmaXhlZENvb3JkaW5hdGUpO1xuICAgICAgICAgICAgY29uc3QgZWRnZVBvaW50ID0gZml4ZWRDb29yZGluYXRlIC0gZGlyZWN0aW9uICogaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGNvbnN0IG91dE9mVmlld3BvcnQgPSBkaXJlY3Rpb24gPT09IDEgPyBlZGdlUG9pbnQgPCAwIDogZWRnZVBvaW50ID4gc2NhbGVIZWlnaHQ7XG4gICAgICAgICAgICBpZiAob3V0T2ZWaWV3cG9ydCAmJiBzcGFjZUJlZm9yZUN1cnJlbnRHcm91cCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzaGlmdCB0aGUgd2hvbGUgZ3JvdXAgdXAgb3IgZG93blxuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRHcm91cFNoaWZ0ID0gZGlyZWN0aW9uID09PSAxID8gLTEgLSBlZGdlUG9pbnQgOiBlZGdlUG9pbnQgLSBzY2FsZUhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZVNoaWZ0ID0gTWF0aC5taW4oZGVzaXJlZEdyb3VwU2hpZnQsIHNwYWNlQmVmb3JlQ3VycmVudEdyb3VwKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gY3VycmVudEdyb3VwU3RhcnQ7IGsgPCB2aWV3cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3c1trXS5faW50ZXJuYWxfc2V0Rml4ZWRDb29yZGluYXRlKHZpZXdzW2tdLl9pbnRlcm5hbF9nZXRGaXhlZENvb3JkaW5hdGUoKSArIGRpcmVjdGlvbiAqIHBvc3NpYmxlU2hpZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFjZUJlZm9yZUN1cnJlbnRHcm91cCAtPSBwb3NzaWJsZVNoaWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEdyb3VwU3RhcnQgPSBpO1xuICAgICAgICAgICAgc3BhY2VCZWZvcmVDdXJyZW50R3JvdXAgPSBkaXJlY3Rpb24gPT09IDFcbiAgICAgICAgICAgICAgICA/IHByZXZGaXhlZENvb3JkaW5hdGUgLSBoZWlnaHQgLSBjb29yZGluYXRlXG4gICAgICAgICAgICAgICAgOiBjb29yZGluYXRlIC0gKHByZXZGaXhlZENvb3JkaW5hdGUgKyBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHJpY2VTY2FsZUNyb3NzaGFpckxhYmVsVmlzaWJsZShjcm9zc2hhaXIpIHtcbiAgICByZXR1cm4gY3Jvc3NoYWlyLm1vZGUgIT09IDIgLyogQ3Jvc3NoYWlyTW9kZS5IaWRkZW4gKi8gJiYgY3Jvc3NoYWlyLmhvcnpMaW5lLnZpc2libGUgJiYgY3Jvc3NoYWlyLmhvcnpMaW5lLmxhYmVsVmlzaWJsZTtcbn1cbmNsYXNzIFByaWNlQXhpc1dpZGdldCB7XG4gICAgY29uc3RydWN0b3IocGFuZSwgb3B0aW9ucywgcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIsIHNpZGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZSA9IG5ldyBUZXh0V2lkdGhDYWNoZSgyMDApO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19mb250ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJldk9wdGltYWxXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUgPSBwYW5lO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGF5b3V0T3B0aW9ucyA9IG9wdGlvbnNbJ2xheW91dCddO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnNQcm92aWRlciA9IHJlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pc0xlZnQgPSBzaWRlID09PSAnbGVmdCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NvdXJjZVBhbmVWaWV3cyA9IGJ1aWxkUHJpY2VBeGlzVmlld3NHZXR0ZXIoJ25vcm1hbCcsIHNpZGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3VyY2VUb3BQYW5lVmlld3MgPSBidWlsZFByaWNlQXhpc1ZpZXdzR2V0dGVyKCd0b3AnLCBzaWRlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc291cmNlQm90dG9tUGFuZVZpZXdzID0gYnVpbGRQcmljZUF4aXNWaWV3c0dldHRlcignYm90dG9tJywgc2lkZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS53aWR0aCA9ICcyNXB4JztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZyA9IGNyZWF0ZUJvdW5kQ2FudmFzKHRoaXMuX3ByaXZhdGVfX2NlbGwsIHNpemUkMSh7IHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiB9KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50O1xuICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEnO1xuICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZyA9IGNyZWF0ZUJvdW5kQ2FudmFzKHRoaXMuX3ByaXZhdGVfX2NlbGwsIHNpemUkMSh7IHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiB9KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgY29uc3QgdG9wQ2FudmFzID0gdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50O1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUuekluZGV4ID0gJzInO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgdG9wQ2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tb3VzZURvd25FdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3duRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3VjaFN0YXJ0RXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlRG93bkV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfcHJlc3NlZE1vdXNlTW92ZUV2ZW50OiB0aGlzLl9wcml2YXRlX19wcmVzc2VkTW91c2VNb3ZlRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3VjaE1vdmVFdmVudDogdGhpcy5fcHJpdmF0ZV9fcHJlc3NlZE1vdXNlTW92ZUV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfbW91c2VEb3duT3V0c2lkZUV2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZURvd25PdXRzaWRlRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9tb3VzZVVwRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlVXBFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvdWNoRW5kRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlVXBFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX21vdXNlRG91YmxlQ2xpY2tFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3VibGVDbGlja0V2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfZG91YmxlVGFwRXZlbnQ6IHRoaXMuX3ByaXZhdGVfX21vdXNlRG91YmxlQ2xpY2tFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX2ludGVybmFsX21vdXNlRW50ZXJFdmVudDogdGhpcy5fcHJpdmF0ZV9fbW91c2VFbnRlckV2ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfbW91c2VMZWF2ZUV2ZW50OiB0aGlzLl9wcml2YXRlX19tb3VzZUxlYXZlRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIgPSBuZXcgTW91c2VFdmVudEhhbmRsZXIodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50LCBoYW5kbGVyLCB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdHJlYXRWZXJ0VG91Y2hEcmFnQXNQYWdlU2Nyb2xsOiAoKSA9PiAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc1snaGFuZGxlU2Nyb2xsJ10udmVydFRvdWNoRHJhZyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90cmVhdEhvcnpUb3VjaERyYWdBc1BhZ2VTY3JvbGw6ICgpID0+IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VFdmVudEhhbmRsZXIuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy51bnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIHJlbGVhc2VDYW52YXModGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcudW5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICByZWxlYXNlQ2FudmFzKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfb25NYXJrc0NoYW5nZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2VsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX2ZvbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGF5b3V0T3B0aW9ucy5mb250U2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucygpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IGlzRm9udENoYW5nZWQgPSB0aGlzLl9wcml2YXRlX19mb250ICE9PSBvcHRpb25zLl9pbnRlcm5hbF9mb250O1xuICAgICAgICBpZiAoaXNGb250Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZS5faW50ZXJuYWxfcmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnQgPSBvcHRpb25zLl9pbnRlcm5hbF9mb250O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW1hbFdpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpY2tNYXJrTWF4V2lkdGggPSAwO1xuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB0aGlzLl9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgY3R4ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICAgICAgICBjb2xvclNwYWNlOiB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9vcHRpb25zKCkubGF5b3V0LmNvbG9yU3BhY2UsXG4gICAgICAgIH0pKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY29uc3QgdGlja01hcmtzID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfbWFya3MoKTtcbiAgICAgICAgY3R4LmZvbnQgPSB0aGlzLl9wcml2YXRlX19iYXNlRm9udCgpO1xuICAgICAgICBpZiAodGlja01hcmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRpY2tNYXJrTWF4V2lkdGggPSBNYXRoLm1heCh0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLl9pbnRlcm5hbF9tZWFzdXJlVGV4dChjdHgsIHRpY2tNYXJrc1swXS5faW50ZXJuYWxfbGFiZWwpLCB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLl9pbnRlcm5hbF9tZWFzdXJlVGV4dChjdHgsIHRpY2tNYXJrc1t0aWNrTWFya3MubGVuZ3RoIC0gMV0uX2ludGVybmFsX2xhYmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld3MgPSB0aGlzLl9wcml2YXRlX19iYWNrTGFiZWxzKCk7XG4gICAgICAgIGZvciAobGV0IGogPSB2aWV3cy5sZW5ndGg7IGotLTspIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZS5faW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCB2aWV3c1tqXS5faW50ZXJuYWxfdGV4dCgpKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA+IHRpY2tNYXJrTWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aWNrTWFya01heFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHByaWNlU2NhbGVDcm9zc2hhaXJMYWJlbFZpc2libGUodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5jcm9zc2hhaXIpKSB7XG4gICAgICAgICAgICBjb25zdCB0b3BWYWx1ZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX2Nvb3JkaW5hdGVUb1ByaWNlKDEsIGZpcnN0VmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tVmFsdWUgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9jb29yZGluYXRlVG9QcmljZSh0aGlzLl9wcml2YXRlX19zaXplLmhlaWdodCAtIDIsIGZpcnN0VmFsdWUpO1xuICAgICAgICAgICAgdGlja01hcmtNYXhXaWR0aCA9IE1hdGgubWF4KHRpY2tNYXJrTWF4V2lkdGgsIHRoaXMuX3ByaXZhdGVfX3dpZHRoQ2FjaGUuX2ludGVybmFsX21lYXN1cmVUZXh0KGN0eCwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZm9ybWF0UHJpY2UoTWF0aC5mbG9vcihNYXRoLm1pbih0b3BWYWx1ZSwgYm90dG9tVmFsdWUpKSArIDAuMTExMTExMTExMTExMTEsIGZpcnN0VmFsdWUpKSwgdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZS5faW50ZXJuYWxfbWVhc3VyZVRleHQoY3R4LCB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9mb3JtYXRQcmljZShNYXRoLmNlaWwoTWF0aC5tYXgodG9wVmFsdWUsIGJvdHRvbVZhbHVlKSkgLSAwLjExMTExMTExMTExMTExLCBmaXJzdFZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdFRpY2tNYXJrc01heFdpZHRoID0gdGlja01hcmtNYXhXaWR0aCB8fCAzNCAvKiBDb25zdGFudHMuRGVmYXVsdE9wdGltYWxXaWR0aCAqLztcbiAgICAgICAgY29uc3QgcmVzID0gTWF0aC5jZWlsKHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfYm9yZGVyU2l6ZSArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGggK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nSW5uZXIgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nT3V0ZXIgK1xuICAgICAgICAgICAgNSAvKiBDb25zdGFudHMuTGFiZWxPZmZzZXQgKi8gK1xuICAgICAgICAgICAgcmVzdWx0VGlja01hcmtzTWF4V2lkdGgpO1xuICAgICAgICAvLyBtYWtlIGl0IGV2ZW4sIHJlbW92ZSB0aGlzIGFmdGVyIG1pZ3JhdGlvbiB0byBwZXJmZWN0IGZhbmN5IGNhbnZhc1xuICAgICAgICByZXR1cm4gc3VnZ2VzdFByaWNlU2NhbGVXaWR0aChyZXMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U2l6ZShuZXdTaXplKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsIHx8ICFlcXVhbFNpemVzKHRoaXMuX3ByaXZhdGVfX3NpemUsIG5ld1NpemUpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplID0gbmV3U2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5yZXNpemVDYW52YXNFbGVtZW50KG5ld1NpemUpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5yZXNpemVDYW52YXNFbGVtZW50KG5ld1NpemUpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS53aWR0aCA9IGAke25ld1NpemUud2lkdGh9cHhgO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5oZWlnaHQgPSBgJHtuZXdTaXplLmhlaWdodH1weGA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2dldFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19zaXplKS53aWR0aDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFByaWNlU2NhbGUocHJpY2VTY2FsZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gcHJpY2VTY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9vbk1hcmtzQ2hhbmdlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID0gcHJpY2VTY2FsZTtcbiAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfb25NYXJrc0NoYW5nZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX29uTWFya3NDaGFuZ2VkLmJpbmQodGhpcyksIHRoaXMpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcHJpY2VTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZXNldCgpIHtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3N0YXRlKCk7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgbW9kZWwuX2ludGVybmFsX3Jlc2V0UHJpY2VTY2FsZShwYW5lLCBlbnN1cmVOb3ROdWxsKHRoaXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFpbnQodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhc09wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb2xvclNwYWNlOiB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9vcHRpb25zKCkubGF5b3V0LmNvbG9yU3BhY2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlICE9PSAxIC8qIEludmFsaWRhdGlvbkxldmVsLkN1cnNvciAqLykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYWxpZ25MYWJlbHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplKCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0cnlDcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLCBjYW52YXNPcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3QmFja2dyb3VuZChzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdCb3JkZXIoc2NvcGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2RyYXdBZGRpdGlvbmFsU291cmNlcyh0YXJnZXQsIHRoaXMuX3ByaXZhdGVfX3NvdXJjZUJvdHRvbVBhbmVWaWV3cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1RpY2tNYXJrcyh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2RyYXdBZGRpdGlvbmFsU291cmNlcyh0YXJnZXQsIHRoaXMuX3ByaXZhdGVfX3NvdXJjZVBhbmVWaWV3cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JhY2tMYWJlbHModGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmFwcGx5U3VnZ2VzdGVkQml0bWFwU2l6ZSgpO1xuICAgICAgICBjb25zdCB0b3BUYXJnZXQgPSB0cnlDcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCh0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLCBjYW52YXNPcHRpb25zKTtcbiAgICAgICAgaWYgKHRvcFRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9wVGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgYml0bWFwU2l6ZS53aWR0aCwgYml0bWFwU2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3Q3Jvc3NoYWlyTGFiZWwodG9wVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2RyYXdBZGRpdGlvbmFsU291cmNlcyh0b3BUYXJnZXQsIHRoaXMuX3ByaXZhdGVfX3NvdXJjZVRvcFBhbmVWaWV3cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2dldEJpdG1hcFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmJpdG1hcFNpemU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgeCwgeSkge1xuICAgICAgICBjb25zdCBiaXRtYXBTaXplID0gdGhpcy5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpO1xuICAgICAgICBpZiAoYml0bWFwU2l6ZS53aWR0aCA+IDAgJiYgYml0bWFwU2l6ZS5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgLy8gdGhpcyBjYWxsIGhhcyBzaWRlLWVmZmVjdCAtIGl0IHJlZ2VuZXJhdGVzIG1hcmtzIG9uIHRoZSBwcmljZSBzY2FsZVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlPy5faW50ZXJuYWxfbWFya3MoKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlRG93bkV2ZW50KGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpIHx8ICF0aGlzLl9wcml2YXRlX19vcHRpb25zWydoYW5kbGVTY2FsZSddLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnByaWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2Vkb3duID0gdHJ1ZTtcbiAgICAgICAgbW9kZWwuX2ludGVybmFsX3N0YXJ0U2NhbGVQcmljZShwYW5lLCB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLCBlLmxvY2FsWSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19wcmVzc2VkTW91c2VNb3ZlRXZlbnQoZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSA9PT0gbnVsbCB8fCAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc1snaGFuZGxlU2NhbGUnXS5heGlzUHJlc3NlZE1vdXNlTW92ZS5wcmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3N0YXRlKCk7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlO1xuICAgICAgICBtb2RlbC5faW50ZXJuYWxfc2NhbGVQcmljZVRvKHBhbmUsIHByaWNlU2NhbGUsIGUubG9jYWxZKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlRG93bk91dHNpZGVFdmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwgfHwgIXRoaXMuX3ByaXZhdGVfX29wdGlvbnNbJ2hhbmRsZVNjYWxlJ10uYXhpc1ByZXNzZWRNb3VzZU1vdmUucHJpY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9zdGF0ZSgpO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX21vdXNlZG93bikge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgICAgICBtb2RlbC5faW50ZXJuYWxfZW5kU2NhbGVQcmljZShwYW5lLCBwcmljZVNjYWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VVcEV2ZW50KGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwgfHwgIXRoaXMuX3ByaXZhdGVfX29wdGlvbnNbJ2hhbmRsZVNjYWxlJ10uYXhpc1ByZXNzZWRNb3VzZU1vdmUucHJpY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9zdGF0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgbW9kZWwuX2ludGVybmFsX2VuZFNjYWxlUHJpY2UocGFuZSwgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19tb3VzZURvdWJsZUNsaWNrRXZlbnQoZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9uc1snaGFuZGxlU2NhbGUnXS5heGlzRG91YmxlQ2xpY2tSZXNldC5wcmljZSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VFbnRlckV2ZW50KGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGlmIChtb2RlbC5faW50ZXJuYWxfb3B0aW9ucygpWydoYW5kbGVTY2FsZSddLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnByaWNlICYmICF0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9pc1BlcmNlbnRhZ2UoKSAmJiAhdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNJbmRleGVkVG8xMDAoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0Q3Vyc29yKDEgLyogQ3Vyc29yVHlwZS5Oc1Jlc2l6ZSAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21vdXNlTGVhdmVFdmVudChlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldEN1cnNvcigwIC8qIEN1cnNvclR5cGUuRGVmYXVsdCAqLyk7XG4gICAgfVxuICAgIF9wcml2YXRlX19iYWNrTGFiZWxzKCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9ICh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsKSA/IHVuZGVmaW5lZCA6IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGU7XG4gICAgICAgIGNvbnN0IGFkZFZpZXdzRm9yU291cmNlcyA9IChzb3VyY2VzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdzID0gc291cmNlLl9pbnRlcm5hbF9wcmljZUF4aXNWaWV3cyh0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9zdGF0ZSgpLCBwcmljZVNjYWxlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZpZXdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHZpZXdzW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBtYXggYW5kIG1pbiBjb29yZGluYXRlcyBmb3Igdmlld3Mgb24gc2VsZWN0aW9uXG4gICAgICAgIC8vIGNyb3NzaGFpciBpbmRpdmlkdWFsbHlcbiAgICAgICAgYWRkVmlld3NGb3JTb3VyY2VzKHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3N0YXRlKCkuX2ludGVybmFsX29yZGVyZWRTb3VyY2VzKCkpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JhY2tncm91bmQoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUgfSkge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGJpdG1hcFNpemU7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfc3RhdGUoKS5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgY29uc3QgdG9wQ29sb3IgPSBtb2RlbC5faW50ZXJuYWxfYmFja2dyb3VuZFRvcENvbG9yKCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbUNvbG9yID0gbW9kZWwuX2ludGVybmFsX2JhY2tncm91bmRCb3R0b21Db2xvcigpO1xuICAgICAgICBpZiAodG9wQ29sb3IgPT09IGJvdHRvbUNvbG9yKSB7XG4gICAgICAgICAgICBjbGVhclJlY3QoY3R4LCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCB0b3BDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGVhclJlY3RXaXRoR3JhZGllbnQoY3R4LCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCB0b3BDb2xvciwgYm90dG9tQ29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3Qm9yZGVyKHsgY29udGV4dDogY3R4LCBiaXRtYXBTaXplLCBob3Jpem9udGFsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwgfHwgIXRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKS5ib3JkZXJWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKS5ib3JkZXJDb2xvcjtcbiAgICAgICAgY29uc3QgYm9yZGVyU2l6ZSA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodGhpcy5faW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zKCkuX2ludGVybmFsX2JvcmRlclNpemUgKiBob3Jpem9udGFsUGl4ZWxSYXRpbykpO1xuICAgICAgICBsZXQgbGVmdDtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzTGVmdCkge1xuICAgICAgICAgICAgbGVmdCA9IGJpdG1hcFNpemUud2lkdGggLSBib3JkZXJTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIDAsIGJvcmRlclNpemUsIGJpdG1hcFNpemUuaGVpZ2h0KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdUaWNrTWFya3ModGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsIHx8IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aWNrTWFya3MgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9tYXJrcygpO1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlT3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJPcHRpb25zID0gdGhpcy5faW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IHRpY2tNYXJrTGVmdFggPSB0aGlzLl9wcml2YXRlX19pc0xlZnQgP1xuICAgICAgICAgICAgKHRoaXMuX3ByaXZhdGVfX3NpemUud2lkdGggLSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3RpY2tMZW5ndGgpIDpcbiAgICAgICAgICAgIDA7XG4gICAgICAgIGlmIChwcmljZVNjYWxlT3B0aW9ucy5ib3JkZXJWaXNpYmxlICYmIHByaWNlU2NhbGVPcHRpb25zLnRpY2tzVmlzaWJsZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBwcmljZVNjYWxlT3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrSGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih2ZXJ0aWNhbFBpeGVsUmF0aW8pKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrT2Zmc2V0ID0gTWF0aC5mbG9vcih2ZXJ0aWNhbFBpeGVsUmF0aW8gKiAwLjUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tMZW5ndGggPSBNYXRoLnJvdW5kKHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfdGlja0xlbmd0aCAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0aWNrTWFyayBvZiB0aWNrTWFya3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoTWF0aC5mbG9vcih0aWNrTWFya0xlZnRYICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pLCBNYXRoLnJvdW5kKHRpY2tNYXJrLl9pbnRlcm5hbF9jb29yZCAqIHZlcnRpY2FsUGl4ZWxSYXRpbykgLSB0aWNrT2Zmc2V0LCB0aWNrTGVuZ3RoLCB0aWNrSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC51c2VNZWRpYUNvb3JkaW5hdGVTcGFjZSgoeyBjb250ZXh0OiBjdHggfSkgPT4ge1xuICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLl9wcml2YXRlX19iYXNlRm9udCgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHByaWNlU2NhbGVPcHRpb25zLnRleHRDb2xvciA/PyB0aGlzLl9wcml2YXRlX19sYXlvdXRPcHRpb25zLnRleHRDb2xvcjtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLl9wcml2YXRlX19pc0xlZnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgY29uc3QgdGV4dExlZnRYID0gdGhpcy5fcHJpdmF0ZV9faXNMZWZ0ID9cbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRpY2tNYXJrTGVmdFggLSByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdJbm5lcikgOlxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGlja01hcmtMZWZ0WCArIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfdGlja0xlbmd0aCArIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0lubmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHlNaWRDb3JyZWN0aW9ucyA9IHRpY2tNYXJrcy5tYXAoKG1hcmspID0+IHRoaXMuX3ByaXZhdGVfX3dpZHRoQ2FjaGUuX2ludGVybmFsX3lNaWRDb3JyZWN0aW9uKGN0eCwgbWFyay5faW50ZXJuYWxfbGFiZWwpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aWNrTWFya3MubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja01hcmsgPSB0aWNrTWFya3NbaV07XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRpY2tNYXJrLl9pbnRlcm5hbF9sYWJlbCwgdGV4dExlZnRYLCB0aWNrTWFyay5faW50ZXJuYWxfY29vcmQgKyB5TWlkQ29ycmVjdGlvbnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2FsaWduTGFiZWxzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2l6ZSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNlbnRlciA9IHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0IC8gMjtcbiAgICAgICAgY29uc3Qgdmlld3MgPSBbXTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZFNvdXJjZXMgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlLl9pbnRlcm5hbF9vcmRlcmVkU291cmNlcygpLnNsaWNlKCk7IC8vIENvcHkgb2YgYXJyYXlcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmU7XG4gICAgICAgIGNvbnN0IHBhbmVTdGF0ZSA9IHBhbmUuX2ludGVybmFsX3N0YXRlKCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX2ludGVybmFsX3JlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgZGVmYXVsdCBwcmljZSBzY2FsZSwgYXBwZW5kIGxhYmVscyBmcm9tIG5vLXNjYWxlXG4gICAgICAgIGNvbnN0IGlzRGVmYXVsdCA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPT09IHBhbmVTdGF0ZS5faW50ZXJuYWxfZGVmYXVsdFZpc2libGVQcmljZVNjYWxlKCk7XG4gICAgICAgIGlmIChpc0RlZmF1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3N0YXRlKCkuX2ludGVybmFsX29yZGVyZWRTb3VyY2VzKCkuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmVTdGF0ZS5faW50ZXJuYWxfaXNPdmVybGF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZFNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGNhbiB1c2UgYW55LCBidXQgbGV0J3MgdXNlIHRoZSBmaXJzdCBzb3VyY2UgYXMgXCJjZW50ZXJcIiBvbmVcbiAgICAgICAgY29uc3QgY2VudGVyU291cmNlID0gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZS5faW50ZXJuYWxfZGF0YVNvdXJjZXMoKVswXTtcbiAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZvclNvdXJjZXMgPSAoc291cmNlcykgPT4ge1xuICAgICAgICAgICAgc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VWaWV3cyA9IHNvdXJjZS5faW50ZXJuYWxfcHJpY2VBeGlzVmlld3MocGFuZVN0YXRlLCBwcmljZVNjYWxlKTtcbiAgICAgICAgICAgICAgICAvLyBuZXZlciBhbGlnbiBzZWxlY3RlZCBzb3VyY2VzXG4gICAgICAgICAgICAgICAgc291cmNlVmlld3MuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2aWV3Ll9pbnRlcm5hbF9zZXRGaXhlZENvb3JkaW5hdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3Ll9pbnRlcm5hbF9pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjZW50ZXJTb3VyY2UgPT09IHNvdXJjZSAmJiBzb3VyY2VWaWV3cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlciA9IHNvdXJjZVZpZXdzWzBdLl9pbnRlcm5hbF9jb29yZGluYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNyb3NzaGFpciBpbmRpdmlkdWFsbHlcbiAgICAgICAgdXBkYXRlRm9yU291cmNlcyhvcmRlcmVkU291cmNlcyk7XG4gICAgICAgIHZpZXdzLmZvckVhY2goKHZpZXcpID0+IHZpZXcuX2ludGVybmFsX3NldEZpeGVkQ29vcmRpbmF0ZSh2aWV3Ll9pbnRlcm5hbF9jb29yZGluYXRlKCkpKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmFsaWduTGFiZWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZml4TGFiZWxPdmVybGFwKHZpZXdzLCByZW5kZXJlck9wdGlvbnMsIGNlbnRlcik7XG4gICAgfVxuICAgIF9wcml2YXRlX19maXhMYWJlbE92ZXJsYXAodmlld3MsIHJlbmRlcmVyT3B0aW9ucywgY2VudGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BsaXQgaW50byB0d28gcGFydHNcbiAgICAgICAgY29uc3QgdG9wID0gdmlld3MuZmlsdGVyKCh2aWV3KSA9PiB2aWV3Ll9pbnRlcm5hbF9jb29yZGluYXRlKCkgPD0gY2VudGVyKTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gdmlld3MuZmlsdGVyKCh2aWV3KSA9PiB2aWV3Ll9pbnRlcm5hbF9jb29yZGluYXRlKCkgPiBjZW50ZXIpO1xuICAgICAgICAvLyBzb3J0IHRvcCBmcm9tIGNlbnRlciB0byB0b3BcbiAgICAgICAgdG9wLnNvcnQoKGwsIHIpID0+IHIuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSAtIGwuX2ludGVybmFsX2Nvb3JkaW5hdGUoKSk7XG4gICAgICAgIC8vIHNoYXJlIGNlbnRlciBsYWJlbFxuICAgICAgICBpZiAodG9wLmxlbmd0aCAmJiBib3R0b20ubGVuZ3RoKSB7XG4gICAgICAgICAgICBib3R0b20ucHVzaCh0b3BbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGJvdHRvbS5zb3J0KChsLCByKSA9PiBsLl9pbnRlcm5hbF9jb29yZGluYXRlKCkgLSByLl9pbnRlcm5hbF9jb29yZGluYXRlKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygdmlld3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbGZIZWlnaHQgPSBNYXRoLmZsb29yKHZpZXcuX2ludGVybmFsX2hlaWdodChyZW5kZXJlck9wdGlvbnMpIC8gMik7XG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlID0gdmlldy5faW50ZXJuYWxfY29vcmRpbmF0ZSgpO1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGUgPiAtaGFsZkhlaWdodCAmJiBjb29yZGluYXRlIDwgaGFsZkhlaWdodCkge1xuICAgICAgICAgICAgICAgIHZpZXcuX2ludGVybmFsX3NldEZpeGVkQ29vcmRpbmF0ZShoYWxmSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlID4gKHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0IC0gaGFsZkhlaWdodCkgJiYgY29vcmRpbmF0ZSA8IHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0ICsgaGFsZkhlaWdodCkge1xuICAgICAgICAgICAgICAgIHZpZXcuX2ludGVybmFsX3NldEZpeGVkQ29vcmRpbmF0ZSh0aGlzLl9wcml2YXRlX19zaXplLmhlaWdodCAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlY2FsY3VsYXRlT3ZlcmxhcHBpbmcodG9wLCAxLCB0aGlzLl9wcml2YXRlX19zaXplLmhlaWdodCwgcmVuZGVyZXJPcHRpb25zKTtcbiAgICAgICAgcmVjYWxjdWxhdGVPdmVybGFwcGluZyhib3R0b20sIC0xLCB0aGlzLl9wcml2YXRlX19zaXplLmhlaWdodCwgcmVuZGVyZXJPcHRpb25zKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdCYWNrTGFiZWxzKHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdzID0gdGhpcy5fcHJpdmF0ZV9fYmFja0xhYmVscygpO1xuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB0aGlzLl9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgYWxpZ24gPSB0aGlzLl9wcml2YXRlX19pc0xlZnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICB2aWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5faW50ZXJuYWxfaXNBeGlzTGFiZWxWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHZpZXcuX2ludGVybmFsX3JlbmRlcmVyKGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSkpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLl9pbnRlcm5hbF9kcmF3KHRhcmdldCwgcmVuZGVyZXJPcHRpb25zLCB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLCBhbGlnbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0Nyb3NzaGFpckxhYmVsKHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2l6ZSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9jaGFydCgpLl9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBjb25zdCB2aWV3cyA9IFtdOyAvLyBhcnJheSBvZiBhcnJheXNcbiAgICAgICAgY29uc3QgcGFuZSA9IHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX3N0YXRlKCk7XG4gICAgICAgIGNvbnN0IHYgPSBtb2RlbC5faW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlKCkuX2ludGVybmFsX3ByaWNlQXhpc1ZpZXdzKHBhbmUsIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUpO1xuICAgICAgICBpZiAodi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZpZXdzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm8gPSB0aGlzLl9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgYWxpZ24gPSB0aGlzLl9wcml2YXRlX19pc0xlZnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICB2aWV3cy5mb3JFYWNoKChhcnIpID0+IHtcbiAgICAgICAgICAgIGFyci5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgdmlldy5faW50ZXJuYWxfcmVuZGVyZXIoZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlKSkuX2ludGVybmFsX2RyYXcodGFyZ2V0LCBybywgdGhpcy5fcHJpdmF0ZV9fd2lkdGhDYWNoZSwgYWxpZ24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2V0Q3Vyc29yKHR5cGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5jdXJzb3IgPSB0eXBlID09PSAxIC8qIEN1cnNvclR5cGUuTnNSZXNpemUgKi8gPyAnbnMtcmVzaXplJyA6ICdkZWZhdWx0JztcbiAgICB9XG4gICAgX3ByaXZhdGVfX29uTWFya3NDaGFuZ2VkKCkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX2ludGVybmFsX29wdGltYWxXaWR0aCgpO1xuICAgICAgICAvLyBhdm9pZCBwcmljZSBzY2FsZSBpcyBzaHJ1bmtcbiAgICAgICAgLy8gdXNpbmcgPCBpbnN0ZWFkICE9PSB0byBhdm9pZCBpbmZpbml0ZSBjaGFuZ2VzXG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wcmV2T3B0aW1hbFdpZHRoIDwgd2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2NoYXJ0KCkuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2T3B0aW1hbFdpZHRoID0gd2lkdGg7XG4gICAgfVxuICAgIF9wcml2YXRlX19iYXNlRm9udCgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VGb250KHRoaXMuX3ByaXZhdGVfX2xheW91dE9wdGlvbnMuZm9udFNpemUsIHRoaXMuX3ByaXZhdGVfX2xheW91dE9wdGlvbnMuZm9udEZhbWlseSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzb3VyY2VCb3R0b21QYW5lVmlld3MkMShzb3VyY2UsIHBhbmUpIHtcbiAgICByZXR1cm4gc291cmNlLl9pbnRlcm5hbF9ib3R0b21QYW5lVmlld3M/LihwYW5lKSA/PyBbXTtcbn1cbmZ1bmN0aW9uIHNvdXJjZVBhbmVWaWV3cyQxKHNvdXJjZSwgcGFuZSkge1xuICAgIHJldHVybiBzb3VyY2UuX2ludGVybmFsX3BhbmVWaWV3cz8uKHBhbmUpID8/IFtdO1xufVxuZnVuY3Rpb24gc291cmNlTGFiZWxQYW5lVmlld3Moc291cmNlLCBwYW5lKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5faW50ZXJuYWxfbGFiZWxQYW5lVmlld3M/LihwYW5lKSA/PyBbXTtcbn1cbmZ1bmN0aW9uIHNvdXJjZVRvcFBhbmVWaWV3cyQxKHNvdXJjZSwgcGFuZSkge1xuICAgIHJldHVybiBzb3VyY2UuX2ludGVybmFsX3RvcFBhbmVWaWV3cz8uKHBhbmUpID8/IFtdO1xufVxuY2xhc3MgUGFuZVdpZGdldCB7XG4gICAgY29uc3RydWN0b3IoY2hhcnQsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemUgPSBzaXplJDEoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hdHRyaWJ1dGlvbkxvZ29XaWRnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1BvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2UGluY2hTY2FsZSA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvbmdUYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZXhpdFRyYWNraW5nTW9kZU9uTmV4dFRyeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbml0Q3Jvc3NoYWlyUG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSB8fCB0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplIHx8IHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfbGlnaHRVcGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQgPSBjaGFydDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX29uRGVzdHJveWVkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblN0YXRlRGVzdHJveWVkLmJpbmQodGhpcyksIHRoaXMsIHRydWUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lQ2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVDZWxsLnN0eWxlLnBhZGRpbmcgPSAnMCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVDZWxsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgY29uc3QgcGFuZVdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcGFuZVdyYXBwZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHBhbmVXcmFwcGVyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgcGFuZVdyYXBwZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICBwYW5lV3JhcHBlci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0QXhpc0NlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0QXhpc0NlbGwuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRBeGlzQ2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0QXhpc0NlbGwuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZUNlbGwuYXBwZW5kQ2hpbGQocGFuZVdyYXBwZXIpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nID0gY3JlYXRlQm91bmRDYW52YXMocGFuZVdyYXBwZXIsIHNpemUkMSh7IHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiB9KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50O1xuICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEnO1xuICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZyA9IGNyZWF0ZUJvdW5kQ2FudmFzKHBhbmVXcmFwcGVyLCBzaXplJDEoeyB3aWR0aDogMTYsIGhlaWdodDogMTYgfSkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIGNvbnN0IHRvcENhbnZhcyA9IHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudDtcbiAgICAgICAgdG9wQ2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdG9wQ2FudmFzLnN0eWxlLnpJbmRleCA9ICcyJztcbiAgICAgICAgdG9wQ2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIHRvcENhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jvd0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yb3dFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX2xlZnRBeGlzQ2VsbCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Jvd0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fcGFuZUNlbGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yb3dFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX3JpZ2h0QXhpc0NlbGwpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVQcmljZUF4aXNXaWRnZXRzU3RhdGVzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyID0gbmV3IE1vdXNlRXZlbnRIYW5kbGVyKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCwgdGhpcywge1xuICAgICAgICAgICAgX2ludGVybmFsX3RyZWF0VmVydFRvdWNoRHJhZ0FzUGFnZVNjcm9sbDogKCkgPT4gdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID09PSBudWxsICYmICF0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpWydoYW5kbGVTY3JvbGwnXS52ZXJ0VG91Y2hEcmFnLFxuICAgICAgICAgICAgX2ludGVybmFsX3RyZWF0SG9yelRvdWNoRHJhZ0FzUGFnZVNjcm9sbDogKCkgPT4gdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50ID09PSBudWxsICYmICF0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpWydoYW5kbGVTY3JvbGwnXS5ob3J6VG91Y2hEcmFnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2F0dHJpYnV0aW9uTG9nb1dpZGdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcudW5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX190b3BDYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICByZWxlYXNlQ2FudmFzKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLnVuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgcmVsZWFzZUNhbnZhcyh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfb25EZXN0cm95ZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRXZlbnRIYW5kbGVyLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fc3RhdGUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U3RhdGUocGFuZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9vbkRlc3Ryb3llZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZSA9IHBhbmU7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX29uRGVzdHJveWVkKCkuX2ludGVybmFsX3N1YnNjcmliZShQYW5lV2lkZ2V0LnByb3RvdHlwZS5fcHJpdmF0ZV9fb25TdGF0ZURlc3Ryb3llZC5iaW5kKHRoaXMpLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGVQcmljZUF4aXNXaWRnZXRzU3RhdGVzKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfcGFuZVdpZGdldHMoKS5pbmRleE9mKHRoaXMpID09PSB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfcGFuZVdpZGdldHMoKS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hdHRyaWJ1dGlvbkxvZ29XaWRnZXQgPSB0aGlzLl9wcml2YXRlX19hdHRyaWJ1dGlvbkxvZ29XaWRnZXQgPz8gbmV3IEF0dHJpYnV0aW9uTG9nb1dpZGdldCh0aGlzLl9wcml2YXRlX19wYW5lQ2VsbCwgdGhpcy5fcHJpdmF0ZV9fY2hhcnQpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXR0cmlidXRpb25Mb2dvV2lkZ2V0Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2F0dHJpYnV0aW9uTG9nb1dpZGdldD8uX2ludGVybmFsX3JlbW92ZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2F0dHJpYnV0aW9uTG9nb1dpZGdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2NoYXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcm93RWxlbWVudDtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZVByaWNlQXhpc1dpZGdldHNTdGF0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlY3JlYXRlUHJpY2VBeGlzV2lkZ2V0cygpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfc2VyaWVzZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbGVmdFByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfbGVmdFByaWNlU2NhbGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX3NldFByaWNlU2NhbGUoZW5zdXJlTm90TnVsbChsZWZ0UHJpY2VTY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmlnaHRQcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX3JpZ2h0UHJpY2VTY2FsZSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX3NldFByaWNlU2NhbGUoZW5zdXJlTm90TnVsbChyaWdodFByaWNlU2NhbGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlUHJpY2VBeGlzV2lkZ2V0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zdHJldGNoRmFjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc3RhdGUgIT09IG51bGwgPyB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfc3RyZXRjaEZhY3RvcigpIDogMDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFN0cmV0Y2hGYWN0b3Ioc3RyZXRjaEZhY3Rvcikge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9zZXRTdHJldGNoRmFjdG9yKHN0cmV0Y2hGYWN0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZUVudGVyRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19zdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW91c2VFdmVudCgpO1xuICAgICAgICBjb25zdCB4ID0gZXZlbnQubG9jYWxYO1xuICAgICAgICBjb25zdCB5ID0gZXZlbnQubG9jYWxZO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbih4LCB5LCBldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZURvd25FdmVudChldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbk1vdXNlRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VUb3VjaERvd25FdmVudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbihldmVudC5sb2NhbFgsIGV2ZW50LmxvY2FsWSwgZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19zdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW91c2VFdmVudCgpO1xuICAgICAgICBjb25zdCB4ID0gZXZlbnQubG9jYWxYO1xuICAgICAgICBjb25zdCB5ID0gZXZlbnQubG9jYWxZO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbih4LCB5LCBldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZUNsaWNrRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25Nb3VzZUV2ZW50KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpcmVDbGlja2VkRGVsZWdhdGUoZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZpcmVNb3VzZUNsaWNrRGVsZWdhdGUodGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZCwgZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZG91YmxlVGFwRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByZXNzZWRNb3VzZU1vdmVFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbk1vdXNlRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJlc3NlZE1vdXNlVG91Y2hNb3ZlRXZlbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbihldmVudC5sb2NhbFgsIGV2ZW50LmxvY2FsWSwgZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VVcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW91c2VFdmVudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb25nVGFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VuZFNjcm9sbChldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90YXBFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19maXJlQ2xpY2tlZERlbGVnYXRlKGV2ZW50KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2xvbmdUYXBFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb25nVGFwID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB7IHg6IGV2ZW50LmxvY2FsWCwgeTogZXZlbnQubG9jYWxZIH07XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNraW5nTW9kZShwb2ludCwgcG9pbnQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VMZWF2ZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uTW91c2VFdmVudCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfc2V0SG92ZXJlZFNvdXJjZShudWxsKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xlYXJDcm9zc2hhaXJQb3NpdGlvbigpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2xpY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kYmxDbGlja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZDtcbiAgICB9XG4gICAgX2ludGVybmFsX3BpbmNoU3RhcnRFdmVudCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJldlBpbmNoU2NhbGUgPSAxO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF9zdG9wVGltZVNjYWxlQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9waW5jaEV2ZW50KG1pZGRsZVBvaW50LCBzY2FsZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKClbJ2hhbmRsZVNjYWxlJ10ucGluY2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB6b29tU2NhbGUgPSAoc2NhbGUgLSB0aGlzLl9wcml2YXRlX19wcmV2UGluY2hTY2FsZSkgKiA1O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmV2UGluY2hTY2FsZSA9IHNjYWxlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF96b29tVGltZShtaWRkbGVQb2ludC5faW50ZXJuYWxfeCwgem9vbVNjYWxlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RvdWNoU3RhcnRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sb25nVGFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2V4aXRUcmFja2luZ01vZGVPbk5leHRUcnkgPSB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgIT09IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlVG91Y2hEb3duRXZlbnQoKTtcbiAgICAgICAgY29uc3QgY3Jvc3NoYWlyID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKS5faW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgIT09IG51bGwgJiYgY3Jvc3NoYWlyLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2luaXRDcm9zc2hhaXJQb3NpdGlvbiA9IHsgeDogY3Jvc3NoYWlyLl9pbnRlcm5hbF9hcHBsaWVkWCgpLCB5OiBjcm9zc2hhaXIuX2ludGVybmFsX2FwcGxpZWRZKCkgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCA9IHsgeDogZXZlbnQubG9jYWxYLCB5OiBldmVudC5sb2NhbFkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfdG91Y2hNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IGV2ZW50LmxvY2FsWDtcbiAgICAgICAgY29uc3QgeSA9IGV2ZW50LmxvY2FsWTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gdHJhY2tpbmcgbW9kZTogbW92ZSBjcm9zc2hhaXJcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2V4aXRUcmFja2luZ01vZGVPbk5leHRUcnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdQb2ludCA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9faW5pdENyb3NzaGFpclBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ggPSBvcmlnUG9pbnQueCArICh4IC0gdGhpcy5fcHJpdmF0ZV9fc3RhcnRUcmFja1BvaW50LngpO1xuICAgICAgICAgICAgY29uc3QgbmV3WSA9IG9yaWdQb2ludC55ICsgKHkgLSB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQueSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbihuZXdYLCBuZXdZLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJlc3NlZE1vdXNlVG91Y2hNb3ZlRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdG91Y2hFbmRFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfY2hhcnQoKS5faW50ZXJuYWxfb3B0aW9ucygpLnRyYWNraW5nTW9kZS5leGl0TW9kZSA9PT0gMCAvKiBUcmFja2luZ01vZGVFeGl0TW9kZS5PblRvdWNoRW5kICovKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19leGl0VHJhY2tpbmdNb2RlT25OZXh0VHJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190cnlFeGl0VHJhY2tpbmdNb2RlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VuZFNjcm9sbChldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oaXRUZXN0KHgsIHkpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9wcml2YXRlX19zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGl0VGVzdFBhbmUoc3RhdGUsIHgsIHkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0UHJpY2VBeGlzU2l6ZSh3aWR0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcHJpY2VBeGlzV2lkZ2V0ID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgOiB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZGdldDtcbiAgICAgICAgZW5zdXJlTm90TnVsbChwcmljZUF4aXNXaWRnZXQpLl9pbnRlcm5hbF9zZXRTaXplKHNpemUkMSh7IHdpZHRoLCBoZWlnaHQ6IHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0IH0pKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19zaXplO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U2l6ZShuZXdTaXplKSB7XG4gICAgICAgIGlmIChlcXVhbFNpemVzKHRoaXMuX3ByaXZhdGVfX3NpemUsIG5ld1NpemUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLnJlc2l6ZUNhbnZhc0VsZW1lbnQobmV3U2l6ZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcucmVzaXplQ2FudmFzRWxlbWVudChuZXdTaXplKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lQ2VsbC5zdHlsZS53aWR0aCA9IG5ld1NpemUud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lQ2VsbC5zdHlsZS5oZWlnaHQgPSBuZXdTaXplLmhlaWdodCArICdweCc7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZWNhbGN1bGF0ZVByaWNlU2NhbGVzKCkge1xuICAgICAgICBjb25zdCBwYW5lID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19zdGF0ZSk7XG4gICAgICAgIHBhbmUuX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZShwYW5lLl9pbnRlcm5hbF9sZWZ0UHJpY2VTY2FsZSgpKTtcbiAgICAgICAgcGFuZS5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlKHBhbmUuX2ludGVybmFsX3JpZ2h0UHJpY2VTY2FsZSgpKTtcbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgcGFuZS5faW50ZXJuYWxfZGF0YVNvdXJjZXMoKSkge1xuICAgICAgICAgICAgaWYgKHBhbmUuX2ludGVybmFsX2lzT3ZlcmxheShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpY2VTY2FsZSA9IHNvdXJjZS5faW50ZXJuYWxfcHJpY2VTY2FsZSgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmljZVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUuX2ludGVybmFsX3JlY2FsY3VsYXRlUHJpY2VTY2FsZShwcmljZVNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZm9yIG92ZXJsYXkgZHJhd2luZ3MgcHJpY2Ugc2NhbGUgaXMgb3duZXIncyBwcmljZSBzY2FsZVxuICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIgb3duZXIncyBwcmljZSBzY2FsZSBjb3VsZCBub3QgY29udGFpbiBkc1xuICAgICAgICAgICAgICAgIHNvdXJjZS5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwYW5lLl9pbnRlcm5hbF9wcmltaXRpdmVzKCkpIHtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5faW50ZXJuYWxfdXBkYXRlQWxsVmlld3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuYml0bWFwU2l6ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2RyYXdCaXRtYXAoY3R4LCB4LCB5KSB7XG4gICAgICAgIGNvbnN0IGJpdG1hcFNpemUgPSB0aGlzLl9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCk7XG4gICAgICAgIGlmIChiaXRtYXBTaXplLndpZHRoID4gMCAmJiBiaXRtYXBTaXplLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50LCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFpbnQodHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gMCAvKiBJbnZhbGlkYXRpb25MZXZlbC5Ob25lICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPiAxIC8qIEludmFsaWRhdGlvbkxldmVsLkN1cnNvciAqLykge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVjYWxjdWxhdGVQcmljZVNjYWxlcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9wYWludCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9wYWludCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW52YXNPcHRpb25zID0ge1xuICAgICAgICAgICAgY29sb3JTcGFjZTogdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKS5sYXlvdXQuY29sb3JTcGFjZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgIT09IDEgLyogSW52YWxpZGF0aW9uTGV2ZWwuQ3Vyc29yICovKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmFwcGx5U3VnZ2VzdGVkQml0bWFwU2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQodGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZywgY2FudmFzT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoc2NvcGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JhY2tncm91bmQoc2NvcGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlcyh0YXJnZXQsIHNvdXJjZUJvdHRvbVBhbmVWaWV3cyQxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0dyaWQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZXModGFyZ2V0LCBzb3VyY2VQYW5lVmlld3MkMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdTb3VyY2VzKHRhcmdldCwgc291cmNlTGFiZWxQYW5lVmlld3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmFwcGx5U3VnZ2VzdGVkQml0bWFwU2l6ZSgpO1xuICAgICAgICBjb25zdCB0b3BUYXJnZXQgPSB0cnlDcmVhdGVDYW52YXNSZW5kZXJpbmdUYXJnZXQyRCh0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLCBjYW52YXNPcHRpb25zKTtcbiAgICAgICAgaWYgKHRvcFRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9wVGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgYml0bWFwU2l6ZS53aWR0aCwgYml0bWFwU2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3Q3Jvc3NoYWlyKHRvcFRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlcyh0b3BUYXJnZXQsIHNvdXJjZVRvcFBhbmVWaWV3cyQxKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdTb3VyY2VzKHRvcFRhcmdldCwgc291cmNlTGFiZWxQYW5lVmlld3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sZWZ0UHJpY2VBeGlzV2lkZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldDtcbiAgICB9XG4gICAgX2ludGVybmFsX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3QWRkaXRpb25hbFNvdXJjZXModGFyZ2V0LCBwYW5lVmlld3NHZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZXModGFyZ2V0LCBwYW5lVmlld3NHZXR0ZXIpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25TdGF0ZURlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfb25EZXN0cm95ZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZmlyZUNsaWNrZWREZWxlZ2F0ZShldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19maXJlTW91c2VDbGlja0RlbGVnYXRlKHRoaXMuX3ByaXZhdGVfX2NsaWNrZWQsIGV2ZW50KTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2ZpcmVNb3VzZUNsaWNrRGVsZWdhdGUoZGVsZWdhdGUsIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHggPSBldmVudC5sb2NhbFg7XG4gICAgICAgIGNvbnN0IHkgPSBldmVudC5sb2NhbFk7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5faW50ZXJuYWxfaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgICAgICAgIGRlbGVnYXRlLl9pbnRlcm5hbF9maXJlKHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9jb29yZGluYXRlVG9JbmRleCh4KSwgeyB4LCB5IH0sIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JhY2tncm91bmQoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUgfSkge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGJpdG1hcFNpemU7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwoKTtcbiAgICAgICAgY29uc3QgdG9wQ29sb3IgPSBtb2RlbC5faW50ZXJuYWxfYmFja2dyb3VuZFRvcENvbG9yKCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbUNvbG9yID0gbW9kZWwuX2ludGVybmFsX2JhY2tncm91bmRCb3R0b21Db2xvcigpO1xuICAgICAgICBpZiAodG9wQ29sb3IgPT09IGJvdHRvbUNvbG9yKSB7XG4gICAgICAgICAgICBjbGVhclJlY3QoY3R4LCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCBib3R0b21Db2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGVhclJlY3RXaXRoR3JhZGllbnQoY3R4LCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCB0b3BDb2xvciwgYm90dG9tQ29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3R3JpZCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3N0YXRlKTtcbiAgICAgICAgY29uc3QgcGFuZVZpZXcgPSBzdGF0ZS5faW50ZXJuYWxfZ3JpZCgpLl9pbnRlcm5hbF9wYW5lVmlldygpO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHBhbmVWaWV3Ll9pbnRlcm5hbF9yZW5kZXJlcihzdGF0ZSk7XG4gICAgICAgIGlmIChyZW5kZXJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVuZGVyZXIuX2ludGVybmFsX2RyYXcodGFyZ2V0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdDcm9zc2hhaXIodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdTb3VyY2VJbXBsKHRhcmdldCwgc291cmNlUGFuZVZpZXdzJDEsIGRyYXdGb3JlZ3JvdW5kLCB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF9jcm9zc2hhaXJTb3VyY2UoKSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3U291cmNlcyh0YXJnZXQsIHBhbmVWaWV3c0dldHRlcikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fc3RhdGUpO1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gc3RhdGUuX2ludGVybmFsX29yZGVyZWRTb3VyY2VzKCk7XG4gICAgICAgIGNvbnN0IHBhbmVQcmltaXRpdmVzID0gc3RhdGUuX2ludGVybmFsX3ByaW1pdGl2ZXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBwYW5lUHJpbWl0aXZlIG9mIHBhbmVQcmltaXRpdmVzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3U291cmNlSW1wbCh0YXJnZXQsIHBhbmVWaWV3c0dldHRlciwgZHJhd0JhY2tncm91bmQsIHBhbmVQcmltaXRpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdTb3VyY2VJbXBsKHRhcmdldCwgcGFuZVZpZXdzR2V0dGVyLCBkcmF3QmFja2dyb3VuZCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhbmVQcmltaXRpdmUgb2YgcGFuZVByaW1pdGl2ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdTb3VyY2VJbXBsKHRhcmdldCwgcGFuZVZpZXdzR2V0dGVyLCBkcmF3Rm9yZWdyb3VuZCwgcGFuZVByaW1pdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1NvdXJjZUltcGwodGFyZ2V0LCBwYW5lVmlld3NHZXR0ZXIsIGRyYXdGb3JlZ3JvdW5kLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3U291cmNlSW1wbCh0YXJnZXQsIHBhbmVWaWV3c0dldHRlciwgZHJhd0ZuLCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3N0YXRlKTtcbiAgICAgICAgY29uc3QgaG92ZXJlZFNvdXJjZSA9IHN0YXRlLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9ob3ZlcmVkU291cmNlKCk7XG4gICAgICAgIGNvbnN0IGlzSG92ZXJlZCA9IGhvdmVyZWRTb3VyY2UgIT09IG51bGwgJiYgaG92ZXJlZFNvdXJjZS5faW50ZXJuYWxfc291cmNlID09PSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IG9iamVjSWQgPSBob3ZlcmVkU291cmNlICE9PSBudWxsICYmIGlzSG92ZXJlZCAmJiBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9vYmplY3QgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9vYmplY3QuX2ludGVybmFsX2hpdFRlc3REYXRhXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZHJhd1JlbmRlcmVyRm4gPSAocmVuZGVyZXIpID0+IGRyYXdGbihyZW5kZXJlciwgdGFyZ2V0LCBpc0hvdmVyZWQsIG9iamVjSWQpO1xuICAgICAgICBkcmF3U291cmNlVmlld3MocGFuZVZpZXdzR2V0dGVyLCBkcmF3UmVuZGVyZXJGbiwgc291cmNlLCBzdGF0ZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19yZWNyZWF0ZVByaWNlQXhpc1dpZGdldHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQ7XG4gICAgICAgIGNvbnN0IGxlZnRBeGlzVmlzaWJsZSA9IHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9sZWZ0UHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9vcHRpb25zKCkudmlzaWJsZTtcbiAgICAgICAgY29uc3QgcmlnaHRBeGlzVmlzaWJsZSA9IHRoaXMuX3ByaXZhdGVfX3N0YXRlLl9pbnRlcm5hbF9yaWdodFByaWNlU2NhbGUoKS5faW50ZXJuYWxfb3B0aW9ucygpLnZpc2libGU7XG4gICAgICAgIGlmICghbGVmdEF4aXNWaXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRBeGlzQ2VsbC5yZW1vdmVDaGlsZCh0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZGdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyaWdodEF4aXNWaXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodEF4aXNDZWxsLnJlbW92ZUNoaWxkKHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnNQcm92aWRlciA9IGNoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnNQcm92aWRlcigpO1xuICAgICAgICBpZiAobGVmdEF4aXNWaXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQgPSBuZXcgUHJpY2VBeGlzV2lkZ2V0KHRoaXMsIGNoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKCksIHJlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyLCAnbGVmdCcpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdEF4aXNDZWxsLmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX2xlZnRQcmljZUF4aXNXaWRnZXQuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0QXhpc1Zpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWRnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0ID0gbmV3IFByaWNlQXhpc1dpZGdldCh0aGlzLCBjaGFydC5faW50ZXJuYWxfb3B0aW9ucygpLCByZW5kZXJlck9wdGlvbnNQcm92aWRlciwgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodEF4aXNDZWxsLmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19wcmV2ZW50U2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5faW50ZXJuYWxfaXNUb3VjaCAmJiB0aGlzLl9wcml2YXRlX19sb25nVGFwIHx8IHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCAhPT0gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NvcnJlY3RYQ29vcmQoeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oeCwgdGhpcy5fcHJpdmF0ZV9fc2l6ZS53aWR0aCAtIDEpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NvcnJlY3RZQ29vcmQoeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oeSwgdGhpcy5fcHJpdmF0ZV9fc2l6ZS5oZWlnaHQgLSAxKSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbih4LCB5LCBldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF9zZXRBbmRTYXZlQ3VycmVudFBvc2l0aW9uKHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RYQ29vcmQoeCksIHRoaXMuX3ByaXZhdGVfX2NvcnJlY3RZQ29vcmQoeSksIGV2ZW50LCBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX3N0YXRlKSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19jbGVhckNyb3NzaGFpclBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF9jbGVhckN1cnJlbnRQb3NpdGlvbigpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdHJ5RXhpdFRyYWNraW5nTW9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2V4aXRUcmFja2luZ01vZGVPbk5leHRUcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jbGVhckNyb3NzaGFpclBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX3N0YXJ0VHJhY2tpbmdNb2RlKHN0YXJ0VHJhY2tQb2ludCwgY3Jvc3NIYWlyUG9zaXRpb24sIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0VHJhY2tQb2ludCA9IHN0YXJ0VHJhY2tQb2ludDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZXhpdFRyYWNraW5nTW9kZU9uTmV4dFRyeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDcm9zc2hhaXJQb3NpdGlvbihjcm9zc0hhaXJQb3NpdGlvbi54LCBjcm9zc0hhaXJQb3NpdGlvbi55LCBldmVudCk7XG4gICAgICAgIGNvbnN0IGNyb3NzaGFpciA9IHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX2Nyb3NzaGFpclNvdXJjZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbml0Q3Jvc3NoYWlyUG9zaXRpb24gPSB7IHg6IGNyb3NzaGFpci5faW50ZXJuYWxfYXBwbGllZFgoKSwgeTogY3Jvc3NoYWlyLl9pbnRlcm5hbF9hcHBsaWVkWSgpIH07XG4gICAgfVxuICAgIF9wcml2YXRlX19tb2RlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZW5kU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9faXNTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX21vZGVsKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5faW50ZXJuYWxfc3RhdGUoKTtcbiAgICAgICAgbW9kZWwuX2ludGVybmFsX2VuZFNjcm9sbFByaWNlKHN0YXRlLCBzdGF0ZS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3N0YXJ0U2Nyb2xsaW5nUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgbW9kZWwuX2ludGVybmFsX2VuZFNjcm9sbFRpbWUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3Njcm9sbFhBbmltYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0QW5pbWF0aW9uVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgdGltZVNjYWxlID0gbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsWEFuaW1hdGlvbi5faW50ZXJuYWxfc3RhcnQodGltZVNjYWxlLl9pbnRlcm5hbF9yaWdodE9mZnNldCgpLCBzdGFydEFuaW1hdGlvblRpbWUpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uLl9pbnRlcm5hbF9maW5pc2hlZChzdGFydEFuaW1hdGlvblRpbWUpKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuX2ludGVybmFsX3NldFRpbWVTY2FsZUFuaW1hdGlvbih0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25Nb3VzZUV2ZW50KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFRyYWNrUG9pbnQgPSBudWxsO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbW91c2VUb3VjaERvd25FdmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19zdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsKCkuX2ludGVybmFsX3N0b3BUaW1lU2NhbGVBbmltYXRpb24oKTtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBJZiBhbnkgZm9jdXNhYmxlIGVsZW1lbnQgZXhjZXB0IHRoZSBwYWdlIGl0c2VsZiBpcyBmb2N1c2VkLCByZW1vdmUgdGhlIGZvY3VzXG4gICAgICAgICAgICBlbnN1cmVOb3ROdWxsKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHNlbGVjdGlvblxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9wcml2YXRlX19zdGF0ZS5faW50ZXJuYWxfZGVmYXVsdFByaWNlU2NhbGUoKTtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSB8fCB0aGlzLl9wcml2YXRlX19tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBfcHJpdmF0ZV9fcHJlc3NlZE1vdXNlVG91Y2hNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19tb2RlbCgpO1xuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSBtb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIGlmICh0aW1lU2NhbGUuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYXJ0T3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbE9wdGlvbnMgPSBjaGFydE9wdGlvbnNbJ2hhbmRsZVNjcm9sbCddO1xuICAgICAgICBjb25zdCBraW5ldGljU2Nyb2xsT3B0aW9ucyA9IGNoYXJ0T3B0aW9ucy5raW5ldGljU2Nyb2xsO1xuICAgICAgICBpZiAoKCFzY3JvbGxPcHRpb25zLnByZXNzZWRNb3VzZU1vdmUgfHwgZXZlbnQuX2ludGVybmFsX2lzVG91Y2gpICYmXG4gICAgICAgICAgICAoIXNjcm9sbE9wdGlvbnMuaG9yelRvdWNoRHJhZyAmJiAhc2Nyb2xsT3B0aW9ucy52ZXJ0VG91Y2hEcmFnIHx8ICFldmVudC5faW50ZXJuYWxfaXNUb3VjaCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fc3RhdGUuX2ludGVybmFsX2RlZmF1bHRQcmljZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc3RhcnRTY3JvbGxpbmdQb3MgPT09IG51bGwgJiYgIXRoaXMuX3ByaXZhdGVfX3ByZXZlbnRTY3JvbGwoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1BvcyA9IHtcbiAgICAgICAgICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RpbWVzdGFtcDogbm93LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9sb2NhbFg6IGV2ZW50LmxvY2FsWCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbG9jYWxZOiBldmVudC5sb2NhbFksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1BvcyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgIXRoaXMuX3ByaXZhdGVfX2lzU2Nyb2xsaW5nICYmXG4gICAgICAgICAgICAodGhpcy5fcHJpdmF0ZV9fc3RhcnRTY3JvbGxpbmdQb3MueCAhPT0gZXZlbnQuY2xpZW50WCB8fCB0aGlzLl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1Bvcy55ICE9PSBldmVudC5jbGllbnRZKSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50Ll9pbnRlcm5hbF9pc1RvdWNoICYmIGtpbmV0aWNTY3JvbGxPcHRpb25zLnRvdWNoIHx8ICFldmVudC5faW50ZXJuYWxfaXNUb3VjaCAmJiBraW5ldGljU2Nyb2xsT3B0aW9ucy5tb3VzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhclNwYWNpbmcgPSB0aW1lU2NhbGUuX2ludGVybmFsX2JhclNwYWNpbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zY3JvbGxYQW5pbWF0aW9uID0gbmV3IEtpbmV0aWNBbmltYXRpb24oMC4yIC8qIEtpbmV0aWNTY3JvbGxDb25zdGFudHMuTWluU2Nyb2xsU3BlZWQgKi8gLyBiYXJTcGFjaW5nLCA3IC8qIEtpbmV0aWNTY3JvbGxDb25zdGFudHMuTWF4U2Nyb2xsU3BlZWQgKi8gLyBiYXJTcGFjaW5nLCAwLjk5NyAvKiBLaW5ldGljU2Nyb2xsQ29uc3RhbnRzLkR1bXBpbmdDb2VmZiAqLywgMTUgLyogS2luZXRpY1Njcm9sbENvbnN0YW50cy5TY3JvbGxNaW5Nb3ZlICovIC8gYmFyU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2Nyb2xsWEFuaW1hdGlvbi5faW50ZXJuYWxfYWRkUG9zaXRpb24odGltZVNjYWxlLl9pbnRlcm5hbF9yaWdodE9mZnNldCgpLCB0aGlzLl9wcml2YXRlX19zdGFydFNjcm9sbGluZ1Bvcy5faW50ZXJuYWxfdGltZXN0YW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Njcm9sbFhBbmltYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmljZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5faW50ZXJuYWxfc3RhcnRTY3JvbGxQcmljZSh0aGlzLl9wcml2YXRlX19zdGF0ZSwgcHJpY2VTY2FsZSwgZXZlbnQubG9jYWxZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVsLl9pbnRlcm5hbF9zdGFydFNjcm9sbFRpbWUoZXZlbnQubG9jYWxYKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgYWxsb3dzIHNjcm9sbGluZyBub3QgZGVmYXVsdCBwcmljZSBzY2FsZXNcbiAgICAgICAgICAgIGlmICghcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuX2ludGVybmFsX3Njcm9sbFByaWNlVG8odGhpcy5fcHJpdmF0ZV9fc3RhdGUsIHByaWNlU2NhbGUsIGV2ZW50LmxvY2FsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlbC5faW50ZXJuYWxfc2Nyb2xsVGltZVRvKGV2ZW50LmxvY2FsWCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2Nyb2xsWEFuaW1hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Njcm9sbFhBbmltYXRpb24uX2ludGVybmFsX2FkZFBvc2l0aW9uKHRpbWVTY2FsZS5faW50ZXJuYWxfcmlnaHRPZmZzZXQoKSwgbm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgUHJpY2VBeGlzU3R1YiB7XG4gICAgY29uc3RydWN0b3Ioc2lkZSwgb3B0aW9ucywgcGFyYW1zLCBib3JkZXJWaXNpYmxlLCBib3R0b21Db2xvcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemUgPSBzaXplJDEoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIgPSAoKSA9PiB0aGlzLl9pbnRlcm5hbF9wYWludCgzIC8qIEludmFsaWRhdGlvbkxldmVsLkZ1bGwgKi8pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pc0xlZnQgPSBzaWRlID09PSAnbGVmdCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyID0gcGFyYW1zLl9pbnRlcm5hbF9yZW5kZXJlck9wdGlvbnNQcm92aWRlcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2JvcmRlclZpc2libGUgPSBib3JkZXJWaXNpYmxlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ib3R0b21Db2xvciA9IGJvdHRvbUNvbG9yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUud2lkdGggPSAnMjVweCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcgPSBjcmVhdGVCb3VuZENhbnZhcyh0aGlzLl9wcml2YXRlX19jZWxsLCBzaXplJDEoeyB3aWR0aDogMTYsIGhlaWdodDogMTYgfSkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX2NhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLnVuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgcmVsZWFzZUNhbnZhcyh0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jZWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3NpemU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRTaXplKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKCFlcXVhbFNpemVzKHRoaXMuX3ByaXZhdGVfX3NpemUsIG5ld1NpemUpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplID0gbmV3U2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcucmVzaXplQ2FudmFzRWxlbWVudChuZXdTaXplKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUud2lkdGggPSBgJHtuZXdTaXplLndpZHRofXB4YDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUuaGVpZ2h0ID0gYCR7bmV3U2l6ZS5oZWlnaHR9cHhgO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wYWludCh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlIDwgMyAvKiBJbnZhbGlkYXRpb25MZXZlbC5GdWxsICovICYmICF0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19zaXplLndpZHRoID09PSAwIHx8IHRoaXMuX3ByaXZhdGVfX3NpemUuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5hcHBseVN1Z2dlc3RlZEJpdG1hcFNpemUoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdHJ5Q3JlYXRlQ2FudmFzUmVuZGVyaW5nVGFyZ2V0MkQodGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZywge1xuICAgICAgICAgICAgY29sb3JTcGFjZTogdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sYXlvdXQuY29sb3JTcGFjZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHNjb3BlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JhY2tncm91bmQoc2NvcGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdCb3JkZXIoc2NvcGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2dldEJpdG1hcFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmJpdG1hcFNpemU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgeCwgeSkge1xuICAgICAgICBjb25zdCBiaXRtYXBTaXplID0gdGhpcy5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpO1xuICAgICAgICBpZiAoYml0bWFwU2l6ZS53aWR0aCA+IDAgJiYgYml0bWFwU2l6ZS5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdCb3JkZXIoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX2JvcmRlclZpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS5ib3JkZXJDb2xvcjtcbiAgICAgICAgY29uc3QgaG9yekJvcmRlclNpemUgPSBNYXRoLmZsb29yKHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyLl9pbnRlcm5hbF9vcHRpb25zKCkuX2ludGVybmFsX2JvcmRlclNpemUgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGNvbnN0IHZlcnRCb3JkZXJTaXplID0gTWF0aC5mbG9vcih0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnNQcm92aWRlci5faW50ZXJuYWxfb3B0aW9ucygpLl9pbnRlcm5hbF9ib3JkZXJTaXplICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgY29uc3QgbGVmdCA9ICh0aGlzLl9wcml2YXRlX19pc0xlZnQpID8gYml0bWFwU2l6ZS53aWR0aCAtIGhvcnpCb3JkZXJTaXplIDogMDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIDAsIGhvcnpCb3JkZXJTaXplLCB2ZXJ0Qm9yZGVyU2l6ZSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3QmFja2dyb3VuZCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSB9KSB7XG4gICAgICAgIGNsZWFyUmVjdChjdHgsIDAsIDAsIGJpdG1hcFNpemUud2lkdGgsIGJpdG1hcFNpemUuaGVpZ2h0LCB0aGlzLl9wcml2YXRlX19ib3R0b21Db2xvcigpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVGltZUF4aXNWaWV3c0dldHRlcih6T3JkZXIpIHtcbiAgICByZXR1cm4gKHNvdXJjZSkgPT4gc291cmNlLl9pbnRlcm5hbF90aW1lUGFuZVZpZXdzPy4oek9yZGVyKSA/PyBbXTtcbn1cbmNvbnN0IHNvdXJjZVBhbmVWaWV3cyA9IGJ1aWxkVGltZUF4aXNWaWV3c0dldHRlcignbm9ybWFsJyk7XG5jb25zdCBzb3VyY2VUb3BQYW5lVmlld3MgPSBidWlsZFRpbWVBeGlzVmlld3NHZXR0ZXIoJ3RvcCcpO1xuY29uc3Qgc291cmNlQm90dG9tUGFuZVZpZXdzID0gYnVpbGRUaW1lQXhpc1ZpZXdzR2V0dGVyKCdib3R0b20nKTtcbmNsYXNzIFRpbWVBeGlzV2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFydFdpZGdldCwgaG9yelNjYWxlQmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IHNpemUkMSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemVDaGFuZ2VkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3dpZHRoQ2FjaGUgPSBuZXcgVGV4dFdpZHRoQ2FjaGUoNSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19pc1NldHRpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2xpZ2h0VXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9faXNTZXR0aW5nU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9saWdodFVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydCA9IGNoYXJ0V2lkZ2V0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gY2hhcnRXaWRnZXQuX2ludGVybmFsX29wdGlvbnMoKVsnbGF5b3V0J107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YkNlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YkNlbGwuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViQ2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YkNlbGwuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUuaGVpZ2h0ID0gJzI1cHgnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jZWxsLnN0eWxlLnBhZGRpbmcgPSAnMCc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2R2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2R2LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kdi5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2R2LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHYuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19kdik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcgPSBjcmVhdGVCb3VuZENhbnZhcyh0aGlzLl9wcml2YXRlX19kdiwgc2l6ZSQxKHsgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH0pKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nID0gY3JlYXRlQm91bmRDYW52YXModGhpcy5fcHJpdmF0ZV9fZHYsIHNpemUkMSh7IHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiB9KSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuc3Vic2NyaWJlU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzU3VnZ2VzdGVkQml0bWFwU2l6ZUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgY29uc3QgdG9wQ2FudmFzID0gdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50O1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUuekluZGV4ID0gJzInO1xuICAgICAgICB0b3BDYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgdG9wQ2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19sZWZ0U3R1YkNlbGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX2NlbGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YkNlbGwpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNyZWF0ZVN0dWJzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19yZWNyZWF0ZVN0dWJzLmJpbmQodGhpcyksIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlciA9IG5ldyBNb3VzZUV2ZW50SGFuZGxlcih0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLmNhbnZhc0VsZW1lbnQsIHRoaXMsIHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF90cmVhdFZlcnRUb3VjaERyYWdBc1BhZ2VTY3JvbGw6ICgpID0+IHRydWUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdHJlYXRIb3J6VG91Y2hEcmFnQXNQYWdlU2Nyb2xsOiAoKSA9PiAhdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKVsnaGFuZGxlU2Nyb2xsJ10uaG9yelRvdWNoRHJhZyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb3VzZUV2ZW50SGFuZGxlci5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy51bnN1YnNjcmliZVN1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc1N1Z2dlc3RlZEJpdG1hcFNpemVDaGFuZ2VkSGFuZGxlcik7XG4gICAgICAgIHJlbGVhc2VDYW52YXModGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdG9wQ2FudmFzQmluZGluZy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcudW5zdWJzY3JpYmVTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZCh0aGlzLl9wcml2YXRlX19jYW52YXNTdWdnZXN0ZWRCaXRtYXBTaXplQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICByZWxlYXNlQ2FudmFzKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9sZWZ0U3R1YigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcmlnaHRTdHViKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VEb3duRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX21vdXNlRG93bikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIGlmIChtb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2lzRW1wdHkoKSB8fCAhdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKVsnaGFuZGxlU2NhbGUnXS5heGlzUHJlc3NlZE1vdXNlTW92ZS50aW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuX2ludGVybmFsX3N0YXJ0U2NhbGVUaW1lKGV2ZW50LmxvY2FsWCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90b3VjaFN0YXJ0RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfbW91c2VEb3duRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VEb3duT3V0c2lkZUV2ZW50KCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBpZiAoIW1vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaXNFbXB0eSgpICYmIHRoaXMuX3ByaXZhdGVfX21vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKVsnaGFuZGxlU2NhbGUnXS5heGlzUHJlc3NlZE1vdXNlTW92ZS50aW1lKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuX2ludGVybmFsX2VuZFNjYWxlVGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmVzc2VkTW91c2VNb3ZlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgaWYgKG1vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaXNFbXB0eSgpIHx8ICF0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpWydoYW5kbGVTY2FsZSddLmF4aXNQcmVzc2VkTW91c2VNb3ZlLnRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5faW50ZXJuYWxfc2NhbGVUaW1lVG8oZXZlbnQubG9jYWxYKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RvdWNoTW92ZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3ByZXNzZWRNb3VzZU1vdmVFdmVudChldmVudCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tb3VzZVVwRXZlbnQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBpZiAobW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9pc0VtcHR5KCkgJiYgIXRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKClbJ2hhbmRsZVNjYWxlJ10uYXhpc1ByZXNzZWRNb3VzZU1vdmUudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9lbmRTY2FsZVRpbWUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3RvdWNoRW5kRXZlbnQoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vdXNlVXBFdmVudCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VEb3VibGVDbGlja0V2ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX29wdGlvbnMoKVsnaGFuZGxlU2NhbGUnXS5heGlzRG91YmxlQ2xpY2tSZXNldC50aW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcmVzZXRUaW1lU2NhbGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZG91YmxlVGFwRXZlbnQoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vdXNlRG91YmxlQ2xpY2tFdmVudCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VFbnRlckV2ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX29wdGlvbnMoKVsnaGFuZGxlU2NhbGUnXS5heGlzUHJlc3NlZE1vdXNlTW92ZS50aW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDdXJzb3IoMSAvKiBDdXJzb3JUeXBlLkV3UmVzaXplICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfbW91c2VMZWF2ZUV2ZW50KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRDdXJzb3IoMCAvKiBDdXJzb3JUeXBlLkRlZmF1bHQgKi8pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3NpemU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zaXplQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3NpemVDaGFuZ2VkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U2l6ZXModGltZUF4aXNTaXplLCBsZWZ0U3R1YldpZHRoLCByaWdodFN0dWJXaWR0aCkge1xuICAgICAgICBpZiAoIWVxdWFsU2l6ZXModGhpcy5fcHJpdmF0ZV9fc2l6ZSwgdGltZUF4aXNTaXplKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZSA9IHRpbWVBeGlzU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5yZXNpemVDYW52YXNFbGVtZW50KHRpbWVBeGlzU2l6ZSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190b3BDYW52YXNCaW5kaW5nLnJlc2l6ZUNhbnZhc0VsZW1lbnQodGltZUF4aXNTaXplKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2lzU2V0dGluZ1NpemUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUud2lkdGggPSBgJHt0aW1lQXhpc1NpemUud2lkdGh9cHhgO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2VsbC5zdHlsZS5oZWlnaHQgPSBgJHt0aW1lQXhpc1NpemUuaGVpZ2h0fXB4YDtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3NpemVDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKHRpbWVBeGlzU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1Yi5faW50ZXJuYWxfc2V0U2l6ZShzaXplJDEoeyB3aWR0aDogbGVmdFN0dWJXaWR0aCwgaGVpZ2h0OiB0aW1lQXhpc1NpemUuaGVpZ2h0IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIuX2ludGVybmFsX3NldFNpemUoc2l6ZSQxKHsgd2lkdGg6IHJpZ2h0U3R1YldpZHRoLCBoZWlnaHQ6IHRpbWVBeGlzU2l6ZS5oZWlnaHQgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpbWFsSGVpZ2h0KCkge1xuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19nZXRSZW5kZXJlck9wdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChcbiAgICAgICAgLy8gcmVuZGVyZXJPcHRpb25zLm9mZnNldFNpemUgK1xuICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2JvcmRlclNpemUgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemUgK1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nVG9wICtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0JvdHRvbSArXG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2xhYmVsQm90dG9tT2Zmc2V0KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSgpIHtcbiAgICAgICAgLy8gdGhpcyBjYWxsIGhhcyBzaWRlLWVmZmVjdCAtIGl0IHJlZ2VuZXJhdGVzIG1hcmtzIG9uIHRoZSB0aW1lIHNjYWxlXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfbWFya3MoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2dldEJpdG1hcFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYW52YXNCaW5kaW5nLmJpdG1hcFNpemU7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgeCwgeSkge1xuICAgICAgICBjb25zdCBiaXRtYXBTaXplID0gdGhpcy5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpO1xuICAgICAgICBpZiAoYml0bWFwU2l6ZS53aWR0aCA+IDAgJiYgYml0bWFwU2l6ZS5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcuY2FudmFzRWxlbWVudCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX3BhaW50KHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IDAgLyogSW52YWxpZGF0aW9uTGV2ZWwuTm9uZSAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhc09wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb2xvclNwYWNlOiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmNvbG9yU3BhY2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlICE9PSAxIC8qIEludmFsaWRhdGlvbkxldmVsLkN1cnNvciAqLykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2FudmFzQmluZGluZy5hcHBseVN1Z2dlc3RlZEJpdG1hcFNpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEKHRoaXMuX3ByaXZhdGVfX2NhbnZhc0JpbmRpbmcsIGNhbnZhc09wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHNjb3BlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdCYWNrZ3JvdW5kKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JvcmRlcihzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdBZGRpdGlvbmFsU291cmNlcyh0YXJnZXQsIHNvdXJjZUJvdHRvbVBhbmVWaWV3cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1RpY2tNYXJrcyh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdBZGRpdGlvbmFsU291cmNlcyh0YXJnZXQsIHNvdXJjZVBhbmVWaWV3cyk7XG4gICAgICAgICAgICAgICAgLy8gYXRtIHdlIGRvbid0IGhhdmUgc291cmNlcyB0byBiZSBkcmF3biBvbiB0aW1lIGF4aXMgZXhjZXB0IGNyb3NzaGFpciB3aGljaCBpcyByZW5kZXJlZCBvbiB0b3AgbGV2ZWwgY2FudmFzXG4gICAgICAgICAgICAgICAgLy8gc28gbGV0J3MgZG9uJ3QgY2FsbCB0aGlzIGNvZGUgYXQgYWxsIGZvciBub3dcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9kcmF3TGFiZWxzKHRoaXMuX2NoYXJ0Lm1vZGVsKCkuZGF0YVNvdXJjZXMoKSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sZWZ0U3R1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViLl9pbnRlcm5hbF9wYWludCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yaWdodFN0dWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIuX2ludGVybmFsX3BhaW50KHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcuYXBwbHlTdWdnZXN0ZWRCaXRtYXBTaXplKCk7XG4gICAgICAgIGNvbnN0IHRvcFRhcmdldCA9IHRyeUNyZWF0ZUNhbnZhc1JlbmRlcmluZ1RhcmdldDJEKHRoaXMuX3ByaXZhdGVfX3RvcENhbnZhc0JpbmRpbmcsIGNhbnZhc09wdGlvbnMpO1xuICAgICAgICBpZiAodG9wVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BUYXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCwgYml0bWFwU2l6ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBiaXRtYXBTaXplLndpZHRoLCBiaXRtYXBTaXplLmhlaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdMYWJlbHMoWy4uLnRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9zZXJpZXNlcygpLCB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlKCldLCB0b3BUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0FkZGl0aW9uYWxTb3VyY2VzKHRvcFRhcmdldCwgc291cmNlVG9wUGFuZVZpZXdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0FkZGl0aW9uYWxTb3VyY2VzKHRhcmdldCwgYXhpc1ZpZXdzR2V0dGVyKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfc2VyaWVzZXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgZHJhd1NvdXJjZVZpZXdzKGF4aXNWaWV3c0dldHRlciwgKHJlbmRlcmVyKSA9PiBkcmF3QmFja2dyb3VuZChyZW5kZXJlciwgdGFyZ2V0LCBmYWxzZSwgdW5kZWZpbmVkKSwgc291cmNlLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIGRyYXdTb3VyY2VWaWV3cyhheGlzVmlld3NHZXR0ZXIsIChyZW5kZXJlcikgPT4gZHJhd0ZvcmVncm91bmQocmVuZGVyZXIsIHRhcmdldCwgZmFsc2UsIHVuZGVmaW5lZCksIHNvdXJjZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JhY2tncm91bmQoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUgfSkge1xuICAgICAgICBjbGVhclJlY3QoY3R4LCAwLCAwLCBiaXRtYXBTaXplLndpZHRoLCBiaXRtYXBTaXplLmhlaWdodCwgdGhpcy5fcHJpdmF0ZV9fY2hhcnQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2JhY2tncm91bmRCb3R0b21Db2xvcigpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2RyYXdCb3JkZXIoeyBjb250ZXh0OiBjdHgsIGJpdG1hcFNpemUsIHZlcnRpY2FsUGl4ZWxSYXRpbyB9KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpLnRpbWVTY2FsZS5ib3JkZXJWaXNpYmxlKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fcHJpdmF0ZV9fbGluZUNvbG9yKCk7XG4gICAgICAgICAgICBjb25zdCBib3JkZXJTaXplID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih0aGlzLl9wcml2YXRlX19nZXRSZW5kZXJlck9wdGlvbnMoKS5faW50ZXJuYWxfYm9yZGVyU2l6ZSAqIHZlcnRpY2FsUGl4ZWxSYXRpbykpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGJpdG1hcFNpemUud2lkdGgsIGJvcmRlclNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3VGlja01hcmtzKHRhcmdldCkge1xuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHRpY2tNYXJrcyA9IHRpbWVTY2FsZS5faW50ZXJuYWxfbWFya3MoKTtcbiAgICAgICAgaWYgKCF0aWNrTWFya3MgfHwgdGlja01hcmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heFdlaWdodCA9IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLm1heFRpY2tNYXJrV2VpZ2h0KHRpY2tNYXJrcyk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX2dldFJlbmRlcmVyT3B0aW9ucygpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGltZVNjYWxlLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmJvcmRlclZpc2libGUgJiYgb3B0aW9ucy50aWNrc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHRhcmdldC51c2VCaXRtYXBDb29yZGluYXRlU3BhY2UoKHsgY29udGV4dDogY3R4LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9wcml2YXRlX19saW5lQ29sb3IoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fcHJpdmF0ZV9fbGluZUNvbG9yKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja1dpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tPZmZzZXQgPSBNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvICogMC41KTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja0xlbiA9IE1hdGgucm91bmQocmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF90aWNrTGVuZ3RoICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IHRpY2tNYXJrcy5sZW5ndGg7IGluZGV4LS07KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKHRpY2tNYXJrc1tpbmRleF0uY29vcmQgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHggLSB0aWNrT2Zmc2V0LCAwLCB0aWNrV2lkdGgsIHRpY2tMZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnVzZU1lZGlhQ29vcmRpbmF0ZVNwYWNlKCh7IGNvbnRleHQ6IGN0eCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB5VGV4dCA9IChyZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2JvcmRlclNpemUgK1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfdGlja0xlbmd0aCArXG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nVG9wICtcbiAgICAgICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnRTaXplIC8gMik7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fcHJpdmF0ZV9fdGV4dENvbG9yKCk7XG4gICAgICAgICAgICAvLyBkcmF3IGJhc2UgbWFya3NcbiAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5fcHJpdmF0ZV9fYmFzZUZvbnQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGlja01hcmsgb2YgdGlja01hcmtzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpY2tNYXJrLndlaWdodCA8IG1heFdlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29yZGluYXRlID0gdGlja01hcmsubmVlZEFsaWduQ29vcmRpbmF0ZSA/IHRoaXMuX3ByaXZhdGVfX2FsaWduVGlja01hcmtMYWJlbENvb3JkaW5hdGUoY3R4LCB0aWNrTWFyay5jb29yZCwgdGlja01hcmsubGFiZWwpIDogdGlja01hcmsuY29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aWNrTWFyay5sYWJlbCwgY29vcmRpbmF0ZSwgeVRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfb3B0aW9ucygpLnRpbWVTY2FsZS5hbGxvd0JvbGRMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuX3ByaXZhdGVfX2Jhc2VCb2xkRm9udCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB0aWNrTWFyayBvZiB0aWNrTWFya3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGlja01hcmsud2VpZ2h0ID49IG1heFdlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29yZGluYXRlID0gdGlja01hcmsubmVlZEFsaWduQ29vcmRpbmF0ZSA/IHRoaXMuX3ByaXZhdGVfX2FsaWduVGlja01hcmtMYWJlbENvb3JkaW5hdGUoY3R4LCB0aWNrTWFyay5jb29yZCwgdGlja01hcmsubGFiZWwpIDogdGlja01hcmsuY29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aWNrTWFyay5sYWJlbCwgY29vcmRpbmF0ZSwgeVRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19hbGlnblRpY2tNYXJrTGFiZWxDb29yZGluYXRlKGN0eCwgY29vcmRpbmF0ZSwgbGFiZWxUZXh0KSB7XG4gICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aGlzLl9wcml2YXRlX193aWR0aENhY2hlLl9pbnRlcm5hbF9tZWFzdXJlVGV4dChjdHgsIGxhYmVsVGV4dCk7XG4gICAgICAgIGNvbnN0IGxhYmVsV2lkdGhIYWxmID0gbGFiZWxXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IGxlZnRUZXh0Q29vcmRpbmF0ZSA9IE1hdGguZmxvb3IoY29vcmRpbmF0ZSAtIGxhYmVsV2lkdGhIYWxmKSArIDAuNTtcbiAgICAgICAgaWYgKGxlZnRUZXh0Q29vcmRpbmF0ZSA8IDApIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlICsgTWF0aC5hYnMoMCAtIGxlZnRUZXh0Q29vcmRpbmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVmdFRleHRDb29yZGluYXRlICsgbGFiZWxXaWR0aCA+IHRoaXMuX3ByaXZhdGVfX3NpemUud2lkdGgpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlIC0gTWF0aC5hYnModGhpcy5fcHJpdmF0ZV9fc2l6ZS53aWR0aCAtIChsZWZ0VGV4dENvb3JkaW5hdGUgKyBsYWJlbFdpZHRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3TGFiZWxzKHNvdXJjZXMsIHRhcmdldCkge1xuICAgICAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19nZXRSZW5kZXJlck9wdGlvbnMoKTtcbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2aWV3IG9mIHNvdXJjZS5faW50ZXJuYWxfdGltZUF4aXNWaWV3cygpKSB7XG4gICAgICAgICAgICAgICAgdmlldy5faW50ZXJuYWxfcmVuZGVyZXIoKS5faW50ZXJuYWxfZHJhdyh0YXJnZXQsIHJlbmRlcmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2xpbmVDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9vcHRpb25zKCkudGltZVNjYWxlLmJvcmRlckNvbG9yO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdGV4dENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50ZXh0Q29sb3I7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb250U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZm9udFNpemU7XG4gICAgfVxuICAgIF9wcml2YXRlX19iYXNlRm9udCgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VGb250KHRoaXMuX3ByaXZhdGVfX2ZvbnRTaXplKCksIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuZm9udEZhbWlseSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19iYXNlQm9sZEZvbnQoKSB7XG4gICAgICAgIHJldHVybiBtYWtlRm9udCh0aGlzLl9wcml2YXRlX19mb250U2l6ZSgpLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLmZvbnRGYW1pbHksICdib2xkJyk7XG4gICAgfVxuICAgIF9wcml2YXRlX19nZXRSZW5kZXJlck9wdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yZW5kZXJlck9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfYm9yZGVyU2l6ZTogMSAvKiBDb25zdGFudHMuQm9yZGVyU2l6ZSAqLyxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfYmFzZWxpbmVPZmZzZXQ6IE5hTixcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfcGFkZGluZ1RvcDogTmFOLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9wYWRkaW5nQm90dG9tOiBOYU4sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3BhZGRpbmdIb3Jpem9udGFsOiBOYU4sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RpY2tMZW5ndGg6IDUgLyogQ29uc3RhbnRzLlRpY2tMZW5ndGggKi8sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2ZvbnRTaXplOiBOYU4sXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2ZvbnQ6ICcnLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF93aWR0aENhY2hlOiBuZXcgVGV4dFdpZHRoQ2FjaGUoKSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbGFiZWxCb3R0b21PZmZzZXQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgbmV3Rm9udCA9IHRoaXMuX3ByaXZhdGVfX2Jhc2VGb250KCk7XG4gICAgICAgIGlmIChyZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2ZvbnQgIT09IG5ld0ZvbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fcHJpdmF0ZV9fZm9udFNpemUoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfZm9udCA9IG5ld0ZvbnQ7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3BhZGRpbmdUb3AgPSAzICogZm9udFNpemUgLyAxMjtcbiAgICAgICAgICAgIHJlbmRlcmVyT3B0aW9ucy5faW50ZXJuYWxfcGFkZGluZ0JvdHRvbSA9IDMgKiBmb250U2l6ZSAvIDEyO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9wYWRkaW5nSG9yaXpvbnRhbCA9IDkgKiBmb250U2l6ZSAvIDEyO1xuICAgICAgICAgICAgcmVuZGVyZXJPcHRpb25zLl9pbnRlcm5hbF9iYXNlbGluZU9mZnNldCA9IDA7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX2xhYmVsQm90dG9tT2Zmc2V0ID0gNCAqIGZvbnRTaXplIC8gMTI7XG4gICAgICAgICAgICByZW5kZXJlck9wdGlvbnMuX2ludGVybmFsX3dpZHRoQ2FjaGUuX2ludGVybmFsX3Jlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucztcbiAgICB9XG4gICAgX3ByaXZhdGVfX3NldEN1cnNvcih0eXBlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NlbGwuc3R5bGUuY3Vyc29yID0gdHlwZSA9PT0gMSAvKiBDdXJzb3JUeXBlLkV3UmVzaXplICovID8gJ2V3LXJlc2l6ZScgOiAnZGVmYXVsdCc7XG4gICAgfVxuICAgIF9wcml2YXRlX19yZWNyZWF0ZVN0dWJzKCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Ll9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbW9kZWwuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmxlZnRQcmljZVNjYWxlLnZpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViQ2VsbC5yZW1vdmVDaGlsZCh0aGlzLl9wcml2YXRlX19sZWZ0U3R1Yi5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sZWZ0U3R1YiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnJpZ2h0UHJpY2VTY2FsZS52aXNpYmxlICYmIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViQ2VsbC5yZW1vdmVDaGlsZCh0aGlzLl9wcml2YXRlX19yaWdodFN0dWIuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIgPSB0aGlzLl9wcml2YXRlX19jaGFydC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcmVuZGVyZXJPcHRpb25zUHJvdmlkZXIoKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3JlbmRlcmVyT3B0aW9uc1Byb3ZpZGVyOiByZW5kZXJlck9wdGlvbnNQcm92aWRlcixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm9yZGVyVmlzaWJsZUdldHRlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmxlZnRQcmljZVNjYWxlLmJvcmRlclZpc2libGUgJiYgbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9vcHRpb25zKCkuYm9yZGVyVmlzaWJsZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm90dG9tQ29sb3JHZXR0ZXIgPSAoKSA9PiBtb2RlbC5faW50ZXJuYWxfYmFja2dyb3VuZEJvdHRvbUNvbG9yKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZnRQcmljZVNjYWxlLnZpc2libGUgJiYgdGhpcy5fcHJpdmF0ZV9fbGVmdFN0dWIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViID0gbmV3IFByaWNlQXhpc1N0dWIoJ2xlZnQnLCBvcHRpb25zLCBwYXJhbXMsIGJvcmRlclZpc2libGVHZXR0ZXIsIGJvdHRvbUNvbG9yR2V0dGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xlZnRTdHViQ2VsbC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19sZWZ0U3R1Yi5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yaWdodFByaWNlU2NhbGUudmlzaWJsZSAmJiB0aGlzLl9wcml2YXRlX19yaWdodFN0dWIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JpZ2h0U3R1YiA9IG5ldyBQcmljZUF4aXNTdHViKCdyaWdodCcsIG9wdGlvbnMsIHBhcmFtcywgYm9yZGVyVmlzaWJsZUdldHRlciwgYm90dG9tQ29sb3JHZXR0ZXIpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRTdHViQ2VsbC5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19yaWdodFN0dWIuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHdpbmRvd3NDaHJvbWUgPSBpc0Nocm9taXVtQmFzZWQoKSAmJiBpc1dpbmRvd3MoKTtcbmNsYXNzIENoYXJ0V2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIG9wdGlvbnMsIGhvcnpTY2FsZUJlaGF2aW9yKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVTZXBhcmF0b3JzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdSYWZJZCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmlnaHRQcmljZUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1BsYW5uZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZCA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Vyc29yU3R5bGVPdmVycmlkZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yID0gaG9yelNjYWxlQmVoYXZpb3I7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0di1saWdodHdlaWdodC1jaGFydHMnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LnN0eWxlLmRpcmVjdGlvbiA9ICdsdHInO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgZGlzYWJsZVNlbGVjdGlvbih0aGlzLl9wcml2YXRlX19lbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFibGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGFibGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2VsbHNwYWNpbmcnLCAnMCcpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29uV2hlZWxCb3VuZCA9IHRoaXMuX3ByaXZhdGVfX29uTW91c2V3aGVlbC5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAoc2hvdWxkU3Vic2NyaWJlTW91c2VXaGVlbCh0aGlzLl9wcml2YXRlX19vcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0TW91c2VXaGVlbEV2ZW50TGlzdGVuZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwgPSBuZXcgQ2hhcnRNb2RlbCh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlSGFuZGxlci5iaW5kKHRoaXMpLCB0aGlzLl9wcml2YXRlX19vcHRpb25zLCBob3J6U2NhbGVCZWhhdmlvcik7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2Nyb3NzaGFpck1vdmVkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblBhbmVXaWRnZXRDcm9zc2hhaXJNb3ZlZC5iaW5kKHRoaXMpLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQgPSBuZXcgVGltZUF4aXNXaWRnZXQodGhpcywgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YWJsZUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgIGNvbnN0IHVzZWRPYnNlcnZlciA9IG9wdGlvbnMuYXV0b1NpemUgJiYgdGhpcy5fcHJpdmF0ZV9faW5zdGFsbE9ic2VydmVyKCk7XG4gICAgICAgIC8vIG9ic2VydmVyIGNvdWxkIG5vdCBmaXJlIGV2ZW50IGltbWVkaWF0ZWx5IGZvciBzb21lIGNhc2VzXG4gICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gc2V0IGluaXRpYWwgc2l6ZSBtYW51YWxseVxuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLndpZHRoO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIC8vIGlnbm9yZSB3aWR0aC9oZWlnaHQgb3B0aW9ucyBpZiBvYnNlcnZlciBoYXMgYWN0dWFsbHkgYmVlbiB1c2VkXG4gICAgICAgIC8vIGhvd2V2ZXIgcmVzcGVjdCBvcHRpb25zIGlmIGluc3RhbGxpbmcgcmVzaXplIG9ic2VydmVyIGZhaWxlZFxuICAgICAgICBpZiAodXNlZE9ic2VydmVyIHx8IHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHdpZHRoID0gd2lkdGggfHwgY29udGFpbmVyUmVjdC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBjb250YWluZXJSZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCRVdBUkU6IHJlc2l6ZSBtdXN0IGJlIGNhbGxlZCBCRUZPUkUgX3N5bmNHdWlXaXRoTW9kZWwgKGluIGNvbnN0cnVjdG9yIG9ubHkpXG4gICAgICAgIC8vIG9yIGFmdGVyIGJ1dCB3aXRoIGFkanVzdFNpemUgdG8gcHJvcGVybHkgdXBkYXRlIHRpbWUgc2NhbGVcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zeW5jR3VpV2l0aE1vZGVsKCk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9wcml2YXRlX19lbGVtZW50KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlVGltZUF4aXNWaXNpYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfb3B0aW9uc0FwcGxpZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9mdWxsVXBkYXRlLmJpbmQodGhpcy5fcHJpdmF0ZV9fbW9kZWwpLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3ByaWNlU2NhbGVzT3B0aW9uc0NoYW5nZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9mdWxsVXBkYXRlLmJpbmQodGhpcy5fcHJpdmF0ZV9fbW9kZWwpLCB0aGlzKTtcbiAgICB9XG4gICAgX2ludGVybmFsX21vZGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbW9kZWw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9vcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucztcbiAgICB9XG4gICAgX2ludGVybmFsX3BhbmVXaWRnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF90aW1lQXhpc1dpZGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2V0TW91c2VXaGVlbEV2ZW50TGlzdGVuZXIoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZHJhd1JhZklkICE9PSAwKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcHJpdmF0ZV9fZHJhd1JhZklkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfY3Jvc3NoYWlyTW92ZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfb3B0aW9uc0FwcGxpZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9wcmljZVNjYWxlc09wdGlvbnNDaGFuZ2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhbmVXaWRnZXQgb2YgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5yZW1vdmVDaGlsZChwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfY2xpY2tlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX2RibENsaWNrZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYW5lU2VwYXJhdG9yIG9mIHRoaXMuX3ByaXZhdGVfX3BhbmVTZXBhcmF0b3JzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kZXN0cm95U2VwYXJhdG9yKHBhbmVTZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVTZXBhcmF0b3JzID0gW107XG4gICAgICAgIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQpLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19lbGVtZW50LnBhcmVudEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9wcml2YXRlX19lbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja2VkLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdW5pbnN0YWxsT2JzZXJ2ZXIoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBmb3JjZVJlcGFpbnQgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faGVpZ2h0ID09PSBoZWlnaHQgJiYgdGhpcy5fcHJpdmF0ZV9fd2lkdGggPT09IHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZUhpbnQgPSBzdWdnZXN0Q2hhcnRTaXplKHNpemUkMSh7IHdpZHRoLCBoZWlnaHQgfSkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19oZWlnaHQgPSBzaXplSGludC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3dpZHRoID0gc2l6ZUhpbnQud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodFN0ciA9IHRoaXMuX3ByaXZhdGVfX2hlaWdodCArICdweCc7XG4gICAgICAgIGNvbnN0IHdpZHRoU3RyID0gdGhpcy5fcHJpdmF0ZV9fd2lkdGggKyAncHgnO1xuICAgICAgICBlbnN1cmVOb3ROdWxsKHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQpLnN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICAgICAgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19lbGVtZW50KS5zdHlsZS53aWR0aCA9IHdpZHRoU3RyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YWJsZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0U3RyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YWJsZUVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgICAgaWYgKGZvcmNlUmVwYWludCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0ltcGwoSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2Z1bGwoKSwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFpbnQoaW52YWxpZGF0ZU1hc2spIHtcbiAgICAgICAgaWYgKGludmFsaWRhdGVNYXNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGludmFsaWRhdGVNYXNrID0gSW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2Z1bGwoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0c1tpXS5faW50ZXJuYWxfcGFpbnQoaW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2ludmFsaWRhdGVGb3JQYW5lKGkpLl9pbnRlcm5hbF9sZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGltZVNjYWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9wYWludChpbnZhbGlkYXRlTWFzay5faW50ZXJuYWxfZnVsbEludmFsaWRhdGlvbigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY3VycmVudGx5SGFzTW91c2VXaGVlbExpc3RlbmVyID0gc2hvdWxkU3Vic2NyaWJlTW91c2VXaGVlbCh0aGlzLl9wcml2YXRlX19vcHRpb25zKTtcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBtZXJnZSBvcHRpb25zIGhlcmUgYmVjYXVzZSBpdCdzIGRvbmUgaW4gY2hhcnQgbW9kZWxcbiAgICAgICAgLy8gYW5kIHNpbmNlIGJvdGggbW9kZWwgYW5kIHdpZGdldCBzaGFyZSB0aGUgc2FtZSBvYmplY3QgaXQgd2lsbCBiZSBkb25lIGF1dG9tYXRpY2FsbHkgZm9yIHdpZGdldCBhcyB3ZWxsXG4gICAgICAgIC8vIG5vdCBpZGVhbCBzb2x1dGlvbiBmb3Igc3VyZSwgYnV0IGl0IHdvcmsncyBmb3Igbm93IMKvXFxfKOODhClfL8KvXG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHNob3VsZEhhdmVNb3VzZVdoZWVsTGlzdGVuZXIgPSBzaG91bGRTdWJzY3JpYmVNb3VzZVdoZWVsKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMpO1xuICAgICAgICBpZiAoc2hvdWxkSGF2ZU1vdXNlV2hlZWxMaXN0ZW5lciAhPT0gY3VycmVudGx5SGFzTW91c2VXaGVlbExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19zZXRNb3VzZVdoZWVsRXZlbnRMaXN0ZW5lcihzaG91bGRIYXZlTW91c2VXaGVlbExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uc1snbGF5b3V0J10/LnBhbmVzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseVBhbmVzT3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZVRpbWVBeGlzVmlzaWJpbGl0eSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19hcHBseUF1dG9TaXplT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2NsaWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jbGlja2VkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGJsQ2xpY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9jcm9zc2hhaXJNb3ZlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdGFrZVNjcmVlbnNob3QoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0ltcGwodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2ssIHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JlZXNob3RCaXRtYXBTaXplID0gdGhpcy5fcHJpdmF0ZV9fdHJhdmVyc2VMYXlvdXQobnVsbCk7XG4gICAgICAgIGNvbnN0IHNjcmVlbnNob3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgc2NyZWVuc2hvdENhbnZhcy53aWR0aCA9IHNjcmVlc2hvdEJpdG1hcFNpemUud2lkdGg7XG4gICAgICAgIHNjcmVlbnNob3RDYW52YXMuaGVpZ2h0ID0gc2NyZWVzaG90Qml0bWFwU2l6ZS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGN0eCA9IGVuc3VyZU5vdE51bGwoc2NyZWVuc2hvdENhbnZhcy5nZXRDb250ZXh0KCcyZCcpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdHJhdmVyc2VMYXlvdXQoY3R4KTtcbiAgICAgICAgcmV0dXJuIHNjcmVlbnNob3RDYW52YXM7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9nZXRQcmljZUF4aXNXaWR0aChwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IFwibGVmdFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuTGVmdCAqLyAmJiAhdGhpcy5fcHJpdmF0ZV9faXNMZWZ0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSBcInJpZ2h0XCIgLyogRGVmYXVsdFByaWNlU2NhbGVJZC5SaWdodCAqLyAmJiAhdGhpcy5fcHJpdmF0ZV9faXNSaWdodEF4aXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgZXhhY3RseSBwYW5lIHdpZGdldCBoZXJlXG4gICAgICAgIC8vIGJlY2F1c2UgYWxsIHBhbmUgd2lkZ2V0cyBoYXZlIHRoZSBzYW1lIHdpZHRoIG9mIHByaWNlIGF4aXMgd2lkZ2V0XG4gICAgICAgIC8vIHNlZSBfYWRqdXN0U2l6ZUltcGxcbiAgICAgICAgY29uc3QgcHJpY2VBeGlzV2lkZ2V0ID0gcG9zaXRpb24gPT09IFwibGVmdFwiIC8qIERlZmF1bHRQcmljZVNjYWxlSWQuTGVmdCAqL1xuICAgICAgICAgICAgPyB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0c1swXS5faW50ZXJuYWxfbGVmdFByaWNlQXhpc1dpZGdldCgpXG4gICAgICAgICAgICA6IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzWzBdLl9pbnRlcm5hbF9yaWdodFByaWNlQXhpc1dpZGdldCgpO1xuICAgICAgICByZXR1cm4gZW5zdXJlTm90TnVsbChwcmljZUF4aXNXaWRnZXQpLl9pbnRlcm5hbF9nZXRXaWR0aCgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXV0b1NpemVBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zLmF1dG9TaXplICYmIHRoaXMuX3ByaXZhdGVfX29ic2VydmVyICE9PSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQ7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRDdXJzb3JTdHlsZShzdHlsZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jdXJzb3JTdHlsZU92ZXJyaWRlID0gc3R5bGU7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jdXJzb3JTdHlsZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9lbGVtZW50KCkuc3R5bGUuc2V0UHJvcGVydHkoJ2N1cnNvcicsIHN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2VsZW1lbnQoKS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY3Vyc29yJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ludGVybmFsX2dldEN1cnNvck92ZXJyaWRlU3R5bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jdXJzb3JTdHlsZU92ZXJyaWRlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfcGFuZVNpemUocGFuZUluZGV4KSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzW3BhbmVJbmRleF0pLl9pbnRlcm5hbF9nZXRTaXplKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19hcHBseVBhbmVzT3B0aW9ucygpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVNlcGFyYXRvcnMuZm9yRWFjaCgoc2VwYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICBzZXBhcmF0b3IuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBfcHJpdmF0ZV9fYXBwbHlBdXRvU2l6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvU2l6ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3ByaXZhdGVfX29ic2VydmVyICYmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYFlvdSBzaG91bGQgdHVybiBhdXRvU2l6ZSBvZmYgZXhwbGljaXRseSBiZWZvcmUgc3BlY2lmeWluZyBzaXplczsgdHJ5IGFkZGluZyBvcHRpb25zLmF1dG9TaXplOiBmYWxzZSB0byBuZXcgb3B0aW9uc2ApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9TaXplICYmICF0aGlzLl9wcml2YXRlX19vYnNlcnZlcikge1xuICAgICAgICAgICAgLy8gaW5zdGFsbGluZyBvYnNlcnZlciB3aWxsIG92ZXJyaWRlIHJlc2l6ZSBpZiBzdWNjZXNzZnVsXG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnN0YWxsT2JzZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hdXRvU2l6ZSA9PT0gZmFsc2UgJiYgdGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VuaW5zdGFsbE9ic2VydmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmF1dG9TaXplICYmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3Jlc2l6ZShvcHRpb25zLndpZHRoIHx8IHRoaXMuX3ByaXZhdGVfX3dpZHRoLCBvcHRpb25zLmhlaWdodCB8fCB0aGlzLl9wcml2YXRlX19oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyB0aGUgd2lkZ2V0J3MgbGF5b3V0IChwYW5lIGFuZCBheGlzIGNoaWxkIHdpZGdldHMpLFxuICAgICAqIGRyYXdzIHRoZSBzY3JlZW5zaG90IChpZiByZW5kZXJpbmcgY29udGV4dCBpcyBwYXNzZWQpIGFuZCByZXR1cm5zIHRoZSBzY3JlZW5zaG90IGJpdG1hcCBzaXplXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3R4IC0gaWYgcGFzc2VkLCB1c2VkIHRvIGRyYXcgdGhlIHNjcmVlbnNob3Qgb2Ygd2lkZ2V0XG4gICAgICogQHJldHVybnMgc2NyZWVuc2hvdCBiaXRtYXAgc2l6ZVxuICAgICAqL1xuICAgIF9wcml2YXRlX190cmF2ZXJzZUxheW91dChjdHgpIHtcbiAgICAgICAgbGV0IHRvdGFsV2lkdGggPSAwO1xuICAgICAgICBsZXQgdG90YWxIZWlnaHQgPSAwO1xuICAgICAgICBjb25zdCBmaXJzdFBhbmUgPSB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0c1swXTtcbiAgICAgICAgY29uc3QgZHJhd1ByaWNlQXhpc2VzID0gKHBvc2l0aW9uLCB0YXJnZXRYKSA9PiB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0WSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBwYW5lSW5kZXggPSAwOyBwYW5lSW5kZXggPCB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cy5sZW5ndGg7IHBhbmVJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZVdpZGdldCA9IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzW3BhbmVJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpY2VBeGlzV2lkZ2V0ID0gZW5zdXJlTm90TnVsbChwb3NpdGlvbiA9PT0gJ2xlZnQnID8gcGFuZVdpZGdldC5faW50ZXJuYWxfbGVmdFByaWNlQXhpc1dpZGdldCgpIDogcGFuZVdpZGdldC5faW50ZXJuYWxfcmlnaHRQcmljZUF4aXNXaWRnZXQoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0bWFwU2l6ZSA9IHByaWNlQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpY2VBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9kcmF3Qml0bWFwKGN0eCwgdGFyZ2V0WCwgdGFyZ2V0WSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldFkgKz0gYml0bWFwU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmVJbmRleCA8IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVNlcGFyYXRvcnNbcGFuZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yQml0bWFwU2l6ZSA9IHNlcGFyYXRvci5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IuX2ludGVybmFsX2RyYXdCaXRtYXAoY3R4LCB0YXJnZXRYLCB0YXJnZXRZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRZICs9IHNlcGFyYXRvckJpdG1hcFNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZHJhdyBsZWZ0IHByaWNlIHNjYWxlIGlmIGV4aXN0c1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNMZWZ0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgZHJhd1ByaWNlQXhpc2VzKCdsZWZ0JywgMCk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0QXhpc0JpdG1hcFdpZHRoID0gZW5zdXJlTm90TnVsbChmaXJzdFBhbmUuX2ludGVybmFsX2xlZnRQcmljZUF4aXNXaWRnZXQoKSkuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKS53aWR0aDtcbiAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gbGVmdEF4aXNCaXRtYXBXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwYW5lSW5kZXggPSAwOyBwYW5lSW5kZXggPCB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cy5sZW5ndGg7IHBhbmVJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYW5lV2lkZ2V0ID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHNbcGFuZUluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGJpdG1hcFNpemUgPSBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9nZXRCaXRtYXBTaXplKCk7XG4gICAgICAgICAgICBpZiAoY3R4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfZHJhd0JpdG1hcChjdHgsIHRvdGFsV2lkdGgsIHRvdGFsSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvdGFsSGVpZ2h0ICs9IGJpdG1hcFNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHBhbmVJbmRleCA8IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSB0aGlzLl9wcml2YXRlX19wYW5lU2VwYXJhdG9yc1twYW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvckJpdG1hcFNpemUgPSBzZXBhcmF0b3IuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5faW50ZXJuYWxfZHJhd0JpdG1hcChjdHgsIHRvdGFsV2lkdGgsIHRvdGFsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gc2VwYXJhdG9yQml0bWFwU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RQYW5lQml0bWFwV2lkdGggPSBmaXJzdFBhbmUuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKS53aWR0aDtcbiAgICAgICAgdG90YWxXaWR0aCArPSBmaXJzdFBhbmVCaXRtYXBXaWR0aDtcbiAgICAgICAgLy8gZHJhdyByaWdodCBwcmljZSBzY2FsZSBpZiBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzUmlnaHRBeGlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICBkcmF3UHJpY2VBeGlzZXMoJ3JpZ2h0JywgdG90YWxXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCByaWdodEF4aXNCaXRtYXBXaWR0aCA9IGVuc3VyZU5vdE51bGwoZmlyc3RQYW5lLl9pbnRlcm5hbF9yaWdodFByaWNlQXhpc1dpZGdldCgpKS5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpLndpZHRoO1xuICAgICAgICAgICAgdG90YWxXaWR0aCArPSByaWdodEF4aXNCaXRtYXBXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcmF3U3R1YiA9IChwb3NpdGlvbiwgdGFyZ2V0WCwgdGFyZ2V0WSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3R1YiA9IGVuc3VyZU5vdE51bGwocG9zaXRpb24gPT09ICdsZWZ0JyA/IHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9sZWZ0U3R1YigpIDogdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX3JpZ2h0U3R1YigpKTtcbiAgICAgICAgICAgIHN0dWIuX2ludGVybmFsX2RyYXdCaXRtYXAoZW5zdXJlTm90TnVsbChjdHgpLCB0YXJnZXRYLCB0YXJnZXRZKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZHJhdyB0aW1lIHNjYWxlIGFuZCBzdHVic1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy50aW1lU2NhbGUudmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgdGltZUF4aXNCaXRtYXBTaXplID0gdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX2dldEJpdG1hcFNpemUoKTtcbiAgICAgICAgICAgIGlmIChjdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0WCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzTGVmdEF4aXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd1N0dWIoJ2xlZnQnLCB0YXJnZXRYLCB0b3RhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFggPSBlbnN1cmVOb3ROdWxsKGZpcnN0UGFuZS5faW50ZXJuYWxfbGVmdFByaWNlQXhpc1dpZGdldCgpKS5faW50ZXJuYWxfZ2V0Qml0bWFwU2l6ZSgpLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfZHJhd0JpdG1hcChjdHgsIHRhcmdldFgsIHRvdGFsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0YXJnZXRYICs9IHRpbWVBeGlzQml0bWFwU2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNSaWdodEF4aXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd1N0dWIoJ3JpZ2h0JywgdGFyZ2V0WCwgdG90YWxIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvdGFsSGVpZ2h0ICs9IHRpbWVBeGlzQml0bWFwU2l6ZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemUkMSh7XG4gICAgICAgICAgICB3aWR0aDogdG90YWxXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdG90YWxIZWlnaHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIF9wcml2YXRlX19hZGp1c3RTaXplSW1wbCgpIHtcbiAgICAgICAgbGV0IHRvdGFsU3RyZXRjaCA9IDA7XG4gICAgICAgIGxldCBsZWZ0UHJpY2VBeGlzV2lkdGggPSAwO1xuICAgICAgICBsZXQgcmlnaHRQcmljZUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcGFuZVdpZGdldCBvZiB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2lzTGVmdEF4aXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBsZWZ0UHJpY2VBeGlzV2lkdGggPSBNYXRoLm1heChsZWZ0UHJpY2VBeGlzV2lkdGgsIGVuc3VyZU5vdE51bGwocGFuZVdpZGdldC5faW50ZXJuYWxfbGVmdFByaWNlQXhpc1dpZGdldCgpKS5faW50ZXJuYWxfb3B0aW1hbFdpZHRoKCksIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubGVmdFByaWNlU2NhbGUubWluaW11bVdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc1JpZ2h0QXhpc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0UHJpY2VBeGlzV2lkdGggPSBNYXRoLm1heChyaWdodFByaWNlQXhpc1dpZHRoLCBlbnN1cmVOb3ROdWxsKHBhbmVXaWRnZXQuX2ludGVybmFsX3JpZ2h0UHJpY2VBeGlzV2lkZ2V0KCkpLl9pbnRlcm5hbF9vcHRpbWFsV2lkdGgoKSwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5yaWdodFByaWNlU2NhbGUubWluaW11bVdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvdGFsU3RyZXRjaCArPSBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9zdHJldGNoRmFjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVmdFByaWNlQXhpc1dpZHRoID0gc3VnZ2VzdFByaWNlU2NhbGVXaWR0aChsZWZ0UHJpY2VBeGlzV2lkdGgpO1xuICAgICAgICByaWdodFByaWNlQXhpc1dpZHRoID0gc3VnZ2VzdFByaWNlU2NhbGVXaWR0aChyaWdodFByaWNlQXhpc1dpZHRoKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl9wcml2YXRlX193aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5fcHJpdmF0ZV9faGVpZ2h0O1xuICAgICAgICBjb25zdCBwYW5lV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIGxlZnRQcmljZUF4aXNXaWR0aCAtIHJpZ2h0UHJpY2VBeGlzV2lkdGgsIDApO1xuICAgICAgICBjb25zdCBzZXBhcmF0b3JDb3VudCA9IHRoaXMuX3ByaXZhdGVfX3BhbmVTZXBhcmF0b3JzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9ySGVpZ2h0ID0gMSAvKiBTZXBhcmF0b3JDb25zdGFudHMuU2VwYXJhdG9ySGVpZ2h0ICovO1xuICAgICAgICBjb25zdCBzZXBhcmF0b3JzSGVpZ2h0ID0gc2VwYXJhdG9ySGVpZ2h0ICogc2VwYXJhdG9yQ291bnQ7XG4gICAgICAgIGNvbnN0IHRpbWVBeGlzVmlzaWJsZSA9IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGltZVNjYWxlLnZpc2libGU7XG4gICAgICAgIGxldCB0aW1lQXhpc0hlaWdodCA9IHRpbWVBeGlzVmlzaWJsZSA/IE1hdGgubWF4KHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9vcHRpbWFsSGVpZ2h0KCksIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudGltZVNjYWxlLm1pbmltdW1IZWlnaHQpIDogMDtcbiAgICAgICAgdGltZUF4aXNIZWlnaHQgPSBzdWdnZXN0VGltZVNjYWxlSGVpZ2h0KHRpbWVBeGlzSGVpZ2h0KTtcbiAgICAgICAgY29uc3Qgb3RoZXJXaWRnZXRIZWlnaHQgPSBzZXBhcmF0b3JzSGVpZ2h0ICsgdGltZUF4aXNIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHRvdGFsUGFuZUhlaWdodCA9IGhlaWdodCA8IG90aGVyV2lkZ2V0SGVpZ2h0ID8gMCA6IGhlaWdodCAtIG90aGVyV2lkZ2V0SGVpZ2h0O1xuICAgICAgICBjb25zdCBzdHJldGNoUGl4ZWxzID0gdG90YWxQYW5lSGVpZ2h0IC8gdG90YWxTdHJldGNoO1xuICAgICAgICBsZXQgYWNjdW11bGF0ZWRIZWlnaHQgPSAwO1xuICAgICAgICBjb25zdCBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgZm9yIChsZXQgcGFuZUluZGV4ID0gMDsgcGFuZUluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMubGVuZ3RoOyArK3BhbmVJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgcGFuZVdpZGdldCA9IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzW3BhbmVJbmRleF07XG4gICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9zZXRTdGF0ZSh0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfcGFuZXMoKVtwYW5lSW5kZXhdKTtcbiAgICAgICAgICAgIGxldCBwYW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGxldCBjYWxjdWxhdGVQYW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGlmIChwYW5lSW5kZXggPT09IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVQYW5lSGVpZ2h0ID0gTWF0aC5jZWlsKCh0b3RhbFBhbmVIZWlnaHQgLSBhY2N1bXVsYXRlZEhlaWdodCkgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVQYW5lSGVpZ2h0ID0gTWF0aC5yb3VuZChwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9zdHJldGNoRmFjdG9yKCkgKiBzdHJldGNoUGl4ZWxzICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFuZUhlaWdodCA9IE1hdGgubWF4KGNhbGN1bGF0ZVBhbmVIZWlnaHQsIDIpO1xuICAgICAgICAgICAgYWNjdW11bGF0ZWRIZWlnaHQgKz0gcGFuZUhlaWdodDtcbiAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX3NldFNpemUoc2l6ZSQxKHsgd2lkdGg6IHBhbmVXaWR0aCwgaGVpZ2h0OiBwYW5lSGVpZ2h0IH0pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pc0xlZnRBeGlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfc2V0UHJpY2VBeGlzU2l6ZShsZWZ0UHJpY2VBeGlzV2lkdGgsICdsZWZ0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faXNSaWdodEF4aXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9zZXRQcmljZUF4aXNTaXplKHJpZ2h0UHJpY2VBeGlzV2lkdGgsICdyaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhbmVXaWRnZXQuX2ludGVybmFsX3N0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0UGFuZUhlaWdodChwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9zdGF0ZSgpLCBwYW5lSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfc2V0U2l6ZXMoc2l6ZSQxKHsgd2lkdGg6IHRpbWVBeGlzVmlzaWJsZSA/IHBhbmVXaWR0aCA6IDAsIGhlaWdodDogdGltZUF4aXNIZWlnaHQgfSksIHRpbWVBeGlzVmlzaWJsZSA/IGxlZnRQcmljZUF4aXNXaWR0aCA6IDAsIHRpbWVBeGlzVmlzaWJsZSA/IHJpZ2h0UHJpY2VBeGlzV2lkdGggOiAwKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3NldFdpZHRoKHBhbmVXaWR0aCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19sZWZ0UHJpY2VBeGlzV2lkdGggIT09IGxlZnRQcmljZUF4aXNXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGVmdFByaWNlQXhpc1dpZHRoID0gbGVmdFByaWNlQXhpc1dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZHRoICE9PSByaWdodFByaWNlQXhpc1dpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yaWdodFByaWNlQXhpc1dpZHRoID0gcmlnaHRQcmljZUF4aXNXaWR0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fc2V0TW91c2VXaGVlbEV2ZW50TGlzdGVuZXIoYWRkKSB7XG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9wcml2YXRlX19vbldoZWVsQm91bmQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX3ByaXZhdGVfX29uV2hlZWxCb3VuZCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kZXRlcm1pbmVXaGVlbFNwZWVkQWRqdXN0bWVudChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmRlbHRhTW9kZSkge1xuICAgICAgICAgICAgY2FzZSBldmVudC5ET01fREVMVEFfUEFHRTpcbiAgICAgICAgICAgICAgICAvLyBvbmUgc2NyZWVuIGF0IHRpbWUgc2Nyb2xsIG1vZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gMTIwO1xuICAgICAgICAgICAgY2FzZSBldmVudC5ET01fREVMVEFfTElORTpcbiAgICAgICAgICAgICAgICAvLyBvbmUgbGluZSBhdCB0aW1lIHNjcm9sbCBtb2RlXG4gICAgICAgICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2luZG93c0Nocm9tZSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hyb21pdW0gb24gV2luZG93cyBoYXMgYSBidWcgd2hlcmUgdGhlIHNjcm9sbCBzcGVlZCBpc24ndCBjb3JyZWN0bHlcbiAgICAgICAgLy8gYWRqdXN0ZWQgZm9yIGhpZ2ggZGVuc2l0eSBkaXNwbGF5cy4gV2UgbmVlZCB0byBjb3JyZWN0IGZvciB0aGlzIHNvIHRoYXRcbiAgICAgICAgLy8gc2Nyb2xsIHNwZWVkIGlzIGNvbnNpc3RlbnQgYmV0d2VlbiBicm93c2Vycy5cbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAwMTczNVxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjA3MzA4XG4gICAgICAgIHJldHVybiAoMSAvIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX29uTW91c2V3aGVlbChldmVudCkge1xuICAgICAgICBpZiAoKGV2ZW50LmRlbHRhWCA9PT0gMCB8fCAhdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc1snaGFuZGxlU2Nyb2xsJ10ubW91c2VXaGVlbCkgJiZcbiAgICAgICAgICAgIChldmVudC5kZWx0YVkgPT09IDAgfHwgIXRoaXMuX3ByaXZhdGVfX29wdGlvbnNbJ2hhbmRsZVNjYWxlJ10ubW91c2VXaGVlbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JvbGxTcGVlZEFkanVzdG1lbnQgPSB0aGlzLl9wcml2YXRlX19kZXRlcm1pbmVXaGVlbFNwZWVkQWRqdXN0bWVudChldmVudCk7XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IHNjcm9sbFNwZWVkQWRqdXN0bWVudCAqIGV2ZW50LmRlbHRhWCAvIDEwMDtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gLShzY3JvbGxTcGVlZEFkanVzdG1lbnQgKiBldmVudC5kZWx0YVkgLyAxMDApO1xuICAgICAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGFZICE9PSAwICYmIHRoaXMuX3ByaXZhdGVfX29wdGlvbnNbJ2hhbmRsZVNjYWxlJ10ubW91c2VXaGVlbCkge1xuICAgICAgICAgICAgY29uc3Qgem9vbVNjYWxlID0gTWF0aC5zaWduKGRlbHRhWSkgKiBNYXRoLm1pbigxLCBNYXRoLmFicyhkZWx0YVkpKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuX3ByaXZhdGVfX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3pvb21UaW1lKHNjcm9sbFBvc2l0aW9uLCB6b29tU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YVggIT09IDAgJiYgdGhpcy5fcHJpdmF0ZV9fb3B0aW9uc1snaGFuZGxlU2Nyb2xsJ10ubW91c2VXaGVlbCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfc2Nyb2xsQ2hhcnQoZGVsdGFYICogLTgwKTsgLy8gODAgaXMgYSBtYWRlIHVwIGNvZWZmaWNpZW50LCBhbmQgbWludXMgaXMgZm9yIHRoZSBcIm5hdHVyYWxcIiBzY3JvbGxcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0ltcGwoaW52YWxpZGF0ZU1hc2ssIHRpbWUpIHtcbiAgICAgICAgY29uc3QgaW52YWxpZGF0aW9uVHlwZSA9IGludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9mdWxsSW52YWxpZGF0aW9uKCk7XG4gICAgICAgIC8vIGFjdGlvbnMgZm9yIGZ1bGwgaW52YWxpZGF0aW9uIE9OTFkgKG5vdCBzaGFyZWQgd2l0aCBsaWdodClcbiAgICAgICAgaWYgKGludmFsaWRhdGlvblR5cGUgPT09IDMgLyogSW52YWxpZGF0aW9uTGV2ZWwuRnVsbCAqLykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlR3VpKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGlnaHQgb3IgZnVsbCBpbnZhbGlkYXRlIGFjdGlvbnNcbiAgICAgICAgaWYgKGludmFsaWRhdGlvblR5cGUgPT09IDMgLyogSW52YWxpZGF0aW9uTGV2ZWwuRnVsbCAqLyB8fFxuICAgICAgICAgICAgaW52YWxpZGF0aW9uVHlwZSA9PT0gMiAvKiBJbnZhbGlkYXRpb25MZXZlbC5MaWdodCAqLykge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXBwbHlNb21lbnRhcnlBdXRvU2NhbGUoaW52YWxpZGF0ZU1hc2spO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXBwbHlUaW1lU2NhbGVJbnZhbGlkYXRpb25zKGludmFsaWRhdGVNYXNrLCB0aW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmZvckVhY2goKHBhbmUpID0+IHtcbiAgICAgICAgICAgICAgICBwYW5lLl9pbnRlcm5hbF91cGRhdGVQcmljZUF4aXNXaWRnZXRzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIGEgZnVsbCBpbnZhbGlkYXRpb24gaGFzIGJlZW4gcG9zdHBvbmVkIGR1cmluZyB0aGUgZHJhdywgcmVhcHBseVxuICAgICAgICAgICAgLy8gdGhlIHRpbWVzY2FsZSBpbnZhbGlkYXRpb25zLiBBIGZ1bGwgaW52YWxpZGF0aW9uIHdvdWxkIG1lYW4gdGhlcmUgaXMgYSBjaGFuZ2VcbiAgICAgICAgICAgIC8vIGluIHRoZSB0aW1lc2NhbGUgd2lkdGggKGNhdXNlZCBieSBwcmljZSBzY2FsZSBjaGFuZ2VzKSB0aGF0IG5lZWRzIHRvIGJlIGRyYXduXG4gICAgICAgICAgICAvLyByaWdodCBhd2F5IHRvIGF2b2lkIGZsaWNrZXJpbmcuXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2s/Ll9pbnRlcm5hbF9mdWxsSW52YWxpZGF0aW9uKCkgPT09IDMgLyogSW52YWxpZGF0aW9uTGV2ZWwuRnVsbCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrLl9pbnRlcm5hbF9tZXJnZShpbnZhbGlkYXRlTWFzayk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlR3VpKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXBwbHlNb21lbnRhcnlBdXRvU2NhbGUodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2spO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2FwcGx5VGltZVNjYWxlSW52YWxpZGF0aW9ucyh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzaywgdGltZSk7XG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZU1hc2sgPSB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzaztcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcGFpbnQoaW52YWxpZGF0ZU1hc2spO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYXBwbHlUaW1lU2NhbGVJbnZhbGlkYXRpb25zKGludmFsaWRhdGVNYXNrLCB0aW1lKSB7XG4gICAgICAgIGZvciAoY29uc3QgdHNJbnZhbGlkYXRpb24gb2YgaW52YWxpZGF0ZU1hc2suX2ludGVybmFsX3RpbWVTY2FsZUludmFsaWRhdGlvbnMoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXBwbHlUaW1lU2NhbGVJbnZhbGlkYXRpb24odHNJbnZhbGlkYXRpb24sIHRpbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19hcHBseU1vbWVudGFyeUF1dG9TY2FsZShpbnZhbGlkYXRlTWFzaykge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9wYW5lcygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW52YWxpZGF0ZU1hc2suX2ludGVybmFsX2ludmFsaWRhdGVGb3JQYW5lKGkpLl9pbnRlcm5hbF9hdXRvU2NhbGUpIHtcbiAgICAgICAgICAgICAgICBwYW5lc1tpXS5faW50ZXJuYWxfbW9tZW50YXJ5QXV0b1NjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2FwcGx5VGltZVNjYWxlSW52YWxpZGF0aW9uKGludmFsaWRhdGlvbiwgdGltZSkge1xuICAgICAgICBjb25zdCB0aW1lU2NhbGUgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIHN3aXRjaCAoaW52YWxpZGF0aW9uLl9pbnRlcm5hbF90eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5GaXRDb250ZW50ICovOlxuICAgICAgICAgICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfZml0Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQXBwbHlSYW5nZSAqLzpcbiAgICAgICAgICAgICAgICB0aW1lU2NhbGUuX2ludGVybmFsX3NldExvZ2ljYWxSYW5nZShpbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBUaW1lU2NhbGVJbnZhbGlkYXRpb25UeXBlLkFwcGx5QmFyU3BhY2luZyAqLzpcbiAgICAgICAgICAgICAgICB0aW1lU2NhbGUuX2ludGVybmFsX3NldEJhclNwYWNpbmcoaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BcHBseVJpZ2h0T2Zmc2V0ICovOlxuICAgICAgICAgICAgICAgIHRpbWVTY2FsZS5faW50ZXJuYWxfc2V0UmlnaHRPZmZzZXQoaW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5SZXNldCAqLzpcbiAgICAgICAgICAgICAgICB0aW1lU2NhbGUuX2ludGVybmFsX3Jlc3RvcmVEZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDUgLyogVGltZVNjYWxlSW52YWxpZGF0aW9uVHlwZS5BbmltYXRpb24gKi86XG4gICAgICAgICAgICAgICAgaWYgKCFpbnZhbGlkYXRpb24uX2ludGVybmFsX3ZhbHVlLl9pbnRlcm5hbF9maW5pc2hlZCh0aW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lU2NhbGUuX2ludGVybmFsX3NldFJpZ2h0T2Zmc2V0KGludmFsaWRhdGlvbi5faW50ZXJuYWxfdmFsdWUuX2ludGVybmFsX2dldFBvc2l0aW9uKHRpbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2ludmFsaWRhdGVIYW5kbGVyKGludmFsaWRhdGVNYXNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2suX2ludGVybmFsX21lcmdlKGludmFsaWRhdGVNYXNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrID0gaW52YWxpZGF0ZU1hc2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19kcmF3UGxhbm5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1BsYW5uZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1JhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdQbGFubmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd1JhZklkID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZU1hc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFzayA9IHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVNYXNrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlTWFzayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdJbXBsKG1hc2ssIHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRzSW52YWxpZGF0aW9uIG9mIG1hc2suX2ludGVybmFsX3RpbWVTY2FsZUludmFsaWRhdGlvbnMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRzSW52YWxpZGF0aW9uLl9pbnRlcm5hbF90eXBlID09PSA1IC8qIFRpbWVTY2FsZUludmFsaWRhdGlvblR5cGUuQW5pbWF0aW9uICovICYmICF0c0ludmFsaWRhdGlvbi5faW50ZXJuYWxfdmFsdWUuX2ludGVybmFsX2ZpbmlzaGVkKHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfc2V0VGltZVNjYWxlQW5pbWF0aW9uKHRzSW52YWxpZGF0aW9uLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlR3VpKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zeW5jR3VpV2l0aE1vZGVsKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kZXN0cm95U2VwYXJhdG9yKHNlcGFyYXRvcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190YWJsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc2VwYXJhdG9yLl9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICBzZXBhcmF0b3IuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3N5bmNHdWlXaXRoTW9kZWwoKSB7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3BhbmVzKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldFBhbmVXaWRnZXRzQ291bnQgPSBwYW5lcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFjdHVhbFBhbmVXaWRnZXRzQ291bnQgPSB0aGlzLl9wcml2YXRlX19wYW5lV2lkZ2V0cy5sZW5ndGg7XG4gICAgICAgIC8vIFJlbW92ZSAoaWYgbmVlZGVkKSBwYW5lIHdpZGdldHMgYW5kIHNlcGFyYXRvcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHRhcmdldFBhbmVXaWRnZXRzQ291bnQ7IGkgPCBhY3R1YWxQYW5lV2lkZ2V0c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhbmVXaWRnZXQgPSBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLnBvcCgpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5yZW1vdmVDaGlsZChwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgcGFuZVdpZGdldC5faW50ZXJuYWxfY2xpY2tlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX2RibENsaWNrZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgICAgICBjb25zdCBwYW5lU2VwYXJhdG9yID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVNlcGFyYXRvcnMucG9wKCk7XG4gICAgICAgICAgICBpZiAocGFuZVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGVzdHJveVNlcGFyYXRvcihwYW5lU2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgKGlmIG5lZWRlZCkgbmV3IHBhbmUgd2lkZ2V0cyBhbmQgc2VwYXJhdG9yc1xuICAgICAgICBmb3IgKGxldCBpID0gYWN0dWFsUGFuZVdpZGdldHNDb3VudDsgaSA8IHRhcmdldFBhbmVXaWRnZXRzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFuZVdpZGdldCA9IG5ldyBQYW5lV2lkZ2V0KHRoaXMsIHBhbmVzW2ldKTtcbiAgICAgICAgICAgIHBhbmVXaWRnZXQuX2ludGVybmFsX2NsaWNrZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHRoaXMuX3ByaXZhdGVfX29uUGFuZVdpZGdldENsaWNrZWQuYmluZCh0aGlzLCBwYW5lV2lkZ2V0KSwgdGhpcyk7XG4gICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9kYmxDbGlja2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblBhbmVXaWRnZXREYmxDbGlja2VkLmJpbmQodGhpcywgcGFuZVdpZGdldCksIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHMucHVzaChwYW5lV2lkZ2V0KTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbmQgaW5zZXJ0IHNlcGFyYXRvclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZVNlcGFyYXRvciA9IG5ldyBQYW5lU2VwYXJhdG9yKHRoaXMsIGkgLSAxLCBpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lU2VwYXJhdG9ycy5wdXNoKHBhbmVTZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3RhYmxlRWxlbWVudC5pbnNlcnRCZWZvcmUocGFuZVNlcGFyYXRvci5faW50ZXJuYWxfZ2V0RWxlbWVudCgpLCB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldC5faW50ZXJuYWxfZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluc2VydCBwYW5lV2lkZ2V0XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190YWJsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKHBhbmVXaWRnZXQuX2ludGVybmFsX2dldEVsZW1lbnQoKSwgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX2dldEVsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRQYW5lV2lkZ2V0c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gcGFuZXNbaV07XG4gICAgICAgICAgICBjb25zdCBwYW5lV2lkZ2V0ID0gdGhpcy5fcHJpdmF0ZV9fcGFuZVdpZGdldHNbaV07XG4gICAgICAgICAgICBpZiAocGFuZVdpZGdldC5faW50ZXJuYWxfc3RhdGUoKSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF9zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYW5lV2lkZ2V0Ll9pbnRlcm5hbF91cGRhdGVQcmljZUF4aXNXaWRnZXRzU3RhdGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlVGltZUF4aXNWaXNpYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FkanVzdFNpemVJbXBsKCk7XG4gICAgfVxuICAgIF9wcml2YXRlX19nZXRNb3VzZUV2ZW50UGFyYW1zSW1wbChpbmRleCwgcG9pbnQsIGV2ZW50LCBwYW5lKSB7XG4gICAgICAgIGNvbnN0IHNlcmllc0RhdGEgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWVzZXMgPSB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2VyaWVzZXMoKTtcbiAgICAgICAgICAgIHNlcmllc2VzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggc2VhcmNoIGxlZnRcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9zZWFyY2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0RhdGEuc2V0KHMsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGllbnRUaW1lO1xuICAgICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVQb2ludCA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfaW5kZXhUb1RpbWVTY2FsZVBvaW50KGluZGV4KT8ub3JpZ2luYWxUaW1lO1xuICAgICAgICAgICAgaWYgKHRpbWVQb2ludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50VGltZSA9IHRpbWVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3ZlcmVkU291cmNlID0gdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfaG92ZXJlZFNvdXJjZSgpO1xuICAgICAgICBjb25zdCBob3ZlcmVkU2VyaWVzID0gaG92ZXJlZFNvdXJjZSAhPT0gbnVsbCAmJiBob3ZlcmVkU291cmNlLl9pbnRlcm5hbF9zb3VyY2UgaW5zdGFuY2VvZiBTZXJpZXNcbiAgICAgICAgICAgID8gaG92ZXJlZFNvdXJjZS5faW50ZXJuYWxfc291cmNlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaG92ZXJlZE9iamVjdCA9IGhvdmVyZWRTb3VyY2UgIT09IG51bGwgJiYgaG92ZXJlZFNvdXJjZS5faW50ZXJuYWxfb2JqZWN0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gaG92ZXJlZFNvdXJjZS5faW50ZXJuYWxfb2JqZWN0Ll9pbnRlcm5hbF9leHRlcm5hbElkXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGFuZUluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fZ2V0UGFuZUluZGV4KHBhbmUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX29yaWdpbmFsVGltZTogY2xpZW50VGltZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pbmRleDogaW5kZXggPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgX2ludGVybmFsX3BvaW50OiBwb2ludCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcGFuZUluZGV4OiBwYW5lSW5kZXggIT09IC0xID8gcGFuZUluZGV4IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX2ludGVybmFsX2hvdmVyZWRTZXJpZXM6IGhvdmVyZWRTZXJpZXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfc2VyaWVzRGF0YTogc2VyaWVzRGF0YSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ob3ZlcmVkT2JqZWN0OiBob3ZlcmVkT2JqZWN0LFxuICAgICAgICAgICAgX2ludGVybmFsX3RvdWNoTW91c2VFdmVudERhdGE6IGV2ZW50ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldFBhbmVJbmRleChwYW5lKSB7XG4gICAgICAgIGxldCBwYW5lSW5kZXggPSAtMTtcbiAgICAgICAgaWYgKHBhbmUpIHtcbiAgICAgICAgICAgIHBhbmVJbmRleCA9IHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzLmluZGV4T2YocGFuZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjcm9zc2hhaXJQYW5lID0gdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfY3Jvc3NoYWlyU291cmNlKCkuX2ludGVybmFsX3BhbmUoKTtcbiAgICAgICAgICAgIGlmIChjcm9zc2hhaXJQYW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFuZUluZGV4ID0gdGhpcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcGFuZXMoKS5pbmRleE9mKGNyb3NzaGFpclBhbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYW5lSW5kZXg7XG4gICAgfVxuICAgIF9wcml2YXRlX19vblBhbmVXaWRnZXRDbGlja2VkKHBhbmUsIHRpbWUsIHBvaW50LCBldmVudCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jbGlja2VkLl9pbnRlcm5hbF9maXJlKCgpID0+IHRoaXMuX3ByaXZhdGVfX2dldE1vdXNlRXZlbnRQYXJhbXNJbXBsKHRpbWUsIHBvaW50LCBldmVudCwgcGFuZSkpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25QYW5lV2lkZ2V0RGJsQ2xpY2tlZChwYW5lLCB0aW1lLCBwb2ludCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZC5faW50ZXJuYWxfZmlyZSgoKSA9PiB0aGlzLl9wcml2YXRlX19nZXRNb3VzZUV2ZW50UGFyYW1zSW1wbCh0aW1lLCBwb2ludCwgZXZlbnQsIHBhbmUpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX29uUGFuZVdpZGdldENyb3NzaGFpck1vdmVkKHRpbWUsIHBvaW50LCBldmVudCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9zZXRDdXJzb3JTdHlsZSh0aGlzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9ob3ZlcmVkU291cmNlKCk/Ll9pbnRlcm5hbF9jdXJzb3JTdHlsZSA/PyBudWxsKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWQuX2ludGVybmFsX2ZpcmUoKCkgPT4gdGhpcy5fcHJpdmF0ZV9fZ2V0TW91c2VFdmVudFBhcmFtc0ltcGwodGltZSwgcG9pbnQsIGV2ZW50KSk7XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVUaW1lQXhpc1Zpc2liaWxpdHkoKSB7XG4gICAgICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9wcml2YXRlX19vcHRpb25zLnRpbWVTY2FsZS52aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgfVxuICAgIF9wcml2YXRlX19pc0xlZnRBeGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzWzBdLl9pbnRlcm5hbF9zdGF0ZSgpLl9pbnRlcm5hbF9sZWZ0UHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9vcHRpb25zKCkudmlzaWJsZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2lzUmlnaHRBeGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVXaWRnZXRzWzBdLl9pbnRlcm5hbF9zdGF0ZSgpLl9pbnRlcm5hbF9yaWdodFByaWNlU2NhbGUoKS5faW50ZXJuYWxfb3B0aW9ucygpLnZpc2libGU7XG4gICAgfVxuICAgIF9wcml2YXRlX19pbnN0YWxsT2JzZXJ2ZXIoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBpZiAoISgnUmVzaXplT2JzZXJ2ZXInIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgIHdhcm4oJ09wdGlvbnMgY29udGFpbnMgXCJhdXRvU2l6ZVwiIGZsYWcsIGJ1dCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFJlc2l6ZU9ic2VydmVyIGZlYXR1cmUuIFBsZWFzZSBwcm92aWRlIHBvbHlmaWxsLicpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGlmIGVudHJ5LnRhcmdldCA9PT0gdGhpcy5fY29udGFpbmVyIHNpbmNlIHRoZXJlIGlzIG9ubHlcbiAgICAgICAgICAgICAgICAvLyBhIHNpbmdsZSBlbGVtZW50IGJlaW5nIG9ic2VydmVkLlxuICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSB3YW50IHRvIHVzZSB0aGUgbGFzdCBlbnRyeSAoaWYgbXVsdGlwbGUpIGJlY2F1c2UgaXQgd291bGQgYmUgbW9zdCB1cCB0byBkYXRlXG4gICAgICAgICAgICAgICAgLy8gKHNpbmNlIHRoZSBicm93c2VyIG1heSBiYXRjaCBtdWx0aXBsZSB1cGRhdGVzKS5cbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJFbnRyeSA9IGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lckVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgZW50cmllcyBhcnJheSB3YXMgZW1wdHkuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVzaXplKGNvbnRhaW5lckVudHJ5LmNvbnRlbnRSZWN0LndpZHRoLCBjb250YWluZXJFbnRyeS5jb250ZW50UmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vYnNlcnZlci5vYnNlcnZlKHRoaXMuX3ByaXZhdGVfX2NvbnRhaW5lciwgeyBib3g6ICdib3JkZXItYm94JyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX191bmluc3RhbGxPYnNlcnZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRpc2FibGVTZWxlY3Rpb24oZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgZWxlbWVudC5zdHlsZS5tc1VzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgZWxlbWVudC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VGFwSGlnaGxpZ2h0Q29sb3IgPSAndHJhbnNwYXJlbnQnO1xufVxuZnVuY3Rpb24gc2hvdWxkU3Vic2NyaWJlTW91c2VXaGVlbChvcHRpb25zKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4ob3B0aW9uc1snaGFuZGxlU2Nyb2xsJ10ubW91c2VXaGVlbCB8fCBvcHRpb25zWydoYW5kbGVTY2FsZSddLm1vdXNlV2hlZWwpO1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2VEYXRhKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5vcGVuID09PSB1bmRlZmluZWQgJiYgZGF0YS52YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWREYXRhKGRhdGEpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWRCYXJEYXRhKGRhdGEpIHx8IGlzRnVsZmlsbGVkTGluZURhdGEoZGF0YSk7XG59XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZEJhckRhdGEoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLm9wZW4gIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzRnVsZmlsbGVkTGluZURhdGEoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldENvbG9yZWRMaW5lQmFzZWRTZXJpZXNQbG90Um93KHRpbWUsIGluZGV4LCBpdGVtLCBvcmlnaW5hbFRpbWUpIHtcbiAgICBjb25zdCB2YWwgPSBpdGVtLnZhbHVlO1xuICAgIGNvbnN0IHJlcyA9IHsgX2ludGVybmFsX2luZGV4OiBpbmRleCwgX2ludGVybmFsX3RpbWU6IHRpbWUsIF9pbnRlcm5hbF92YWx1ZTogW3ZhbCwgdmFsLCB2YWwsIHZhbF0sIF9pbnRlcm5hbF9vcmlnaW5hbFRpbWU6IG9yaWdpbmFsVGltZSB9O1xuICAgIGlmIChpdGVtLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzLl9pbnRlcm5hbF9jb2xvciA9IGl0ZW0uY29sb3I7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRBcmVhU2VyaWVzUGxvdFJvdyh0aW1lLCBpbmRleCwgaXRlbSwgb3JpZ2luYWxUaW1lKSB7XG4gICAgY29uc3QgdmFsID0gaXRlbS52YWx1ZTtcbiAgICBjb25zdCByZXMgPSB7IF9pbnRlcm5hbF9pbmRleDogaW5kZXgsIF9pbnRlcm5hbF90aW1lOiB0aW1lLCBfaW50ZXJuYWxfdmFsdWU6IFt2YWwsIHZhbCwgdmFsLCB2YWxdLCBfaW50ZXJuYWxfb3JpZ2luYWxUaW1lOiBvcmlnaW5hbFRpbWUgfTtcbiAgICBpZiAoaXRlbS5saW5lQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX2xpbmVDb2xvciA9IGl0ZW0ubGluZUNvbG9yO1xuICAgIH1cbiAgICBpZiAoaXRlbS50b3BDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfdG9wQ29sb3IgPSBpdGVtLnRvcENvbG9yO1xuICAgIH1cbiAgICBpZiAoaXRlbS5ib3R0b21Db2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfYm90dG9tQ29sb3IgPSBpdGVtLmJvdHRvbUNvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0QmFzZWxpbmVTZXJpZXNQbG90Um93KHRpbWUsIGluZGV4LCBpdGVtLCBvcmlnaW5hbFRpbWUpIHtcbiAgICBjb25zdCB2YWwgPSBpdGVtLnZhbHVlO1xuICAgIGNvbnN0IHJlcyA9IHsgX2ludGVybmFsX2luZGV4OiBpbmRleCwgX2ludGVybmFsX3RpbWU6IHRpbWUsIF9pbnRlcm5hbF92YWx1ZTogW3ZhbCwgdmFsLCB2YWwsIHZhbF0sIF9pbnRlcm5hbF9vcmlnaW5hbFRpbWU6IG9yaWdpbmFsVGltZSB9O1xuICAgIGlmIChpdGVtLnRvcExpbmVDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfdG9wTGluZUNvbG9yID0gaXRlbS50b3BMaW5lQ29sb3I7XG4gICAgfVxuICAgIGlmIChpdGVtLmJvdHRvbUxpbmVDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfYm90dG9tTGluZUNvbG9yID0gaXRlbS5ib3R0b21MaW5lQ29sb3I7XG4gICAgfVxuICAgIGlmIChpdGVtLnRvcEZpbGxDb2xvcjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX3RvcEZpbGxDb2xvcjEgPSBpdGVtLnRvcEZpbGxDb2xvcjE7XG4gICAgfVxuICAgIGlmIChpdGVtLnRvcEZpbGxDb2xvcjIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX3RvcEZpbGxDb2xvcjIgPSBpdGVtLnRvcEZpbGxDb2xvcjI7XG4gICAgfVxuICAgIGlmIChpdGVtLmJvdHRvbUZpbGxDb2xvcjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX2JvdHRvbUZpbGxDb2xvcjEgPSBpdGVtLmJvdHRvbUZpbGxDb2xvcjE7XG4gICAgfVxuICAgIGlmIChpdGVtLmJvdHRvbUZpbGxDb2xvcjIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX2JvdHRvbUZpbGxDb2xvcjIgPSBpdGVtLmJvdHRvbUZpbGxDb2xvcjI7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRCYXJTZXJpZXNQbG90Um93KHRpbWUsIGluZGV4LCBpdGVtLCBvcmlnaW5hbFRpbWUpIHtcbiAgICBjb25zdCByZXMgPSB7IF9pbnRlcm5hbF9pbmRleDogaW5kZXgsIF9pbnRlcm5hbF90aW1lOiB0aW1lLCBfaW50ZXJuYWxfdmFsdWU6IFtpdGVtLm9wZW4sIGl0ZW0uaGlnaCwgaXRlbS5sb3csIGl0ZW0uY2xvc2VdLCBfaW50ZXJuYWxfb3JpZ2luYWxUaW1lOiBvcmlnaW5hbFRpbWUgfTtcbiAgICBpZiAoaXRlbS5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfY29sb3IgPSBpdGVtLmNvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0Q2FuZGxlc3RpY2tTZXJpZXNQbG90Um93KHRpbWUsIGluZGV4LCBpdGVtLCBvcmlnaW5hbFRpbWUpIHtcbiAgICBjb25zdCByZXMgPSB7IF9pbnRlcm5hbF9pbmRleDogaW5kZXgsIF9pbnRlcm5hbF90aW1lOiB0aW1lLCBfaW50ZXJuYWxfdmFsdWU6IFtpdGVtLm9wZW4sIGl0ZW0uaGlnaCwgaXRlbS5sb3csIGl0ZW0uY2xvc2VdLCBfaW50ZXJuYWxfb3JpZ2luYWxUaW1lOiBvcmlnaW5hbFRpbWUgfTtcbiAgICBpZiAoaXRlbS5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfY29sb3IgPSBpdGVtLmNvbG9yO1xuICAgIH1cbiAgICBpZiAoaXRlbS5ib3JkZXJDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcy5faW50ZXJuYWxfYm9yZGVyQ29sb3IgPSBpdGVtLmJvcmRlckNvbG9yO1xuICAgIH1cbiAgICBpZiAoaXRlbS53aWNrQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMuX2ludGVybmFsX3dpY2tDb2xvciA9IGl0ZW0ud2lja0NvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0Q3VzdG9tU2VyaWVzUGxvdFJvdyh0aW1lLCBpbmRleCwgaXRlbSwgb3JpZ2luYWxUaW1lLCBkYXRhVG9QbG90Um93KSB7XG4gICAgY29uc3QgdmFsdWVzID0gZW5zdXJlRGVmaW5lZChkYXRhVG9QbG90Um93KShpdGVtKTtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heCguLi52YWx1ZXMpO1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKC4uLnZhbHVlcyk7XG4gICAgY29uc3QgbGFzdCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgdmFsdWUgPSBbbGFzdCwgbWF4LCBtaW4sIGxhc3RdO1xuICAgIGNvbnN0IHsgdGltZTogZXhjbHVkZWRUaW1lLCBjb2xvciwgLi4uZGF0YSB9ID0gaXRlbTtcbiAgICByZXR1cm4geyBfaW50ZXJuYWxfaW5kZXg6IGluZGV4LCBfaW50ZXJuYWxfdGltZTogdGltZSwgX2ludGVybmFsX3ZhbHVlOiB2YWx1ZSwgX2ludGVybmFsX29yaWdpbmFsVGltZTogb3JpZ2luYWxUaW1lLCBfaW50ZXJuYWxfZGF0YTogZGF0YSwgX2ludGVybmFsX2NvbG9yOiBjb2xvciB9O1xufVxuZnVuY3Rpb24gaXNTZXJpZXNQbG90Um93KHJvdykge1xuICAgIHJldHVybiByb3cuX2ludGVybmFsX3ZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB3cmFwQ3VzdG9tVmFsdWVzKHBsb3RSb3csIGJhcikge1xuICAgIGlmIChiYXIuY3VzdG9tVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGxvdFJvdy5faW50ZXJuYWxfY3VzdG9tVmFsdWVzID0gYmFyLmN1c3RvbVZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIHBsb3RSb3c7XG59XG5mdW5jdGlvbiBpc1doaXRlc3BhY2VEYXRhV2l0aEN1c3RvbUNoZWNrKGJhciwgY3VzdG9tSXNXaGl0ZXNwYWNlKSB7XG4gICAgaWYgKGN1c3RvbUlzV2hpdGVzcGFjZSkge1xuICAgICAgICByZXR1cm4gY3VzdG9tSXNXaGl0ZXNwYWNlKGJhcik7XG4gICAgfVxuICAgIHJldHVybiBpc1doaXRlc3BhY2VEYXRhKGJhcik7XG59XG5mdW5jdGlvbiB3cmFwV2hpdGVzcGFjZURhdGEoY3JlYXRlUGxvdFJvd0ZuKSB7XG4gICAgcmV0dXJuICh0aW1lLCBpbmRleCwgYmFyLCBvcmlnaW5hbFRpbWUsIGRhdGFUb1Bsb3RSb3csIGN1c3RvbUlzV2hpdGVzcGFjZSkgPT4ge1xuICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlRGF0YVdpdGhDdXN0b21DaGVjayhiYXIsIGN1c3RvbUlzV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwQ3VzdG9tVmFsdWVzKHsgX2ludGVybmFsX3RpbWU6IHRpbWUsIF9pbnRlcm5hbF9pbmRleDogaW5kZXgsIF9pbnRlcm5hbF9vcmlnaW5hbFRpbWU6IG9yaWdpbmFsVGltZSB9LCBiYXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwQ3VzdG9tVmFsdWVzKGNyZWF0ZVBsb3RSb3dGbih0aW1lLCBpbmRleCwgYmFyLCBvcmlnaW5hbFRpbWUsIGRhdGFUb1Bsb3RSb3cpLCBiYXIpO1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTZXJpZXNQbG90Um93Q3JlYXRvcihzZXJpZXNUeXBlKSB7XG4gICAgY29uc3Qgc2VyaWVzUGxvdFJvd0ZuTWFwID0ge1xuICAgICAgICBDYW5kbGVzdGljazogd3JhcFdoaXRlc3BhY2VEYXRhKGdldENhbmRsZXN0aWNrU2VyaWVzUGxvdFJvdyksXG4gICAgICAgIEJhcjogd3JhcFdoaXRlc3BhY2VEYXRhKGdldEJhclNlcmllc1Bsb3RSb3cpLFxuICAgICAgICBBcmVhOiB3cmFwV2hpdGVzcGFjZURhdGEoZ2V0QXJlYVNlcmllc1Bsb3RSb3cpLFxuICAgICAgICBCYXNlbGluZTogd3JhcFdoaXRlc3BhY2VEYXRhKGdldEJhc2VsaW5lU2VyaWVzUGxvdFJvdyksXG4gICAgICAgIEhpc3RvZ3JhbTogd3JhcFdoaXRlc3BhY2VEYXRhKGdldENvbG9yZWRMaW5lQmFzZWRTZXJpZXNQbG90Um93KSxcbiAgICAgICAgTGluZTogd3JhcFdoaXRlc3BhY2VEYXRhKGdldENvbG9yZWRMaW5lQmFzZWRTZXJpZXNQbG90Um93KSxcbiAgICAgICAgQ3VzdG9tOiB3cmFwV2hpdGVzcGFjZURhdGEoZ2V0Q3VzdG9tU2VyaWVzUGxvdFJvdyksXG4gICAgfTtcbiAgICByZXR1cm4gc2VyaWVzUGxvdFJvd0ZuTWFwW3Nlcmllc1R5cGVdO1xufVxuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIl9idWlsZC10aW1lLWNvbnN0YW50c1wiIC8+XG5mdW5jdGlvbiBjcmVhdGVFbXB0eVRpbWVQb2ludERhdGEodGltZVBvaW50KSB7XG4gICAgcmV0dXJuIHsgX2ludGVybmFsX2luZGV4OiAwLCBfaW50ZXJuYWxfbWFwcGluZzogbmV3IE1hcCgpLCBfaW50ZXJuYWxfdGltZVBvaW50OiB0aW1lUG9pbnQgfTtcbn1cbmZ1bmN0aW9uIHNlcmllc1Jvd3NGaXJzdEFuZExhc3RUaW1lKHNlcmllc1Jvd3MsIGJoKSB7XG4gICAgaWYgKHNlcmllc1Jvd3MgPT09IHVuZGVmaW5lZCB8fCBzZXJpZXNSb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZXJuYWxfZmlyc3RUaW1lOiBiaC5rZXkoc2VyaWVzUm93c1swXS5faW50ZXJuYWxfdGltZSksXG4gICAgICAgIF9pbnRlcm5hbF9sYXN0VGltZTogYmgua2V5KHNlcmllc1Jvd3Nbc2VyaWVzUm93cy5sZW5ndGggLSAxXS5faW50ZXJuYWxfdGltZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlcmllc1VwZGF0ZUluZm8oc2VyaWVzUm93cywgcHJldlNlcmllc1Jvd3MsIGJoKSB7XG4gICAgY29uc3QgZmlyc3RBbmRMYXN0VGltZSA9IHNlcmllc1Jvd3NGaXJzdEFuZExhc3RUaW1lKHNlcmllc1Jvd3MsIGJoKTtcbiAgICBjb25zdCBwcmV2Rmlyc3RBbmRMYXN0VGltZSA9IHNlcmllc1Jvd3NGaXJzdEFuZExhc3RUaW1lKHByZXZTZXJpZXNSb3dzLCBiaCk7XG4gICAgaWYgKGZpcnN0QW5kTGFzdFRpbWUgIT09IHVuZGVmaW5lZCAmJiBwcmV2Rmlyc3RBbmRMYXN0VGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfaGlzdG9yaWNhbFVwZGF0ZTogZmFsc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGFzdEJhclVwZGF0ZWRPck5ld0JhcnNBZGRlZFRvVGhlUmlnaHQ6IGZpcnN0QW5kTGFzdFRpbWUuX2ludGVybmFsX2xhc3RUaW1lID49IHByZXZGaXJzdEFuZExhc3RUaW1lLl9pbnRlcm5hbF9sYXN0VGltZSAmJlxuICAgICAgICAgICAgICAgIGZpcnN0QW5kTGFzdFRpbWUuX2ludGVybmFsX2ZpcnN0VGltZSA+PSBwcmV2Rmlyc3RBbmRMYXN0VGltZS5faW50ZXJuYWxfZmlyc3RUaW1lLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdGltZVNjYWxlUG9pbnRUaW1lKG1lcmdlZFBvaW50RGF0YSkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgbWVyZ2VkUG9pbnREYXRhLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2Ll9pbnRlcm5hbF9vcmlnaW5hbFRpbWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZW5zdXJlRGVmaW5lZChyZXN1bHQpO1xufVxuZnVuY3Rpb24gc2F2ZU9yaWdpbmFsVGltZShkYXRhKSB7XG4gICAgaWYgKGRhdGEuX2ludGVybmFsX29yaWdpbmFsVGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGEuX2ludGVybmFsX29yaWdpbmFsVGltZSA9IGRhdGEudGltZTtcbiAgICB9XG59XG5jbGFzcyBEYXRhTGF5ZXIge1xuICAgIGNvbnN0cnVjdG9yKGhvcnpTY2FsZUJlaGF2aW9yKSB7XG4gICAgICAgIC8vIG5vdGUgdGhhdCBfcG9pbnREYXRhQnlUaW1lUG9pbnQgYW5kIF9zZXJpZXNSb3dzQnlTZXJpZXMgc2hhcmVzIFRIRSBTQU1FIG9iamVjdHMgaW4gdGhlaXIgdmFsdWVzIGJldHdlZW4gZWFjaCBvdGhlclxuICAgICAgICAvLyBpdCdzIGp1c3QgZGlmZmVyZW50IGtpbmQgb2YgbWFwcyB0byBtYWtlIHVzYWdlcy9wZXJmIGJldHRlclxuICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludERhdGFCeVRpbWVQb2ludCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNMYXN0VGltZVBvaW50ID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0aGlzIGlzIGtpbmQgb2YgXCJkZXN0XCIgdmFsdWVzIChpbiBvcHBvc2l0ZSB0byBcInNvdXJjZVwiIG9uZXMpIC0gd2UgZG9uJ3QgbmVlZCB0byBtb2RpZnkgaXQgbWFudWFsbHksIHRoZSBvbmx5IGJ5IGNhbGxpbmcgX3VwZGF0ZVRpbWVTY2FsZVBvaW50cyBvciB1cGRhdGVTZXJpZXNEYXRhIG1ldGhvZHNcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc0xhc3RUaW1lUG9pbnQuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cyA9IFtdO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0U2VyaWVzRGF0YShzZXJpZXMsIGRhdGEpIHtcbiAgICAgICAgbGV0IG5lZWRDbGVhbnVwUG9pbnRzID0gdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuc2l6ZSAhPT0gMDtcbiAgICAgICAgbGV0IGlzVGltZVNjYWxlQWZmZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gc2F2ZSBwcmV2aW91cyBzZXJpZXMgcm93cyBkYXRhIGJlZm9yZSBpdCdzIHJlcGxhY2VkIGluc2lkZSB0aGlzLl9zZXRSb3dzVG9TZXJpZXNcbiAgICAgICAgY29uc3QgcHJldlNlcmllc1Jvd3MgPSB0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuZ2V0KHNlcmllcyk7XG4gICAgICAgIGlmIChwcmV2U2VyaWVzUm93cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBuZWVkQ2xlYW51cFBvaW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzVGltZVNjYWxlQWZmZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHBlcmYgb3B0aW1pemF0aW9uIC0gaWYgdGhlcmUgaXMgb25seSAxIHNlcmllcywgdGhlbiB3ZSBjYW4ganVzdCBjbGVhciBhbmQgZmlsbCBldmVyeXRoaW5nIGZyb20gc2NyYXRjaFxuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BvaW50RGF0YUJ5VGltZVBvaW50LmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwZXJmIG9wdGltaXphdGlvbiAtIGFjdHVhbGx5IHdlIGhhdmUgdG8gdXNlIHRoaXMuX3BvaW50RGF0YUJ5VGltZVBvaW50IGZvciBnb2luZyB0aHJvdWdoIGhlcmVcbiAgICAgICAgICAgICAgICAvLyBidXQgYXMgc29vbiBhcyB0aGlzLl9zb3J0ZWRUaW1lUG9pbnRzIGlzIGp1c3QgYSBkaWZmZXJlbnQgZm9ybSBvZiBfcG9pbnREYXRhQnlUaW1lUG9pbnQgd2UgY2FuIHVzZSBpdCBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludC5wb2ludERhdGEuX2ludGVybmFsX21hcHBpbmcuZGVsZXRlKHNlcmllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVGltZVNjYWxlQWZmZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzZXJpZXNSb3dzID0gW107XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxUaW1lcyA9IGRhdGEubWFwKChkKSA9PiBkLnRpbWUpO1xuICAgICAgICAgICAgY29uc3QgdGltZUNvbnZlcnRlciA9IHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmNyZWF0ZUNvbnZlcnRlclRvSW50ZXJuYWxPYmooZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVQbG90Um93ID0gZ2V0U2VyaWVzUGxvdFJvd0NyZWF0b3Ioc2VyaWVzLl9pbnRlcm5hbF9zZXJpZXNUeXBlKCkpO1xuICAgICAgICAgICAgY29uc3QgZGF0YVRvUGxvdFJvdyA9IHNlcmllcy5faW50ZXJuYWxfY3VzdG9tU2VyaWVzUGxvdFZhbHVlc0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbVdoaXRlc3BhY2VDaGVja2VyID0gc2VyaWVzLl9pbnRlcm5hbF9jdXN0b21TZXJpZXNXaGl0ZXNwYWNlQ2hlY2soKTtcbiAgICAgICAgICAgIHNlcmllc1Jvd3MgPSBkYXRhLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gdGltZUNvbnZlcnRlcihpdGVtLnRpbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvcnpJdGVtS2V5ID0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHRpbWUpO1xuICAgICAgICAgICAgICAgIGxldCB0aW1lUG9pbnREYXRhID0gdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuZ2V0KGhvcnpJdGVtS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodGltZVBvaW50RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpbmRleGVzIHdpbGwgYmUgc3luYyBsYXRlclxuICAgICAgICAgICAgICAgICAgICB0aW1lUG9pbnREYXRhID0gY3JlYXRlRW1wdHlUaW1lUG9pbnREYXRhKHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludERhdGFCeVRpbWVQb2ludC5zZXQoaG9yekl0ZW1LZXksIHRpbWVQb2ludERhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpc1RpbWVTY2FsZUFmZmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlUGxvdFJvdyh0aW1lLCB0aW1lUG9pbnREYXRhLl9pbnRlcm5hbF9pbmRleCwgaXRlbSwgb3JpZ2luYWxUaW1lc1tpbmRleF0sIGRhdGFUb1Bsb3RSb3csIGN1c3RvbVdoaXRlc3BhY2VDaGVja2VyKTtcbiAgICAgICAgICAgICAgICB0aW1lUG9pbnREYXRhLl9pbnRlcm5hbF9tYXBwaW5nLnNldChzZXJpZXMsIHJvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkQ2xlYW51cFBvaW50cykge1xuICAgICAgICAgICAgLy8gd2UgZGVsZXRlZCB0aGUgb2xkIGRhdGEgZnJvbSBtYXBwaW5nIGFuZCBhZGRlZCB0aGUgbmV3IG9uZXNcbiAgICAgICAgICAgIC8vIHNvIHRoZXJlIG1pZ2h0IGJlIGVtcHR5IHBvaW50cyBub3csIGxldCdzIHJlbW92ZSB0aGVtIGZpcnN0XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jbGVhbnVwUG9pbnRzRGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NldFJvd3NUb1NlcmllcyhzZXJpZXMsIHNlcmllc1Jvd3MpO1xuICAgICAgICBsZXQgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCA9IC0xO1xuICAgICAgICBpZiAoaXNUaW1lU2NhbGVBZmZlY3RlZCkge1xuICAgICAgICAgICAgLy8gdGhlbiBnZW5lcmF0ZSB0aGUgdGltZSBzY2FsZSBwb2ludHNcbiAgICAgICAgICAgIC8vIHRpbWVXZWlnaHQgd2lsbCBiZSB1cGRhdGVzIGluIF91cGRhdGVUaW1lU2NhbGVQb2ludHMgbGF0ZXJcbiAgICAgICAgICAgIGNvbnN0IG5ld1RpbWVTY2FsZVBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuZm9yRWFjaCgocG9pbnREYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgbmV3VGltZVNjYWxlUG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lV2VpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBwb2ludERhdGEuX2ludGVybmFsX3RpbWVQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnREYXRhLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFRpbWU6IHRpbWVTY2FsZVBvaW50VGltZShwb2ludERhdGEuX2ludGVybmFsX21hcHBpbmcpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdUaW1lU2NhbGVQb2ludHMuc29ydCgodDEsIHQyKSA9PiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkodDEudGltZSkgLSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkodDIudGltZSkpO1xuICAgICAgICAgICAgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCA9IHRoaXMuX3ByaXZhdGVfX3JlcGxhY2VUaW1lU2NhbGVQb2ludHMobmV3VGltZVNjYWxlUG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fZ2V0VXBkYXRlUmVzcG9uc2Uoc2VyaWVzLCBmaXJzdENoYW5nZWRQb2ludEluZGV4LCBzZXJpZXNVcGRhdGVJbmZvKHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5nZXQoc2VyaWVzKSwgcHJldlNlcmllc1Jvd3MsIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yKSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW1vdmVTZXJpZXMoc2VyaWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9zZXRTZXJpZXNEYXRhKHNlcmllcywgW10pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlU2VyaWVzRGF0YShzZXJpZXMsIGRhdGEsIGhpc3RvcmljYWxVcGRhdGUpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5kZWREYXRhID0gZGF0YTtcbiAgICAgICAgc2F2ZU9yaWdpbmFsVGltZShleHRlbmRlZERhdGEpO1xuICAgICAgICAvLyBjb252ZXJ0U3RyaW5nVG9CdXNpbmVzc0RheShkYXRhKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IucHJlcHJvY2Vzc0RhdGEoZGF0YSk7XG4gICAgICAgIGNvbnN0IHRpbWVDb252ZXJ0ZXIgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5jcmVhdGVDb252ZXJ0ZXJUb0ludGVybmFsT2JqKFtkYXRhXSk7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aW1lQ29udmVydGVyKGRhdGEudGltZSk7XG4gICAgICAgIGNvbnN0IGxhc3RTZXJpZXNUaW1lID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTGFzdFRpbWVQb2ludC5nZXQoc2VyaWVzKTtcbiAgICAgICAgaWYgKCFoaXN0b3JpY2FsVXBkYXRlICYmIGxhc3RTZXJpZXNUaW1lICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KHRpbWUpIDwgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KGxhc3RTZXJpZXNUaW1lKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1iYXNlLXRvLXN0cmluZ1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBkYXRlIG9sZGVzdCBkYXRhLCBsYXN0IHRpbWU9JHtsYXN0U2VyaWVzVGltZX0sIG5ldyB0aW1lPSR7dGltZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9pbnREYXRhQXRUaW1lID0gdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuZ2V0KHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0aW1lKSk7XG4gICAgICAgIGlmIChoaXN0b3JpY2FsVXBkYXRlICYmIHBvaW50RGF0YUF0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgbm9uLWV4aXN0aW5nIGRhdGEgcG9pbnQgd2hlbiBoaXN0b3JpY2FsVXBkYXRlIGlzIHRydWUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBubyBwb2ludCBkYXRhIGZvdW5kIGZvciB0aGUgbmV3IGRhdGEgaXRlbVxuICAgICAgICAvLyB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB1cGRhdGUgc2NhbGVcbiAgICAgICAgY29uc3QgYWZmZWN0c1RpbWVTY2FsZSA9IHBvaW50RGF0YUF0VGltZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocG9pbnREYXRhQXRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBpbmRleGVzIHdpbGwgYmUgc3luYyBsYXRlclxuICAgICAgICAgICAgcG9pbnREYXRhQXRUaW1lID0gY3JlYXRlRW1wdHlUaW1lUG9pbnREYXRhKHRpbWUpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuc2V0KHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleSh0aW1lKSwgcG9pbnREYXRhQXRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVQbG90Um93ID0gZ2V0U2VyaWVzUGxvdFJvd0NyZWF0b3Ioc2VyaWVzLl9pbnRlcm5hbF9zZXJpZXNUeXBlKCkpO1xuICAgICAgICBjb25zdCBkYXRhVG9QbG90Um93ID0gc2VyaWVzLl9pbnRlcm5hbF9jdXN0b21TZXJpZXNQbG90VmFsdWVzQnVpbGRlcigpO1xuICAgICAgICBjb25zdCBjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlciA9IHNlcmllcy5faW50ZXJuYWxfY3VzdG9tU2VyaWVzV2hpdGVzcGFjZUNoZWNrKCk7XG4gICAgICAgIGNvbnN0IHBsb3RSb3cgPSBjcmVhdGVQbG90Um93KHRpbWUsIHBvaW50RGF0YUF0VGltZS5faW50ZXJuYWxfaW5kZXgsIGRhdGEsIGV4dGVuZGVkRGF0YS5faW50ZXJuYWxfb3JpZ2luYWxUaW1lLCBkYXRhVG9QbG90Um93LCBjdXN0b21XaGl0ZXNwYWNlQ2hlY2tlcik7XG4gICAgICAgIHBvaW50RGF0YUF0VGltZS5faW50ZXJuYWxfbWFwcGluZy5zZXQoc2VyaWVzLCBwbG90Um93KTtcbiAgICAgICAgaWYgKGhpc3RvcmljYWxVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUhpc3RvcmljYWxTZXJpZXNSb3coc2VyaWVzLCBwbG90Um93LCBwb2ludERhdGFBdFRpbWUuX2ludGVybmFsX2luZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUxhc3RTZXJpZXNSb3coc2VyaWVzLCBwbG90Um93KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX2xhc3RCYXJVcGRhdGVkT3JOZXdCYXJzQWRkZWRUb1RoZVJpZ2h0OiBpc1Nlcmllc1Bsb3RSb3cocGxvdFJvdyksXG4gICAgICAgICAgICBfaW50ZXJuYWxfaGlzdG9yaWNhbFVwZGF0ZTogaGlzdG9yaWNhbFVwZGF0ZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaWYgcG9pbnQgYWxyZWFkeSBleGlzdCBvbiB0aGUgdGltZSBzY2FsZSAtIHdlIGRvbid0IG5lZWQgdG8gbWFrZSBhIGZ1bGwgdXBkYXRlIGFuZCBqdXN0IG1ha2UgYW4gaW5jcmVtZW50YWwgb25lXG4gICAgICAgIGlmICghYWZmZWN0c1RpbWVTY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2dldFVwZGF0ZVJlc3BvbnNlKHNlcmllcywgLTEsIGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1BvaW50ID0ge1xuICAgICAgICAgICAgdGltZVdlaWdodDogMCxcbiAgICAgICAgICAgIHRpbWU6IHBvaW50RGF0YUF0VGltZS5faW50ZXJuYWxfdGltZVBvaW50LFxuICAgICAgICAgICAgcG9pbnREYXRhOiBwb2ludERhdGFBdFRpbWUsXG4gICAgICAgICAgICBvcmlnaW5hbFRpbWU6IHRpbWVTY2FsZVBvaW50VGltZShwb2ludERhdGFBdFRpbWUuX2ludGVybmFsX21hcHBpbmcpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbnNlcnRJbmRleCA9IGxvd2VyQm91bmQodGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cywgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KG5ld1BvaW50LnRpbWUpLCAoYSwgYikgPT4gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KGEudGltZSkgPCBiKTtcbiAgICAgICAgLy8geWVzLCBJIGtub3cgdGhhdCB0aGlzIGFycmF5IGlzIHJlYWRvbmx5IGFuZCB0aGlzIGNoYW5nZSBpcyBpbnRlbmRlZCB0byBtYWtlIGl0IHBlcmZvcm1hdGl2ZVxuICAgICAgICAvLyB3ZSBtYXJrZWQgX3NvcnRlZFRpbWVQb2ludHMgYXJyYXkgYXMgcmVhZG9ubHkgdG8gYXZvaWQgbW9kaWZ5aW5nIHRoaXMgYXJyYXkgYW55d2hlcmUgZWxzZVxuICAgICAgICAvLyBidXQgdGhpcyBwbGFjZSBpcyBleGNlcHRpb25hbCBjYXNlIGR1ZSBwZXJmb3JtYW5jZSByZWFzb25zLCBzb3JyeVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgbmV3UG9pbnQpO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IGluc2VydEluZGV4OyBpbmRleCA8IHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBhc3NpZ25JbmRleFRvUG9pbnREYXRhKHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHNbaW5kZXhdLnBvaW50RGF0YSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmZpbGxXZWlnaHRzRm9yUG9pbnRzKHRoaXMuX3ByaXZhdGVfX3NvcnRlZFRpbWVQb2ludHMsIGluc2VydEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2dldFVwZGF0ZVJlc3BvbnNlKHNlcmllcywgaW5zZXJ0SW5kZXgsIGluZm8pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlTGFzdFNlcmllc1JvdyhzZXJpZXMsIHBsb3RSb3cpIHtcbiAgICAgICAgbGV0IHNlcmllc0RhdGEgPSB0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuZ2V0KHNlcmllcyk7XG4gICAgICAgIGlmIChzZXJpZXNEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlcmllc0RhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5zZXQoc2VyaWVzLCBzZXJpZXNEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0U2VyaWVzUm93ID0gc2VyaWVzRGF0YS5sZW5ndGggIT09IDAgPyBzZXJpZXNEYXRhW3Nlcmllc0RhdGEubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICBpZiAobGFzdFNlcmllc1JvdyA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkocGxvdFJvdy5faW50ZXJuYWxfdGltZSkgPiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkobGFzdFNlcmllc1Jvdy5faW50ZXJuYWxfdGltZSkpIHtcbiAgICAgICAgICAgIGlmIChpc1Nlcmllc1Bsb3RSb3cocGxvdFJvdykpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNEYXRhLnB1c2gocGxvdFJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNTZXJpZXNQbG90Um93KHBsb3RSb3cpKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzRGF0YVtzZXJpZXNEYXRhLmxlbmd0aCAtIDFdID0gcGxvdFJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlcmllc0RhdGEuc3BsaWNlKC0xLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNMYXN0VGltZVBvaW50LnNldChzZXJpZXMsIHBsb3RSb3cuX2ludGVybmFsX3RpbWUpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fdXBkYXRlSGlzdG9yaWNhbFNlcmllc1JvdyhzZXJpZXMsIHBsb3RSb3csIHBvaW50RGF0YUluZGV4KSB7XG4gICAgICAgIGNvbnN0IHNlcmllc0RhdGEgPSB0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuZ2V0KHNlcmllcyk7XG4gICAgICAgIGlmIChzZXJpZXNEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiaW5hcnkgc2VhcmNoIGZvciBhY3R1YWwgaW5kZXggaW4gYXJyYXkuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbG93ZXJCb3VuZChzZXJpZXNEYXRhLCBwb2ludERhdGFJbmRleCwgKHJvdywgY3VycmVudEluZGV4KSA9PiByb3cuX2ludGVybmFsX2luZGV4IDwgY3VycmVudEluZGV4KTtcbiAgICAgICAgaWYgKGlzU2VyaWVzUGxvdFJvdyhwbG90Um93KSkge1xuICAgICAgICAgICAgc2VyaWVzRGF0YVtpbmRleF0gPSBwbG90Um93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VyaWVzRGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19zZXRSb3dzVG9TZXJpZXMoc2VyaWVzLCBzZXJpZXNSb3dzKSB7XG4gICAgICAgIGlmIChzZXJpZXNSb3dzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLnNldChzZXJpZXMsIHNlcmllc1Jvd3MuZmlsdGVyKGlzU2VyaWVzUGxvdFJvdykpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTGFzdFRpbWVQb2ludC5zZXQoc2VyaWVzLCBzZXJpZXNSb3dzW3Nlcmllc1Jvd3MubGVuZ3RoIC0gMV0uX2ludGVybmFsX3RpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLmRlbGV0ZShzZXJpZXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTGFzdFRpbWVQb2ludC5kZWxldGUoc2VyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2xlYW51cFBvaW50c0RhdGEoKSB7XG4gICAgICAgIC8vIGxldCdzIHRyZWF0IGFsbCBjdXJyZW50IHBvaW50cyBhcyBcInBvdGVudGlhbGx5IHJlbW92ZWRcIlxuICAgICAgICAvLyB3ZSBjb3VsZCBjcmVhdGUgYW4gYXJyYXkgd2l0aCBhY3R1YWxseSBwb3RlbnRpYWxseSByZW1vdmVkIHBvaW50c1xuICAgICAgICAvLyBidXQgbW9zdCBsaWtlbHkgdGhpcyBhcnJheSB3aWxsIGJlIHNpbWlsYXIgdG8gX3NvcnRlZFRpbWVQb2ludHMgc28gbGV0J3MgYXZvaWQgdXNpbmcgYWRkaXRpb25hbCBtZW1vcnlcbiAgICAgICAgLy8gbm90ZSB0aGF0IHdlIGNhbiB1c2UgX3NvcnRlZFRpbWVQb2ludHMgaGVyZSBzaW5jZSBhIHBvaW50IG1pZ2h0IGJlIHJlbW92ZWQgb25seSBpdCB3YXMgaGVyZSBwcmV2aW91c2x5XG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cykge1xuICAgICAgICAgICAgaWYgKHBvaW50LnBvaW50RGF0YS5faW50ZXJuYWxfbWFwcGluZy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcG9pbnREYXRhQnlUaW1lUG9pbnQuZGVsZXRlKHRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yLmtleShwb2ludC50aW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBuZXcgdGltZSBzY2FsZSBhbmQgbWFrZSBpbmRleGVzIHZhbGlkIGZvciBhbGwgc2VyaWVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYW5nZWQgcG9pbnQgb3IgYC0xYCBpZiB0aGVyZSBpcyBubyBjaGFuZ2UuXG4gICAgICovXG4gICAgX3ByaXZhdGVfX3JlcGxhY2VUaW1lU2NhbGVQb2ludHMobmV3VGltZVBvaW50cykge1xuICAgICAgICBsZXQgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCA9IC0xO1xuICAgICAgICAvLyBzZWFyY2ggdGhlIGZpcnN0IGRpZmZlcmVudCBwb2ludCBhbmQgXCJzeW5jaW5nXCIgdGltZSB3ZWlnaHQgYnkgdGhlIHdheVxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cy5sZW5ndGggJiYgaW5kZXggPCBuZXdUaW1lUG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkUG9pbnQgPSB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BvaW50ID0gbmV3VGltZVBvaW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3Iua2V5KG9sZFBvaW50LnRpbWUpICE9PSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkobmV3UG9pbnQudGltZSkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoYW5nZWRQb2ludEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZS1hc3NpZ24gcG9pbnQncyB0aW1lIHdlaWdodCBmb3IgcG9pbnRzIGlmIHRpbWUgaXMgdGhlIHNhbWUgKGFuZCBhbGwgcHJpb3IgdGltZXMgd2FzIHRoZSBzYW1lKVxuICAgICAgICAgICAgbmV3UG9pbnQudGltZVdlaWdodCA9IG9sZFBvaW50LnRpbWVXZWlnaHQ7XG4gICAgICAgICAgICBhc3NpZ25JbmRleFRvUG9pbnREYXRhKG5ld1BvaW50LnBvaW50RGF0YSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdENoYW5nZWRQb2ludEluZGV4ID09PSAtMSAmJiB0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aCAhPT0gbmV3VGltZVBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHRoZSBjb21tb24gcGFydCBvZiB0aGUgcHJldiBhbmQgdGhlIG5ldyBwb2ludHMgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyBzbyB0aGUgZmlyc3QgY2hhbmdlZCBwb2ludCBpcyB0aGUgbmV4dCBhZnRlciB0aGUgY29tbW9uIHBhcnRcbiAgICAgICAgICAgIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXggPSBNYXRoLm1pbih0aGlzLl9wcml2YXRlX19zb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aCwgbmV3VGltZVBvaW50cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdENoYW5nZWRQb2ludEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gaWYgbm8gdGltZSBzY2FsZSBjaGFuZ2VkLCB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aW1lIHNjYWxlIHBvaW50cyBhcmUgY2hhbmdlZCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBtYWtlIGZ1bGwgdXBkYXRlIHRvIGFsbCBzZXJpZXMgKHdpdGggY2xlYXJpbmcgcG9pbnRzKVxuICAgICAgICAvLyBidXQgZmlyc3Qgd2UgbmVlZCB0byBzeW5jaHJvbml6ZSBpbmRleGVzIGFuZCByZS1maWxsIHRpbWUgd2VpZ2h0c1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IGZpcnN0Q2hhbmdlZFBvaW50SW5kZXg7IGluZGV4IDwgbmV3VGltZVBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGFzc2lnbkluZGV4VG9Qb2ludERhdGEobmV3VGltZVBvaW50c1tpbmRleF0ucG9pbnREYXRhLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmUtZmlsbCB0aW1lIHdlaWdodHMgZm9yIHBvaW50IGFmdGVyIHRoZSBmaXJzdCBjaGFuZ2VkIG9uZVxuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5maWxsV2VpZ2h0c0ZvclBvaW50cyhuZXdUaW1lUG9pbnRzLCBmaXJzdENoYW5nZWRQb2ludEluZGV4KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cyA9IG5ld1RpbWVQb2ludHM7XG4gICAgICAgIHJldHVybiBmaXJzdENoYW5nZWRQb2ludEluZGV4O1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZ2V0QmFzZUluZGV4KCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm8gZGF0YSB0aGVuICdyZXNldCcgdGhlIGJhc2UgaW5kZXggdG8gbnVsbFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJhc2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc1Jvd3NCeVNlcmllcy5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBiYXNlSW5kZXggPSBNYXRoLm1heChiYXNlSW5kZXgsIGRhdGFbZGF0YS5sZW5ndGggLSAxXS5faW50ZXJuYWxfaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJhc2VJbmRleDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldFVwZGF0ZVJlc3BvbnNlKHVwZGF0ZWRTZXJpZXMsIGZpcnN0Q2hhbmdlZFBvaW50SW5kZXgsIGluZm8pIHtcbiAgICAgICAgY29uc3QgZGF0YVVwZGF0ZVJlc3BvbnNlID0ge1xuICAgICAgICAgICAgX2ludGVybmFsX3NlcmllczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgX2ludGVybmFsX3RpbWVTY2FsZToge1xuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlSW5kZXg6IHRoaXMuX3ByaXZhdGVfX2dldEJhc2VJbmRleCgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpcnN0Q2hhbmdlZFBvaW50SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpdCdzIHBvc3NpYmxlIHRvIG1ha2UgcGVyZiBpbXByb3ZlbWVudHMgYnkgY2hlY2tpbmcgd2hhdCBzZXJpZXMgaGFzIGRhdGEgYWZ0ZXIgZmlyc3RDaGFuZ2VkUG9pbnRJbmRleFxuICAgICAgICAgICAgLy8gYnV0IGxldCdzIHNraXAgZm9yIG5vd1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLmZvckVhY2goKGRhdGEsIHMpID0+IHtcbiAgICAgICAgICAgICAgICBkYXRhVXBkYXRlUmVzcG9uc2UuX2ludGVybmFsX3Nlcmllcy5zZXQocywge1xuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX2luZm86IHMgPT09IHVwZGF0ZWRTZXJpZXMgPyBpbmZvIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc2VyaWVzIGRhdGEgd2FzIHNldCB0byBbXSBpdCB3aWxsIGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZnJvbSBfc2VyaWVzUm93QnlTZXJpZXNcbiAgICAgICAgICAgIC8vIG1lYW5pbmcgdGhlIGZvckVhY2ggYWJvdmUgd29uJ3QgYWRkIHRoZSBzZXJpZXMgdG8gdGhlIGRhdGEgdXBkYXRlIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyBzbyB3ZSBoYW5kbGUgdGhhdCBjYXNlIGhlcmVcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fc2VyaWVzUm93c0J5U2VyaWVzLmhhcyh1cGRhdGVkU2VyaWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGFVcGRhdGVSZXNwb25zZS5faW50ZXJuYWxfc2VyaWVzLnNldCh1cGRhdGVkU2VyaWVzLCB7IF9pbnRlcm5hbF9kYXRhOiBbXSwgX2ludGVybmFsX2luZm86IGluZm8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhVXBkYXRlUmVzcG9uc2UuX2ludGVybmFsX3RpbWVTY2FsZS5faW50ZXJuYWxfcG9pbnRzID0gdGhpcy5fcHJpdmF0ZV9fc29ydGVkVGltZVBvaW50cztcbiAgICAgICAgICAgIGRhdGFVcGRhdGVSZXNwb25zZS5faW50ZXJuYWxfdGltZVNjYWxlLl9pbnRlcm5hbF9maXJzdENoYW5nZWRQb2ludEluZGV4ID0gZmlyc3RDaGFuZ2VkUG9pbnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc0RhdGEgPSB0aGlzLl9wcml2YXRlX19zZXJpZXNSb3dzQnlTZXJpZXMuZ2V0KHVwZGF0ZWRTZXJpZXMpO1xuICAgICAgICAgICAgLy8gaWYgbm8gc2VyaWVzRGF0YSBmb3VuZCB0aGF0IG1lYW5zIHRoYXQgd2UganVzdCByZW1vdmVkIHRoZSBzZXJpZXNcbiAgICAgICAgICAgIGRhdGFVcGRhdGVSZXNwb25zZS5faW50ZXJuYWxfc2VyaWVzLnNldCh1cGRhdGVkU2VyaWVzLCB7IF9pbnRlcm5hbF9kYXRhOiBzZXJpZXNEYXRhIHx8IFtdLCBfaW50ZXJuYWxfaW5mbzogaW5mbyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVVwZGF0ZVJlc3BvbnNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnbkluZGV4VG9Qb2ludERhdGEocG9pbnREYXRhLCBpbmRleCkge1xuICAgIC8vIGZpcnN0LCBuZXZlcnRoZWxlc3MgdXBkYXRlIGluZGV4IG9mIHBvaW50IGRhdGEgKFwibWFrZSBpdCB2YWxpZFwiKVxuICAgIHBvaW50RGF0YS5faW50ZXJuYWxfaW5kZXggPSBpbmRleDtcbiAgICAvLyBhbmQgdGhlbiB3ZSBuZWVkIHRvIHN5bmMgaW5kZXhlcyBmb3IgYWxsIHNlcmllc1xuICAgIHBvaW50RGF0YS5faW50ZXJuYWxfbWFwcGluZy5mb3JFYWNoKChzZXJpZXNSb3cpID0+IHtcbiAgICAgICAgc2VyaWVzUm93Ll9pbnRlcm5hbF9pbmRleCA9IGluZGV4O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBsb3dlckJvdW5kSXRlbXNDb21wYXJlKGl0ZW0sIHRpbWUpIHtcbiAgICByZXR1cm4gaXRlbS5faW50ZXJuYWxfdGltZSA8IHRpbWU7XG59XG5mdW5jdGlvbiB1cHBlckJvdW5kSXRlbXNDb21wYXJlKGl0ZW0sIHRpbWUpIHtcbiAgICByZXR1cm4gdGltZSA8IGl0ZW0uX2ludGVybmFsX3RpbWU7XG59XG5mdW5jdGlvbiB2aXNpYmxlVGltZWRWYWx1ZXMoaXRlbXMsIHJhbmdlLCBleHRlbmRlZFJhbmdlKSB7XG4gICAgY29uc3QgZmlyc3RCYXIgPSByYW5nZS5faW50ZXJuYWxfbGVmdCgpO1xuICAgIGNvbnN0IGxhc3RCYXIgPSByYW5nZS5faW50ZXJuYWxfcmlnaHQoKTtcbiAgICBjb25zdCBmcm9tID0gbG93ZXJCb3VuZChpdGVtcywgZmlyc3RCYXIsIGxvd2VyQm91bmRJdGVtc0NvbXBhcmUpO1xuICAgIGNvbnN0IHRvID0gdXBwZXJCb3VuZChpdGVtcywgbGFzdEJhciwgdXBwZXJCb3VuZEl0ZW1zQ29tcGFyZSk7XG4gICAgaWYgKCFleHRlbmRlZFJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgfVxuICAgIGxldCBleHRlbmRlZEZyb20gPSBmcm9tO1xuICAgIGxldCBleHRlbmRlZFRvID0gdG87XG4gICAgaWYgKGZyb20gPiAwICYmIGZyb20gPCBpdGVtcy5sZW5ndGggJiYgaXRlbXNbZnJvbV0uX2ludGVybmFsX3RpbWUgPj0gZmlyc3RCYXIpIHtcbiAgICAgICAgZXh0ZW5kZWRGcm9tID0gZnJvbSAtIDE7XG4gICAgfVxuICAgIGlmICh0byA+IDAgJiYgdG8gPCBpdGVtcy5sZW5ndGggJiYgaXRlbXNbdG8gLSAxXS5faW50ZXJuYWxfdGltZSA8PSBsYXN0QmFyKSB7XG4gICAgICAgIGV4dGVuZGVkVG8gPSB0byArIDE7XG4gICAgfVxuICAgIHJldHVybiB7IGZyb206IGV4dGVuZGVkRnJvbSwgdG86IGV4dGVuZGVkVG8gfTtcbn1cblxuY2xhc3MgU2VyaWVzUGFuZVZpZXdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIG1vZGVsLCBleHRlbmRlZFZpc2libGVSYW5nZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YUludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX29wdGlvbnNJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZXh0ZW5kZWRWaXNpYmxlUmFuZ2UgPSBleHRlbmRlZFZpc2libGVSYW5nZTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZSh1cGRhdGVUeXBlKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh1cGRhdGVUeXBlID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVUeXBlID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19vcHRpb25zSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF92aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ha2VWYWxpZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX2ludGVybmFsX19yZW5kZXJlcjtcbiAgICB9XG4gICAgX2ludGVybmFsX191cGRhdGVPcHRpb25zKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faXRlbXMgPSB0aGlzLl9pbnRlcm5hbF9faXRlbXMubWFwKChpdGVtKSA9PiAoe1xuICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgIC4uLnRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhckNvbG9yZXIoKS5faW50ZXJuYWxfYmFyU3R5bGUoaXRlbS5faW50ZXJuYWxfdGltZSksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19jbGVhclZpc2libGVSYW5nZSgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlID0gbnVsbDtcbiAgICB9XG4gICAgX3ByaXZhdGVfX21ha2VWYWxpZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX19kYXRhSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19maWxsUmF3UG9pbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YUludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX19vcHRpb25zSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX191cGRhdGVPcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9fb3B0aW9uc0ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX19pbnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFrZVZhbGlkSW1wbCgpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX2ludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX21ha2VWYWxpZEltcGwoKSB7XG4gICAgICAgIGNvbnN0IHByaWNlU2NhbGUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9wcmljZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX2ludGVybmFsX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19jbGVhclZpc2libGVSYW5nZSgpO1xuICAgICAgICBpZiAodGltZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkgfHwgcHJpY2VTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnMgPSB0aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVTdHJpY3RSYW5nZSgpO1xuICAgICAgICBpZiAodmlzaWJsZUJhcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSA9IHZpc2libGVUaW1lZFZhbHVlcyh0aGlzLl9pbnRlcm5hbF9faXRlbXMsIHZpc2libGVCYXJzLCB0aGlzLl9wcml2YXRlX19leHRlbmRlZFZpc2libGVSYW5nZSk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19jb252ZXJ0VG9Db29yZGluYXRlcyhwcmljZVNjYWxlLCB0aW1lU2NhbGUsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByZXBhcmVSZW5kZXJlckRhdGEoKTtcbiAgICB9XG59XG5cbmNsYXNzIEN1c3RvbVNlcmllc1BhbmVSZW5kZXJlcldyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZVJlbmRlcmVyLCBwcmljZVNjYWxlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NvdXJjZVJlbmRlcmVyID0gc291cmNlUmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUgPSBwcmljZVNjYWxlO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZHJhdyh0YXJnZXQsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc291cmNlUmVuZGVyZXIuZHJhdyh0YXJnZXQsIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGUsIGlzSG92ZXJlZCwgaGl0VGVzdERhdGEpO1xuICAgIH1cbn1cbmNsYXNzIFNlcmllc0N1c3RvbVBhbmVWaWV3IGV4dGVuZHMgU2VyaWVzUGFuZVZpZXdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpZXMsIG1vZGVsLCBwYW5lVmlldykge1xuICAgICAgICBzdXBlcihzZXJpZXMsIG1vZGVsLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3ID0gcGFuZVZpZXc7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlciA9IG5ldyBDdXN0b21TZXJpZXNQYW5lUmVuZGVyZXJXcmFwcGVyKHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3LnJlbmRlcmVyKCksIChwcmljZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHNlcmllcy5faW50ZXJuYWxfZmlyc3RWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXJpZXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfcHJpY2VUb0Nvb3JkaW5hdGUocHJpY2UsIGZpcnN0VmFsdWUuX2ludGVybmFsX3ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9wcmljZVZhbHVlQnVpbGRlcihwbG90Um93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5wcmljZVZhbHVlQnVpbGRlcihwbG90Um93KTtcbiAgICB9XG4gICAgX2ludGVybmFsX2lzV2hpdGVzcGFjZShkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlldy5pc1doaXRlc3BhY2UoZGF0YSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZmlsbFJhd1BvaW50cygpIHtcbiAgICAgICAgY29uc3QgY29sb3JlciA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhckNvbG9yZXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2l0ZW1zID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9yb3dzKClcbiAgICAgICAgICAgIC5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGltZTogcm93Ll9pbnRlcm5hbF9pbmRleCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeDogTmFOLFxuICAgICAgICAgICAgICAgIC4uLmNvbG9yZXIuX2ludGVybmFsX2JhclN0eWxlKHJvdy5faW50ZXJuYWxfaW5kZXgpLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9vcmlnaW5hbERhdGE6IHJvdy5faW50ZXJuYWxfZGF0YSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NvbnZlcnRUb0Nvb3JkaW5hdGVzKHByaWNlU2NhbGUsIHRpbWVTY2FsZSkge1xuICAgICAgICB0aW1lU2NhbGUuX2ludGVybmFsX2luZGV4ZXNUb0Nvb3JkaW5hdGVzKHRoaXMuX2ludGVybmFsX19pdGVtcywgdW5kZWZpbmVkSWZOdWxsKHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3ByZXBhcmVSZW5kZXJlckRhdGEoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3LnVwZGF0ZSh7XG4gICAgICAgICAgICBiYXJzOiB0aGlzLl9pbnRlcm5hbF9faXRlbXMubWFwKHVud3JhcEl0ZW1EYXRhKSxcbiAgICAgICAgICAgIGJhclNwYWNpbmc6IHRoaXMuX2ludGVybmFsX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2JhclNwYWNpbmcoKSxcbiAgICAgICAgICAgIHZpc2libGVSYW5nZTogdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLFxuICAgICAgICB9LCB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVud3JhcEl0ZW1EYXRhKGl0ZW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBpdGVtLl9pbnRlcm5hbF94LFxuICAgICAgICB0aW1lOiBpdGVtLl9pbnRlcm5hbF90aW1lLFxuICAgICAgICBvcmlnaW5hbERhdGE6IGl0ZW0uX2ludGVybmFsX29yaWdpbmFsRGF0YSxcbiAgICAgICAgYmFyQ29sb3I6IGl0ZW0uX2ludGVybmFsX2JhckNvbG9yLFxuICAgIH07XG59XG5cbmNvbnN0IGN1c3RvbVN0eWxlRGVmYXVsdHMgPSB7XG4gICAgY29sb3I6ICcjMjE5NmYzJyxcbn07XG5jb25zdCBjcmVhdGVQYW5lVmlldyQ2ID0gKHNlcmllcywgbW9kZWwsIGN1c3RvbVBhbmVWaWV3KSA9PiB7XG4gICAgY29uc3QgcGFuZVZpZXcgPSBlbnN1cmUoY3VzdG9tUGFuZVZpZXcpO1xuICAgIHJldHVybiBuZXcgU2VyaWVzQ3VzdG9tUGFuZVZpZXcoc2VyaWVzLCBtb2RlbCwgcGFuZVZpZXcpO1xufTtcbmNvbnN0IGNyZWF0ZUN1c3RvbVNlcmllc0RlZmluaXRpb24gPSAocGFuZVZpZXcpID0+IHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgICB0eXBlOiAnQ3VzdG9tJyxcbiAgICAgICAgaXNCdWlsdEluOiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHsgLi4uY3VzdG9tU3R5bGVEZWZhdWx0cywgLi4ucGFuZVZpZXcuZGVmYXVsdE9wdGlvbnMoKSB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBfaW50ZXJuYWxfY3JlYXRlUGFuZVZpZXc6IGNyZWF0ZVBhbmVWaWV3JDYsXG4gICAgICAgIF9pbnRlcm5hbF9jdXN0b21QYW5lVmlldzogcGFuZVZpZXcsXG4gICAgfTtcbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbn07XG5cbmNvbnN0IGlzU2VyaWVzRGVmaW5pdGlvbiA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZS5faW50ZXJuYWxfY3JlYXRlUGFuZVZpZXcgIT09IHVuZGVmaW5lZDtcbn07XG5cbmZ1bmN0aW9uIHNpbmdsZVZhbHVlRGF0YShwbG90Um93KSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgdmFsdWU6IHBsb3RSb3cuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dLFxuICAgICAgICB0aW1lOiBwbG90Um93Ll9pbnRlcm5hbF9vcmlnaW5hbFRpbWUsXG4gICAgfTtcbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfY3VzdG9tVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0YS5jdXN0b21WYWx1ZXMgPSBwbG90Um93Ll9pbnRlcm5hbF9jdXN0b21WYWx1ZXM7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gbGluZURhdGEocGxvdFJvdykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNpbmdsZVZhbHVlRGF0YShwbG90Um93KTtcbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuY29sb3IgPSBwbG90Um93Ll9pbnRlcm5hbF9jb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFyZWFEYXRhKHBsb3RSb3cpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzaW5nbGVWYWx1ZURhdGEocGxvdFJvdyk7XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX2xpbmVDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5saW5lQ29sb3IgPSBwbG90Um93Ll9pbnRlcm5hbF9saW5lQ29sb3I7XG4gICAgfVxuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF90b3BDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC50b3BDb2xvciA9IHBsb3RSb3cuX2ludGVybmFsX3RvcENvbG9yO1xuICAgIH1cbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfYm90dG9tQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuYm90dG9tQ29sb3IgPSBwbG90Um93Ll9pbnRlcm5hbF9ib3R0b21Db2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJhc2VsaW5lRGF0YShwbG90Um93KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc2luZ2xlVmFsdWVEYXRhKHBsb3RSb3cpO1xuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF90b3BMaW5lQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQudG9wTGluZUNvbG9yID0gcGxvdFJvdy5faW50ZXJuYWxfdG9wTGluZUNvbG9yO1xuICAgIH1cbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfYm90dG9tTGluZUNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmJvdHRvbUxpbmVDb2xvciA9IHBsb3RSb3cuX2ludGVybmFsX2JvdHRvbUxpbmVDb2xvcjtcbiAgICB9XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX3RvcEZpbGxDb2xvcjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQudG9wRmlsbENvbG9yMSA9IHBsb3RSb3cuX2ludGVybmFsX3RvcEZpbGxDb2xvcjE7XG4gICAgfVxuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF90b3BGaWxsQ29sb3IyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnRvcEZpbGxDb2xvcjIgPSBwbG90Um93Ll9pbnRlcm5hbF90b3BGaWxsQ29sb3IyO1xuICAgIH1cbiAgICBpZiAocGxvdFJvdy5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5ib3R0b21GaWxsQ29sb3IxID0gcGxvdFJvdy5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMTtcbiAgICB9XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX2JvdHRvbUZpbGxDb2xvcjIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuYm90dG9tRmlsbENvbG9yMiA9IHBsb3RSb3cuX2ludGVybmFsX2JvdHRvbUZpbGxDb2xvcjI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvaGxjRGF0YShwbG90Um93KSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgb3BlbjogcGxvdFJvdy5faW50ZXJuYWxfdmFsdWVbMCAvKiBQbG90Um93VmFsdWVJbmRleC5PcGVuICovXSxcbiAgICAgICAgaGlnaDogcGxvdFJvdy5faW50ZXJuYWxfdmFsdWVbMSAvKiBQbG90Um93VmFsdWVJbmRleC5IaWdoICovXSxcbiAgICAgICAgbG93OiBwbG90Um93Ll9pbnRlcm5hbF92YWx1ZVsyIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkxvdyAqL10sXG4gICAgICAgIGNsb3NlOiBwbG90Um93Ll9pbnRlcm5hbF92YWx1ZVszIC8qIFBsb3RSb3dWYWx1ZUluZGV4LkNsb3NlICovXSxcbiAgICAgICAgdGltZTogcGxvdFJvdy5faW50ZXJuYWxfb3JpZ2luYWxUaW1lLFxuICAgIH07XG4gICAgaWYgKHBsb3RSb3cuX2ludGVybmFsX2N1c3RvbVZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGEuY3VzdG9tVmFsdWVzID0gcGxvdFJvdy5faW50ZXJuYWxfY3VzdG9tVmFsdWVzO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGJhckRhdGEocGxvdFJvdykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG9obGNEYXRhKHBsb3RSb3cpO1xuICAgIGlmIChwbG90Um93Ll9pbnRlcm5hbF9jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5jb2xvciA9IHBsb3RSb3cuX2ludGVybmFsX2NvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FuZGxlc3RpY2tEYXRhKHBsb3RSb3cpIHtcbiAgICBjb25zdCByZXN1bHQgPSBvaGxjRGF0YShwbG90Um93KTtcbiAgICBjb25zdCB7IF9pbnRlcm5hbF9jb2xvcjogY29sb3IsIF9pbnRlcm5hbF9ib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IsIF9pbnRlcm5hbF93aWNrQ29sb3I6IHdpY2tDb2xvciB9ID0gcGxvdFJvdztcbiAgICBpZiAoY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuY29sb3IgPSBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGJvcmRlckNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmJvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XG4gICAgfVxuICAgIGlmICh3aWNrQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQud2lja0NvbG9yID0gd2lja0NvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0U2VyaWVzRGF0YUNyZWF0b3Ioc2VyaWVzVHlwZSkge1xuICAgIGNvbnN0IHNlcmllc1Bsb3RSb3dUb0RhdGFNYXAgPSB7XG4gICAgICAgIEFyZWE6IChhcmVhRGF0YSksXG4gICAgICAgIExpbmU6IChsaW5lRGF0YSksXG4gICAgICAgIEJhc2VsaW5lOiAoYmFzZWxpbmVEYXRhKSxcbiAgICAgICAgSGlzdG9ncmFtOiAobGluZURhdGEpLFxuICAgICAgICBCYXI6IChiYXJEYXRhKSxcbiAgICAgICAgQ2FuZGxlc3RpY2s6IChjYW5kbGVzdGlja0RhdGEpLFxuICAgICAgICBDdXN0b206IChjdXN0b21EYXRhKSxcbiAgICB9O1xuICAgIHJldHVybiBzZXJpZXNQbG90Um93VG9EYXRhTWFwW3Nlcmllc1R5cGVdO1xufVxuZnVuY3Rpb24gY3VzdG9tRGF0YShwbG90Um93KSB7XG4gICAgY29uc3QgdGltZSA9IHBsb3RSb3cuX2ludGVybmFsX29yaWdpbmFsVGltZTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wbG90Um93Ll9pbnRlcm5hbF9kYXRhLFxuICAgICAgICB0aW1lLFxuICAgIH07XG59XG5cbmNvbnN0IGNyb3NzaGFpck9wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICB2ZXJ0TGluZToge1xuICAgICAgICBjb2xvcjogJyM5NTk4QTEnLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgc3R5bGU6IDMgLyogTGluZVN0eWxlLkxhcmdlRGFzaGVkICovLFxuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICBsYWJlbFZpc2libGU6IHRydWUsXG4gICAgICAgIGxhYmVsQmFja2dyb3VuZENvbG9yOiAnIzEzMTcyMicsXG4gICAgfSxcbiAgICBob3J6TGluZToge1xuICAgICAgICBjb2xvcjogJyM5NTk4QTEnLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgc3R5bGU6IDMgLyogTGluZVN0eWxlLkxhcmdlRGFzaGVkICovLFxuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICBsYWJlbFZpc2libGU6IHRydWUsXG4gICAgICAgIGxhYmVsQmFja2dyb3VuZENvbG9yOiAnIzEzMTcyMicsXG4gICAgfSxcbiAgICBtb2RlOiAxIC8qIENyb3NzaGFpck1vZGUuTWFnbmV0ICovLFxufTtcblxuY29uc3QgZ3JpZE9wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICB2ZXJ0TGluZXM6IHtcbiAgICAgICAgY29sb3I6ICcjRDZEQ0RFJyxcbiAgICAgICAgc3R5bGU6IDAgLyogTGluZVN0eWxlLlNvbGlkICovLFxuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgIH0sXG4gICAgaG9yekxpbmVzOiB7XG4gICAgICAgIGNvbG9yOiAnI0Q2RENERScsXG4gICAgICAgIHN0eWxlOiAwIC8qIExpbmVTdHlsZS5Tb2xpZCAqLyxcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICB9LFxufTtcblxuY29uc3QgbGF5b3V0T3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgdHlwZTogXCJzb2xpZFwiIC8qIENvbG9yVHlwZS5Tb2xpZCAqLyxcbiAgICAgICAgY29sb3I6ICcjRkZGRkZGJyxcbiAgICB9LFxuICAgIHRleHRDb2xvcjogJyMxOTE5MTknLFxuICAgIGZvbnRTaXplOiAxMixcbiAgICBmb250RmFtaWx5OiBkZWZhdWx0Rm9udEZhbWlseSxcbiAgICBwYW5lczoge1xuICAgICAgICBlbmFibGVSZXNpemU6IHRydWUsXG4gICAgICAgIHNlcGFyYXRvckNvbG9yOiAnI0UwRTNFQicsXG4gICAgICAgIHNlcGFyYXRvckhvdmVyQ29sb3I6ICdyZ2JhKDE3OCwgMTgxLCAxODksIDAuMiknLFxuICAgIH0sXG4gICAgYXR0cmlidXRpb25Mb2dvOiB0cnVlLFxuICAgIGNvbG9yU3BhY2U6ICdzcmdiJyxcbiAgICBjb2xvclBhcnNlcnM6IFtdLFxufTtcblxuY29uc3QgcHJpY2VTY2FsZU9wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICBhdXRvU2NhbGU6IHRydWUsXG4gICAgbW9kZTogMCAvKiBQcmljZVNjYWxlTW9kZS5Ob3JtYWwgKi8sXG4gICAgaW52ZXJ0U2NhbGU6IGZhbHNlLFxuICAgIGFsaWduTGFiZWxzOiB0cnVlLFxuICAgIGJvcmRlclZpc2libGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6ICcjMkIyQjQzJyxcbiAgICBlbnRpcmVUZXh0T25seTogZmFsc2UsXG4gICAgdmlzaWJsZTogZmFsc2UsXG4gICAgdGlja3NWaXNpYmxlOiBmYWxzZSxcbiAgICBzY2FsZU1hcmdpbnM6IHtcbiAgICAgICAgYm90dG9tOiAwLjEsXG4gICAgICAgIHRvcDogMC4yLFxuICAgIH0sXG4gICAgbWluaW11bVdpZHRoOiAwLFxuICAgIGVuc3VyZUVkZ2VUaWNrTWFya3NWaXNpYmxlOiBmYWxzZSxcbn07XG5cbmNvbnN0IHRpbWVTY2FsZU9wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICByaWdodE9mZnNldDogMCxcbiAgICBiYXJTcGFjaW5nOiA2LFxuICAgIG1pbkJhclNwYWNpbmc6IDAuNSxcbiAgICBtYXhCYXJTcGFjaW5nOiAwLFxuICAgIGZpeExlZnRFZGdlOiBmYWxzZSxcbiAgICBmaXhSaWdodEVkZ2U6IGZhbHNlLFxuICAgIGxvY2tWaXNpYmxlVGltZVJhbmdlT25SZXNpemU6IGZhbHNlLFxuICAgIHJpZ2h0QmFyU3RheXNPblNjcm9sbDogZmFsc2UsXG4gICAgYm9yZGVyVmlzaWJsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogJyMyQjJCNDMnLFxuICAgIHZpc2libGU6IHRydWUsXG4gICAgdGltZVZpc2libGU6IGZhbHNlLFxuICAgIHNlY29uZHNWaXNpYmxlOiB0cnVlLFxuICAgIHNoaWZ0VmlzaWJsZVJhbmdlT25OZXdCYXI6IHRydWUsXG4gICAgYWxsb3dTaGlmdFZpc2libGVSYW5nZU9uV2hpdGVzcGFjZVJlcGxhY2VtZW50OiBmYWxzZSxcbiAgICB0aWNrc1Zpc2libGU6IGZhbHNlLFxuICAgIHVuaWZvcm1EaXN0cmlidXRpb246IGZhbHNlLFxuICAgIG1pbmltdW1IZWlnaHQ6IDAsXG4gICAgYWxsb3dCb2xkTGFiZWxzOiB0cnVlLFxuICAgIGlnbm9yZVdoaXRlc3BhY2VJbmRpY2VzOiBmYWxzZSxcbn07XG5cbmZ1bmN0aW9uIGNoYXJ0T3B0aW9uc0RlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIGF1dG9TaXplOiBmYWxzZSxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgIGNyb3NzaGFpcjogY3Jvc3NoYWlyT3B0aW9uc0RlZmF1bHRzLFxuICAgICAgICBncmlkOiBncmlkT3B0aW9uc0RlZmF1bHRzLFxuICAgICAgICBvdmVybGF5UHJpY2VTY2FsZXM6IHtcbiAgICAgICAgICAgIC4uLnByaWNlU2NhbGVPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgIH0sXG4gICAgICAgIGxlZnRQcmljZVNjYWxlOiB7XG4gICAgICAgICAgICAuLi5wcmljZVNjYWxlT3B0aW9uc0RlZmF1bHRzLFxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0UHJpY2VTY2FsZToge1xuICAgICAgICAgICAgLi4ucHJpY2VTY2FsZU9wdGlvbnNEZWZhdWx0cyxcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVTY2FsZTogdGltZVNjYWxlT3B0aW9uc0RlZmF1bHRzLFxuICAgICAgICBsb2NhbGl6YXRpb246IHtcbiAgICAgICAgICAgIGxvY2FsZTogaXNSdW5uaW5nT25DbGllbnRTaWRlID8gbmF2aWdhdG9yLmxhbmd1YWdlIDogJycsXG4gICAgICAgICAgICBkYXRlRm9ybWF0OiAnZGQgTU1NIFxcJ3l5JyxcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlU2Nyb2xsOiB7XG4gICAgICAgICAgICBtb3VzZVdoZWVsOiB0cnVlLFxuICAgICAgICAgICAgcHJlc3NlZE1vdXNlTW92ZTogdHJ1ZSxcbiAgICAgICAgICAgIGhvcnpUb3VjaERyYWc6IHRydWUsXG4gICAgICAgICAgICB2ZXJ0VG91Y2hEcmFnOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVTY2FsZToge1xuICAgICAgICAgICAgYXhpc1ByZXNzZWRNb3VzZU1vdmU6IHtcbiAgICAgICAgICAgICAgICB0aW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByaWNlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF4aXNEb3VibGVDbGlja1Jlc2V0OiB7XG4gICAgICAgICAgICAgICAgdGltZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcmljZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZVdoZWVsOiB0cnVlLFxuICAgICAgICAgICAgcGluY2g6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGtpbmV0aWNTY3JvbGw6IHtcbiAgICAgICAgICAgIG1vdXNlOiBmYWxzZSxcbiAgICAgICAgICAgIHRvdWNoOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB0cmFja2luZ01vZGU6IHtcbiAgICAgICAgICAgIGV4aXRNb2RlOiAxIC8qIFRyYWNraW5nTW9kZUV4aXRNb2RlLk9uTmV4dFRhcCAqLyxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jbGFzcyBQcmljZVNjYWxlQXBpIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFydFdpZGdldCwgcHJpY2VTY2FsZUlkLCBwYW5lSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQgPSBjaGFydFdpZGdldDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZUlkID0gcHJpY2VTY2FsZUlkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lSW5kZXggPSBwYW5lSW5kZXggPz8gMDtcbiAgICB9XG4gICAgYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2FwcGx5UHJpY2VTY2FsZU9wdGlvbnModGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZUlkLCBvcHRpb25zLCB0aGlzLl9wcml2YXRlX19wYW5lSW5kZXgpO1xuICAgIH1cbiAgICBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgfVxuICAgIHdpZHRoKCkge1xuICAgICAgICBpZiAoIWlzRGVmYXVsdFByaWNlU2NhbGUodGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9nZXRQcmljZUF4aXNXaWR0aCh0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlSWQpO1xuICAgIH1cbiAgICBzZXRWaXNpYmxlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRBdXRvU2NhbGUoZmFsc2UpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlKCkuX2ludGVybmFsX3NldEN1c3RvbVByaWNlUmFuZ2UobmV3IFByaWNlUmFuZ2VJbXBsKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgfVxuICAgIGdldFZpc2libGVSYW5nZSgpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLl9wcml2YXRlX19wcmljZVNjYWxlKCkuX2ludGVybmFsX3ByaWNlUmFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlID09PSBudWxsID8gbnVsbCA6IHtcbiAgICAgICAgICAgIGZyb206IHJhbmdlLl9pbnRlcm5hbF9taW5WYWx1ZSgpLFxuICAgICAgICAgICAgdG86IHJhbmdlLl9pbnRlcm5hbF9tYXhWYWx1ZSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRBdXRvU2NhbGUob24pIHtcbiAgICAgICAgdGhpcy5hcHBseU9wdGlvbnMoeyBhdXRvU2NhbGU6IG9uIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJpY2VTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2ZpbmRQcmljZVNjYWxlKHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVJZCwgdGhpcy5fcHJpdmF0ZV9fcGFuZUluZGV4KSkuX2ludGVybmFsX3ByaWNlU2NhbGU7XG4gICAgfVxufVxuXG5jbGFzcyBQYW5lQXBpIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFydFdpZGdldCwgc2VyaWVzQXBpR2V0dGVyLCBwYW5lLCBjaGFydEFwaSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldCA9IGNoYXJ0V2lkZ2V0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lID0gcGFuZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzQXBpR2V0dGVyID0gc2VyaWVzQXBpR2V0dGVyO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fY2hhcnRBcGkgPSBjaGFydEFwaTtcbiAgICB9XG4gICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfaGVpZ2h0KCk7XG4gICAgfVxuICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgY2hhcnRNb2RlbCA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9tb2RlbCgpO1xuICAgICAgICBjb25zdCBwYW5lSW5kZXggPSBjaGFydE1vZGVsLl9pbnRlcm5hbF9nZXRQYW5lSW5kZXgodGhpcy5fcHJpdmF0ZV9fcGFuZSk7XG4gICAgICAgIGNoYXJ0TW9kZWwuX2ludGVybmFsX2NoYW5nZVBhbmVzSGVpZ2h0KHBhbmVJbmRleCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgcGFuZUluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2dldFBhbmVJbmRleCh0aGlzLl9wcml2YXRlX19wYW5lKTtcbiAgICB9XG4gICAgbW92ZVRvKHBhbmVJbmRleCkge1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLnBhbmVJbmRleCgpO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSBwYW5lSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocGFuZUluZGV4ID49IDAgJiYgcGFuZUluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX3BhbmVXaWRnZXRzKCkubGVuZ3RoLCAnSW52YWxpZCBwYW5lIGluZGV4Jyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9zd2FwUGFuZXMoY3VycmVudEluZGV4LCBwYW5lSW5kZXgpO1xuICAgIH1cbiAgICBnZXRTZXJpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9zZXJpZXMoKS5tYXAoKHNvdXJjZSkgPT4gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzQXBpR2V0dGVyKHNvdXJjZSkpID8/IFtdO1xuICAgIH1cbiAgICBnZXRIVE1MRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9wYW5lV2lkZ2V0cygpW3RoaXMucGFuZUluZGV4KCldLl9pbnRlcm5hbF9nZXRFbGVtZW50KCk7XG4gICAgfVxuICAgIGF0dGFjaFByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfYXR0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG4gICAgICAgIGlmIChwcmltaXRpdmUuYXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5hdHRhY2hlZCh7XG4gICAgICAgICAgICAgICAgY2hhcnQ6IHRoaXMuX2ludGVybmFsX19jaGFydEFwaSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0VXBkYXRlOiAoKSA9PiB0aGlzLl9wcml2YXRlX19wYW5lLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9mdWxsVXBkYXRlKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXRhY2hQcmltaXRpdmUocHJpbWl0aXZlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuX2ludGVybmFsX2RldGFjaFByaW1pdGl2ZShwcmltaXRpdmUpO1xuICAgIH1cbiAgICBwcmljZVNjYWxlKHByaWNlU2NhbGVJZCkge1xuICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fcGFuZS5faW50ZXJuYWxfcHJpY2VTY2FsZUJ5SWQocHJpY2VTY2FsZUlkKTtcbiAgICAgICAgaWYgKHByaWNlU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgcHJpY2Ugc2NhbGUgd2l0aCBpZDogJHtwcmljZVNjYWxlSWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcmljZVNjYWxlQXBpKHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0LCBwcmljZVNjYWxlSWQsIHRoaXMucGFuZUluZGV4KCkpO1xuICAgIH1cbn1cblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJfYnVpbGQtdGltZS1jb25zdGFudHNcIiAvPlxuZnVuY3Rpb24gY2hlY2tQcmljZUxpbmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBhc3NlcnQodHlwZW9mIG9wdGlvbnMucHJpY2UgPT09ICdudW1iZXInLCBgdGhlIHR5cGUgb2YgJ3ByaWNlJyBwcmljZSBsaW5lJ3MgcHJvcGVydHkgbXVzdCBiZSBhIG51bWJlciwgZ290ICcke3R5cGVvZiBvcHRpb25zLnByaWNlfSdgKTtcbn1cbmZ1bmN0aW9uIGNoZWNrSXRlbXNBcmVPcmRlcmVkKGRhdGEsIGJoLCBhbGxvd0R1cGxpY2F0ZXMgPSBmYWxzZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcmV2VGltZSA9IGJoLmtleShkYXRhWzBdLnRpbWUpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IGJoLmtleShkYXRhW2ldLnRpbWUpO1xuICAgICAgICBjb25zdCBjaGVja1Jlc3VsdCA9IGFsbG93RHVwbGljYXRlcyA/IHByZXZUaW1lIDw9IGN1cnJlbnRUaW1lIDogcHJldlRpbWUgPCBjdXJyZW50VGltZTtcbiAgICAgICAgYXNzZXJ0KGNoZWNrUmVzdWx0LCBgZGF0YSBtdXN0IGJlIGFzYyBvcmRlcmVkIGJ5IHRpbWUsIGluZGV4PSR7aX0sIHRpbWU9JHtjdXJyZW50VGltZX0sIHByZXYgdGltZT0ke3ByZXZUaW1lfWApO1xuICAgICAgICBwcmV2VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2VyaWVzVmFsdWVzVHlwZSh0eXBlLCBkYXRhKSB7XG4gICAgZGF0YS5mb3JFYWNoKGdldENoZWNrZXIodHlwZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tlcih0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ0Jhcic6XG4gICAgICAgIGNhc2UgJ0NhbmRsZXN0aWNrJzpcbiAgICAgICAgICAgIHJldHVybiBjaGVja0Jhckl0ZW0uYmluZChudWxsLCB0eXBlKTtcbiAgICAgICAgY2FzZSAnQXJlYSc6XG4gICAgICAgIGNhc2UgJ0Jhc2VsaW5lJzpcbiAgICAgICAgY2FzZSAnTGluZSc6XG4gICAgICAgIGNhc2UgJ0hpc3RvZ3JhbSc6XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tMaW5lSXRlbS5iaW5kKG51bGwsIHR5cGUpO1xuICAgICAgICBjYXNlICdDdXN0b20nOlxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrQ3VzdG9tSXRlbS5iaW5kKG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQmFySXRlbSh0eXBlLCBiYXJJdGVtKSB7XG4gICAgaWYgKCFpc0Z1bGZpbGxlZERhdGEoYmFySXRlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBbJ29wZW4nLCAnaGlnaCcsICdsb3cnLCAnY2xvc2UnXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBiYXJJdGVtW2tleV0gPT09ICdudW1iZXInLCBgJHt0eXBlfSBzZXJpZXMgaXRlbSBkYXRhIHZhbHVlIG9mICR7a2V5fSBtdXN0IGJlIGEgbnVtYmVyLCBnb3Q9JHt0eXBlb2YgYmFySXRlbVtrZXldfSwgdmFsdWU9JHtiYXJJdGVtW2tleV19YCk7XG4gICAgICAgIGFzc2VydChpc1NhZmVWYWx1ZShiYXJJdGVtW2tleV0pLCBgJHt0eXBlfSBzZXJpZXMgaXRlbSBkYXRhIHZhbHVlIG9mICR7a2V5fSBtdXN0IGJlIGJldHdlZW4gJHtNSU5fU0FGRV9WQUxVRS50b1ByZWNpc2lvbigxNil9IGFuZCAke01BWF9TQUZFX1ZBTFVFLnRvUHJlY2lzaW9uKDE2KX0sIGdvdD0ke3R5cGVvZiBiYXJJdGVtW2tleV19LCB2YWx1ZT0ke2Jhckl0ZW1ba2V5XX1gKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNoZWNrTGluZUl0ZW0odHlwZSwgbGluZUl0ZW0pIHtcbiAgICBpZiAoIWlzRnVsZmlsbGVkRGF0YShsaW5lSXRlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NlcnQodHlwZW9mIGxpbmVJdGVtLnZhbHVlID09PSAnbnVtYmVyJywgYCR7dHlwZX0gc2VyaWVzIGl0ZW0gZGF0YSB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLCBnb3Q9JHt0eXBlb2YgbGluZUl0ZW0udmFsdWV9LCB2YWx1ZT0ke2xpbmVJdGVtLnZhbHVlfWApO1xuICAgIGFzc2VydChpc1NhZmVWYWx1ZShsaW5lSXRlbS52YWx1ZSksIGAke3R5cGV9IHNlcmllcyBpdGVtIGRhdGEgdmFsdWUgbXVzdCBiZSBiZXR3ZWVuICR7TUlOX1NBRkVfVkFMVUUudG9QcmVjaXNpb24oMTYpfSBhbmQgJHtNQVhfU0FGRV9WQUxVRS50b1ByZWNpc2lvbigxNil9LCBnb3Q9JHt0eXBlb2YgbGluZUl0ZW0udmFsdWV9LCB2YWx1ZT0ke2xpbmVJdGVtLnZhbHVlfWApO1xufVxuZnVuY3Rpb24gY2hlY2tDdXN0b21JdGVtKFxuLy8gdHlwZTogJ0N1c3RvbScsXG4vLyBjdXN0b21JdGVtOiBTZXJpZXNEYXRhSXRlbVR5cGVNYXBbdHlwZW9mIHR5cGVdXG4pIHtcbiAgICAvLyBOb3RoaW5nIHRvIGNoZWNrIHlldC4uLlxuICAgIHJldHVybjtcbn1cbmNvbnN0IE1JTl9TQUZFX1ZBTFVFID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgLyAxMDA7XG5jb25zdCBNQVhfU0FGRV9WQUxVRSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIC8gMTAwO1xuZnVuY3Rpb24gaXNTYWZlVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPj0gTUlOX1NBRkVfVkFMVUUgJiYgdmFsdWUgPD0gTUFYX1NBRkVfVkFMVUU7XG59XG5cbmNvbnN0IHByaWNlTGluZU9wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogJyNGRjAwMDAnLFxuICAgIHByaWNlOiAwLFxuICAgIGxpbmVTdHlsZTogMiAvKiBMaW5lU3R5bGUuRGFzaGVkICovLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBsaW5lVmlzaWJsZTogdHJ1ZSxcbiAgICBheGlzTGFiZWxWaXNpYmxlOiB0cnVlLFxuICAgIHRpdGxlOiAnJyxcbiAgICBheGlzTGFiZWxDb2xvcjogJycsXG4gICAgYXhpc0xhYmVsVGV4dENvbG9yOiAnJyxcbn07XG5cbmNsYXNzIFByaWNlTGluZSB7XG4gICAgY29uc3RydWN0b3IocHJpY2VMaW5lKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZSA9IHByaWNlTGluZTtcbiAgICB9XG4gICAgYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VMaW5lLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wcmljZUxpbmUuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3ByaWNlTGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlTGluZTtcbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc0FwaSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBkYXRhVXBkYXRlc0NvbnN1bWVyLCBwcmljZVNjYWxlQXBpUHJvdmlkZXIsIGNoYXJ0QXBpLCBob3J6U2NhbGVCZWhhdmlvciwgcGFuZUFwaUdldHRlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhQ2hhbmdlZERlbGVnYXRlID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhVXBkYXRlc0NvbnN1bWVyID0gZGF0YVVwZGF0ZXNDb25zdW1lcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJpY2VTY2FsZUFwaVByb3ZpZGVyID0gcHJpY2VTY2FsZUFwaVByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fY2hhcnRBcGkgPSBjaGFydEFwaTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZUFwaUdldHRlciA9IHBhbmVBcGlHZXR0ZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9kZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhQ2hhbmdlZERlbGVnYXRlLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgfVxuICAgIHByaWNlRm9ybWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfZm9ybWF0dGVyKCk7XG4gICAgfVxuICAgIHByaWNlVG9Db29yZGluYXRlKHByaWNlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShwcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgIH1cbiAgICBjb29yZGluYXRlVG9QcmljZShjb29yZGluYXRlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCk7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9jb29yZGluYXRlVG9QcmljZShjb29yZGluYXRlLCBmaXJzdFZhbHVlLl9pbnRlcm5hbF92YWx1ZSk7XG4gICAgfVxuICAgIGJhcnNJbkxvZ2ljYWxSYW5nZShyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIHVzZSBUaW1lU2NhbGVWaXNpYmxlUmFuZ2UgaGVyZSB0byBjb252ZXJ0IExvZ2ljYWxSYW5nZSB0byBzdHJpY3QgcmFuZ2UgcHJvcGVybHlcbiAgICAgICAgY29uc3QgY29ycmVjdGVkUmFuZ2UgPSBuZXcgVGltZVNjYWxlVmlzaWJsZVJhbmdlKG5ldyBSYW5nZUltcGwocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKS5faW50ZXJuYWxfc3RyaWN0UmFuZ2UoKTtcbiAgICAgICAgY29uc3QgYmFycyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhcnMoKTtcbiAgICAgICAgaWYgKGJhcnMuX2ludGVybmFsX2lzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YUZpcnN0QmFySW5SYW5nZSA9IGJhcnMuX2ludGVybmFsX3NlYXJjaChjb3JyZWN0ZWRSYW5nZS5faW50ZXJuYWxfbGVmdCgpLCAxIC8qIE1pc21hdGNoRGlyZWN0aW9uLk5lYXJlc3RSaWdodCAqLyk7XG4gICAgICAgIGNvbnN0IGRhdGFMYXN0QmFySW5SYW5nZSA9IGJhcnMuX2ludGVybmFsX3NlYXJjaChjb3JyZWN0ZWRSYW5nZS5faW50ZXJuYWxfcmlnaHQoKSwgLTEgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTmVhcmVzdExlZnQgKi8pO1xuICAgICAgICBjb25zdCBkYXRhRmlyc3RJbmRleCA9IGVuc3VyZU5vdE51bGwoYmFycy5faW50ZXJuYWxfZmlyc3RJbmRleCgpKTtcbiAgICAgICAgY29uc3QgZGF0YUxhc3RJbmRleCA9IGVuc3VyZU5vdE51bGwoYmFycy5faW50ZXJuYWxfbGFzdEluZGV4KCkpO1xuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgd2UgcmVxdWVzdCBkYXRhIGluIHRoZSBkYXRhIGdhcFxuICAgICAgICAvLyBlLmcuIGxldCdzIHNheSB3ZSBoYXZlIHNlcmllcyB3aXRoIGRhdGEgWzAuLjEwLCAzMC4uNjBdXG4gICAgICAgIC8vIGFuZCB3ZSByZXF1ZXN0IGJhcnMgaW5mbyBpbiByYW5nZSBbMTUsIDI1XVxuICAgICAgICAvLyB0aHVzLCBkYXRhRmlyc3RCYXJJblJhbmdlIHdpbGwgYmUgd2l0aCBpbmRleCAzMCBhbmQgZGF0YUxhc3RCYXJJblJhbmdlIHdpdGggMTBcbiAgICAgICAgaWYgKGRhdGFGaXJzdEJhckluUmFuZ2UgIT09IG51bGwgJiYgZGF0YUxhc3RCYXJJblJhbmdlICE9PSBudWxsICYmIGRhdGFGaXJzdEJhckluUmFuZ2UuX2ludGVybmFsX2luZGV4ID4gZGF0YUxhc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiYXJzQmVmb3JlOiByYW5nZS5mcm9tIC0gZGF0YUZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgYmFyc0FmdGVyOiBkYXRhTGFzdEluZGV4IC0gcmFuZ2UudG8sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhcnNCZWZvcmUgPSAoZGF0YUZpcnN0QmFySW5SYW5nZSA9PT0gbnVsbCB8fCBkYXRhRmlyc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9pbmRleCA9PT0gZGF0YUZpcnN0SW5kZXgpXG4gICAgICAgICAgICA/IHJhbmdlLmZyb20gLSBkYXRhRmlyc3RJbmRleFxuICAgICAgICAgICAgOiBkYXRhRmlyc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9pbmRleCAtIGRhdGFGaXJzdEluZGV4O1xuICAgICAgICBjb25zdCBiYXJzQWZ0ZXIgPSAoZGF0YUxhc3RCYXJJblJhbmdlID09PSBudWxsIHx8IGRhdGFMYXN0QmFySW5SYW5nZS5faW50ZXJuYWxfaW5kZXggPT09IGRhdGFMYXN0SW5kZXgpXG4gICAgICAgICAgICA/IGRhdGFMYXN0SW5kZXggLSByYW5nZS50b1xuICAgICAgICAgICAgOiBkYXRhTGFzdEluZGV4IC0gZGF0YUxhc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9pbmRleDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBiYXJzQmVmb3JlLCBiYXJzQWZ0ZXIgfTtcbiAgICAgICAgLy8gYWN0dWFsbHkgdGhleSBjYW4ndCBleGlzdCBzZXBhcmF0ZWx5XG4gICAgICAgIGlmIChkYXRhRmlyc3RCYXJJblJhbmdlICE9PSBudWxsICYmIGRhdGFMYXN0QmFySW5SYW5nZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmZyb20gPSBkYXRhRmlyc3RCYXJJblJhbmdlLl9pbnRlcm5hbF9vcmlnaW5hbFRpbWU7XG4gICAgICAgICAgICByZXN1bHQudG8gPSBkYXRhTGFzdEJhckluUmFuZ2UuX2ludGVybmFsX29yaWdpbmFsVGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZXREYXRhKGRhdGEpIHtcbiAgICAgICAgY2hlY2tJdGVtc0FyZU9yZGVyZWQoZGF0YSwgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IpO1xuICAgICAgICBjaGVja1Nlcmllc1ZhbHVlc1R5cGUodGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfc2VyaWVzVHlwZSgpLCBkYXRhKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RhdGFVcGRhdGVzQ29uc3VtZXIuX2ludGVybmFsX2FwcGx5TmV3RGF0YSh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLCBkYXRhKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb25EYXRhQ2hhbmdlZCgnZnVsbCcpO1xuICAgIH1cbiAgICB1cGRhdGUoYmFyLCBoaXN0b3JpY2FsVXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgY2hlY2tTZXJpZXNWYWx1ZXNUeXBlKHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3Nlcmllc1R5cGUoKSwgW2Jhcl0pO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YVVwZGF0ZXNDb25zdW1lci5faW50ZXJuYWxfdXBkYXRlRGF0YSh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLCBiYXIsIGhpc3RvcmljYWxVcGRhdGUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vbkRhdGFDaGFuZ2VkKCd1cGRhdGUnKTtcbiAgICB9XG4gICAgZGF0YUJ5SW5kZXgobG9naWNhbEluZGV4LCBtaXNtYXRjaERpcmVjdGlvbikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFycygpLl9pbnRlcm5hbF9zZWFyY2gobG9naWNhbEluZGV4LCBtaXNtYXRjaERpcmVjdGlvbik7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBhY3R1YWxseSBpdCBjYW4gYmUgYSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdG9yID0gZ2V0U2VyaWVzRGF0YUNyZWF0b3IodGhpcy5zZXJpZXNUeXBlKCkpO1xuICAgICAgICByZXR1cm4gY3JlYXRvcihkYXRhKTtcbiAgICB9XG4gICAgZGF0YSgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzQ3JlYXRvciA9IGdldFNlcmllc0RhdGFDcmVhdG9yKHRoaXMuc2VyaWVzVHlwZSgpKTtcbiAgICAgICAgY29uc3Qgcm93cyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhcnMoKS5faW50ZXJuYWxfcm93cygpO1xuICAgICAgICByZXR1cm4gcm93cy5tYXAoKHJvdykgPT4gc2VyaWVzQ3JlYXRvcihyb3cpKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlRGF0YUNoYW5nZWQoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhQ2hhbmdlZERlbGVnYXRlLl9pbnRlcm5hbF9zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlRGF0YUNoYW5nZWQoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhQ2hhbmdlZERlbGVnYXRlLl9pbnRlcm5hbF91bnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gY2xvbmUodGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpKTtcbiAgICB9XG4gICAgcHJpY2VTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3ByaWNlU2NhbGVBcGlQcm92aWRlci5wcmljZVNjYWxlKHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX3ByaWNlU2NhbGUoKS5faW50ZXJuYWxfaWQoKSwgdGhpcy5nZXRQYW5lKCkucGFuZUluZGV4KCkpO1xuICAgIH1cbiAgICBjcmVhdGVQcmljZUxpbmUob3B0aW9ucykge1xuICAgICAgICBjaGVja1ByaWNlTGluZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHN0cmljdE9wdGlvbnMgPSBtZXJnZShjbG9uZShwcmljZUxpbmVPcHRpb25zRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcHJpY2VMaW5lID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfY3JlYXRlUHJpY2VMaW5lKHN0cmljdE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFByaWNlTGluZShwcmljZUxpbmUpO1xuICAgIH1cbiAgICByZW1vdmVQcmljZUxpbmUobGluZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9yZW1vdmVQcmljZUxpbmUobGluZS5faW50ZXJuYWxfcHJpY2VMaW5lKCkpO1xuICAgIH1cbiAgICBwcmljZUxpbmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VMaW5lcygpLm1hcCgocHJpY2VMaW5lKSA9PiBuZXcgUHJpY2VMaW5lKHByaWNlTGluZSkpO1xuICAgIH1cbiAgICBzZXJpZXNUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfc2VyaWVzVHlwZSgpO1xuICAgIH1cbiAgICBhdHRhY2hQcmltaXRpdmUocHJpbWl0aXZlKSB7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgY2FzdCB0aGUgZ2VuZXJpYyB0byB1bmtub3duIGJlY2F1c2Ugd2VcbiAgICAgICAgLy8gZG9uJ3Qgd2FudCB0aGUgbW9kZWwgdG8ga25vdyB0aGUgdHlwZXMgb2YgdGhlIEFQSSAo4peRX+KXkSlcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYXR0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG4gICAgICAgIGlmIChwcmltaXRpdmUuYXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5hdHRhY2hlZCh7XG4gICAgICAgICAgICAgICAgY2hhcnQ6IHRoaXMuX2ludGVybmFsX19jaGFydEFwaSxcbiAgICAgICAgICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZTogKCkgPT4gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfZnVsbFVwZGF0ZSgpLFxuICAgICAgICAgICAgICAgIGhvcnpTY2FsZUJlaGF2aW9yOiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGFjaFByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfZGV0YWNoUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG4gICAgICAgIGlmIChwcmltaXRpdmUuZGV0YWNoZWQpIHtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5kZXRhY2hlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2Z1bGxVcGRhdGUoKTtcbiAgICB9XG4gICAgZ2V0UGFuZSgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5faW50ZXJuYWxfX3NlcmllcztcbiAgICAgICAgY29uc3QgcGFuZSA9IGVuc3VyZU5vdE51bGwodGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcGFuZUZvclNvdXJjZShzZXJpZXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVBcGlHZXR0ZXIocGFuZSk7XG4gICAgfVxuICAgIG1vdmVUb1BhbmUocGFuZUluZGV4KSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX21vdmVTZXJpZXNUb1BhbmUodGhpcy5faW50ZXJuYWxfX3NlcmllcywgcGFuZUluZGV4KTtcbiAgICB9XG4gICAgc2VyaWVzT3JkZXIoKSB7XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9wYW5lRm9yU291cmNlKHRoaXMuX2ludGVybmFsX19zZXJpZXMpO1xuICAgICAgICBpZiAocGFuZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYW5lLl9pbnRlcm5hbF9zZXJpZXMoKS5pbmRleE9mKHRoaXMuX2ludGVybmFsX19zZXJpZXMpO1xuICAgIH1cbiAgICBzZXRTZXJpZXNPcmRlcihvcmRlcikge1xuICAgICAgICBjb25zdCBwYW5lID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcGFuZUZvclNvdXJjZSh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzKTtcbiAgICAgICAgaWYgKHBhbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYW5lLl9pbnRlcm5hbF9zZXRTZXJpZXNPcmRlcih0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLCBvcmRlcik7XG4gICAgfVxuICAgIF9wcml2YXRlX19vbkRhdGFDaGFuZ2VkKHNjb3BlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhQ2hhbmdlZERlbGVnYXRlLl9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUNoYW5nZWREZWxlZ2F0ZS5faW50ZXJuYWxfZmlyZShzY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFRpbWVTY2FsZUFwaSB7XG4gICAgY29uc3RydWN0b3IobW9kZWwsIHRpbWVBeGlzV2lkZ2V0LCBob3J6U2NhbGVCZWhhdmlvcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lUmFuZ2VDaGFuZ2VkID0gbmV3IERlbGVnYXRlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZUNoYW5nZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZUNoYW5nZWQgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlID0gbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lQXhpc1dpZGdldCA9IHRpbWVBeGlzV2lkZ2V0O1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3Zpc2libGVCYXJzQ2hhbmdlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fb25WaXNpYmxlQmFyc0NoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfbG9naWNhbFJhbmdlQ2hhbmdlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUodGhpcy5fcHJpdmF0ZV9fb25WaXNpYmxlTG9naWNhbFJhbmdlQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX3NpemVDaGFuZ2VkKCkuX2ludGVybmFsX3N1YnNjcmliZSh0aGlzLl9wcml2YXRlX19vblNpemVDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF92aXNpYmxlQmFyc0NoYW5nZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfbG9naWNhbFJhbmdlQ2hhbmdlZCgpLl9pbnRlcm5hbF91bnN1YnNjcmliZUFsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZUF4aXNXaWRnZXQuX2ludGVybmFsX3NpemVDaGFuZ2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lUmFuZ2VDaGFuZ2VkLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZUNoYW5nZWQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZUNoYW5nZWQuX2ludGVybmFsX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgc2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX3JpZ2h0T2Zmc2V0KCk7XG4gICAgfVxuICAgIHNjcm9sbFRvUG9zaXRpb24ocG9zaXRpb24sIGFuaW1hdGVkKSB7XG4gICAgICAgIGlmICghYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF9zZXRSaWdodE9mZnNldChwb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9zY3JvbGxUb09mZnNldEFuaW1hdGVkKHBvc2l0aW9uLCAxMDAwIC8qIENvbnN0YW50cy5BbmltYXRpb25EdXJhdGlvbk1zICovKTtcbiAgICB9XG4gICAgc2Nyb2xsVG9SZWFsVGltZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9zY3JvbGxUb1JlYWxUaW1lKCk7XG4gICAgfVxuICAgIGdldFZpc2libGVSYW5nZSgpIHtcbiAgICAgICAgY29uc3QgdGltZVJhbmdlID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF92aXNpYmxlVGltZVJhbmdlKCk7XG4gICAgICAgIGlmICh0aW1lUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiB0aW1lUmFuZ2UuZnJvbS5vcmlnaW5hbFRpbWUsXG4gICAgICAgICAgICB0bzogdGltZVJhbmdlLnRvLm9yaWdpbmFsVGltZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0VmlzaWJsZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZFJhbmdlID0ge1xuICAgICAgICAgICAgZnJvbTogdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuY29udmVydEhvcnpJdGVtVG9JbnRlcm5hbChyYW5nZS5mcm9tKSxcbiAgICAgICAgICAgIHRvOiB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5jb252ZXJ0SG9yekl0ZW1Ub0ludGVybmFsKHJhbmdlLnRvKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbG9naWNhbFJhbmdlID0gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9sb2dpY2FsUmFuZ2VGb3JUaW1lUmFuZ2UoY29udmVydGVkUmFuZ2UpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfc2V0VGFyZ2V0TG9naWNhbFJhbmdlKGxvZ2ljYWxSYW5nZSk7XG4gICAgfVxuICAgIGdldFZpc2libGVMb2dpY2FsUmFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGxvZ2ljYWxSYW5nZSA9IHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfdmlzaWJsZUxvZ2ljYWxSYW5nZSgpO1xuICAgICAgICBpZiAobG9naWNhbFJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogbG9naWNhbFJhbmdlLl9pbnRlcm5hbF9sZWZ0KCksXG4gICAgICAgICAgICB0bzogbG9naWNhbFJhbmdlLl9pbnRlcm5hbF9yaWdodCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRWaXNpYmxlTG9naWNhbFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGFzc2VydChyYW5nZS5mcm9tIDw9IHJhbmdlLnRvLCAnVGhlIGZyb20gaW5kZXggY2Fubm90IGJlIGFmdGVyIHRoZSB0byBpbmRleC4nKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX3NldFRhcmdldExvZ2ljYWxSYW5nZShyYW5nZSk7XG4gICAgfVxuICAgIHJlc2V0VGltZVNjYWxlKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tb2RlbC5faW50ZXJuYWxfcmVzZXRUaW1lU2NhbGUoKTtcbiAgICB9XG4gICAgZml0Q29udGVudCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbW9kZWwuX2ludGVybmFsX2ZpdENvbnRlbnQoKTtcbiAgICB9XG4gICAgbG9naWNhbFRvQ29vcmRpbmF0ZShsb2dpY2FsKSB7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgaWYgKHRpbWVTY2FsZS5faW50ZXJuYWxfaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKGxvZ2ljYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvb3JkaW5hdGVUb0xvZ2ljYWwoeCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfY29vcmRpbmF0ZVRvSW5kZXgoeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGltZVRvSW5kZXgodGltZSwgZmluZE5lYXJlc3QpIHtcbiAgICAgICAgY29uc3QgdGltZVBvaW50ID0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IuY29udmVydEhvcnpJdGVtVG9JbnRlcm5hbCh0aW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfdGltZVRvSW5kZXgodGltZVBvaW50LCBmaW5kTmVhcmVzdCk7XG4gICAgfVxuICAgIHRpbWVUb0Nvb3JkaW5hdGUodGltZSkge1xuICAgICAgICBjb25zdCB0aW1lUG9pbnRJbmRleCA9IHRoaXMudGltZVRvSW5kZXgodGltZSwgZmFsc2UpO1xuICAgICAgICBpZiAodGltZVBvaW50SW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9Db29yZGluYXRlKHRpbWVQb2ludEluZGV4KTtcbiAgICB9XG4gICAgY29vcmRpbmF0ZVRvVGltZSh4KSB7XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKTtcbiAgICAgICAgY29uc3QgdGltZVBvaW50SW5kZXggPSB0aW1lU2NhbGUuX2ludGVybmFsX2Nvb3JkaW5hdGVUb0luZGV4KHgpO1xuICAgICAgICBjb25zdCB0aW1lUG9pbnQgPSB0aW1lU2NhbGUuX2ludGVybmFsX2luZGV4VG9UaW1lU2NhbGVQb2ludCh0aW1lUG9pbnRJbmRleCk7XG4gICAgICAgIGlmICh0aW1lUG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lUG9pbnQub3JpZ2luYWxUaW1lO1xuICAgIH1cbiAgICB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRTaXplKCkud2lkdGg7XG4gICAgfVxuICAgIGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3RpbWVBeGlzV2lkZ2V0Ll9pbnRlcm5hbF9nZXRTaXplKCkuaGVpZ2h0O1xuICAgIH1cbiAgICBzdWJzY3JpYmVWaXNpYmxlVGltZVJhbmdlQ2hhbmdlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZVZpc2libGVUaW1lUmFuZ2VDaGFuZ2UoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lUmFuZ2VDaGFuZ2VkLl9pbnRlcm5hbF91bnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlVmlzaWJsZUxvZ2ljYWxSYW5nZUNoYW5nZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZUNoYW5nZWQuX2ludGVybmFsX3N1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVWaXNpYmxlTG9naWNhbFJhbmdlQ2hhbmdlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfdW5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHN1YnNjcmliZVNpemVDaGFuZ2UoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplQ2hhbmdlZC5faW50ZXJuYWxfc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZVNpemVDaGFuZ2UoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zaXplQ2hhbmdlZC5faW50ZXJuYWxfdW5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIGFwcGx5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZS5faW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY2xvbmUodGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9vcHRpb25zKCkpLFxuICAgICAgICAgICAgYmFyU3BhY2luZzogdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9wcml2YXRlX19vblZpc2libGVCYXJzQ2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3RpbWVSYW5nZUNoYW5nZWQuX2ludGVybmFsX2hhc0xpc3RlbmVycygpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lUmFuZ2VDaGFuZ2VkLl9pbnRlcm5hbF9maXJlKHRoaXMuZ2V0VmlzaWJsZVJhbmdlKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19vblZpc2libGVMb2dpY2FsUmFuZ2VDaGFuZ2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fbG9naWNhbFJhbmdlQ2hhbmdlZC5faW50ZXJuYWxfaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2xvZ2ljYWxSYW5nZUNoYW5nZWQuX2ludGVybmFsX2ZpcmUodGhpcy5nZXRWaXNpYmxlTG9naWNhbFJhbmdlKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19vblNpemVDaGFuZ2VkKHNpemUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2l6ZUNoYW5nZWQuX2ludGVybmFsX2ZpcmUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgIH1cbn1cblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJfYnVpbGQtdGltZS1jb25zdGFudHNcIiAvPlxuZnVuY3Rpb24gcGF0Y2hQcmljZUZvcm1hdChwcmljZUZvcm1hdCkge1xuICAgIGlmIChwcmljZUZvcm1hdCA9PT0gdW5kZWZpbmVkIHx8IHByaWNlRm9ybWF0LnR5cGUgPT09ICdjdXN0b20nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJpY2VGb3JtYXRCdWlsdEluID0gcHJpY2VGb3JtYXQ7XG4gICAgaWYgKHByaWNlRm9ybWF0QnVpbHRJbi5taW5Nb3ZlICE9PSB1bmRlZmluZWQgJiYgcHJpY2VGb3JtYXRCdWlsdEluLnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByaWNlRm9ybWF0QnVpbHRJbi5wcmVjaXNpb24gPSBwcmVjaXNpb25CeU1pbk1vdmUocHJpY2VGb3JtYXRCdWlsdEluLm1pbk1vdmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1pZ3JhdGVIYW5kbGVTY2FsZVNjcm9sbE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChpc0Jvb2xlYW4ob3B0aW9uc1snaGFuZGxlU2NhbGUnXSkpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlU2NhbGUgPSBvcHRpb25zWydoYW5kbGVTY2FsZSddO1xuICAgICAgICBvcHRpb25zWydoYW5kbGVTY2FsZSddID0ge1xuICAgICAgICAgICAgYXhpc0RvdWJsZUNsaWNrUmVzZXQ6IHtcbiAgICAgICAgICAgICAgICB0aW1lOiBoYW5kbGVTY2FsZSxcbiAgICAgICAgICAgICAgICBwcmljZTogaGFuZGxlU2NhbGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXhpc1ByZXNzZWRNb3VzZU1vdmU6IHtcbiAgICAgICAgICAgICAgICB0aW1lOiBoYW5kbGVTY2FsZSxcbiAgICAgICAgICAgICAgICBwcmljZTogaGFuZGxlU2NhbGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2VXaGVlbDogaGFuZGxlU2NhbGUsXG4gICAgICAgICAgICBwaW5jaDogaGFuZGxlU2NhbGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnNbJ2hhbmRsZVNjYWxlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGF4aXNQcmVzc2VkTW91c2VNb3ZlLCBheGlzRG91YmxlQ2xpY2tSZXNldCB9ID0gb3B0aW9uc1snaGFuZGxlU2NhbGUnXTtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihheGlzUHJlc3NlZE1vdXNlTW92ZSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ2hhbmRsZVNjYWxlJ10uYXhpc1ByZXNzZWRNb3VzZU1vdmUgPSB7XG4gICAgICAgICAgICAgICAgdGltZTogYXhpc1ByZXNzZWRNb3VzZU1vdmUsXG4gICAgICAgICAgICAgICAgcHJpY2U6IGF4aXNQcmVzc2VkTW91c2VNb3ZlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCb29sZWFuKGF4aXNEb3VibGVDbGlja1Jlc2V0KSkge1xuICAgICAgICAgICAgb3B0aW9uc1snaGFuZGxlU2NhbGUnXS5heGlzRG91YmxlQ2xpY2tSZXNldCA9IHtcbiAgICAgICAgICAgICAgICB0aW1lOiBheGlzRG91YmxlQ2xpY2tSZXNldCxcbiAgICAgICAgICAgICAgICBwcmljZTogYXhpc0RvdWJsZUNsaWNrUmVzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVNjcm9sbCA9IG9wdGlvbnNbJ2hhbmRsZVNjcm9sbCddO1xuICAgIGlmIChpc0Jvb2xlYW4oaGFuZGxlU2Nyb2xsKSkge1xuICAgICAgICBvcHRpb25zWydoYW5kbGVTY3JvbGwnXSA9IHtcbiAgICAgICAgICAgIGhvcnpUb3VjaERyYWc6IGhhbmRsZVNjcm9sbCxcbiAgICAgICAgICAgIHZlcnRUb3VjaERyYWc6IGhhbmRsZVNjcm9sbCxcbiAgICAgICAgICAgIG1vdXNlV2hlZWw6IGhhbmRsZVNjcm9sbCxcbiAgICAgICAgICAgIHByZXNzZWRNb3VzZU1vdmU6IGhhbmRsZVNjcm9sbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0ludGVybmFsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgbWlncmF0ZUhhbmRsZVNjYWxlU2Nyb2xsT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmNsYXNzIENoYXJ0QXBpIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIGhvcnpTY2FsZUJlaGF2aW9yLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwUmV2ZXJzZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWREZWxlZ2F0ZSA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkRGVsZWdhdGUgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWREZWxlZ2F0ZSA9IG5ldyBEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFMYXllciA9IG5ldyBEYXRhTGF5ZXIoaG9yelNjYWxlQmVoYXZpb3IpO1xuICAgICAgICBjb25zdCBpbnRlcm5hbE9wdGlvbnMgPSAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSA/XG4gICAgICAgICAgICBjbG9uZShjaGFydE9wdGlvbnNEZWZhdWx0cygpKSA6XG4gICAgICAgICAgICBtZXJnZShjbG9uZShjaGFydE9wdGlvbnNEZWZhdWx0cygpKSwgdG9JbnRlcm5hbE9wdGlvbnMob3B0aW9ucykpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faG9yelNjYWxlQmVoYXZpb3IgPSBob3J6U2NhbGVCZWhhdmlvcjtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQgPSBuZXcgQ2hhcnRXaWRnZXQoY29udGFpbmVyLCBpbnRlcm5hbE9wdGlvbnMsIGhvcnpTY2FsZUJlaGF2aW9yKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2NsaWNrZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKChwYXJhbVN1cHBsaWVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fY2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWREZWxlZ2F0ZS5faW50ZXJuYWxfZmlyZSh0aGlzLl9wcml2YXRlX19jb252ZXJ0TW91c2VQYXJhbXMocGFyYW1TdXBwbGllcigpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfZGJsQ2xpY2tlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUoKHBhcmFtU3VwcGxpZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkRGVsZWdhdGUuX2ludGVybmFsX2hhc0xpc3RlbmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF9maXJlKHRoaXMuX3ByaXZhdGVfX2NvbnZlcnRNb3VzZVBhcmFtcyhwYXJhbVN1cHBsaWVyKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9jcm9zc2hhaXJNb3ZlZCgpLl9pbnRlcm5hbF9zdWJzY3JpYmUoKHBhcmFtU3VwcGxpZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZERlbGVnYXRlLl9pbnRlcm5hbF9oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkRGVsZWdhdGUuX2ludGVybmFsX2ZpcmUodGhpcy5fcHJpdmF0ZV9fY29udmVydE1vdXNlUGFyYW1zKHBhcmFtU3VwcGxpZXIoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlQXBpID0gbmV3IFRpbWVTY2FsZUFwaShtb2RlbCwgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX3RpbWVBeGlzV2lkZ2V0KCksIHRoaXMuX2ludGVybmFsX19ob3J6U2NhbGVCZWhhdmlvcik7XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2NsaWNrZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9kYmxDbGlja2VkKCkuX2ludGVybmFsX3Vuc3Vic2NyaWJlQWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfY3Jvc3NoYWlyTW92ZWQoKS5faW50ZXJuYWxfdW5zdWJzY3JpYmVBbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RpbWVTY2FsZUFwaS5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwUmV2ZXJzZWQuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RibENsaWNrZWREZWxlZ2F0ZS5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jcm9zc2hhaXJNb3ZlZERlbGVnYXRlLl9pbnRlcm5hbF9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFMYXllci5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCwgZm9yY2VSZXBhaW50KSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9TaXplQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIC8vIFdlIHJldHVybiBlYXJseSBoZXJlIGluc3RlYWQgb2YgY2hlY2tpbmcgdGhpcyB3aXRoaW4gdGhlIGFjdHVhbCBfY2hhcnRXaWRnZXQucmVzaXplIG1ldGhvZFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBvbmx5IGFwcGx5IHRvIGV4dGVybmFsIHJlc2l6ZSByZXF1ZXN0cy5cbiAgICAgICAgICAgIHdhcm4oYEhlaWdodCBhbmQgd2lkdGggdmFsdWVzIGlnbm9yZWQgYmVjYXVzZSAnYXV0b1NpemUnIG9wdGlvbiBpcyBlbmFibGVkLmApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9yZXNpemUod2lkdGgsIGhlaWdodCwgZm9yY2VSZXBhaW50KTtcbiAgICB9XG4gICAgYWRkQ3VzdG9tU2VyaWVzKGN1c3RvbVBhbmVWaWV3LCBvcHRpb25zID0ge30sIHBhbmVJbmRleCA9IDApIHtcbiAgICAgICAgY29uc3QgcGFuZVZpZXcgPSBlbnN1cmUoY3VzdG9tUGFuZVZpZXcpO1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gY3JlYXRlQ3VzdG9tU2VyaWVzRGVmaW5pdGlvbihwYW5lVmlldyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19hZGRTZXJpZXNJbXBsKGRlZmluaXRpb24sIG9wdGlvbnMsIHBhbmVJbmRleCk7XG4gICAgfVxuICAgIGFkZFNlcmllcyhkZWZpbml0aW9uLCBvcHRpb25zID0ge30sIHBhbmVJbmRleCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2FkZFNlcmllc0ltcGwoZGVmaW5pdGlvbiwgb3B0aW9ucywgcGFuZUluZGV4KTtcbiAgICB9XG4gICAgcmVtb3ZlU2VyaWVzKHNlcmllc0FwaSkge1xuICAgICAgICBjb25zdCBzZXJpZXMgPSBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcC5nZXQoc2VyaWVzQXBpKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMuX3ByaXZhdGVfX2RhdGFMYXllci5faW50ZXJuYWxfcmVtb3ZlU2VyaWVzKHNlcmllcyk7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCk7XG4gICAgICAgIG1vZGVsLl9pbnRlcm5hbF9yZW1vdmVTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VuZFVwZGF0ZVRvQ2hhcnQodXBkYXRlKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwLmRlbGV0ZShzZXJpZXNBcGkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXBSZXZlcnNlZC5kZWxldGUoc2VyaWVzKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2FwcGx5TmV3RGF0YShzZXJpZXMsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VuZFVwZGF0ZVRvQ2hhcnQodGhpcy5fcHJpdmF0ZV9fZGF0YUxheWVyLl9pbnRlcm5hbF9zZXRTZXJpZXNEYXRhKHNlcmllcywgZGF0YSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlRGF0YShzZXJpZXMsIGRhdGEsIGhpc3RvcmljYWxVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VuZFVwZGF0ZVRvQ2hhcnQodGhpcy5fcHJpdmF0ZV9fZGF0YUxheWVyLl9pbnRlcm5hbF91cGRhdGVTZXJpZXNEYXRhKHNlcmllcywgZGF0YSwgaGlzdG9yaWNhbFVwZGF0ZSkpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVDbGljayhoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NsaWNrZWREZWxlZ2F0ZS5faW50ZXJuYWxfc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZUNsaWNrKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF91bnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlQ3Jvc3NoYWlyTW92ZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2Nyb3NzaGFpck1vdmVkRGVsZWdhdGUuX2ludGVybmFsX3N1YnNjcmliZShoYW5kbGVyKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVDcm9zc2hhaXJNb3ZlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY3Jvc3NoYWlyTW92ZWREZWxlZ2F0ZS5faW50ZXJuYWxfdW5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHN1YnNjcmliZURibENsaWNrKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGJsQ2xpY2tlZERlbGVnYXRlLl9pbnRlcm5hbF9zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlRGJsQ2xpY2soaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYmxDbGlja2VkRGVsZWdhdGUuX2ludGVybmFsX3Vuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIH1cbiAgICBwcmljZVNjYWxlKHByaWNlU2NhbGVJZCwgcGFuZUluZGV4ID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFByaWNlU2NhbGVBcGkodGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQsIHByaWNlU2NhbGVJZCwgcGFuZUluZGV4KTtcbiAgICB9XG4gICAgdGltZVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fdGltZVNjYWxlQXBpO1xuICAgIH1cbiAgICBhcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjb2xvclNwYWNlID0gb3B0aW9ucy5sYXlvdXQ/LmNvbG9yU3BhY2U7XG4gICAgICAgICAgICBpZiAoY29sb3JTcGFjZSAhPT0gdW5kZWZpbmVkICYmIGNvbG9yU3BhY2UgIT09IHRoaXMub3B0aW9ucygpLmxheW91dC5jb2xvclNwYWNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2xvclNwYWNlIG9wdGlvbiBzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSB0aGUgY2hhcnQgaGFzIGJlZW4gY3JlYXRlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbG9yUGFyc2VycyA9IG9wdGlvbnMubGF5b3V0Py5jb2xvclBhcnNlcnM7XG4gICAgICAgICAgICBpZiAoY29sb3JQYXJzZXJzICE9PSB1bmRlZmluZWQgJiYgY29sb3JQYXJzZXJzICE9PSB0aGlzLm9wdGlvbnMoKS5sYXlvdXQuY29sb3JQYXJzZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2xvclBhcnNlcnMgb3B0aW9uIHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHRoZSBjaGFydCBoYXMgYmVlbiBjcmVhdGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9hcHBseU9wdGlvbnModG9JbnRlcm5hbE9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cbiAgICBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICB9XG4gICAgdGFrZVNjcmVlbnNob3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfdGFrZVNjcmVlbnNob3QoKTtcbiAgICB9XG4gICAgcmVtb3ZlUGFuZShpbmRleCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcmVtb3ZlUGFuZShpbmRleCk7XG4gICAgfVxuICAgIHN3YXBQYW5lcyhmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9zd2FwUGFuZXMoZmlyc3QsIHNlY29uZCk7XG4gICAgfVxuICAgIGF1dG9TaXplQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX2F1dG9TaXplQWN0aXZlKCk7XG4gICAgfVxuICAgIGNoYXJ0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9lbGVtZW50KCk7XG4gICAgfVxuICAgIHBhbmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX3BhbmVzKCkubWFwKChwYW5lKSA9PiB0aGlzLl9wcml2YXRlX19nZXRQYW5lQXBpKHBhbmUpKTtcbiAgICB9XG4gICAgcGFuZVNpemUocGFuZUluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX3BhbmVTaXplKHBhbmVJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldENyb3NzaGFpclBvc2l0aW9uKHByaWNlLCBob3Jpem9udGFsUG9zaXRpb24sIHNlcmllc0FwaSkge1xuICAgICAgICBjb25zdCBzZXJpZXMgPSB0aGlzLl9wcml2YXRlX19zZXJpZXNNYXAuZ2V0KHNlcmllc0FwaSk7XG4gICAgICAgIGlmIChzZXJpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhbmUgPSB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKS5faW50ZXJuYWxfcGFuZUZvclNvdXJjZShzZXJpZXMpO1xuICAgICAgICBpZiAocGFuZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9zZXRBbmRTYXZlU3ludGhldGljUG9zaXRpb24ocHJpY2UsIGhvcml6b250YWxQb3NpdGlvbiwgcGFuZSk7XG4gICAgfVxuICAgIGNsZWFyQ3Jvc3NoYWlyUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0V2lkZ2V0Ll9pbnRlcm5hbF9tb2RlbCgpLl9pbnRlcm5hbF9jbGVhckN1cnJlbnRQb3NpdGlvbih0cnVlKTtcbiAgICB9XG4gICAgaG9yekJlaGF2aW91cigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19ob3J6U2NhbGVCZWhhdmlvcjtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2FkZFNlcmllc0ltcGwoZGVmaW5pdGlvbiwgb3B0aW9ucyA9IHt9LCBwYW5lSW5kZXggPSAwKSB7XG4gICAgICAgIGFzc2VydChpc1Nlcmllc0RlZmluaXRpb24oZGVmaW5pdGlvbikpO1xuICAgICAgICBwYXRjaFByaWNlRm9ybWF0KG9wdGlvbnMucHJpY2VGb3JtYXQpO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi50eXBlID09PSAnQ2FuZGxlc3RpY2snKSB7XG4gICAgICAgICAgICBmaWxsVXBEb3duQ2FuZGxlc3RpY2tzQ29sb3JzKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmljdE9wdGlvbnMgPSBtZXJnZShjbG9uZShzZXJpZXNPcHRpb25zRGVmYXVsdHMpLCBjbG9uZShkZWZpbml0aW9uLmRlZmF1bHRPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZVBhbmVWaWV3ID0gZGVmaW5pdGlvbi5faW50ZXJuYWxfY3JlYXRlUGFuZVZpZXc7XG4gICAgICAgIGNvbnN0IHNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCksIGRlZmluaXRpb24udHlwZSwgc3RyaWN0T3B0aW9ucywgY3JlYXRlUGFuZVZpZXcsIGRlZmluaXRpb24uX2ludGVybmFsX2N1c3RvbVBhbmVWaWV3KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQuX2ludGVybmFsX21vZGVsKCkuX2ludGVybmFsX2FkZFNlcmllc1RvUGFuZShzZXJpZXMsIHBhbmVJbmRleCk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBTZXJpZXNBcGkoc2VyaWVzLCB0aGlzLCB0aGlzLCB0aGlzLCB0aGlzLl9pbnRlcm5hbF9faG9yelNjYWxlQmVoYXZpb3IsIChwYW5lKSA9PiB0aGlzLl9wcml2YXRlX19nZXRQYW5lQXBpKHBhbmUpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzTWFwLnNldChyZXMsIHNlcmllcyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcFJldmVyc2VkLnNldChzZXJpZXMsIHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9wcml2YXRlX19zZW5kVXBkYXRlVG9DaGFydCh1cGRhdGUpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9wcml2YXRlX19jaGFydFdpZGdldC5faW50ZXJuYWxfbW9kZWwoKTtcbiAgICAgICAgbW9kZWwuX2ludGVybmFsX3VwZGF0ZVRpbWVTY2FsZSh1cGRhdGUuX2ludGVybmFsX3RpbWVTY2FsZS5faW50ZXJuYWxfYmFzZUluZGV4LCB1cGRhdGUuX2ludGVybmFsX3RpbWVTY2FsZS5faW50ZXJuYWxfcG9pbnRzLCB1cGRhdGUuX2ludGVybmFsX3RpbWVTY2FsZS5faW50ZXJuYWxfZmlyc3RDaGFuZ2VkUG9pbnRJbmRleCk7XG4gICAgICAgIHVwZGF0ZS5faW50ZXJuYWxfc2VyaWVzLmZvckVhY2goKHZhbHVlLCBzZXJpZXMpID0+IHNlcmllcy5faW50ZXJuYWxfc2V0RGF0YSh2YWx1ZS5faW50ZXJuYWxfZGF0YSwgdmFsdWUuX2ludGVybmFsX2luZm8pKTtcbiAgICAgICAgbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9yZWNhbGN1bGF0ZUluZGljZXNXaXRoRGF0YSgpO1xuICAgICAgICBtb2RlbC5faW50ZXJuYWxfcmVjYWxjdWxhdGVBbGxQYW5lcygpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWFwU2VyaWVzVG9BcGkoc2VyaWVzKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX3Nlcmllc01hcFJldmVyc2VkLmdldChzZXJpZXMpKTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2NvbnZlcnRNb3VzZVBhcmFtcyhwYXJhbSkge1xuICAgICAgICBjb25zdCBzZXJpZXNEYXRhID0gbmV3IE1hcCgpO1xuICAgICAgICBwYXJhbS5faW50ZXJuYWxfc2VyaWVzRGF0YS5mb3JFYWNoKChwbG90Um93LCBzZXJpZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc1R5cGUgPSBzZXJpZXMuX2ludGVybmFsX3Nlcmllc1R5cGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBnZXRTZXJpZXNEYXRhQ3JlYXRvcihzZXJpZXNUeXBlKShwbG90Um93KTtcbiAgICAgICAgICAgIGlmIChzZXJpZXNUeXBlICE9PSAnQ3VzdG9tJykge1xuICAgICAgICAgICAgICAgIGFzc2VydChpc0Z1bGZpbGxlZERhdGEoZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tV2hpdGVzcGFjZUNoZWNrZXIgPSBzZXJpZXMuX2ludGVybmFsX2N1c3RvbVNlcmllc1doaXRlc3BhY2VDaGVjaygpO1xuICAgICAgICAgICAgICAgIGFzc2VydCghY3VzdG9tV2hpdGVzcGFjZUNoZWNrZXIgfHwgY3VzdG9tV2hpdGVzcGFjZUNoZWNrZXIoZGF0YSkgPT09IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcmllc0RhdGEuc2V0KHRoaXMuX3ByaXZhdGVfX21hcFNlcmllc1RvQXBpKHNlcmllcyksIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaG92ZXJlZFNlcmllcyA9IHBhcmFtLl9pbnRlcm5hbF9ob3ZlcmVkU2VyaWVzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICF0aGlzLl9wcml2YXRlX19zZXJpZXNNYXBSZXZlcnNlZC5oYXMocGFyYW0uX2ludGVybmFsX2hvdmVyZWRTZXJpZXMpXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB0aGlzLl9wcml2YXRlX19tYXBTZXJpZXNUb0FwaShwYXJhbS5faW50ZXJuYWxfaG92ZXJlZFNlcmllcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aW1lOiBwYXJhbS5faW50ZXJuYWxfb3JpZ2luYWxUaW1lLFxuICAgICAgICAgICAgbG9naWNhbDogcGFyYW0uX2ludGVybmFsX2luZGV4LFxuICAgICAgICAgICAgcG9pbnQ6IHBhcmFtLl9pbnRlcm5hbF9wb2ludCxcbiAgICAgICAgICAgIHBhbmVJbmRleDogcGFyYW0uX2ludGVybmFsX3BhbmVJbmRleCxcbiAgICAgICAgICAgIGhvdmVyZWRTZXJpZXMsXG4gICAgICAgICAgICBob3ZlcmVkT2JqZWN0SWQ6IHBhcmFtLl9pbnRlcm5hbF9ob3ZlcmVkT2JqZWN0LFxuICAgICAgICAgICAgc2VyaWVzRGF0YSxcbiAgICAgICAgICAgIHNvdXJjZUV2ZW50OiBwYXJhbS5faW50ZXJuYWxfdG91Y2hNb3VzZUV2ZW50RGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldFBhbmVBcGkocGFuZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fcHJpdmF0ZV9fcGFuZXMuZ2V0KHBhbmUpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFBhbmVBcGkodGhpcy5fcHJpdmF0ZV9fY2hhcnRXaWRnZXQsIChzZXJpZXMpID0+IHRoaXMuX3ByaXZhdGVfX21hcFNlcmllc1RvQXBpKHNlcmllcyksIHBhbmUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZXMuc2V0KHBhbmUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZldGNoSHRtbEVsZW1lbnQoY29udGFpbmVyKSB7XG4gICAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcik7XG4gICAgICAgIGFzc2VydChlbGVtZW50ICE9PSBudWxsLCBgQ2Fubm90IGZpbmQgZWxlbWVudCBpbiBET00gd2l0aCBpZD0ke2NvbnRhaW5lcn1gKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgb2YgdGhlIExpZ2h0d2VpZ2h0IENoYXJ0aW5nIExpYnJhcnkuIElmIHlvdSBhcmUgdXNpbmcgdGltZSB2YWx1ZXNcbiAqIGZvciB0aGUgaG9yaXpvbnRhbCBzY2FsZSB0aGVuIGl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IHJhdGhlciB1c2UgdGhlIHtAbGluayBjcmVhdGVDaGFydH0gZnVuY3Rpb24uXG4gKlxuICogQHRlbXBsYXRlIEhvcnpTY2FsZUl0ZW0gLSB0eXBlIG9mIHBvaW50cyBvbiB0aGUgaG9yaXpvbnRhbCBzY2FsZVxuICogQHRlbXBsYXRlIFRIb3J6U2NhbGVCZWhhdmlvciAtIHR5cGUgb2YgaG9yaXpvbnRhbCBheGlzIHN0cmF0ZWd5IHRoYXQgZW5jYXBzdWxhdGUgYWxsIHRoZSBzcGVjaWZpYyBiZWhhdmlvcnMgb2YgdGhlIGhvcml6b250YWwgc2NhbGUgdHlwZVxuICpcbiAqIEBwYXJhbSBjb250YWluZXIgLSBJRCBvZiBIVE1MIGVsZW1lbnQgb3IgZWxlbWVudCBpdHNlbGZcbiAqIEBwYXJhbSBob3J6U2NhbGVCZWhhdmlvciAtIEhvcml6b250YWwgc2NhbGUgYmVoYXZpb3JcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW55IHN1YnNldCBvZiBvcHRpb25zIHRvIGJlIGFwcGxpZWQgYXQgc3RhcnQuXG4gKiBAcmV0dXJucyBBbiBpbnRlcmZhY2UgdG8gdGhlIGNyZWF0ZWQgY2hhcnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhcnRFeChjb250YWluZXIsIGhvcnpTY2FsZUJlaGF2aW9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaHRtbEVsZW1lbnQgPSBmZXRjaEh0bWxFbGVtZW50KGNvbnRhaW5lcik7XG4gICAgY29uc3QgcmVzID0gbmV3IENoYXJ0QXBpKGh0bWxFbGVtZW50LCBob3J6U2NhbGVCZWhhdmlvciwgb3B0aW9ucyk7XG4gICAgaG9yelNjYWxlQmVoYXZpb3Iuc2V0T3B0aW9ucyhyZXMub3B0aW9ucygpKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBzaW1wbGlmaWVkIG1haW4gZW50cnkgcG9pbnQgb2YgdGhlIExpZ2h0d2VpZ2h0IENoYXJ0aW5nIExpYnJhcnkgd2l0aCB0aW1lIHBvaW50cyBmb3IgdGhlIGhvcml6b250YWwgc2NhbGUuXG4gKlxuICogQHBhcmFtIGNvbnRhaW5lciAtIElEIG9mIEhUTUwgZWxlbWVudCBvciBlbGVtZW50IGl0c2VsZlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbnkgc3Vic2V0IG9mIG9wdGlvbnMgdG8gYmUgYXBwbGllZCBhdCBzdGFydC5cbiAqIEByZXR1cm5zIEFuIGludGVyZmFjZSB0byB0aGUgY3JlYXRlZCBjaGFydFxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFydChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhcnRFeChjb250YWluZXIsIG5ldyBIb3J6U2NhbGVCZWhhdmlvclRpbWUoKSwgSG9yelNjYWxlQmVoYXZpb3JUaW1lLl9pbnRlcm5hbF9hcHBseURlZmF1bHRzKG9wdGlvbnMpKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGhvcml6b250YWwgc2NhbGUgKHRpbWUtYmFzZWQpIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBiYXNlIGZvciBleHRlbmRpbmcgdGhlIGhvcml6b250YWwgc2NhbGUgd2l0aCBjdXN0b20gYmVoYXZpb3IuXG4gKiBUaGlzIGFsbG93cyBmb3IgdGhlIGludHJvZHVjdGlvbiBvZiBjdXN0b20gZnVuY3Rpb25hbGl0eSB3aXRob3V0IHJlLWltcGxlbWVudGluZyB0aGUgZW50aXJlIHtAbGluayBJSG9yelNjYWxlQmVoYXZpb3J9Jmx0O3tAbGluayBUaW1lfSZndDsgaW50ZXJmYWNlLlxuICpcbiAqIEZvciBmdXJ0aGVyIGRldGFpbHMsIHJlZmVyIHRvIHRoZSB7QGxpbmsgY3JlYXRlQ2hhcnRFeH0gY2hhcnQgY29uc3RydWN0b3IgbWV0aG9kLlxuICpcbiAqIEByZXR1cm5zIEFuIHVuaW5pdGlhbGl6ZWQgY2xhc3MgaW1wbGVtZW50aW5nIHRoZSB7QGxpbmsgSUhvcnpTY2FsZUJlaGF2aW9yfSZsdDt7QGxpbmsgVGltZX0mZ3Q7IGludGVyZmFjZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0SG9yelNjYWxlQmVoYXZpb3IoKSB7XG4gICAgcmV0dXJuIEhvcnpTY2FsZUJlaGF2aW9yVGltZTtcbn1cblxuY2xhc3MgTGluZVBhbmVWaWV3QmFzZSBleHRlbmRzIFNlcmllc1BhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBtb2RlbCkge1xuICAgICAgICBzdXBlcihzZXJpZXMsIG1vZGVsLCB0cnVlKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19jb252ZXJ0VG9Db29yZGluYXRlcyhwcmljZVNjYWxlLCB0aW1lU2NhbGUsIGZpcnN0VmFsdWUpIHtcbiAgICAgICAgdGltZVNjYWxlLl9pbnRlcm5hbF9pbmRleGVzVG9Db29yZGluYXRlcyh0aGlzLl9pbnRlcm5hbF9faXRlbXMsIHVuZGVmaW5lZElmTnVsbCh0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UpKTtcbiAgICAgICAgcHJpY2VTY2FsZS5faW50ZXJuYWxfcG9pbnRzQXJyYXlUb0Nvb3JkaW5hdGVzKHRoaXMuX2ludGVybmFsX19pdGVtcywgZmlyc3RWYWx1ZSwgdW5kZWZpbmVkSWZOdWxsKHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW1CYXNlKHRpbWUsIHByaWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfdGltZTogdGltZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wcmljZTogcHJpY2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfeDogTmFOLFxuICAgICAgICAgICAgX2ludGVybmFsX3k6IE5hTixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX19maWxsUmF3UG9pbnRzKCkge1xuICAgICAgICBjb25zdCBjb2xvcmVyID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfYmFyQ29sb3JlcigpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9faXRlbXMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9iYXJzKCkuX2ludGVybmFsX3Jvd3MoKS5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByb3cuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19jcmVhdGVSYXdJdGVtKHJvdy5faW50ZXJuYWxfaW5kZXgsIHZhbHVlLCBjb2xvcmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmF3U2VyaWVzUG9pbnRNYXJrZXJzKHJlbmRlcmluZ1Njb3BlLCBpdGVtcywgcG9pbnRNYXJrZXJzUmFkaXVzLCB2aXNpYmxlUmFuZ2UsIFxuLy8gdGhlIHZhbHVlcyByZXR1cm5lZCBieSBzdHlsZUdldHRlciBhcmUgY29tcGFyZWQgdXNpbmcgdGhlIG9wZXJhdG9yICE9PSxcbi8vIHNvIGlmIHN0eWxlR2V0dGVyIHJldHVybnMgb2JqZWN0cywgdGhlbiBzdHlsZUdldHRlciBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIG9iamVjdCBmb3IgZXF1YWwgc3R5bGVzXG5zdHlsZUdldHRlcikge1xuICAgIGlmICh2aXNpYmxlUmFuZ2UudG8gLSB2aXNpYmxlUmFuZ2UuZnJvbSA8PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvLCBjb250ZXh0IH0gPSByZW5kZXJpbmdTY29wZTtcbiAgICBsZXQgcHJldlN0eWxlID0gbnVsbDtcbiAgICBjb25zdCB0aWNrV2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSk7XG4gICAgY29uc3QgY29ycmVjdGlvbiA9ICh0aWNrV2lkdGggJSAyKSAvIDI7XG4gICAgY29uc3QgcmFkaXVzID0gcG9pbnRNYXJrZXJzUmFkaXVzICogdmVydGljYWxQaXhlbFJhdGlvICsgY29ycmVjdGlvbjtcbiAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLnRvIC0gMTsgaSA+PSB2aXNpYmxlUmFuZ2UuZnJvbTsgLS1pKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChwb2ludCkge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBzdHlsZUdldHRlcihyZW5kZXJpbmdTY29wZSwgcG9pbnQpO1xuICAgICAgICAgICAgaWYgKHN0eWxlICE9PSBwcmV2U3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2U3R5bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjZW50ZXJYID0gTWF0aC5yb3VuZChwb2ludC5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvKSArIGNvcnJlY3Rpb247IC8vIGNvcnJlY3QgeCBjb29yZGluYXRlIG9ubHlcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlclkgPSBwb2ludC5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICAgICAgY29udGV4dC5hcmMoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udGV4dC5maWxsKCk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zLCBjb21wbGV4aXR5XG5mdW5jdGlvbiB3YWxrTGluZShyZW5kZXJpbmdTY29wZSwgaXRlbXMsIGxpbmVUeXBlLCB2aXNpYmxlUmFuZ2UsIGJhcldpZHRoLCBcbi8vIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgc3R5bGVHZXR0ZXIgYXJlIGNvbXBhcmVkIHVzaW5nIHRoZSBvcGVyYXRvciAhPT0sXG4vLyBzbyBpZiBzdHlsZUdldHRlciByZXR1cm5zIG9iamVjdHMsIHRoZW4gc3R5bGVHZXR0ZXIgc2hvdWxkIHJldHVybiB0aGUgc2FtZSBvYmplY3QgZm9yIGVxdWFsIHN0eWxlc1xuc3R5bGVHZXR0ZXIsIGZpbmlzaFN0eWxlZEFyZWEpIHtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwIHx8IHZpc2libGVSYW5nZS5mcm9tID49IGl0ZW1zLmxlbmd0aCB8fCB2aXNpYmxlUmFuZ2UudG8gPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogY3R4LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0gPSByZW5kZXJpbmdTY29wZTtcbiAgICBjb25zdCBmaXJzdEl0ZW0gPSBpdGVtc1t2aXNpYmxlUmFuZ2UuZnJvbV07XG4gICAgbGV0IGN1cnJlbnRTdHlsZSA9IHN0eWxlR2V0dGVyKHJlbmRlcmluZ1Njb3BlLCBmaXJzdEl0ZW0pO1xuICAgIGxldCBjdXJyZW50U3R5bGVGaXJzdEl0ZW0gPSBmaXJzdEl0ZW07XG4gICAgaWYgKHZpc2libGVSYW5nZS50byAtIHZpc2libGVSYW5nZS5mcm9tIDwgMikge1xuICAgICAgICBjb25zdCBoYWxmQmFyV2lkdGggPSBiYXJXaWR0aCAvIDI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29uc3QgaXRlbTEgPSB7IF9pbnRlcm5hbF94OiBmaXJzdEl0ZW0uX2ludGVybmFsX3ggLSBoYWxmQmFyV2lkdGgsIF9pbnRlcm5hbF95OiBmaXJzdEl0ZW0uX2ludGVybmFsX3kgfTtcbiAgICAgICAgY29uc3QgaXRlbTIgPSB7IF9pbnRlcm5hbF94OiBmaXJzdEl0ZW0uX2ludGVybmFsX3ggKyBoYWxmQmFyV2lkdGgsIF9pbnRlcm5hbF95OiBmaXJzdEl0ZW0uX2ludGVybmFsX3kgfTtcbiAgICAgICAgY3R4Lm1vdmVUbyhpdGVtMS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBpdGVtMS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIGN0eC5saW5lVG8oaXRlbTIuX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgaXRlbTIuX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICBmaW5pc2hTdHlsZWRBcmVhKHJlbmRlcmluZ1Njb3BlLCBjdXJyZW50U3R5bGUsIGl0ZW0xLCBpdGVtMik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjaGFuZ2VTdHlsZSA9IChuZXdTdHlsZSwgY3VycmVudEl0ZW0pID0+IHtcbiAgICAgICAgICAgIGZpbmlzaFN0eWxlZEFyZWEocmVuZGVyaW5nU2NvcGUsIGN1cnJlbnRTdHlsZSwgY3VycmVudFN0eWxlRmlyc3RJdGVtLCBjdXJyZW50SXRlbSk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdXJyZW50U3R5bGUgPSBuZXdTdHlsZTtcbiAgICAgICAgICAgIGN1cnJlbnRTdHlsZUZpcnN0SXRlbSA9IGN1cnJlbnRJdGVtO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY3VycmVudEl0ZW0gPSBjdXJyZW50U3R5bGVGaXJzdEl0ZW07XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhmaXJzdEl0ZW0uX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgZmlyc3RJdGVtLl9pbnRlcm5hbF95ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHZpc2libGVSYW5nZS5mcm9tICsgMTsgaSA8IHZpc2libGVSYW5nZS50bzsgKytpKSB7XG4gICAgICAgICAgICBjdXJyZW50SXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgY29uc3QgaXRlbVN0eWxlID0gc3R5bGVHZXR0ZXIocmVuZGVyaW5nU2NvcGUsIGN1cnJlbnRJdGVtKTtcbiAgICAgICAgICAgIHN3aXRjaCAobGluZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogTGluZVR5cGUuU2ltcGxlICovOlxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1cnJlbnRJdGVtLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGN1cnJlbnRJdGVtLl9pbnRlcm5hbF95ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIExpbmVUeXBlLldpdGhTdGVwcyAqLzpcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjdXJyZW50SXRlbS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBpdGVtc1tpIC0gMV0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVN0eWxlICE9PSBjdXJyZW50U3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVN0eWxlKGl0ZW1TdHlsZSwgY3VycmVudEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjdXJyZW50SXRlbS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBpdGVtc1tpIC0gMV0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3VycmVudEl0ZW0uX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgY3VycmVudEl0ZW0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogTGluZVR5cGUuQ3VydmVkICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjcDEsIGNwMl0gPSBnZXRDb250cm9sUG9pbnRzKGl0ZW1zLCBpIC0gMSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNwMS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBjcDEuX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8sIGNwMi5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBjcDIuX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8sIGN1cnJlbnRJdGVtLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGN1cnJlbnRJdGVtLl9pbnRlcm5hbF95ICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbmVUeXBlICE9PSAxIC8qIExpbmVUeXBlLldpdGhTdGVwcyAqLyAmJiBpdGVtU3R5bGUgIT09IGN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZVN0eWxlKGl0ZW1TdHlsZSwgY3VycmVudEl0ZW0pO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY3VycmVudEl0ZW0uX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbywgY3VycmVudEl0ZW0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50U3R5bGVGaXJzdEl0ZW0gIT09IGN1cnJlbnRJdGVtIHx8IGN1cnJlbnRTdHlsZUZpcnN0SXRlbSA9PT0gY3VycmVudEl0ZW0gJiYgbGluZVR5cGUgPT09IDEgLyogTGluZVR5cGUuV2l0aFN0ZXBzICovKSB7XG4gICAgICAgICAgICBmaW5pc2hTdHlsZWRBcmVhKHJlbmRlcmluZ1Njb3BlLCBjdXJyZW50U3R5bGUsIGN1cnJlbnRTdHlsZUZpcnN0SXRlbSwgY3VycmVudEl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgY3VydmVUZW5zaW9uID0gNjtcbmZ1bmN0aW9uIHN1YnRyYWN0KHAxLCBwMikge1xuICAgIHJldHVybiB7IF9pbnRlcm5hbF94OiBwMS5faW50ZXJuYWxfeCAtIHAyLl9pbnRlcm5hbF94LCBfaW50ZXJuYWxfeTogcDEuX2ludGVybmFsX3kgLSBwMi5faW50ZXJuYWxfeSB9O1xufVxuZnVuY3Rpb24gYWRkKHAxLCBwMikge1xuICAgIHJldHVybiB7IF9pbnRlcm5hbF94OiBwMS5faW50ZXJuYWxfeCArIHAyLl9pbnRlcm5hbF94LCBfaW50ZXJuYWxfeTogcDEuX2ludGVybmFsX3kgKyBwMi5faW50ZXJuYWxfeSB9O1xufVxuZnVuY3Rpb24gZGl2aWRlKHAxLCBuKSB7XG4gICAgcmV0dXJuIHsgX2ludGVybmFsX3g6IHAxLl9pbnRlcm5hbF94IC8gbiwgX2ludGVybmFsX3k6IHAxLl9pbnRlcm5hbF95IC8gbiB9O1xufVxuLyoqXG4gKiBAcmV0dXJucyBUd28gY29udHJvbCBwb2ludHMgdGhhdCBjYW4gYmUgdXNlZCBhcyBhcmd1bWVudHMgdG8ge0BsaW5rIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5iZXppZXJDdXJ2ZVRvfSB0byBkcmF3IGEgY3VydmVkIGxpbmUgYmV0d2VlbiBgcG9pbnRzW2Zyb21Qb2ludEluZGV4XWAgYW5kIGBwb2ludHNbdG9Qb2ludEluZGV4XWAuXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRyb2xQb2ludHMocG9pbnRzLCBmcm9tUG9pbnRJbmRleCwgdG9Qb2ludEluZGV4KSB7XG4gICAgY29uc3QgYmVmb3JlRnJvbVBvaW50SW5kZXggPSBNYXRoLm1heCgwLCBmcm9tUG9pbnRJbmRleCAtIDEpO1xuICAgIGNvbnN0IGFmdGVyVG9Qb2ludEluZGV4ID0gTWF0aC5taW4ocG9pbnRzLmxlbmd0aCAtIDEsIHRvUG9pbnRJbmRleCArIDEpO1xuICAgIGNvbnN0IGNwMSA9IGFkZChwb2ludHNbZnJvbVBvaW50SW5kZXhdLCBkaXZpZGUoc3VidHJhY3QocG9pbnRzW3RvUG9pbnRJbmRleF0sIHBvaW50c1tiZWZvcmVGcm9tUG9pbnRJbmRleF0pLCBjdXJ2ZVRlbnNpb24pKTtcbiAgICBjb25zdCBjcDIgPSBzdWJ0cmFjdChwb2ludHNbdG9Qb2ludEluZGV4XSwgZGl2aWRlKHN1YnRyYWN0KHBvaW50c1thZnRlclRvUG9pbnRJbmRleF0sIHBvaW50c1tmcm9tUG9pbnRJbmRleF0pLCBjdXJ2ZVRlbnNpb24pKTtcbiAgICByZXR1cm4gW2NwMSwgY3AyXTtcbn1cblxuZnVuY3Rpb24gZmluaXNoU3R5bGVkQXJlYSQxKHNjb3BlLCBzdHlsZSkge1xuICAgIGNvbnN0IGN0eCA9IHNjb3BlLmNvbnRleHQ7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGU7XG4gICAgY3R4LnN0cm9rZSgpO1xufVxuY2xhc3MgUGFuZVJlbmRlcmVyTGluZUJhc2UgZXh0ZW5kcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwocmVuZGVyaW5nU2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX19kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBfaW50ZXJuYWxfaXRlbXM6IGl0ZW1zLCBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiB2aXNpYmxlUmFuZ2UsIF9pbnRlcm5hbF9iYXJXaWR0aDogYmFyV2lkdGgsIF9pbnRlcm5hbF9saW5lVHlwZTogbGluZVR5cGUsIF9pbnRlcm5hbF9saW5lV2lkdGg6IGxpbmVXaWR0aCwgX2ludGVybmFsX2xpbmVTdHlsZTogbGluZVN0eWxlLCBfaW50ZXJuYWxfcG9pbnRNYXJrZXJzUmFkaXVzOiBwb2ludE1hcmtlcnNSYWRpdXMgfSA9IHRoaXMuX2ludGVybmFsX19kYXRhO1xuICAgICAgICBpZiAodmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3R4ID0gcmVuZGVyaW5nU2NvcGUuY29udGV4dDtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggKiByZW5kZXJpbmdTY29wZS52ZXJ0aWNhbFBpeGVsUmF0aW87XG4gICAgICAgIHNldExpbmVTdHlsZShjdHgsIGxpbmVTdHlsZSk7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgICAgIGNvbnN0IHN0eWxlR2V0dGVyID0gdGhpcy5faW50ZXJuYWxfX3N0cm9rZVN0eWxlLmJpbmQodGhpcyk7XG4gICAgICAgIGlmIChsaW5lVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3YWxrTGluZShyZW5kZXJpbmdTY29wZSwgaXRlbXMsIGxpbmVUeXBlLCB2aXNpYmxlUmFuZ2UsIGJhcldpZHRoLCBzdHlsZUdldHRlciwgZmluaXNoU3R5bGVkQXJlYSQxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnRNYXJrZXJzUmFkaXVzKSB7XG4gICAgICAgICAgICBkcmF3U2VyaWVzUG9pbnRNYXJrZXJzKHJlbmRlcmluZ1Njb3BlLCBpdGVtcywgcG9pbnRNYXJrZXJzUmFkaXVzLCB2aXNpYmxlUmFuZ2UsIHN0eWxlR2V0dGVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgUGFuZVJlbmRlcmVyTGluZSBleHRlbmRzIFBhbmVSZW5kZXJlckxpbmVCYXNlIHtcbiAgICBfaW50ZXJuYWxfX3N0cm9rZVN0eWxlKHJlbmRlcmluZ1Njb3BlLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLl9pbnRlcm5hbF9saW5lQ29sb3I7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNMaW5lUGFuZVZpZXcgZXh0ZW5kcyBMaW5lUGFuZVZpZXdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyID0gbmV3IFBhbmVSZW5kZXJlckxpbmUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19jcmVhdGVSYXdJdGVtKHRpbWUsIHByaWNlLCBjb2xvcmVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLl9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbUJhc2UodGltZSwgcHJpY2UpLFxuICAgICAgICAgICAgLi4uY29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUodGltZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSgpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pdGVtczogdGhpcy5faW50ZXJuYWxfX2l0ZW1zLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVTdHlsZTogb3B0aW9ucy5saW5lU3R5bGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVR5cGU6IG9wdGlvbnMubGluZVZpc2libGUgPyBvcHRpb25zLmxpbmVUeXBlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVXaWR0aDogb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICAgICAgICBfaW50ZXJuYWxfcG9pbnRNYXJrZXJzUmFkaXVzOiBvcHRpb25zLnBvaW50TWFya2Vyc1Zpc2libGUgPyAob3B0aW9ucy5wb2ludE1hcmtlcnNSYWRpdXMgfHwgb3B0aW9ucy5saW5lV2lkdGggLyAyICsgMikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyV2lkdGg6IHRoaXMuX2ludGVybmFsX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2JhclNwYWNpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKGRhdGEpO1xuICAgIH1cbn1cblxuY29uc3QgbGluZVN0eWxlRGVmYXVsdHMgPSB7XG4gICAgY29sb3I6ICcjMjE5NmYzJyxcbiAgICBsaW5lU3R5bGU6IDAgLyogTGluZVN0eWxlLlNvbGlkICovLFxuICAgIGxpbmVXaWR0aDogMyxcbiAgICBsaW5lVHlwZTogMCAvKiBMaW5lVHlwZS5TaW1wbGUgKi8sXG4gICAgbGluZVZpc2libGU6IHRydWUsXG4gICAgY3Jvc3NoYWlyTWFya2VyVmlzaWJsZTogdHJ1ZSxcbiAgICBjcm9zc2hhaXJNYXJrZXJSYWRpdXM6IDQsXG4gICAgY3Jvc3NoYWlyTWFya2VyQm9yZGVyQ29sb3I6ICcnLFxuICAgIGNyb3NzaGFpck1hcmtlckJvcmRlcldpZHRoOiAyLFxuICAgIGNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvcjogJycsXG4gICAgbGFzdFByaWNlQW5pbWF0aW9uOiAwIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuRGlzYWJsZWQgKi8sXG4gICAgcG9pbnRNYXJrZXJzVmlzaWJsZTogZmFsc2UsXG59O1xuY29uc3QgY3JlYXRlUGFuZVZpZXckNSA9IChzZXJpZXMsIG1vZGVsKSA9PiBuZXcgU2VyaWVzTGluZVBhbmVWaWV3KHNlcmllcywgbW9kZWwpO1xuY29uc3QgY3JlYXRlTGluZVNlcmllcyA9ICgpID0+IHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgICB0eXBlOiAnTGluZScsXG4gICAgICAgIGlzQnVpbHRJbjogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdE9wdGlvbnM6IGxpbmVTdHlsZURlZmF1bHRzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBfaW50ZXJuYWxfY3JlYXRlUGFuZVZpZXc6IGNyZWF0ZVBhbmVWaWV3JDUsXG4gICAgfTtcbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbn07XG5jb25zdCBsaW5lU2VyaWVzID0gY3JlYXRlTGluZVNlcmllcygpO1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJvdW5jZWRNaWNyb1Rhc2tIYW5kbGVyKGNhbGxiYWNrKSB7XG4gICAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtXaXRoR3JlYXRlcldlaWdodCQxKGEsIGIpIHtcbiAgICByZXR1cm4gYS53ZWlnaHQgPiBiLndlaWdodCA/IGEgOiBiO1xufVxuZnVuY3Rpb24gdG9JbnRlcm5hbEhvcnpTY2FsZUl0ZW0oaXRlbSkge1xuICAgIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gZnJvbUludGVybmFsSG9yelNjYWxlSXRlbShpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW07XG59XG5jbGFzcyBZaWVsZEN1cnZlSG9yelNjYWxlQmVoYXZpb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb2ludHNDaGFuZ2VkRGVsZWdhdGUgPSBuZXcgRGVsZWdhdGUoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZVdoaXRlc3BhY2UgPSBjcmVhdGVEZWJvdW5jZWRNaWNyb1Rhc2tIYW5kbGVyKCgpID0+IHRoaXMuX3ByaXZhdGVfX3BvaW50c0NoYW5nZWREZWxlZ2F0ZS5faW50ZXJuYWxfZmlyZSh0aGlzLl9wcml2YXRlX19sYXJnZXN0SW5kZXgpKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbGFyZ2VzdEluZGV4ID0gMDtcbiAgICB9XG4gICAgLyoqIERhdGEgY2hhbmdlcyBtaWdodCByZXF1aXJlIHRoYXQgdGhlIHdoaXRlc3BhY2UgYmUgZ2VuZXJhdGVkIGFnYWluICovXG4gICAgX2ludGVybmFsX3doaXRlc3BhY2VJbnZhbGlkYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BvaW50c0NoYW5nZWREZWxlZ2F0ZTtcbiAgICB9XG4gICAgX2ludGVybmFsX2Rlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BvaW50c0NoYW5nZWREZWxlZ2F0ZS5faW50ZXJuYWxfZGVzdHJveSgpO1xuICAgIH1cbiAgICBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucztcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBwcmVwcm9jZXNzRGF0YShkYXRhKSB7XG4gICAgICAgIC8vIE5vIHByZXByb2Nlc3NpbmcgbmVlZGVkIGZvciB5aWVsZCBjdXJ2ZSBkYXRhXG4gICAgfVxuICAgIHVwZGF0ZUZvcm1hdHRlcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubG9jYWxpemF0aW9uID0gb3B0aW9ucztcbiAgICB9XG4gICAgY3JlYXRlQ29udmVydGVyVG9JbnRlcm5hbE9iaihkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVXaGl0ZXNwYWNlKCk7XG4gICAgICAgIHJldHVybiAodGltZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWUgPiB0aGlzLl9wcml2YXRlX19sYXJnZXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19sYXJnZXN0SW5kZXggPSB0aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvSW50ZXJuYWxIb3J6U2NhbGVJdGVtKHRpbWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBrZXkoaW50ZXJuYWxJdGVtKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbEl0ZW07XG4gICAgfVxuICAgIGNhY2hlS2V5KGludGVybmFsSXRlbSkge1xuICAgICAgICByZXR1cm4gZnJvbUludGVybmFsSG9yelNjYWxlSXRlbShpbnRlcm5hbEl0ZW0pO1xuICAgIH1cbiAgICBjb252ZXJ0SG9yekl0ZW1Ub0ludGVybmFsKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRvSW50ZXJuYWxIb3J6U2NhbGVJdGVtKGl0ZW0pO1xuICAgIH1cbiAgICBmb3JtYXRIb3J6SXRlbShpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRUaW1lKGl0ZW0pO1xuICAgIH1cbiAgICBmb3JtYXRUaWNrbWFyayhpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19mb3JtYXRUaW1lKGl0ZW0udGltZSk7XG4gICAgfVxuICAgIG1heFRpY2tNYXJrV2VpZ2h0KG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcy5yZWR1Y2UobWFya1dpdGhHcmVhdGVyV2VpZ2h0JDEsIG1hcmtzWzBdKS53ZWlnaHQ7XG4gICAgfVxuICAgIGZpbGxXZWlnaHRzRm9yUG9pbnRzKHNvcnRlZFRpbWVQb2ludHMsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgdGltZVdlaWdodCA9ICh0aW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodGltZSAlIDEyMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lICUgNjAgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lICUgMzYgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lICUgMTIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lICUgNiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWUgJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZSAlIDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgc29ydGVkVGltZVBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIHNvcnRlZFRpbWVQb2ludHNbaW5kZXhdLnRpbWVXZWlnaHQgPSB0aW1lV2VpZ2h0KGZyb21JbnRlcm5hbEhvcnpTY2FsZUl0ZW0oc29ydGVkVGltZVBvaW50c1tpbmRleF0udGltZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xhcmdlc3RJbmRleCA9IGZyb21JbnRlcm5hbEhvcnpTY2FsZUl0ZW0oc29ydGVkVGltZVBvaW50c1tzb3J0ZWRUaW1lUG9pbnRzLmxlbmd0aCAtIDFdLnRpbWUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlV2hpdGVzcGFjZSgpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZm9ybWF0VGltZShtb250aHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubG9jYWxpemF0aW9uPy50aW1lRm9ybWF0dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sb2NhbGl6YXRpb24udGltZUZvcm1hdHRlcihtb250aHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aHMgPCAxMikge1xuICAgICAgICAgICAgcmV0dXJuIGAke21vbnRoc31NYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB5ZWFycyA9IE1hdGguZmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBjb25zdCByZW1haW5pbmdNb250aHMgPSBtb250aHMgJSAxMjtcbiAgICAgICAgaWYgKHJlbWFpbmluZ01vbnRocyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3llYXJzfVlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt5ZWFyc31ZJHtyZW1haW5pbmdNb250aHN9TWA7XG4gICAgfVxufVxuXG5jb25zdCB5aWVsZENoYXJ0T3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIGJhc2VSZXNvbHV0aW9uOiAxLFxuICAgIG1pbmltdW1UaW1lUmFuZ2U6IDEyMCxcbiAgICBzdGFydFRpbWVSYW5nZTogMCxcbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlV2hpdGVzcGFjZURhdGEoeyBfaW50ZXJuYWxfc3RhcnQ6IHN0YXJ0LCBfaW50ZXJuYWxfZW5kOiBlbmQsIF9pbnRlcm5hbF9yZXNvbHV0aW9uOiByZXNvbHV0aW9uLCB9KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IE1hdGguZmxvb3IoKGVuZCAtIHN0YXJ0KSAvIHJlc29sdXRpb24pICsgMSB9LCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcXVvdGUtcHJvcHNcbiAgICAoaXRlbSwgaSkgPT4gKHsgJ3RpbWUnOiBzdGFydCArIGkgKiByZXNvbHV0aW9uIH0pKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV2hpdGVzcGFjZVN0YXRlKG9wdGlvbnMsIGxhc3RJbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9pbnRlcm5hbF9zdGFydDogTWF0aC5tYXgoMCwgb3B0aW9ucy5zdGFydFRpbWVSYW5nZSksXG4gICAgICAgIF9pbnRlcm5hbF9lbmQ6IE1hdGgubWF4KDAsIG9wdGlvbnMubWluaW11bVRpbWVSYW5nZSwgbGFzdEluZGV4IHx8IDApLFxuICAgICAgICBfaW50ZXJuYWxfcmVzb2x1dGlvbjogTWF0aC5tYXgoMSwgb3B0aW9ucy5iYXNlUmVzb2x1dGlvbiksXG4gICAgfTtcbn1cbmNvbnN0IGdlbmVyYXRlV2hpdGVzcGFjZUhhc2ggPSAoeyBfaW50ZXJuYWxfc3RhcnQ6IHN0YXJ0LCBfaW50ZXJuYWxfZW5kOiBlbmQsIF9pbnRlcm5hbF9yZXNvbHV0aW9uOiByZXNvbHV0aW9uLCB9KSA9PiBgJHtzdGFydH1+JHtlbmR9fiR7cmVzb2x1dGlvbn1gO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgeWllbGRDdXJ2ZTogeWllbGRDaGFydE9wdGlvbnNEZWZhdWx0cyxcbiAgICAvLyBhbmQgYWRkIHNlbnNpYmxlIGRlZmF1bHQgb3B0aW9ucyBmb3IgeWllbGQgY2hhcnRzIHdoaWNoXG4gICAgLy8gYXJlIGRpZmZlcmVudCBmcm9tIHRoZSB1c3VhbCBkZWZhdWx0cy5cbiAgICB0aW1lU2NhbGU6IHtcbiAgICAgICAgaWdub3JlV2hpdGVzcGFjZUluZGljZXM6IHRydWUsXG4gICAgfSxcbiAgICBsZWZ0UHJpY2VTY2FsZToge1xuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgIH0sXG4gICAgcmlnaHRQcmljZVNjYWxlOiB7XG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgIH0sXG4gICAgbG9jYWxpemF0aW9uOiB7XG4gICAgICAgIHByaWNlRm9ybWF0dGVyOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0ZpeGVkKDMpICsgJyUnO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuY29uc3QgbGluZVN0eWxlRGVmYXVsdE9wdGlvbk92ZXJyaWRlcyA9IHtcbiAgICBsYXN0VmFsdWVWaXNpYmxlOiBmYWxzZSxcbiAgICBwcmljZUxpbmVWaXNpYmxlOiBmYWxzZSxcbn07XG5jbGFzcyBZaWVsZENoYXJ0QXBpIGV4dGVuZHMgQ2hhcnRBcGkge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmdWxsT3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgY29uc3QgaG9yekJlaGF2aW91ciA9IG5ldyBZaWVsZEN1cnZlSG9yelNjYWxlQmVoYXZpb3IoKTtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyLCBob3J6QmVoYXZpb3VyLCBmdWxsT3B0aW9ucyk7XG4gICAgICAgIGhvcnpCZWhhdmlvdXIuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMoKSk7XG4gICAgICAgIHRoaXMuX2luaXRXaGl0ZXNwYWNlU2VyaWVzKCk7XG4gICAgfVxuICAgIGFkZFNlcmllcyhkZWZpbml0aW9uLCBvcHRpb25zID0ge30sIHBhbmVJbmRleCA9IDApIHtcbiAgICAgICAgaWYgKGRlZmluaXRpb24uaXNCdWlsdEluICYmIFsnQXJlYScsICdMaW5lJ10uaW5jbHVkZXMoZGVmaW5pdGlvbi50eXBlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWWllbGQgY3VydmUgb25seSBzdXBwb3J0IEFyZWEgYW5kIExpbmUgc2VyaWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9uT3ZlcnJpZGVzID0ge1xuICAgICAgICAgICAgLi4ubGluZVN0eWxlRGVmYXVsdE9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdXBlci5hZGRTZXJpZXMoZGVmaW5pdGlvbiwgb3B0aW9uT3ZlcnJpZGVzLCBwYW5lSW5kZXgpO1xuICAgIH1cbiAgICBfaW5pdFdoaXRlc3BhY2VTZXJpZXMoKSB7XG4gICAgICAgIGNvbnN0IGhvcnpCZWhhdmlvdXIgPSB0aGlzLmhvcnpCZWhhdmlvdXIoKTtcbiAgICAgICAgY29uc3Qgd2hpdGVTcGFjZVNlcmllcyA9IHRoaXMuYWRkU2VyaWVzKGxpbmVTZXJpZXMpO1xuICAgICAgICBsZXQgY3VycmVudFdoaXRlc3BhY2VIYXNoO1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVXaGl0ZXNwYWNlKGxhc3RJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgbmV3V2hpdGVzcGFjZVN0YXRlID0gYnVpbGRXaGl0ZXNwYWNlU3RhdGUoaG9yekJlaGF2aW91ci5vcHRpb25zKCkueWllbGRDdXJ2ZSwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1doaXRlc3BhY2VIYXNoID0gZ2VuZXJhdGVXaGl0ZXNwYWNlSGFzaChuZXdXaGl0ZXNwYWNlU3RhdGUpO1xuICAgICAgICAgICAgaWYgKG5ld1doaXRlc3BhY2VIYXNoICE9PSBjdXJyZW50V2hpdGVzcGFjZUhhc2gpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2hpdGVzcGFjZUhhc2ggPSBuZXdXaGl0ZXNwYWNlSGFzaDtcbiAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlU2VyaWVzLnNldERhdGEoZ2VuZXJhdGVXaGl0ZXNwYWNlRGF0YShuZXdXaGl0ZXNwYWNlU3RhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVXaGl0ZXNwYWNlKDApO1xuICAgICAgICBob3J6QmVoYXZpb3VyLl9pbnRlcm5hbF93aGl0ZXNwYWNlSW52YWxpZGF0ZWQoKS5faW50ZXJuYWxfc3Vic2NyaWJlKHVwZGF0ZVdoaXRlc3BhY2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgeWllbGQgY3VydmUgY2hhcnQgd2l0aCB0aGUgc3BlY2lmaWVkIG9wdGlvbnMuXG4gKlxuICogQSB5aWVsZCBjdXJ2ZSBjaGFydCBkaWZmZXJzIGZyb20gdGhlIGRlZmF1bHQgY2hhcnQgdHlwZVxuICogaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBIb3Jpem9udGFsIHNjYWxlIGlzIGxpbmVhcmx5IHNwYWNlZCwgYW5kIGRlZmluZWQgaW4gbW9udGhseVxuICogdGltZSBkdXJhdGlvbiB1bml0c1xuICogLSBXaGl0ZXNwYWNlIGlzIGlnbm9yZWQgZm9yIHRoZSBjcm9zc2hhaXIgYW5kIGdyaWQgbGluZXNcbiAqXG4gKiBAcGFyYW0gY29udGFpbmVyIC0gSUQgb2YgSFRNTCBlbGVtZW50IG9yIGVsZW1lbnQgaXRzZWxmXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSB5aWVsZCBjaGFydCBvcHRpb25zLlxuICogQHJldHVybnMgQW4gaW50ZXJmYWNlIHRvIHRoZSBjcmVhdGVkIGNoYXJ0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVlpZWxkQ3VydmVDaGFydChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBodG1sRWxlbWVudCA9IGZldGNoSHRtbEVsZW1lbnQoY29udGFpbmVyKTtcbiAgICBjb25zdCBjaGFydEFwaSA9IG5ldyBZaWVsZENoYXJ0QXBpKGh0bWxFbGVtZW50LCBvcHRpb25zKTtcbiAgICByZXR1cm4gY2hhcnRBcGk7XG59XG5cbmZ1bmN0aW9uIG1hcmtXaXRoR3JlYXRlcldlaWdodChhLCBiKSB7XG4gICAgcmV0dXJuIGEud2VpZ2h0ID4gYi53ZWlnaHQgPyBhIDogYjtcbn1cbmNsYXNzIEhvcnpTY2FsZUJlaGF2aW9yUHJpY2Uge1xuICAgIG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19vcHRpb25zO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHByZXByb2Nlc3NEYXRhKGRhdGEpIHsgfVxuICAgIHVwZGF0ZUZvcm1hdHRlcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubG9jYWxpemF0aW9uID0gb3B0aW9ucztcbiAgICB9XG4gICAgY3JlYXRlQ29udmVydGVyVG9JbnRlcm5hbE9iaihkYXRhKSB7XG4gICAgICAgIHJldHVybiAocHJpY2UpID0+IHByaWNlO1xuICAgIH1cbiAgICBrZXkoaW50ZXJuYWxJdGVtKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbEl0ZW07XG4gICAgfVxuICAgIGNhY2hlS2V5KGludGVybmFsSXRlbSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxJdGVtO1xuICAgIH1cbiAgICBjb252ZXJ0SG9yekl0ZW1Ub0ludGVybmFsKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGZvcm1hdEhvcnpJdGVtKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9GaXhlZCh0aGlzLl9wcml2YXRlX19wcmVjaXNpb24oKSk7XG4gICAgfVxuICAgIGZvcm1hdFRpY2ttYXJrKGl0ZW0sIGxvY2FsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udGltZS50b0ZpeGVkKHRoaXMuX3ByaXZhdGVfX3ByZWNpc2lvbigpKTtcbiAgICB9XG4gICAgbWF4VGlja01hcmtXZWlnaHQobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzLnJlZHVjZShtYXJrV2l0aEdyZWF0ZXJXZWlnaHQsIG1hcmtzWzBdKS53ZWlnaHQ7XG4gICAgfVxuICAgIGZpbGxXZWlnaHRzRm9yUG9pbnRzKHNvcnRlZFRpbWVQb2ludHMsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgcHJpY2VXZWlnaHQgPSAocHJpY2UpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmljZSA9PT0gTWF0aC5jZWlsKHByaWNlIC8gMTAwKSAqIDEwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaWNlID09PSBNYXRoLmNlaWwocHJpY2UgLyA1MCkgKiA1MCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaWNlID09PSBNYXRoLmNlaWwocHJpY2UgLyAyNSkgKiAyNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaWNlID09PSBNYXRoLmNlaWwocHJpY2UgLyAxMCkgKiAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaWNlID09PSBNYXRoLmNlaWwocHJpY2UgLyA1KSAqIDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmljZSA9PT0gTWF0aC5jZWlsKHByaWNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaWNlICogMiA9PT0gTWF0aC5jZWlsKHByaWNlICogMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgc29ydGVkVGltZVBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIHNvcnRlZFRpbWVQb2ludHNbaW5kZXhdLnRpbWVXZWlnaHQgPSBwcmljZVdlaWdodChzb3J0ZWRUaW1lUG9pbnRzW2luZGV4XS50aW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fcHJlY2lzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5sb2NhbGl6YXRpb25cbiAgICAgICAgICAgIC5wcmVjaXNpb247XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gJ29wdGlvbnMnIGNoYXJ0IHdpdGggcHJpY2UgdmFsdWVzIG9uIHRoZSBob3Jpem9udGFsIHNjYWxlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjcmVhdGUgYSBzcGVjaWFsaXplZCBjaGFydCB0eXBlIHdoZXJlIHRoZSBob3Jpem9udGFsIHNjYWxlXG4gKiByZXByZXNlbnRzIHByaWNlIHZhbHVlcyBpbnN0ZWFkIG9mIHRpbWUuIEl0J3MgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgdmlzdWFsaXppbmdcbiAqIG9wdGlvbiBjaGFpbnMsIHByaWNlIGRpc3RyaWJ1dGlvbnMsIG9yIGFueSBkYXRhIHdoZXJlIHByaWNlIGlzIHRoZSBwcmltYXJ5IHgtYXhpcyBtZXRyaWMuXG4gKlxuICogQHBhcmFtIGNvbnRhaW5lciAtIFRoZSBET00gZWxlbWVudCBvciBpdHMgaWQgd2hlcmUgdGhlIGNoYXJ0IHdpbGwgYmUgcmVuZGVyZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHByaWNlIGNoYXJ0LlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgSUNoYXJ0QXBpQmFzZSBjb25maWd1cmVkIGZvciBwcmljZS1iYXNlZCBob3Jpem9udGFsIHNjYWxpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnNDaGFydChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhcnRFeChjb250YWluZXIsIG5ldyBIb3J6U2NhbGVCZWhhdmlvclByaWNlKCksIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hTdHlsZWRBcmVhKGJhc2VMZXZlbENvb3JkaW5hdGUsIHNjb3BlLCBzdHlsZSwgYXJlYUZpcnN0SXRlbSwgbmV3QXJlYUZpcnN0SXRlbSkge1xuICAgIGNvbnN0IHsgY29udGV4dCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9ID0gc2NvcGU7XG4gICAgY29udGV4dC5saW5lVG8obmV3QXJlYUZpcnN0SXRlbS5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvLCBiYXNlTGV2ZWxDb29yZGluYXRlICogdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICBjb250ZXh0LmxpbmVUbyhhcmVhRmlyc3RJdGVtLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8sIGJhc2VMZXZlbENvb3JkaW5hdGUgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBzdHlsZTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbn1cbmNsYXNzIFBhbmVSZW5kZXJlckFyZWFCYXNlIGV4dGVuZHMgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2RyYXdJbXBsKHJlbmRlcmluZ1Njb3BlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9fZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgX2ludGVybmFsX2l0ZW1zOiBpdGVtcywgX2ludGVybmFsX3Zpc2libGVSYW5nZTogdmlzaWJsZVJhbmdlLCBfaW50ZXJuYWxfYmFyV2lkdGg6IGJhcldpZHRoLCBfaW50ZXJuYWxfbGluZVdpZHRoOiBsaW5lV2lkdGgsIF9pbnRlcm5hbF9saW5lU3R5bGU6IGxpbmVTdHlsZSwgX2ludGVybmFsX2xpbmVUeXBlOiBsaW5lVHlwZSB9ID0gdGhpcy5faW50ZXJuYWxfX2RhdGE7XG4gICAgICAgIGNvbnN0IGJhc2VMZXZlbENvb3JkaW5hdGUgPSB0aGlzLl9pbnRlcm5hbF9fZGF0YS5faW50ZXJuYWxfYmFzZUxldmVsQ29vcmRpbmF0ZSA/P1xuICAgICAgICAgICAgKHRoaXMuX2ludGVybmFsX19kYXRhLl9pbnRlcm5hbF9pbnZlcnRGaWxsZWRBcmVhID8gMCA6IHJlbmRlcmluZ1Njb3BlLm1lZGlhU2l6ZS5oZWlnaHQpO1xuICAgICAgICBpZiAodmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3R4ID0gcmVuZGVyaW5nU2NvcGUuY29udGV4dDtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIHNldExpbmVTdHlsZShjdHgsIGxpbmVTdHlsZSk7XG4gICAgICAgIC8vIHdhbGsgbGluZXMgd2l0aCB3aWR0aD0xIHRvIGhhdmUgbW9yZSBhY2N1cmF0ZSBncmFkaWVudCdzIGZpbGxpbmdcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIHdhbGtMaW5lKHJlbmRlcmluZ1Njb3BlLCBpdGVtcywgbGluZVR5cGUsIHZpc2libGVSYW5nZSwgYmFyV2lkdGgsIHRoaXMuX2ludGVybmFsX19maWxsU3R5bGUuYmluZCh0aGlzKSwgZmluaXNoU3R5bGVkQXJlYS5iaW5kKG51bGwsIGJhc2VMZXZlbENvb3JkaW5hdGUpKTtcbiAgICB9XG59XG5cbmNsYXNzIEdyYWRpZW50U3R5bGVDYWNoZSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBfaW50ZXJuYWxfZ2V0KHNjb3BlLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkUGFyYW1zID0gdGhpcy5fcHJpdmF0ZV9fcGFyYW1zO1xuICAgICAgICBjb25zdCB7IF9pbnRlcm5hbF90b3BDb2xvcjE6IHRvcENvbG9yMSwgX2ludGVybmFsX3RvcENvbG9yMjogdG9wQ29sb3IyLCBfaW50ZXJuYWxfYm90dG9tQ29sb3IxOiBib3R0b21Db2xvcjEsIF9pbnRlcm5hbF9ib3R0b21Db2xvcjI6IGJvdHRvbUNvbG9yMiwgX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGU6IGJhc2VMZXZlbENvb3JkaW5hdGUsIF9pbnRlcm5hbF90b3BDb29yZGluYXRlOiB0b3BDb29yZGluYXRlLCBfaW50ZXJuYWxfYm90dG9tQ29vcmRpbmF0ZTogYm90dG9tQ29vcmRpbmF0ZSwgfSA9IHBhcmFtcztcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2NhY2hlZFZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGNhY2hlZFBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX3RvcENvbG9yMSAhPT0gdG9wQ29sb3IxIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX3RvcENvbG9yMiAhPT0gdG9wQ29sb3IyIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX2JvdHRvbUNvbG9yMSAhPT0gYm90dG9tQ29sb3IxIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX2JvdHRvbUNvbG9yMiAhPT0gYm90dG9tQ29sb3IyIHx8XG4gICAgICAgICAgICBjYWNoZWRQYXJhbXMuX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGUgIT09IGJhc2VMZXZlbENvb3JkaW5hdGUgfHxcbiAgICAgICAgICAgIGNhY2hlZFBhcmFtcy5faW50ZXJuYWxfdG9wQ29vcmRpbmF0ZSAhPT0gdG9wQ29vcmRpbmF0ZSB8fFxuICAgICAgICAgICAgY2FjaGVkUGFyYW1zLl9pbnRlcm5hbF9ib3R0b21Db29yZGluYXRlICE9PSBib3R0b21Db29yZGluYXRlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZlcnRpY2FsUGl4ZWxSYXRpbyB9ID0gc2NvcGU7XG4gICAgICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gYmFzZUxldmVsQ29vcmRpbmF0ZSB8fCB0b3BDb29yZGluYXRlID4gMCA/IHZlcnRpY2FsUGl4ZWxSYXRpbyA6IDE7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSB0b3BDb29yZGluYXRlICogbXVsdGlwbGllcjtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGJvdHRvbUNvb3JkaW5hdGUgPT09IHNjb3BlLmJpdG1hcFNpemUuaGVpZ2h0ID8gYm90dG9tQ29vcmRpbmF0ZSA6IGJvdHRvbUNvb3JkaW5hdGUgKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgY29uc3QgYmFzZWxpbmUgPSAoYmFzZUxldmVsQ29vcmRpbmF0ZSA/PyAwKSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICBjb25zdCBncmFkaWVudCA9IHNjb3BlLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgdG9wLCAwLCBib3R0b20pO1xuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIHRvcENvbG9yMSk7XG4gICAgICAgICAgICBpZiAoYmFzZUxldmVsQ29vcmRpbmF0ZSAhPT0gbnVsbCAmJiBiYXNlTGV2ZWxDb29yZGluYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlbGluZVJhdGlvID0gY2xhbXAoKChiYXNlbGluZSAtIHRvcCkgLyByYW5nZSksIDAsIDEpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChiYXNlbGluZVJhdGlvLCB0b3BDb2xvcjIpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChiYXNlbGluZVJhdGlvLCBib3R0b21Db2xvcjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIGJvdHRvbUNvbG9yMik7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRWYWx1ZSA9IGdyYWRpZW50O1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19jYWNoZWRWYWx1ZTtcbiAgICB9XG59XG5cbmNsYXNzIFBhbmVSZW5kZXJlckJhc2VsaW5lQXJlYSBleHRlbmRzIFBhbmVSZW5kZXJlckFyZWFCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZmlsbENhY2hlID0gbmV3IEdyYWRpZW50U3R5bGVDYWNoZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2ZpbGxTdHlsZShyZW5kZXJpbmdTY29wZSwgaXRlbSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5faW50ZXJuYWxfX2RhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19maWxsQ2FjaGUuX2ludGVybmFsX2dldChyZW5kZXJpbmdTY29wZSwge1xuICAgICAgICAgICAgX2ludGVybmFsX3RvcENvbG9yMTogaXRlbS5faW50ZXJuYWxfdG9wRmlsbENvbG9yMSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BDb2xvcjI6IGl0ZW0uX2ludGVybmFsX3RvcEZpbGxDb2xvcjIsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29sb3IxOiBpdGVtLl9pbnRlcm5hbF9ib3R0b21GaWxsQ29sb3IxLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvbG9yMjogaXRlbS5faW50ZXJuYWxfYm90dG9tRmlsbENvbG9yMixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlTGV2ZWxDb29yZGluYXRlOiBkYXRhLl9pbnRlcm5hbF9iYXNlTGV2ZWxDb29yZGluYXRlLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvcENvb3JkaW5hdGU6IGRhdGEuX2ludGVybmFsX3RvcENvb3JkaW5hdGUgPz8gMCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21Db29yZGluYXRlOiBkYXRhLl9pbnRlcm5hbF9ib3R0b21Db29yZGluYXRlID8/IHJlbmRlcmluZ1Njb3BlLmJpdG1hcFNpemUuaGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFBhbmVSZW5kZXJlckJhc2VsaW5lTGluZSBleHRlbmRzIFBhbmVSZW5kZXJlckxpbmVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc3Ryb2tlQ2FjaGUgPSBuZXcgR3JhZGllbnRTdHlsZUNhY2hlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fc3Ryb2tlU3R5bGUocmVuZGVyaW5nU2NvcGUsIGl0ZW0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2ludGVybmFsX19kYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fc3Ryb2tlQ2FjaGUuX2ludGVybmFsX2dldChyZW5kZXJpbmdTY29wZSwge1xuICAgICAgICAgICAgX2ludGVybmFsX3RvcENvbG9yMTogaXRlbS5faW50ZXJuYWxfdG9wTGluZUNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvcENvbG9yMjogaXRlbS5faW50ZXJuYWxfdG9wTGluZUNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvbG9yMTogaXRlbS5faW50ZXJuYWxfYm90dG9tTGluZUNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvbG9yMjogaXRlbS5faW50ZXJuYWxfYm90dG9tTGluZUNvbG9yLFxuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGU6IGRhdGEuX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29vcmRpbmF0ZTogZGF0YS5faW50ZXJuYWxfdG9wQ29vcmRpbmF0ZSA/PyAwLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvb3JkaW5hdGU6IGRhdGEuX2ludGVybmFsX2JvdHRvbUNvb3JkaW5hdGUgPz8gcmVuZGVyaW5nU2NvcGUuYml0bWFwU2l6ZS5oZWlnaHQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzQmFzZWxpbmVQYW5lVmlldyBleHRlbmRzIExpbmVQYW5lVmlld0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgbW9kZWwpIHtcbiAgICAgICAgc3VwZXIoc2VyaWVzLCBtb2RlbCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlciA9IG5ldyBDb21wb3NpdGVSZW5kZXJlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlbGluZUFyZWFSZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJCYXNlbGluZUFyZWEoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZWxpbmVMaW5lUmVuZGVyZXIgPSBuZXcgUGFuZVJlbmRlcmVyQmFzZWxpbmVMaW5lKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlci5faW50ZXJuYWxfc2V0UmVuZGVyZXJzKFt0aGlzLl9wcml2YXRlX19iYXNlbGluZUFyZWFSZW5kZXJlciwgdGhpcy5fcHJpdmF0ZV9fYmFzZWxpbmVMaW5lUmVuZGVyZXJdKTtcbiAgICB9XG4gICAgX2ludGVybmFsX19jcmVhdGVSYXdJdGVtKHRpbWUsIHByaWNlLCBjb2xvcmVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLl9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbUJhc2UodGltZSwgcHJpY2UpLFxuICAgICAgICAgICAgLi4uY29sb3Jlci5faW50ZXJuYWxfYmFyU3R5bGUodGltZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fcHJlcGFyZVJlbmRlcmVyRGF0YSgpIHtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2ZpcnN0VmFsdWUoKTtcbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBjb25zdCBiYXNlTGV2ZWxDb29yZGluYXRlID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZShvcHRpb25zLmJhc2VWYWx1ZS5wcmljZSwgZmlyc3RWYWx1ZS5faW50ZXJuYWxfdmFsdWUpO1xuICAgICAgICBjb25zdCBiYXJXaWR0aCA9IHRoaXMuX2ludGVybmFsX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2JhclNwYWNpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSA9PT0gbnVsbCB8fCB0aGlzLl9pbnRlcm5hbF9faXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvcENvb3JkaW5hdGU7XG4gICAgICAgIGxldCBib3R0b21Db29yZGluYXRlO1xuICAgICAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZUdyYWRpZW50KSB7XG4gICAgICAgICAgICB0b3BDb29yZGluYXRlID0gdGhpcy5faW50ZXJuYWxfX2l0ZW1zW3RoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZS5mcm9tXS5faW50ZXJuYWxfeTtcbiAgICAgICAgICAgIGJvdHRvbUNvb3JkaW5hdGUgPSB0aGlzLl9pbnRlcm5hbF9faXRlbXNbdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLmZyb21dLl9pbnRlcm5hbF95O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZS5mcm9tOyBpIDwgdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faW50ZXJuYWxfX2l0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLl9pbnRlcm5hbF95IDwgdG9wQ29vcmRpbmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BDb29yZGluYXRlID0gaXRlbS5faW50ZXJuYWxfeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uX2ludGVybmFsX3kgPiBib3R0b21Db29yZGluYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbUNvb3JkaW5hdGUgPSBpdGVtLl9pbnRlcm5hbF95O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXNlbGluZUFyZWFSZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh7XG4gICAgICAgICAgICBfaW50ZXJuYWxfaXRlbXM6IHRoaXMuX2ludGVybmFsX19pdGVtcyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVTdHlsZTogb3B0aW9ucy5saW5lU3R5bGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVR5cGU6IG9wdGlvbnMubGluZVR5cGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFzZUxldmVsQ29vcmRpbmF0ZTogYmFzZUxldmVsQ29vcmRpbmF0ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90b3BDb29yZGluYXRlOiB0b3BDb29yZGluYXRlLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvb3JkaW5hdGU6IGJvdHRvbUNvb3JkaW5hdGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfaW52ZXJ0RmlsbGVkQXJlYTogZmFsc2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFzZWxpbmVMaW5lUmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEoe1xuICAgICAgICAgICAgX2ludGVybmFsX2l0ZW1zOiB0aGlzLl9pbnRlcm5hbF9faXRlbXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVdpZHRoOiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lU3R5bGU6IG9wdGlvbnMubGluZVN0eWxlLFxuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVUeXBlOiBvcHRpb25zLmxpbmVWaXNpYmxlID8gb3B0aW9ucy5saW5lVHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9wb2ludE1hcmtlcnNSYWRpdXM6IG9wdGlvbnMucG9pbnRNYXJrZXJzVmlzaWJsZSA/IChvcHRpb25zLnBvaW50TWFya2Vyc1JhZGl1cyB8fCBvcHRpb25zLmxpbmVXaWR0aCAvIDIgKyAyKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXNlTGV2ZWxDb29yZGluYXRlOiBiYXNlTGV2ZWxDb29yZGluYXRlLFxuICAgICAgICAgICAgX2ludGVybmFsX3RvcENvb3JkaW5hdGU6IHRvcENvb3JkaW5hdGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29vcmRpbmF0ZTogYm90dG9tQ29vcmRpbmF0ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgYmFzZWxpbmVTdHlsZURlZmF1bHRzID0ge1xuICAgIGJhc2VWYWx1ZToge1xuICAgICAgICB0eXBlOiAncHJpY2UnLFxuICAgICAgICBwcmljZTogMCxcbiAgICB9LFxuICAgIHJlbGF0aXZlR3JhZGllbnQ6IGZhbHNlLFxuICAgIHRvcEZpbGxDb2xvcjE6ICdyZ2JhKDM4LCAxNjYsIDE1NCwgMC4yOCknLFxuICAgIHRvcEZpbGxDb2xvcjI6ICdyZ2JhKDM4LCAxNjYsIDE1NCwgMC4wNSknLFxuICAgIHRvcExpbmVDb2xvcjogJ3JnYmEoMzgsIDE2NiwgMTU0LCAxKScsXG4gICAgYm90dG9tRmlsbENvbG9yMTogJ3JnYmEoMjM5LCA4MywgODAsIDAuMDUpJyxcbiAgICBib3R0b21GaWxsQ29sb3IyOiAncmdiYSgyMzksIDgzLCA4MCwgMC4yOCknLFxuICAgIGJvdHRvbUxpbmVDb2xvcjogJ3JnYmEoMjM5LCA4MywgODAsIDEpJyxcbiAgICBsaW5lV2lkdGg6IDMsXG4gICAgbGluZVN0eWxlOiAwIC8qIExpbmVTdHlsZS5Tb2xpZCAqLyxcbiAgICBsaW5lVHlwZTogMCAvKiBMaW5lVHlwZS5TaW1wbGUgKi8sXG4gICAgbGluZVZpc2libGU6IHRydWUsXG4gICAgY3Jvc3NoYWlyTWFya2VyVmlzaWJsZTogdHJ1ZSxcbiAgICBjcm9zc2hhaXJNYXJrZXJSYWRpdXM6IDQsXG4gICAgY3Jvc3NoYWlyTWFya2VyQm9yZGVyQ29sb3I6ICcnLFxuICAgIGNyb3NzaGFpck1hcmtlckJvcmRlcldpZHRoOiAyLFxuICAgIGNyb3NzaGFpck1hcmtlckJhY2tncm91bmRDb2xvcjogJycsXG4gICAgbGFzdFByaWNlQW5pbWF0aW9uOiAwIC8qIExhc3RQcmljZUFuaW1hdGlvbk1vZGUuRGlzYWJsZWQgKi8sXG4gICAgcG9pbnRNYXJrZXJzVmlzaWJsZTogZmFsc2UsXG59O1xuY29uc3QgY3JlYXRlUGFuZVZpZXckNCA9IChzZXJpZXMsIG1vZGVsKSA9PiBuZXcgU2VyaWVzQmFzZWxpbmVQYW5lVmlldyhzZXJpZXMsIG1vZGVsKTtcbmNvbnN0IGNyZWF0ZVNlcmllcyQ0ID0gKCkgPT4ge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgIHR5cGU6ICdCYXNlbGluZScsXG4gICAgICAgIGlzQnVpbHRJbjogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdE9wdGlvbnM6IGJhc2VsaW5lU3R5bGVEZWZhdWx0cyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgX2ludGVybmFsX2NyZWF0ZVBhbmVWaWV3OiBjcmVhdGVQYW5lVmlldyQ0LFxuICAgIH07XG4gICAgcmV0dXJuIGRlZmluaXRpb247XG59O1xuY29uc3QgYmFzZWxpbmVTZXJpZXMgPSBjcmVhdGVTZXJpZXMkNCgpO1xuXG5jbGFzcyBQYW5lUmVuZGVyZXJBcmVhIGV4dGVuZHMgUGFuZVJlbmRlcmVyQXJlYUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19maWxsQ2FjaGUgPSBuZXcgR3JhZGllbnRTdHlsZUNhY2hlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZmlsbFN0eWxlKHJlbmRlcmluZ1Njb3BlLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19maWxsQ2FjaGUuX2ludGVybmFsX2dldChyZW5kZXJpbmdTY29wZSwge1xuICAgICAgICAgICAgX2ludGVybmFsX3RvcENvbG9yMTogaXRlbS5faW50ZXJuYWxfdG9wQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29sb3IyOiAnJyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9ib3R0b21Db2xvcjE6ICcnLFxuICAgICAgICAgICAgX2ludGVybmFsX2JvdHRvbUNvbG9yMjogaXRlbS5faW50ZXJuYWxfYm90dG9tQ29sb3IsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29vcmRpbmF0ZTogdGhpcy5faW50ZXJuYWxfX2RhdGE/Ll9pbnRlcm5hbF90b3BDb29yZGluYXRlID8/IDAsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm90dG9tQ29vcmRpbmF0ZTogcmVuZGVyaW5nU2NvcGUuYml0bWFwU2l6ZS5oZWlnaHQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzQXJlYVBhbmVWaWV3IGV4dGVuZHMgTGluZVBhbmVWaWV3QmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWVzLCBtb2RlbCkge1xuICAgICAgICBzdXBlcihzZXJpZXMsIG1vZGVsKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyID0gbmV3IENvbXBvc2l0ZVJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2FyZWFSZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJBcmVhKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xpbmVSZW5kZXJlciA9IG5ldyBQYW5lUmVuZGVyZXJMaW5lKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlci5faW50ZXJuYWxfc2V0UmVuZGVyZXJzKFt0aGlzLl9wcml2YXRlX19hcmVhUmVuZGVyZXIsIHRoaXMuX3ByaXZhdGVfX2xpbmVSZW5kZXJlcl0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW0odGltZSwgcHJpY2UsIGNvbG9yZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2ludGVybmFsX19jcmVhdGVSYXdJdGVtQmFzZSh0aW1lLCBwcmljZSksXG4gICAgICAgICAgICAuLi5jb2xvcmVyLl9pbnRlcm5hbF9iYXJTdHlsZSh0aW1lKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2ludGVybmFsX19wcmVwYXJlUmVuZGVyZXJEYXRhKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfb3B0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlID09PSBudWxsIHx8IHRoaXMuX2ludGVybmFsX19pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9wQ29vcmRpbmF0ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVsYXRpdmVHcmFkaWVudCkge1xuICAgICAgICAgICAgdG9wQ29vcmRpbmF0ZSA9IHRoaXMuX2ludGVybmFsX19pdGVtc1t0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UuZnJvbV0uX2ludGVybmFsX3k7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pbnRlcm5hbF9faXRlbXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uX2ludGVybmFsX3kgPCB0b3BDb29yZGluYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcENvb3JkaW5hdGUgPSBpdGVtLl9pbnRlcm5hbF95O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19hcmVhUmVuZGVyZXIuX2ludGVybmFsX3NldERhdGEoe1xuICAgICAgICAgICAgX2ludGVybmFsX2xpbmVUeXBlOiBvcHRpb25zLmxpbmVUeXBlLFxuICAgICAgICAgICAgX2ludGVybmFsX2l0ZW1zOiB0aGlzLl9pbnRlcm5hbF9faXRlbXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVN0eWxlOiBvcHRpb25zLmxpbmVTdHlsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgICAgICAgX2ludGVybmFsX2Jhc2VMZXZlbENvb3JkaW5hdGU6IG51bGwsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdG9wQ29vcmRpbmF0ZTogdG9wQ29vcmRpbmF0ZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9pbnZlcnRGaWxsZWRBcmVhOiBvcHRpb25zLmludmVydEZpbGxlZEFyZWEsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyV2lkdGg6IHRoaXMuX2ludGVybmFsX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2JhclNwYWNpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2xpbmVSZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh7XG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVR5cGU6IG9wdGlvbnMubGluZVZpc2libGUgPyBvcHRpb25zLmxpbmVUeXBlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX2ludGVybmFsX2l0ZW1zOiB0aGlzLl9pbnRlcm5hbF9faXRlbXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfbGluZVN0eWxlOiBvcHRpb25zLmxpbmVTdHlsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9saW5lV2lkdGg6IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGVSYW5nZTogdGhpcy5faW50ZXJuYWxfX2l0ZW1zVmlzaWJsZVJhbmdlLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhcldpZHRoOiB0aGlzLl9pbnRlcm5hbF9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCksXG4gICAgICAgICAgICBfaW50ZXJuYWxfcG9pbnRNYXJrZXJzUmFkaXVzOiBvcHRpb25zLnBvaW50TWFya2Vyc1Zpc2libGUgPyAob3B0aW9ucy5wb2ludE1hcmtlcnNSYWRpdXMgfHwgb3B0aW9ucy5saW5lV2lkdGggLyAyICsgMikgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgYXJlYVN0eWxlRGVmYXVsdHMgPSB7XG4gICAgdG9wQ29sb3I6ICdyZ2JhKCA0NiwgMjIwLCAxMzUsIDAuNCknLFxuICAgIGJvdHRvbUNvbG9yOiAncmdiYSggNDAsIDIyMSwgMTAwLCAwKScsXG4gICAgaW52ZXJ0RmlsbGVkQXJlYTogZmFsc2UsXG4gICAgcmVsYXRpdmVHcmFkaWVudDogZmFsc2UsXG4gICAgbGluZUNvbG9yOiAnIzMzRDc3OCcsXG4gICAgbGluZVN0eWxlOiAwIC8qIExpbmVTdHlsZS5Tb2xpZCAqLyxcbiAgICBsaW5lV2lkdGg6IDMsXG4gICAgbGluZVR5cGU6IDAgLyogTGluZVR5cGUuU2ltcGxlICovLFxuICAgIGxpbmVWaXNpYmxlOiB0cnVlLFxuICAgIGNyb3NzaGFpck1hcmtlclZpc2libGU6IHRydWUsXG4gICAgY3Jvc3NoYWlyTWFya2VyUmFkaXVzOiA0LFxuICAgIGNyb3NzaGFpck1hcmtlckJvcmRlckNvbG9yOiAnJyxcbiAgICBjcm9zc2hhaXJNYXJrZXJCb3JkZXJXaWR0aDogMixcbiAgICBjcm9zc2hhaXJNYXJrZXJCYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgIGxhc3RQcmljZUFuaW1hdGlvbjogMCAvKiBMYXN0UHJpY2VBbmltYXRpb25Nb2RlLkRpc2FibGVkICovLFxuICAgIHBvaW50TWFya2Vyc1Zpc2libGU6IGZhbHNlLFxufTtcbmNvbnN0IGNyZWF0ZVBhbmVWaWV3JDMgPSAoc2VyaWVzLCBtb2RlbCkgPT4gbmV3IFNlcmllc0FyZWFQYW5lVmlldyhzZXJpZXMsIG1vZGVsKTtcbmNvbnN0IGNyZWF0ZVNlcmllcyQzID0gKCkgPT4ge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgIHR5cGU6ICdBcmVhJyxcbiAgICAgICAgaXNCdWlsdEluOiB0cnVlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uczogYXJlYVN0eWxlRGVmYXVsdHMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIF9pbnRlcm5hbF9jcmVhdGVQYW5lVmlldzogY3JlYXRlUGFuZVZpZXckMyxcbiAgICB9O1xuICAgIHJldHVybiBkZWZpbml0aW9uO1xufTtcbmNvbnN0IGFyZWFTZXJpZXMgPSBjcmVhdGVTZXJpZXMkMygpO1xuXG5mdW5jdGlvbiBvcHRpbWFsQmFyV2lkdGgoYmFyU3BhY2luZywgcGl4ZWxSYXRpbykge1xuICAgIHJldHVybiBNYXRoLmZsb29yKGJhclNwYWNpbmcgKiAwLjMgKiBwaXhlbFJhdGlvKTtcbn1cbmZ1bmN0aW9uIG9wdGltYWxDYW5kbGVzdGlja1dpZHRoKGJhclNwYWNpbmcsIHBpeGVsUmF0aW8pIHtcbiAgICBjb25zdCBiYXJTcGFjaW5nU3BlY2lhbENhc2VGcm9tID0gMi41O1xuICAgIGNvbnN0IGJhclNwYWNpbmdTcGVjaWFsQ2FzZVRvID0gNDtcbiAgICBjb25zdCBiYXJTcGFjaW5nU3BlY2lhbENhc2VDb2VmZiA9IDM7XG4gICAgaWYgKGJhclNwYWNpbmcgPj0gYmFyU3BhY2luZ1NwZWNpYWxDYXNlRnJvbSAmJiBiYXJTcGFjaW5nIDw9IGJhclNwYWNpbmdTcGVjaWFsQ2FzZVRvKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGJhclNwYWNpbmdTcGVjaWFsQ2FzZUNvZWZmICogcGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIC8vIGNvZWZmIHNob3VsZCBiZSAxIG9uIHNtYWxsIGJhcnNwYWNpbmcgYW5kIGdvIHRvIDAuOCB3aGlsZSBncm9pbmcgYmFyIHNwYWNpbmdcbiAgICBjb25zdCBiYXJTcGFjaW5nUmVkdWNpbmdDb2VmZiA9IDAuMjtcbiAgICBjb25zdCBjb2VmZiA9IDEgLSBiYXJTcGFjaW5nUmVkdWNpbmdDb2VmZiAqIE1hdGguYXRhbihNYXRoLm1heChiYXJTcGFjaW5nU3BlY2lhbENhc2VUbywgYmFyU3BhY2luZykgLSBiYXJTcGFjaW5nU3BlY2lhbENhc2VUbykgLyAoTWF0aC5QSSAqIDAuNSk7XG4gICAgY29uc3QgcmVzID0gTWF0aC5mbG9vcihiYXJTcGFjaW5nICogY29lZmYgKiBwaXhlbFJhdGlvKTtcbiAgICBjb25zdCBzY2FsZWRCYXJTcGFjaW5nID0gTWF0aC5mbG9vcihiYXJTcGFjaW5nICogcGl4ZWxSYXRpbyk7XG4gICAgY29uc3Qgb3B0aW1hbCA9IE1hdGgubWluKHJlcywgc2NhbGVkQmFyU3BhY2luZyk7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGguZmxvb3IocGl4ZWxSYXRpbyksIG9wdGltYWwpO1xufVxuXG5jbGFzcyBQYW5lUmVuZGVyZXJCYXJzIGV4dGVuZHMgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJMaW5lV2lkdGggPSAwO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwoeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9iYXJzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCA9IHRoaXMuX3ByaXZhdGVfX2NhbGNCYXJXaWR0aChob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgIC8vIGdyaWQgYW5kIGNyb3NzaGFpciBoYXZlIGxpbmUgd2lkdGggPSBNYXRoLmZsb29yKHBpeGVsUmF0aW8pXG4gICAgICAgIC8vIGlmIHRoaXMgdmFsdWUgaXMgb2RkLCB3ZSBoYXZlIHRvIG1ha2UgYmFycycgd2lkdGggb2RkXG4gICAgICAgIC8vIGlmIHRoaXMgdmFsdWUgaXMgZXZlbiwgd2UgaGF2ZSB0byBtYWtlIGJhcnMnIHdpZHRoIGV2ZW5cbiAgICAgICAgLy8gaW4gb3JkZXIgb2Yga2VlcGluZyBjcm9zc2hhaXItb3Zlci1iYXIgZHJhd2luZyBzeW1tZXRyaWNcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICAgICAgICAgIGlmICgobGluZVdpZHRoICUgMikgIT09ICh0aGlzLl9wcml2YXRlX19iYXJXaWR0aCAlIDIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBzY2FsZSBpcyBjb21wcmVzc2VkLCBiYXIgY291bGQgYmVjb21lIGxlc3MgdGhhbiAxIENTUyBwaXhlbFxuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJMaW5lV2lkdGggPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF90aGluQmFycyA/IE1hdGgubWluKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoLCBNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSkgOiB0aGlzLl9wcml2YXRlX19iYXJXaWR0aDtcbiAgICAgICAgbGV0IHByZXZDb2xvciA9IG51bGw7XG4gICAgICAgIGNvbnN0IGRyYXdPcGVuQ2xvc2UgPSB0aGlzLl9wcml2YXRlX19iYXJMaW5lV2lkdGggPD0gdGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggJiYgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYmFyU3BhY2luZyA+PSBNYXRoLmZsb29yKDEuNSAqIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS5mcm9tOyBpIDwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLnRvOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhciA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhcnNbaV07XG4gICAgICAgICAgICBpZiAocHJldkNvbG9yICE9PSBiYXIuX2ludGVybmFsX2JhckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhci5faW50ZXJuYWxfYmFyQ29sb3I7XG4gICAgICAgICAgICAgICAgcHJldkNvbG9yID0gYmFyLl9pbnRlcm5hbF9iYXJDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHlXaWR0aEhhbGYgPSBNYXRoLmZsb29yKHRoaXMuX3ByaXZhdGVfX2JhckxpbmVXaWR0aCAqIDAuNSk7XG4gICAgICAgICAgICBjb25zdCBib2R5Q2VudGVyID0gTWF0aC5yb3VuZChiYXIuX2ludGVybmFsX3ggKiBob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBib2R5TGVmdCA9IGJvZHlDZW50ZXIgLSBib2R5V2lkdGhIYWxmO1xuICAgICAgICAgICAgY29uc3QgYm9keVdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fYmFyTGluZVdpZHRoO1xuICAgICAgICAgICAgY29uc3QgYm9keVJpZ2h0ID0gYm9keUxlZnQgKyBib2R5V2lkdGggLSAxO1xuICAgICAgICAgICAgY29uc3QgaGlnaCA9IE1hdGgubWluKGJhci5faW50ZXJuYWxfaGlnaFksIGJhci5faW50ZXJuYWxfbG93WSk7XG4gICAgICAgICAgICBjb25zdCBsb3cgPSBNYXRoLm1heChiYXIuX2ludGVybmFsX2hpZ2hZLCBiYXIuX2ludGVybmFsX2xvd1kpO1xuICAgICAgICAgICAgY29uc3QgYm9keVRvcCA9IE1hdGgucm91bmQoaGlnaCAqIHZlcnRpY2FsUGl4ZWxSYXRpbykgLSBib2R5V2lkdGhIYWxmO1xuICAgICAgICAgICAgY29uc3QgYm9keUJvdHRvbSA9IE1hdGgucm91bmQobG93ICogdmVydGljYWxQaXhlbFJhdGlvKSArIGJvZHlXaWR0aEhhbGY7XG4gICAgICAgICAgICBjb25zdCBib2R5SGVpZ2h0ID0gTWF0aC5tYXgoKGJvZHlCb3R0b20gLSBib2R5VG9wKSwgdGhpcy5fcHJpdmF0ZV9fYmFyTGluZVdpZHRoKTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChib2R5TGVmdCwgYm9keVRvcCwgYm9keVdpZHRoLCBib2R5SGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZGVXaWR0aCA9IE1hdGguY2VpbCh0aGlzLl9wcml2YXRlX19iYXJXaWR0aCAqIDEuNSk7XG4gICAgICAgICAgICBpZiAoZHJhd09wZW5DbG9zZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9vcGVuVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVuTGVmdCA9IGJvZHlDZW50ZXIgLSBzaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvcGVuVG9wID0gTWF0aC5tYXgoYm9keVRvcCwgTWF0aC5yb3VuZChiYXIuX2ludGVybmFsX29wZW5ZICogdmVydGljYWxQaXhlbFJhdGlvKSAtIGJvZHlXaWR0aEhhbGYpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3BlbkJvdHRvbSA9IG9wZW5Ub3AgKyBib2R5V2lkdGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbkJvdHRvbSA+IGJvZHlUb3AgKyBib2R5SGVpZ2h0IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkJvdHRvbSA9IGJvZHlUb3AgKyBib2R5SGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Ub3AgPSBvcGVuQm90dG9tIC0gYm9keVdpZHRoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3Qob3BlbkxlZnQsIG9wZW5Ub3AsIGJvZHlMZWZ0IC0gb3BlbkxlZnQsIG9wZW5Cb3R0b20gLSBvcGVuVG9wICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlUmlnaHQgPSBib2R5Q2VudGVyICsgc2lkZVdpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBjbG9zZVRvcCA9IE1hdGgubWF4KGJvZHlUb3AsIE1hdGgucm91bmQoYmFyLl9pbnRlcm5hbF9jbG9zZVkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pIC0gYm9keVdpZHRoSGFsZik7XG4gICAgICAgICAgICAgICAgbGV0IGNsb3NlQm90dG9tID0gY2xvc2VUb3AgKyBib2R5V2lkdGggLSAxO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZUJvdHRvbSA+IGJvZHlUb3AgKyBib2R5SGVpZ2h0IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZUJvdHRvbSA9IGJvZHlUb3AgKyBib2R5SGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VUb3AgPSBjbG9zZUJvdHRvbSAtIGJvZHlXaWR0aCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChib2R5UmlnaHQgKyAxLCBjbG9zZVRvcCwgY2xvc2VSaWdodCAtIGJvZHlSaWdodCwgY2xvc2VCb3R0b20gLSBjbG9zZVRvcCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19jYWxjQmFyV2lkdGgocGl4ZWxSYXRpbykge1xuICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGguZmxvb3IocGl4ZWxSYXRpbyk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChsaW1pdCwgTWF0aC5mbG9vcihvcHRpbWFsQmFyV2lkdGgoZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19kYXRhKS5faW50ZXJuYWxfYmFyU3BhY2luZywgcGl4ZWxSYXRpbykpKTtcbiAgICB9XG59XG5cbmNsYXNzIEJhcnNQYW5lVmlld0Jhc2UgZXh0ZW5kcyBTZXJpZXNQYW5lVmlld0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgbW9kZWwpIHtcbiAgICAgICAgc3VwZXIoc2VyaWVzLCBtb2RlbCwgZmFsc2UpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NvbnZlcnRUb0Nvb3JkaW5hdGVzKHByaWNlU2NhbGUsIHRpbWVTY2FsZSwgZmlyc3RWYWx1ZSkge1xuICAgICAgICB0aW1lU2NhbGUuX2ludGVybmFsX2luZGV4ZXNUb0Nvb3JkaW5hdGVzKHRoaXMuX2ludGVybmFsX19pdGVtcywgdW5kZWZpbmVkSWZOdWxsKHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSkpO1xuICAgICAgICBwcmljZVNjYWxlLl9pbnRlcm5hbF9iYXJQcmljZXNUb0Nvb3JkaW5hdGVzKHRoaXMuX2ludGVybmFsX19pdGVtcywgZmlyc3RWYWx1ZSwgdW5kZWZpbmVkSWZOdWxsKHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSkpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NyZWF0ZURlZmF1bHRJdGVtKHRpbWUsIGJhciwgY29sb3Jlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX3RpbWU6IHRpbWUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfb3BlbjogYmFyLl9pbnRlcm5hbF92YWx1ZVswIC8qIFBsb3RSb3dWYWx1ZUluZGV4Lk9wZW4gKi9dLFxuICAgICAgICAgICAgX2ludGVybmFsX2hpZ2g6IGJhci5faW50ZXJuYWxfdmFsdWVbMSAvKiBQbG90Um93VmFsdWVJbmRleC5IaWdoICovXSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9sb3c6IGJhci5faW50ZXJuYWxfdmFsdWVbMiAvKiBQbG90Um93VmFsdWVJbmRleC5Mb3cgKi9dLFxuICAgICAgICAgICAgX2ludGVybmFsX2Nsb3NlOiBiYXIuX2ludGVybmFsX3ZhbHVlWzMgLyogUGxvdFJvd1ZhbHVlSW5kZXguQ2xvc2UgKi9dLFxuICAgICAgICAgICAgX2ludGVybmFsX3g6IE5hTixcbiAgICAgICAgICAgIF9pbnRlcm5hbF9vcGVuWTogTmFOLFxuICAgICAgICAgICAgX2ludGVybmFsX2hpZ2hZOiBOYU4sXG4gICAgICAgICAgICBfaW50ZXJuYWxfbG93WTogTmFOLFxuICAgICAgICAgICAgX2ludGVybmFsX2Nsb3NlWTogTmFOLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2ZpbGxSYXdQb2ludHMoKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yZXIgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9iYXJDb2xvcmVyKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19pdGVtcyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX2JhcnMoKS5faW50ZXJuYWxfcm93cygpLm1hcCgocm93KSA9PiB0aGlzLl9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbShyb3cuX2ludGVybmFsX2luZGV4LCByb3csIGNvbG9yZXIpKTtcbiAgICB9XG59XG5cbmNsYXNzIFNlcmllc0JhcnNQYW5lVmlldyBleHRlbmRzIEJhcnNQYW5lVmlld0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcmVuZGVyZXIgPSBuZXcgUGFuZVJlbmRlcmVyQmFycygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW0odGltZSwgYmFyLCBjb2xvcmVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLl9pbnRlcm5hbF9fY3JlYXRlRGVmYXVsdEl0ZW0odGltZSwgYmFyLCBjb2xvcmVyKSxcbiAgICAgICAgICAgIC4uLmNvbG9yZXIuX2ludGVybmFsX2JhclN0eWxlKHRpbWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3ByZXBhcmVSZW5kZXJlckRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGJhclN0eWxlUHJvcHMgPSB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCk7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YSh7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyczogdGhpcy5faW50ZXJuYWxfX2l0ZW1zLFxuICAgICAgICAgICAgX2ludGVybmFsX2JhclNwYWNpbmc6IHRoaXMuX2ludGVybmFsX19tb2RlbC5faW50ZXJuYWxfdGltZVNjYWxlKCkuX2ludGVybmFsX2JhclNwYWNpbmcoKSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9vcGVuVmlzaWJsZTogYmFyU3R5bGVQcm9wcy5vcGVuVmlzaWJsZSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF90aGluQmFyczogYmFyU3R5bGVQcm9wcy50aGluQmFycyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF92aXNpYmxlUmFuZ2U6IHRoaXMuX2ludGVybmFsX19pdGVtc1Zpc2libGVSYW5nZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBiYXJTdHlsZURlZmF1bHRzID0ge1xuICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICBkb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICBvcGVuVmlzaWJsZTogdHJ1ZSxcbiAgICB0aGluQmFyczogdHJ1ZSxcbn07XG5jb25zdCBjcmVhdGVQYW5lVmlldyQyID0gKHNlcmllcywgbW9kZWwpID0+IG5ldyBTZXJpZXNCYXJzUGFuZVZpZXcoc2VyaWVzLCBtb2RlbCk7XG5jb25zdCBjcmVhdGVTZXJpZXMkMiA9ICgpID0+IHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgICB0eXBlOiAnQmFyJyxcbiAgICAgICAgaXNCdWlsdEluOiB0cnVlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uczogYmFyU3R5bGVEZWZhdWx0cyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgX2ludGVybmFsX2NyZWF0ZVBhbmVWaWV3OiBjcmVhdGVQYW5lVmlldyQyLFxuICAgIH07XG4gICAgcmV0dXJuIGRlZmluaXRpb247XG59O1xuY29uc3QgYmFyU2VyaWVzID0gY3JlYXRlU2VyaWVzJDIoKTtcblxuY2xhc3MgUGFuZVJlbmRlcmVyQ2FuZGxlc3RpY2tzIGV4dGVuZHMgQml0bWFwQ29vcmRpbmF0ZXNQYW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gbnVsbDtcbiAgICAgICAgLy8gc2NhbGVkIHdpdGggcGl4ZWxSYXRpb1xuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCA9IDA7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwocmVuZGVyaW5nU2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYmFycy5sZW5ndGggPT09IDAgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBob3Jpem9udGFsUGl4ZWxSYXRpbyB9ID0gcmVuZGVyaW5nU2NvcGU7XG4gICAgICAgIC8vIG5vdyB3ZSBrbm93IHBpeGVsUmF0aW8gYW5kIHdlIGNvdWxkIGNhbGN1bGF0ZSBiYXJXaWR0aCBlZmZlY3RpdmVseVxuICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCA9IG9wdGltYWxDYW5kbGVzdGlja1dpZHRoKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhclNwYWNpbmcsIGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgLy8gZ3JpZCBhbmQgY3Jvc3NoYWlyIGhhdmUgbGluZSB3aWR0aCA9IE1hdGguZmxvb3IocGl4ZWxSYXRpbylcbiAgICAgICAgLy8gaWYgdGhpcyB2YWx1ZSBpcyBvZGQsIHdlIGhhdmUgdG8gbWFrZSBjYW5kbGVzdGlja3MnIHdpZHRoIG9kZFxuICAgICAgICAvLyBpZiB0aGlzIHZhbHVlIGlzIGV2ZW4sIHdlIGhhdmUgdG8gbWFrZSBjYW5kbGVzdGlja3MnIHdpZHRoIGV2ZW5cbiAgICAgICAgLy8gaW4gb3JkZXIgb2Yga2VlcGluZyBjcm9zc2hhaXItb3Zlci1jYW5kbGVzdGlja3MgZHJhd2luZyBzeW1tZXRyaWNcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpY2tXaWR0aCA9IE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgaWYgKCh3aWNrV2lkdGggJSAyKSAhPT0gKHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoICUgMikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcml2YXRlX19iYXJXaWR0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhcnMgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9iYXJzO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfd2lja1Zpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2RyYXdXaWNrcyhyZW5kZXJpbmdTY29wZSwgYmFycywgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfYm9yZGVyVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZHJhd0JvcmRlcihyZW5kZXJpbmdTY29wZSwgYmFycywgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHRoaXMuX3ByaXZhdGVfX2NhbGN1bGF0ZUJvcmRlcldpZHRoKGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9ib3JkZXJWaXNpYmxlIHx8IHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoID4gYm9yZGVyV2lkdGggKiAyKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kcmF3Q2FuZGxlcyhyZW5kZXJpbmdTY29wZSwgYmFycywgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd1dpY2tzKHJlbmRlcmluZ1Njb3BlLCBiYXJzLCB2aXNpYmxlUmFuZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvbnRleHQ6IGN0eCwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyB9ID0gcmVuZGVyaW5nU2NvcGU7XG4gICAgICAgIGxldCBwcmV2V2lja0NvbG9yID0gJyc7XG4gICAgICAgIGxldCB3aWNrV2lkdGggPSBNYXRoLm1pbihNYXRoLmZsb29yKGhvcml6b250YWxQaXhlbFJhdGlvKSwgTWF0aC5mbG9vcih0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9iYXJTcGFjaW5nICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICAgICAgd2lja1dpZHRoID0gTWF0aC5tYXgoTWF0aC5mbG9vcihob3Jpem9udGFsUGl4ZWxSYXRpbyksIE1hdGgubWluKHdpY2tXaWR0aCwgdGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGgpKTtcbiAgICAgICAgY29uc3Qgd2lja09mZnNldCA9IE1hdGguZmxvb3Iod2lja1dpZHRoICogMC41KTtcbiAgICAgICAgbGV0IHByZXZFZGdlID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHZpc2libGVSYW5nZS5mcm9tOyBpIDwgdmlzaWJsZVJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJhciA9IGJhcnNbaV07XG4gICAgICAgICAgICBpZiAoYmFyLl9pbnRlcm5hbF9iYXJXaWNrQ29sb3IgIT09IHByZXZXaWNrQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFyLl9pbnRlcm5hbF9iYXJXaWNrQ29sb3I7XG4gICAgICAgICAgICAgICAgcHJldldpY2tDb2xvciA9IGJhci5faW50ZXJuYWxfYmFyV2lja0NvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9wID0gTWF0aC5yb3VuZChNYXRoLm1pbihiYXIuX2ludGVybmFsX29wZW5ZLCBiYXIuX2ludGVybmFsX2Nsb3NlWSkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5yb3VuZChNYXRoLm1heChiYXIuX2ludGVybmFsX29wZW5ZLCBiYXIuX2ludGVybmFsX2Nsb3NlWSkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgaGlnaCA9IE1hdGgucm91bmQoYmFyLl9pbnRlcm5hbF9oaWdoWSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBsb3cgPSBNYXRoLnJvdW5kKGJhci5faW50ZXJuYWxfbG93WSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRYID0gTWF0aC5yb3VuZChob3Jpem9udGFsUGl4ZWxSYXRpbyAqIGJhci5faW50ZXJuYWxfeCk7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHNjYWxlZFggLSB3aWNrT2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgd2lja1dpZHRoIC0gMTtcbiAgICAgICAgICAgIGlmIChwcmV2RWRnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChwcmV2RWRnZSArIDEsIGxlZnQpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QobGVmdCwgaGlnaCwgd2lkdGgsIHRvcCAtIGhpZ2gpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIGJvdHRvbSArIDEsIHdpZHRoLCBsb3cgLSBib3R0b20pO1xuICAgICAgICAgICAgcHJldkVkZ2UgPSByaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fY2FsY3VsYXRlQm9yZGVyV2lkdGgocGl4ZWxSYXRpbykge1xuICAgICAgICBsZXQgYm9yZGVyV2lkdGggPSBNYXRoLmZsb29yKDEgLyogQ29uc3RhbnRzLkJhckJvcmRlcldpZHRoICovICogcGl4ZWxSYXRpbyk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19iYXJXaWR0aCA8PSAyICogYm9yZGVyV2lkdGgpIHtcbiAgICAgICAgICAgIGJvcmRlcldpZHRoID0gTWF0aC5mbG9vcigodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggLSAxKSAqIDAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gTWF0aC5tYXgoTWF0aC5mbG9vcihwaXhlbFJhdGlvKSwgYm9yZGVyV2lkdGgpO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggPD0gcmVzICogMikge1xuICAgICAgICAgICAgLy8gZG8gbm90IGRyYXcgYm9kaWVzLCByZXN0b3JlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5mbG9vcihwaXhlbFJhdGlvKSwgTWF0aC5mbG9vcigxIC8qIENvbnN0YW50cy5CYXJCb3JkZXJXaWR0aCAqLyAqIHBpeGVsUmF0aW8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fZHJhd0JvcmRlcihyZW5kZXJpbmdTY29wZSwgYmFycywgdmlzaWJsZVJhbmdlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSA9IHJlbmRlcmluZ1Njb3BlO1xuICAgICAgICBsZXQgcHJldkJvcmRlckNvbG9yID0gJyc7XG4gICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdGhpcy5fcHJpdmF0ZV9fY2FsY3VsYXRlQm9yZGVyV2lkdGgoaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBsZXQgcHJldkVkZ2UgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLmZyb207IGkgPCB2aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmFyID0gYmFyc1tpXTtcbiAgICAgICAgICAgIGlmIChiYXIuX2ludGVybmFsX2JhckJvcmRlckNvbG9yICE9PSBwcmV2Qm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFyLl9pbnRlcm5hbF9iYXJCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICBwcmV2Qm9yZGVyQ29sb3IgPSBiYXIuX2ludGVybmFsX2JhckJvcmRlckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxlZnQgPSBNYXRoLnJvdW5kKGJhci5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvKSAtIE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggKiAwLjUpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgdG8gY2FsY3VsYXRlIHJpZ2h0IGJlZm9yZSBwYXRjaGluZyBsZWZ0XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGxlZnQgKyB0aGlzLl9wcml2YXRlX19iYXJXaWR0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBNYXRoLnJvdW5kKE1hdGgubWluKGJhci5faW50ZXJuYWxfb3BlblksIGJhci5faW50ZXJuYWxfY2xvc2VZKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBNYXRoLnJvdW5kKE1hdGgubWF4KGJhci5faW50ZXJuYWxfb3BlblksIGJhci5faW50ZXJuYWxfY2xvc2VZKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBpZiAocHJldkVkZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgocHJldkVkZ2UgKyAxLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhclNwYWNpbmcgKiBob3Jpem9udGFsUGl4ZWxSYXRpbyA+IDIgKiBib3JkZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGZpbGxSZWN0SW5uZXJCb3JkZXIoY3R4LCBsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCArIDEsIGJvdHRvbSAtIHRvcCArIDEsIGJvcmRlcldpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgYm90dG9tIC0gdG9wICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RWRnZSA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX19kcmF3Q2FuZGxlcyhyZW5kZXJpbmdTY29wZSwgYmFycywgdmlzaWJsZVJhbmdlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSA9IHJlbmRlcmluZ1Njb3BlO1xuICAgICAgICBsZXQgcHJldkJhckNvbG9yID0gJyc7XG4gICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdGhpcy5fcHJpdmF0ZV9fY2FsY3VsYXRlQm9yZGVyV2lkdGgoaG9yaXpvbnRhbFBpeGVsUmF0aW8pO1xuICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZVJhbmdlLmZyb207IGkgPCB2aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmFyID0gYmFyc1tpXTtcbiAgICAgICAgICAgIGxldCB0b3AgPSBNYXRoLnJvdW5kKE1hdGgubWluKGJhci5faW50ZXJuYWxfb3BlblksIGJhci5faW50ZXJuYWxfY2xvc2VZKSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gTWF0aC5yb3VuZChNYXRoLm1heChiYXIuX2ludGVybmFsX29wZW5ZLCBiYXIuX2ludGVybmFsX2Nsb3NlWSkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBNYXRoLnJvdW5kKGJhci5faW50ZXJuYWxfeCAqIGhvcml6b250YWxQaXhlbFJhdGlvKSAtIE1hdGguZmxvb3IodGhpcy5fcHJpdmF0ZV9fYmFyV2lkdGggKiAwLjUpO1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gbGVmdCArIHRoaXMuX3ByaXZhdGVfX2JhcldpZHRoIC0gMTtcbiAgICAgICAgICAgIGlmIChiYXIuX2ludGVybmFsX2JhckNvbG9yICE9PSBwcmV2QmFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXJDb2xvciA9IGJhci5faW50ZXJuYWxfYmFyQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhckNvbG9yO1xuICAgICAgICAgICAgICAgIHByZXZCYXJDb2xvciA9IGJhckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JvcmRlclZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IGJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgIHRvcCArPSBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICByaWdodCAtPSBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBib3R0b20gLT0gYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCByaWdodCAtIGxlZnQgKyAxLCBib3R0b20gLSB0b3AgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU2VyaWVzQ2FuZGxlc3RpY2tzUGFuZVZpZXcgZXh0ZW5kcyBCYXJzUGFuZVZpZXdCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyID0gbmV3IFBhbmVSZW5kZXJlckNhbmRsZXN0aWNrcygpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW0odGltZSwgYmFyLCBjb2xvcmVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLl9pbnRlcm5hbF9fY3JlYXRlRGVmYXVsdEl0ZW0odGltZSwgYmFyLCBjb2xvcmVyKSxcbiAgICAgICAgICAgIC4uLmNvbG9yZXIuX2ludGVybmFsX2JhclN0eWxlKHRpbWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3ByZXBhcmVSZW5kZXJlckRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGNhbmRsZXN0aWNrU3R5bGVQcm9wcyA9IHRoaXMuX2ludGVybmFsX19zZXJpZXMuX2ludGVybmFsX29wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHtcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJzOiB0aGlzLl9pbnRlcm5hbF9faXRlbXMsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmFyU3BhY2luZzogdGhpcy5faW50ZXJuYWxfX21vZGVsLl9pbnRlcm5hbF90aW1lU2NhbGUoKS5faW50ZXJuYWxfYmFyU3BhY2luZygpLFxuICAgICAgICAgICAgX2ludGVybmFsX3dpY2tWaXNpYmxlOiBjYW5kbGVzdGlja1N0eWxlUHJvcHMud2lja1Zpc2libGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYm9yZGVyVmlzaWJsZTogY2FuZGxlc3RpY2tTdHlsZVByb3BzLmJvcmRlclZpc2libGUsXG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgY2FuZGxlc3RpY2tTdHlsZURlZmF1bHRzID0ge1xuICAgIHVwQ29sb3I6ICcjMjZhNjlhJyxcbiAgICBkb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICB3aWNrVmlzaWJsZTogdHJ1ZSxcbiAgICBib3JkZXJWaXNpYmxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiAnIzM3ODY1OCcsXG4gICAgYm9yZGVyVXBDb2xvcjogJyMyNmE2OWEnLFxuICAgIGJvcmRlckRvd25Db2xvcjogJyNlZjUzNTAnLFxuICAgIHdpY2tDb2xvcjogJyM3MzczNzUnLFxuICAgIHdpY2tVcENvbG9yOiAnIzI2YTY5YScsXG4gICAgd2lja0Rvd25Db2xvcjogJyNlZjUzNTAnLFxufTtcbmNvbnN0IGNyZWF0ZVBhbmVWaWV3JDEgPSAoc2VyaWVzLCBtb2RlbCkgPT4gbmV3IFNlcmllc0NhbmRsZXN0aWNrc1BhbmVWaWV3KHNlcmllcywgbW9kZWwpO1xuY29uc3QgY3JlYXRlU2VyaWVzJDEgPSAoKSA9PiB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgdHlwZTogJ0NhbmRsZXN0aWNrJyxcbiAgICAgICAgaXNCdWlsdEluOiB0cnVlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uczogY2FuZGxlc3RpY2tTdHlsZURlZmF1bHRzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBfaW50ZXJuYWxfY3JlYXRlUGFuZVZpZXc6IGNyZWF0ZVBhbmVWaWV3JDEsXG4gICAgfTtcbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbn07XG5jb25zdCBjYW5kbGVzdGlja1NlcmllcyA9IGNyZWF0ZVNlcmllcyQxKCk7XG5cbmNvbnN0IHNob3dTcGFjaW5nTWluaW1hbEJhcldpZHRoID0gMTtcbmNvbnN0IGFsaWduVG9NaW5pbWFsV2lkdGhMaW1pdCA9IDQ7XG5jbGFzcyBQYW5lUmVuZGVyZXJIaXN0b2dyYW0gZXh0ZW5kcyBCaXRtYXBDb29yZGluYXRlc1BhbmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGUgPSBbXTtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJlY2FsY3VsYXRlZENhY2hlID0gW107XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fZHJhd0ltcGwoeyBjb250ZXh0OiBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8gfSkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YSA9PT0gbnVsbCB8fCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pdGVtcy5sZW5ndGggPT09IDAgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19maWxsUHJlY2FsY3VsYXRlZENhY2hlKGhvcml6b250YWxQaXhlbFJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aWNrV2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHZlcnRpY2FsUGl4ZWxSYXRpbykpO1xuICAgICAgICBjb25zdCBoaXN0b2dyYW1CYXNlID0gTWF0aC5yb3VuZCgodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaGlzdG9ncmFtQmFzZSkgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICBjb25zdCB0b3BIaXN0b2dyYW1CYXNlID0gaGlzdG9ncmFtQmFzZSAtIE1hdGguZmxvb3IodGlja1dpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGJvdHRvbUhpc3RvZ3JhbUJhc2UgPSB0b3BIaXN0b2dyYW1CYXNlICsgdGlja1dpZHRoO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zW2ldO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZVtpIC0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb21dO1xuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQoaXRlbS5faW50ZXJuYWxfeSAqIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaXRlbS5faW50ZXJuYWxfYmFyQ29sb3I7XG4gICAgICAgICAgICBsZXQgdG9wO1xuICAgICAgICAgICAgbGV0IGJvdHRvbTtcbiAgICAgICAgICAgIGlmICh5IDw9IHRvcEhpc3RvZ3JhbUJhc2UpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSB5O1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IGJvdHRvbUhpc3RvZ3JhbUJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3AgPSB0b3BIaXN0b2dyYW1CYXNlO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHkgLSBNYXRoLmZsb29yKHRpY2tXaWR0aCAvIDIpICsgdGlja1dpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGN1cnJlbnQuX2ludGVybmFsX2xlZnQsIHRvcCwgY3VycmVudC5faW50ZXJuYWxfcmlnaHQgLSBjdXJyZW50Ll9pbnRlcm5hbF9sZWZ0ICsgMSwgYm90dG9tIC0gdG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIF9wcml2YXRlX19maWxsUHJlY2FsY3VsYXRlZENhY2hlKHBpeGVsUmF0aW8pIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXRlbXMubGVuZ3RoID09PSAwIHx8IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcHJlY2FsY3VsYXRlZENhY2hlID0gW107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BhY2luZyA9IE1hdGguY2VpbCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9iYXJTcGFjaW5nICogcGl4ZWxSYXRpbykgPD0gc2hvd1NwYWNpbmdNaW5pbWFsQmFyV2lkdGggPyAwIDogTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihwaXhlbFJhdGlvKSk7XG4gICAgICAgIGNvbnN0IGNvbHVtbldpZHRoID0gTWF0aC5yb3VuZCh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9iYXJTcGFjaW5nICogcGl4ZWxSYXRpbykgLSBzcGFjaW5nO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGUgPSBuZXcgQXJyYXkodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLnRvIC0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb20pO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zW2ldO1xuICAgICAgICAgICAgLy8gZm9yY2UgY2FzdCB0byBhdm9pZCBlbnN1cmVEZWZpbmVkIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKGl0ZW0uX2ludGVybmFsX3ggKiBwaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGxldCBsZWZ0O1xuICAgICAgICAgICAgbGV0IHJpZ2h0O1xuICAgICAgICAgICAgaWYgKGNvbHVtbldpZHRoICUgMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IChjb2x1bW5XaWR0aCAtIDEpIC8gMjtcbiAgICAgICAgICAgICAgICBsZWZ0ID0geCAtIGhhbGZXaWR0aDtcbiAgICAgICAgICAgICAgICByaWdodCA9IHggKyBoYWxmV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzaGlmdCBwaXhlbCB0byBsZWZ0XG4gICAgICAgICAgICAgICAgY29uc3QgaGFsZldpZHRoID0gY29sdW1uV2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB4IC0gaGFsZldpZHRoO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0geCArIGhhbGZXaWR0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGVbaSAtIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS5mcm9tXSA9IHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9yb3VuZGVkQ2VudGVyOiB4LFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9jZW50ZXI6IChpdGVtLl9pbnRlcm5hbF94ICogcGl4ZWxSYXRpbyksXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RpbWU6IGl0ZW0uX2ludGVybmFsX3RpbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcnJlY3QgcG9zaXRpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbSArIDE7IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZVtpIC0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb21dO1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3ByaXZhdGVfX3ByZWNhbGN1bGF0ZWRDYWNoZVtpIC0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb20gLSAxXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Ll9pbnRlcm5hbF90aW1lICE9PSBwcmV2Ll9pbnRlcm5hbF90aW1lICsgMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQuX2ludGVybmFsX2xlZnQgLSBwcmV2Ll9pbnRlcm5hbF9yaWdodCAhPT0gKHNwYWNpbmcgKyAxKSkge1xuICAgICAgICAgICAgICAgIC8vIGhhdmUgdG8gYWxpZ25cbiAgICAgICAgICAgICAgICBpZiAocHJldi5faW50ZXJuYWxfcm91bmRlZENlbnRlciA+IHByZXYuX2ludGVybmFsX2NlbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2IHdhc3NoaWZ0ZWQgdG8gbGVmdCwgc28gYWRkIHBpeGVsIHRvIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHByZXYuX2ludGVybmFsX3JpZ2h0ID0gY3VycmVudC5faW50ZXJuYWxfbGVmdCAtIHNwYWNpbmcgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kIGN1cnJlbnQgdG8gbGVmdFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Ll9pbnRlcm5hbF9sZWZ0ID0gcHJldi5faW50ZXJuYWxfcmlnaHQgKyBzcGFjaW5nICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1pbldpZHRoID0gTWF0aC5jZWlsKHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2JhclNwYWNpbmcgKiBwaXhlbFJhdGlvKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS5mcm9tOyBpIDwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9wcml2YXRlX19wcmVjYWxjdWxhdGVkQ2FjaGVbaSAtIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS5mcm9tXTtcbiAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGlmIGJhcnNwYWNpbmcgPCAxXG4gICAgICAgICAgICBpZiAoY3VycmVudC5faW50ZXJuYWxfcmlnaHQgPCBjdXJyZW50Ll9pbnRlcm5hbF9sZWZ0KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5faW50ZXJuYWxfcmlnaHQgPSBjdXJyZW50Ll9pbnRlcm5hbF9sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBjdXJyZW50Ll9pbnRlcm5hbF9yaWdodCAtIGN1cnJlbnQuX2ludGVybmFsX2xlZnQgKyAxO1xuICAgICAgICAgICAgbWluV2lkdGggPSBNYXRoLm1pbih3aWR0aCwgbWluV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGFjaW5nID4gMCAmJiBtaW5XaWR0aCA8IGFsaWduVG9NaW5pbWFsV2lkdGhMaW1pdCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZS5mcm9tOyBpIDwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fcHJpdmF0ZV9fcHJlY2FsY3VsYXRlZENhY2hlW2kgLSB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UuZnJvbV07XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBjdXJyZW50Ll9pbnRlcm5hbF9yaWdodCAtIGN1cnJlbnQuX2ludGVybmFsX2xlZnQgKyAxO1xuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IG1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Ll9pbnRlcm5hbF9yb3VuZGVkQ2VudGVyID4gY3VycmVudC5faW50ZXJuYWxfY2VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Ll9pbnRlcm5hbF9yaWdodCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5faW50ZXJuYWxfbGVmdCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNIaXN0b2dyYW1QYW5lVmlldyBleHRlbmRzIExpbmVQYW5lVmlld0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fcmVuZGVyZXIgPSBuZXcgUGFuZVJlbmRlcmVySGlzdG9ncmFtKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9fY3JlYXRlUmF3SXRlbSh0aW1lLCBwcmljZSwgY29sb3Jlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5faW50ZXJuYWxfX2NyZWF0ZVJhd0l0ZW1CYXNlKHRpbWUsIHByaWNlKSxcbiAgICAgICAgICAgIC4uLmNvbG9yZXIuX2ludGVybmFsX2JhclN0eWxlKHRpbWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX3ByZXBhcmVSZW5kZXJlckRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfaXRlbXM6IHRoaXMuX2ludGVybmFsX19pdGVtcyxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9iYXJTcGFjaW5nOiB0aGlzLl9pbnRlcm5hbF9fbW9kZWwuX2ludGVybmFsX3RpbWVTY2FsZSgpLl9pbnRlcm5hbF9iYXJTcGFjaW5nKCksXG4gICAgICAgICAgICBfaW50ZXJuYWxfdmlzaWJsZVJhbmdlOiB0aGlzLl9pbnRlcm5hbF9faXRlbXNWaXNpYmxlUmFuZ2UsXG4gICAgICAgICAgICBfaW50ZXJuYWxfaGlzdG9ncmFtQmFzZTogdGhpcy5faW50ZXJuYWxfX3Nlcmllcy5faW50ZXJuYWxfcHJpY2VTY2FsZSgpLl9pbnRlcm5hbF9wcmljZVRvQ29vcmRpbmF0ZSh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9vcHRpb25zKCkuYmFzZSwgZW5zdXJlTm90TnVsbCh0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLl9pbnRlcm5hbF9maXJzdFZhbHVlKCkpLl9pbnRlcm5hbF92YWx1ZSksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19yZW5kZXJlci5faW50ZXJuYWxfc2V0RGF0YShkYXRhKTtcbiAgICB9XG59XG5cbmNvbnN0IGhpc3RvZ3JhbVN0eWxlRGVmYXVsdHMgPSB7XG4gICAgY29sb3I6ICcjMjZhNjlhJyxcbiAgICBiYXNlOiAwLFxufTtcbmNvbnN0IGNyZWF0ZVBhbmVWaWV3ID0gKHNlcmllcywgbW9kZWwpID0+IG5ldyBTZXJpZXNIaXN0b2dyYW1QYW5lVmlldyhzZXJpZXMsIG1vZGVsKTtcbmNvbnN0IGNyZWF0ZVNlcmllcyA9ICgpID0+IHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgICB0eXBlOiAnSGlzdG9ncmFtJyxcbiAgICAgICAgaXNCdWlsdEluOiB0cnVlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uczogaGlzdG9ncmFtU3R5bGVEZWZhdWx0cyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgX2ludGVybmFsX2NyZWF0ZVBhbmVWaWV3OiBjcmVhdGVQYW5lVmlldyxcbiAgICB9O1xuICAgIHJldHVybiBkZWZpbml0aW9uO1xufTtcbmNvbnN0IGhpc3RvZ3JhbVNlcmllcyA9IGNyZWF0ZVNlcmllcygpO1xuXG5jbGFzcyBQYW5lUHJpbWl0aXZlV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IocGFuZSwgcHJpbWl0aXZlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUgPSBwYW5lO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmUgPSBwcmltaXRpdmU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2F0dGFjaCgpO1xuICAgIH1cbiAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmUuZGV0YWNoUHJpbWl0aXZlKHRoaXMuX3ByaXZhdGVfX3ByaW1pdGl2ZSk7XG4gICAgfVxuICAgIGdldFBhbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lO1xuICAgIH1cbiAgICBhcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wcmltaXRpdmUuX2ludGVybmFsX2FwcGx5T3B0aW9ucz8uKG9wdGlvbnMpO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fYXR0YWNoKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lLmF0dGFjaFByaW1pdGl2ZSh0aGlzLl9wcml2YXRlX19wcmltaXRpdmUpO1xuICAgIH1cbn1cblxuY29uc3QgdGV4dFdhdGVybWFya09wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICB2aXNpYmxlOiB0cnVlLFxuICAgIGhvcnpBbGlnbjogJ2NlbnRlcicsXG4gICAgdmVydEFsaWduOiAnY2VudGVyJyxcbiAgICBsaW5lczogW10sXG59O1xuY29uc3QgdGV4dFdhdGVybWFya0xpbmVPcHRpb25zRGVmYXVsdHMgPSB7XG4gICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgIGZvbnRTaXplOiA0OCxcbiAgICBmb250RmFtaWx5OiBkZWZhdWx0Rm9udEZhbWlseSxcbiAgICBmb250U3R5bGU6ICcnLFxuICAgIHRleHQ6ICcnLFxufTtcblxuY2xhc3MgVGV4dFdhdGVybWFya1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21ldHJpY3NDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGRyYXcodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC51c2VNZWRpYUNvb3JkaW5hdGVTcGFjZSgoc2NvcGUpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZV9fZGF0YS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjb250ZXh0OiBjdHgsIG1lZGlhU2l6ZSB9ID0gc2NvcGU7XG4gICAgICAgICAgICBsZXQgdGV4dEhlaWdodCA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy5fcHJpdmF0ZV9fZGF0YS5saW5lcykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGxpbmUuX2ludGVybmFsX2ZvbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gdGhpcy5fcHJpdmF0ZV9fbWV0cmljcyhjdHgsIGxpbmUudGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRXaWR0aCA+IG1lZGlhU2l6ZS53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lLl9pbnRlcm5hbF96b29tID0gbWVkaWFTaXplLndpZHRoIC8gdGV4dFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZS5faW50ZXJuYWxfem9vbSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHRIZWlnaHQgKz0gbGluZS5saW5lSGVpZ2h0ICogbGluZS5faW50ZXJuYWxfem9vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2ZXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fZGF0YS52ZXJ0QWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICB2ZXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgdmVydE9mZnNldCA9IE1hdGgubWF4KChtZWRpYVNpemUuaGVpZ2h0IC0gdGV4dEhlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgdmVydE9mZnNldCA9IE1hdGgubWF4KG1lZGlhU2l6ZS5oZWlnaHQgLSB0ZXh0SGVpZ2h0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy5fcHJpdmF0ZV9fZGF0YS5saW5lcykge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxpbmUuY29sb3I7XG4gICAgICAgICAgICAgICAgbGV0IGhvcnpPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcHJpdmF0ZV9fZGF0YS5ob3J6QWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9yek9mZnNldCA9IGxpbmUubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvcnpPZmZzZXQgPSBtZWRpYVNpemUud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9yek9mZnNldCA9IG1lZGlhU2l6ZS53aWR0aCAtIDEgLSBsaW5lLmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoaG9yek9mZnNldCwgdmVydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gbGluZS5faW50ZXJuYWxfZm9udDtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUobGluZS5faW50ZXJuYWxfem9vbSwgbGluZS5faW50ZXJuYWxfem9vbSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGxpbmUudGV4dCwgMCwgbGluZS5faW50ZXJuYWxfdmVydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB2ZXJ0T2Zmc2V0ICs9IGxpbmUubGluZUhlaWdodCAqIGxpbmUuX2ludGVybmFsX3pvb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fbWV0cmljcyhjdHgsIHRleHQpIHtcbiAgICAgICAgY29uc3QgZm9udENhY2hlID0gdGhpcy5fcHJpdmF0ZV9fZm9udENhY2hlKGN0eC5mb250KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZvbnRDYWNoZS5nZXQodGV4dCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgICAgICAgZm9udENhY2hlLnNldCh0ZXh0LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9wcml2YXRlX19mb250Q2FjaGUoZm9udCkge1xuICAgICAgICBsZXQgZm9udENhY2hlID0gdGhpcy5fcHJpdmF0ZV9fbWV0cmljc0NhY2hlLmdldChmb250KTtcbiAgICAgICAgaWYgKGZvbnRDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb250Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tZXRyaWNzQ2FjaGUuc2V0KGZvbnQsIGZvbnRDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbnRDYWNoZTtcbiAgICB9XG59XG5cbmNsYXNzIFRleHRXYXRlcm1hcmtQYW5lVmlldyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gYnVpbGRSZW5kZXJlck9wdGlvbnMkMShvcHRpb25zKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3VwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBidWlsZFJlbmRlcmVyT3B0aW9ucyQxKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0V2F0ZXJtYXJrUmVuZGVyZXIodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRSZW5kZXJlckxpbmVPcHRpb25zKGxpbmVPcHRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5saW5lT3B0aW9uLFxuICAgICAgICBfaW50ZXJuYWxfZm9udDogbWFrZUZvbnQobGluZU9wdGlvbi5mb250U2l6ZSwgbGluZU9wdGlvbi5mb250RmFtaWx5LCBsaW5lT3B0aW9uLmZvbnRTdHlsZSksXG4gICAgICAgIGxpbmVIZWlnaHQ6IGxpbmVPcHRpb24ubGluZUhlaWdodCB8fCBsaW5lT3B0aW9uLmZvbnRTaXplICogMS4yLFxuICAgICAgICBfaW50ZXJuYWxfdmVydE9mZnNldDogMCxcbiAgICAgICAgX2ludGVybmFsX3pvb206IDAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUmVuZGVyZXJPcHRpb25zJDEob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGxpbmVzOiBvcHRpb25zLmxpbmVzLm1hcChidWlsZFJlbmRlcmVyTGluZU9wdGlvbnMpLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlTGluZU9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRleHRXYXRlcm1hcmtMaW5lT3B0aW9uc0RlZmF1bHRzLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH07XG59XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnNXaXRoRGVmYXVsdHMkMihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGV4dFdhdGVybWFya09wdGlvbnNEZWZhdWx0cyxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbGluZXM6IG9wdGlvbnMubGluZXM/Lm1hcChtZXJnZUxpbmVPcHRpb25zV2l0aERlZmF1bHRzKSA/PyBbXSxcbiAgICB9O1xufVxuY2xhc3MgVGV4dFdhdGVybWFyayB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gbWVyZ2VPcHRpb25zV2l0aERlZmF1bHRzJDIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cyA9IFtuZXcgVGV4dFdhdGVybWFya1BhbmVWaWV3KHRoaXMuX3ByaXZhdGVfX29wdGlvbnMpXTtcbiAgICB9XG4gICAgdXBkYXRlQWxsVmlld3MoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cy5mb3JFYWNoKChwdykgPT4gcHcuX2ludGVybmFsX3VwZGF0ZSh0aGlzLl9wcml2YXRlX19vcHRpb25zKSk7XG4gICAgfVxuICAgIHBhbmVWaWV3cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cztcbiAgICB9XG4gICAgYXR0YWNoZWQoeyByZXF1ZXN0VXBkYXRlIH0pIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVxdWVzdFVwZGF0ZSA9IHJlcXVlc3RVcGRhdGU7XG4gICAgfVxuICAgIGRldGFjaGVkKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG1lcmdlT3B0aW9uc1dpdGhEZWZhdWx0cyQyKHsgLi4udGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsX3JlcXVlc3RVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX3JlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBpbWFnZSB3YXRlcm1hcmsuXG4gKlxuICogQHBhcmFtIHBhbmUgLSBUYXJnZXQgcGFuZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gV2F0ZXJtYXJrIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgSW1hZ2Ugd2F0ZXJtYXJrIHdyYXBwZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBjcmVhdGVUZXh0V2F0ZXJtYXJrIH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbiAqXG4gKiBjb25zdCBmaXJzdFBhbmUgPSBjaGFydC5wYW5lcygpWzBdO1xuICogY29uc3QgdGV4dFdhdGVybWFyayA9IGNyZWF0ZVRleHRXYXRlcm1hcmsoZmlyc3RQYW5lLCB7XG4gKiBcdCAgaG9yekFsaWduOiAnY2VudGVyJyxcbiAqIFx0ICB2ZXJ0QWxpZ246ICdjZW50ZXInLFxuICogXHQgIGxpbmVzOiBbXG4gKiBcdCAgICB7XG4gKiBcdCAgICAgIHRleHQ6ICdIZWxsbycsXG4gKiBcdCAgICAgIGNvbG9yOiAncmdiYSgyNTUsMCwwLDAuNSknLFxuICogXHQgICAgICBmb250U2l6ZTogMTAwLFxuICogXHQgICAgICBmb250U3R5bGU6ICdib2xkJyxcbiAqIFx0ICAgIH0sXG4gKiBcdCAgICB7XG4gKiBcdCAgICAgIHRleHQ6ICdUaGlzIGlzIGEgdGV4dCB3YXRlcm1hcmsnLFxuICogXHQgICAgICBjb2xvcjogJ3JnYmEoMCwwLDI1NSwwLjUpJyxcbiAqIFx0ICAgICAgZm9udFNpemU6IDUwLFxuICogXHQgICAgICBmb250U3R5bGU6ICdpdGFsaWMnLFxuICogXHQgICAgICBmb250RmFtaWx5OiAnbW9ub3NwYWNlJyxcbiAqIFx0ICAgIH0sXG4gKiBcdCAgXSxcbiAqIH0pO1xuICogLy8gdG8gY2hhbmdlIG9wdGlvbnNcbiAqIHRleHRXYXRlcm1hcmsuYXBwbHlPcHRpb25zKHsgaG9yekFsaWduOiAnbGVmdCcgfSk7XG4gKiAvLyB0byByZW1vdmUgd2F0ZXJtYXJrIGZyb20gdGhlIHBhbmVcbiAqIHRleHRXYXRlcm1hcmsuZGV0YWNoKCk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGV4dFdhdGVybWFyayhwYW5lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYW5lUHJpbWl0aXZlV3JhcHBlcihwYW5lLCBuZXcgVGV4dFdhdGVybWFyayhvcHRpb25zKSk7XG59XG5cbmNvbnN0IGltYWdlV2F0ZXJtYXJrT3B0aW9uc0RlZmF1bHRzID0ge1xuICAgIGFscGhhOiAxLFxuICAgIHBhZGRpbmc6IDAsXG59O1xuXG5jbGFzcyBJbWFnZVdhdGVybWFya1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBkcmF3KHRhcmdldCkge1xuICAgICAgICB0YXJnZXQudXNlTWVkaWFDb29yZGluYXRlU3BhY2UoKHNjb3BlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBzY29wZS5jb250ZXh0O1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fcHJpdmF0ZV9fZGV0ZXJtaW5lUGxhY2VtZW50KHRoaXMuX3ByaXZhdGVfX2RhdGEsIHNjb3BlLm1lZGlhU2l6ZSk7XG4gICAgICAgICAgICBpZiAoIXBvcyB8fCAhdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaW1nRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuYWxwaGEgPz8gMTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaW1nRWxlbWVudCwgcG9zLl9pbnRlcm5hbF94LCBwb3MuX2ludGVybmFsX3ksIHBvcy5faW50ZXJuYWxfd2lkdGgsIHBvcy5faW50ZXJuYWxfaGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19kZXRlcm1pbmVQbGFjZW1lbnQoZGF0YSwgcGFuZVNpemUpIHtcbiAgICAgICAgY29uc3QgeyBtYXhIZWlnaHQsIG1heFdpZHRoLCBfaW50ZXJuYWxfaW1nSGVpZ2h0OiBpbWdIZWlnaHQsIF9pbnRlcm5hbF9pbWdXaWR0aDogaW1nV2lkdGgsIHBhZGRpbmcgfSA9IGRhdGE7XG4gICAgICAgIGNvbnN0IHBsb3RDZW50cmVYID0gTWF0aC5yb3VuZChwYW5lU2l6ZS53aWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBwbG90Q2VudHJlWSA9IE1hdGgucm91bmQocGFuZVNpemUuaGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdTaXplID0gcGFkZGluZyA/PyAwO1xuICAgICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBwYW5lU2l6ZS53aWR0aCAtIDIgKiBwYWRkaW5nU2l6ZTtcbiAgICAgICAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IHBhbmVTaXplLmhlaWdodCAtIDIgKiBwYWRkaW5nU2l6ZTtcbiAgICAgICAgaWYgKG1heEhlaWdodCkge1xuICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5taW4oYXZhaWxhYmxlSGVpZ2h0LCBtYXhIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhXaWR0aCkge1xuICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCwgbWF4V2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjYWxlWCA9IGF2YWlsYWJsZVdpZHRoIC8gaW1nV2lkdGg7XG4gICAgICAgIGNvbnN0IHNjYWxlWSA9IGF2YWlsYWJsZUhlaWdodCAvIGltZ0hlaWdodDtcbiAgICAgICAgY29uc3Qgc2NhbGVUb1VzZSA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgY29uc3QgZHJhd1dpZHRoID0gaW1nV2lkdGggKiBzY2FsZVRvVXNlO1xuICAgICAgICBjb25zdCBkcmF3SGVpZ2h0ID0gaW1nSGVpZ2h0ICogc2NhbGVUb1VzZTtcbiAgICAgICAgY29uc3QgeCA9IHBsb3RDZW50cmVYIC0gMC41ICogZHJhd1dpZHRoO1xuICAgICAgICBjb25zdCB5ID0gcGxvdENlbnRyZVkgLSAwLjUgKiBkcmF3SGVpZ2h0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2ludGVybmFsX3g6IHgsXG4gICAgICAgICAgICBfaW50ZXJuYWxfeTogeSxcbiAgICAgICAgICAgIF9pbnRlcm5hbF9oZWlnaHQ6IGRyYXdIZWlnaHQsXG4gICAgICAgICAgICBfaW50ZXJuYWxfd2lkdGg6IGRyYXdXaWR0aCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNsYXNzIEltYWdlV2F0ZXJtYXJrUGFuZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW1hZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbWFnZVdpZHRoID0gMDsgLy8gZG9uJ3QgZHJhdyB1bnRpbCBsb2FkZWRcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW1hZ2VIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zID0gYnVpbGRSZW5kZXJlck9wdGlvbnModGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgdGhpcy5fcHJpdmF0ZV9faW1hZ2UsIHRoaXMuX3ByaXZhdGVfX2ltYWdlV2lkdGgsIHRoaXMuX3ByaXZhdGVfX2ltYWdlSGVpZ2h0KTtcbiAgICB9XG4gICAgX2ludGVybmFsX3N0YXRlVXBkYXRlKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5faW50ZXJuYWxfaW1hZ2VXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbWFnZVdpZHRoID0gc3RhdGUuX2ludGVybmFsX2ltYWdlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLl9pbnRlcm5hbF9pbWFnZUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19pbWFnZUhlaWdodCA9IHN0YXRlLl9pbnRlcm5hbF9pbWFnZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuX2ludGVybmFsX2ltYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ltYWdlID0gc3RhdGUuX2ludGVybmFsX2ltYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZSgpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfb3B0aW9uc1VwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF91cGRhdGUoKTtcbiAgICB9XG4gICAgek9yZGVyKCkge1xuICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyT3B0aW9ucyA9IGJ1aWxkUmVuZGVyZXJPcHRpb25zKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMsIHRoaXMuX3ByaXZhdGVfX2ltYWdlLCB0aGlzLl9wcml2YXRlX19pbWFnZVdpZHRoLCB0aGlzLl9wcml2YXRlX19pbWFnZUhlaWdodCk7XG4gICAgfVxuICAgIHJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IEltYWdlV2F0ZXJtYXJrUmVuZGVyZXIodGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXJPcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFJlbmRlcmVyT3B0aW9ucyhvcHRpb25zLCBpbWdFbGVtZW50LCBpbWdXaWR0aCwgaW1nSGVpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgX2ludGVybmFsX2ltZ0VsZW1lbnQ6IGltZ0VsZW1lbnQsXG4gICAgICAgIF9pbnRlcm5hbF9pbWdXaWR0aDogaW1nV2lkdGgsXG4gICAgICAgIF9pbnRlcm5hbF9pbWdIZWlnaHQ6IGltZ0hlaWdodCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnNXaXRoRGVmYXVsdHMkMShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW1hZ2VXYXRlcm1hcmtPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbn1cbmNsYXNzIEltYWdlV2F0ZXJtYXJrIHtcbiAgICBjb25zdHJ1Y3RvcihpbWFnZVVybCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbWdFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW1hZ2VVcmwgPSBpbWFnZVVybDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG1lcmdlT3B0aW9uc1dpdGhEZWZhdWx0cyQxKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlld3MgPSBbbmV3IEltYWdlV2F0ZXJtYXJrUGFuZVZpZXcodGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyldO1xuICAgIH1cbiAgICB1cGRhdGVBbGxWaWV3cygpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXdzLmZvckVhY2goKHB3KSA9PiBwdy5faW50ZXJuYWxfdXBkYXRlKCkpO1xuICAgIH1cbiAgICBwYW5lVmlld3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19wYW5lVmlld3M7XG4gICAgfVxuICAgIGF0dGFjaGVkKGF0dGFjaGVkUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgcmVxdWVzdFVwZGF0ZSB9ID0gYXR0YWNoZWRQYXJhbXM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlcXVlc3RVcGRhdGUgPSByZXF1ZXN0VXBkYXRlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbWdFbGVtZW50ID0gbmV3IEltYWdlKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ltZ0VsZW1lbnQub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VIZWlnaHQgPSB0aGlzLl9wcml2YXRlX19pbWdFbGVtZW50Py5uYXR1cmFsSGVpZ2h0ID8/IDE7XG4gICAgICAgICAgICBjb25zdCBpbWFnZVdpZHRoID0gdGhpcy5fcHJpdmF0ZV9faW1nRWxlbWVudD8ubmF0dXJhbFdpZHRoID8/IDE7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlld3MuZm9yRWFjaCgocHYpID0+IHB2Ll9pbnRlcm5hbF9zdGF0ZVVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2ltYWdlSGVpZ2h0OiBpbWFnZUhlaWdodCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaW1hZ2VXaWR0aDogaW1hZ2VXaWR0aCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfaW1hZ2U6IHRoaXMuX3ByaXZhdGVfX2ltZ0VsZW1lbnQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmVxdWVzdFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW1nRWxlbWVudC5zcmMgPSB0aGlzLl9wcml2YXRlX19pbWFnZVVybDtcbiAgICB9XG4gICAgZGV0YWNoZWQoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlcXVlc3RVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ltZ0VsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG1lcmdlT3B0aW9uc1dpdGhEZWZhdWx0cyQxKHsgLi4udGhpcy5fcHJpdmF0ZV9fb3B0aW9ucywgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdXBkYXRlT3B0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfcmVxdWVzdFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmVxdWVzdFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcml2YXRlX191cGRhdGVPcHRpb25zKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlld3MuZm9yRWFjaCgocHcpID0+IHB3Ll9pbnRlcm5hbF9vcHRpb25zVXBkYXRlKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMpKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW1hZ2Ugd2F0ZXJtYXJrLlxuICpcbiAqIEBwYXJhbSBwYW5lIC0gVGFyZ2V0IHBhbmUuXG4gKiBAcGFyYW0gaW1hZ2VVcmwgLSBJbWFnZSBVUkwuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFdhdGVybWFyayBvcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIEltYWdlIHdhdGVybWFyayB3cmFwcGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgY3JlYXRlSW1hZ2VXYXRlcm1hcmsgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuICpcbiAqIGNvbnN0IGZpcnN0UGFuZSA9IGNoYXJ0LnBhbmVzKClbMF07XG4gKiBjb25zdCBpbWFnZVdhdGVybWFyayA9IGNyZWF0ZUltYWdlV2F0ZXJtYXJrKGZpcnN0UGFuZSwgJy9pbWFnZXMvbXktaW1hZ2UucG5nJywge1xuICogICBhbHBoYTogMC41LFxuICogICBwYWRkaW5nOiAyMCxcbiAqIH0pO1xuICogLy8gdG8gY2hhbmdlIG9wdGlvbnNcbiAqIGltYWdlV2F0ZXJtYXJrLmFwcGx5T3B0aW9ucyh7IHBhZGRpbmc6IDEwIH0pO1xuICogLy8gdG8gcmVtb3ZlIHdhdGVybWFyayBmcm9tIHRoZSBwYW5lXG4gKiBpbWFnZVdhdGVybWFyay5kZXRhY2goKTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjcmVhdGVJbWFnZVdhdGVybWFyayhwYW5lLCBpbWFnZVVybCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFuZVByaW1pdGl2ZVdyYXBwZXIocGFuZSwgbmV3IEltYWdlV2F0ZXJtYXJrKGltYWdlVXJsLCBvcHRpb25zKSk7XG59XG5cbmNsYXNzIFNlcmllc1ByaW1pdGl2ZUFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgcHJpbWl0aXZlKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUgPSBwcmltaXRpdmU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2F0dGFjaCgpO1xuICAgIH1cbiAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX19zZXJpZXMuZGV0YWNoUHJpbWl0aXZlKHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUpO1xuICAgIH1cbiAgICBnZXRTZXJpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzO1xuICAgIH1cbiAgICBhcHBseU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZSAmJiB0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlLl9pbnRlcm5hbF9hcHBseU9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUuX2ludGVybmFsX2FwcGx5T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fYXR0YWNoKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9fc2VyaWVzLmF0dGFjaFByaW1pdGl2ZSh0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlKTtcbiAgICB9XG59XG5cbmNvbnN0IHNlcmllc01hcmtlck9wdGlvbnNEZWZhdWx0cyA9IHtcbiAgICB6T3JkZXI6ICdub3JtYWwnLFxufTtcblxuZnVuY3Rpb24gc2l6ZShiYXJTcGFjaW5nLCBjb2VmZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IE1hdGgubWluKE1hdGgubWF4KGJhclNwYWNpbmcsIDEyIC8qIENvbnN0YW50cy5NaW5TaGFwZVNpemUgKi8pLCAzMCAvKiBDb25zdGFudHMuTWF4U2hhcGVTaXplICovKSAqIGNvZWZmO1xuICAgIHJldHVybiBjZWlsZWRPZGQocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHNoYXBlU2l6ZShzaGFwZSwgb3JpZ2luYWxTaXplKSB7XG4gICAgc3dpdGNoIChzaGFwZSkge1xuICAgICAgICBjYXNlICdhcnJvd0Rvd24nOlxuICAgICAgICBjYXNlICdhcnJvd1VwJzpcbiAgICAgICAgICAgIHJldHVybiBzaXplKG9yaWdpbmFsU2l6ZSwgMSk7XG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgICByZXR1cm4gc2l6ZShvcmlnaW5hbFNpemUsIDAuOCk7XG4gICAgICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICAgICAgICByZXR1cm4gc2l6ZShvcmlnaW5hbFNpemUsIDAuNyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlU2hhcGVIZWlnaHQoYmFyU3BhY2luZykge1xuICAgIHJldHVybiBjZWlsZWRFdmVuKHNpemUoYmFyU3BhY2luZywgMSkpO1xufVxuZnVuY3Rpb24gc2hhcGVNYXJnaW4oYmFyU3BhY2luZykge1xuICAgIHJldHVybiBNYXRoLm1heChzaXplKGJhclNwYWNpbmcsIDAuMSksIDMgLyogQ29uc3RhbnRzLk1pblNoYXBlTWFyZ2luICovKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFkanVzdGVkTWFyZ2luKG1hcmdpbiwgaGFzU2lkZSwgaGFzSW5CYXIpIHtcbiAgICBpZiAoaGFzU2lkZSkge1xuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYXNJbkJhcikge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG1hcmdpbiAvIDIpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZHJhd0Fycm93KHVwLCBjdHgsIGNvb3Jkcywgc2l6ZSkge1xuICAgIGNvbnN0IGFycm93U2l6ZSA9IHNoYXBlU2l6ZSgnYXJyb3dVcCcsIHNpemUpO1xuICAgIGNvbnN0IGhhbGZBcnJvd1NpemUgPSAoKGFycm93U2l6ZSAtIDEpIC8gMikgKiBjb29yZHMuX2ludGVybmFsX3BpeGVsUmF0aW87XG4gICAgY29uc3QgYmFzZVNpemUgPSBjZWlsZWRPZGQoc2l6ZSAvIDIpO1xuICAgIGNvbnN0IGhhbGZCYXNlU2l6ZSA9ICgoYmFzZVNpemUgLSAxKSAvIDIpICogY29vcmRzLl9pbnRlcm5hbF9waXhlbFJhdGlvO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAodXApIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhjb29yZHMuX2ludGVybmFsX3ggLSBoYWxmQXJyb3dTaXplLCBjb29yZHMuX2ludGVybmFsX3kpO1xuICAgICAgICBjdHgubGluZVRvKGNvb3Jkcy5faW50ZXJuYWxfeCwgY29vcmRzLl9pbnRlcm5hbF95IC0gaGFsZkFycm93U2l6ZSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29vcmRzLl9pbnRlcm5hbF94ICsgaGFsZkFycm93U2l6ZSwgY29vcmRzLl9pbnRlcm5hbF95KTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb29yZHMuX2ludGVybmFsX3ggKyBoYWxmQmFzZVNpemUsIGNvb3Jkcy5faW50ZXJuYWxfeSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29vcmRzLl9pbnRlcm5hbF94ICsgaGFsZkJhc2VTaXplLCBjb29yZHMuX2ludGVybmFsX3kgKyBoYWxmQXJyb3dTaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb29yZHMuX2ludGVybmFsX3ggLSBoYWxmQmFzZVNpemUsIGNvb3Jkcy5faW50ZXJuYWxfeSArIGhhbGZBcnJvd1NpemUpO1xuICAgICAgICBjdHgubGluZVRvKGNvb3Jkcy5faW50ZXJuYWxfeCAtIGhhbGZCYXNlU2l6ZSwgY29vcmRzLl9pbnRlcm5hbF95KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oY29vcmRzLl9pbnRlcm5hbF94IC0gaGFsZkFycm93U2l6ZSwgY29vcmRzLl9pbnRlcm5hbF95KTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb29yZHMuX2ludGVybmFsX3gsIGNvb3Jkcy5faW50ZXJuYWxfeSArIGhhbGZBcnJvd1NpemUpO1xuICAgICAgICBjdHgubGluZVRvKGNvb3Jkcy5faW50ZXJuYWxfeCArIGhhbGZBcnJvd1NpemUsIGNvb3Jkcy5faW50ZXJuYWxfeSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29vcmRzLl9pbnRlcm5hbF94ICsgaGFsZkJhc2VTaXplLCBjb29yZHMuX2ludGVybmFsX3kpO1xuICAgICAgICBjdHgubGluZVRvKGNvb3Jkcy5faW50ZXJuYWxfeCArIGhhbGZCYXNlU2l6ZSwgY29vcmRzLl9pbnRlcm5hbF95IC0gaGFsZkFycm93U2l6ZSk7XG4gICAgICAgIGN0eC5saW5lVG8oY29vcmRzLl9pbnRlcm5hbF94IC0gaGFsZkJhc2VTaXplLCBjb29yZHMuX2ludGVybmFsX3kgLSBoYWxmQXJyb3dTaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbyhjb29yZHMuX2ludGVybmFsX3ggLSBoYWxmQmFzZVNpemUsIGNvb3Jkcy5faW50ZXJuYWxfeSk7XG4gICAgfVxuICAgIGN0eC5maWxsKCk7XG59XG5mdW5jdGlvbiBoaXRUZXN0QXJyb3codXAsIGNlbnRlclgsIGNlbnRlclksIHNpemUsIHgsIHkpIHtcbiAgICBjb25zdCBhcnJvd1NpemUgPSBzaGFwZVNpemUoJ2Fycm93VXAnLCBzaXplKTtcbiAgICBjb25zdCBoYWxmQXJyb3dTaXplID0gKGFycm93U2l6ZSAtIDEpIC8gMjtcbiAgICBjb25zdCBiYXNlU2l6ZSA9IGNlaWxlZE9kZChzaXplIC8gMik7XG4gICAgY29uc3QgaGFsZkJhc2VTaXplID0gKGJhc2VTaXplIC0gMSkgLyAyO1xuICAgIGNvbnN0IHRyaWFuZ2xlVG9sZXJhbmNlID0gMztcbiAgICBjb25zdCByZWN0VG9sZXJhbmNlID0gMjtcbiAgICBjb25zdCBiYXNlTGVmdCA9IGNlbnRlclggLSBoYWxmQmFzZVNpemUgLSByZWN0VG9sZXJhbmNlO1xuICAgIGNvbnN0IGJhc2VSaWdodCA9IGNlbnRlclggKyBoYWxmQmFzZVNpemUgKyByZWN0VG9sZXJhbmNlO1xuICAgIGNvbnN0IGJhc2VUb3AgPSB1cCA/IGNlbnRlclkgOiBjZW50ZXJZIC0gaGFsZkFycm93U2l6ZTtcbiAgICBjb25zdCBiYXNlQm90dG9tID0gdXAgPyBjZW50ZXJZICsgaGFsZkFycm93U2l6ZSA6IGNlbnRlclk7XG4gICAgaWYgKHggPj0gYmFzZUxlZnQgJiYgeCA8PSBiYXNlUmlnaHQgJiZcbiAgICAgICAgeSA+PSBiYXNlVG9wIC0gcmVjdFRvbGVyYW5jZSAmJiB5IDw9IGJhc2VCb3R0b20gKyByZWN0VG9sZXJhbmNlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpc0luVHJpYW5nbGVCb3VuZHMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRMZWZ0ID0gY2VudGVyWCAtIGhhbGZBcnJvd1NpemUgLSB0cmlhbmdsZVRvbGVyYW5jZTtcbiAgICAgICAgY29uc3QgaGVhZFJpZ2h0ID0gY2VudGVyWCArIGhhbGZBcnJvd1NpemUgKyB0cmlhbmdsZVRvbGVyYW5jZTtcbiAgICAgICAgY29uc3QgaGVhZFRvcCA9IHVwID8gY2VudGVyWSAtIGhhbGZBcnJvd1NpemUgLSB0cmlhbmdsZVRvbGVyYW5jZSA6IGNlbnRlclk7XG4gICAgICAgIGNvbnN0IGhlYWRCb3R0b20gPSB1cCA/IGNlbnRlclkgOiBjZW50ZXJZICsgaGFsZkFycm93U2l6ZSArIHRyaWFuZ2xlVG9sZXJhbmNlO1xuICAgICAgICBpZiAoeCA8IGhlYWRMZWZ0IHx8IHggPiBoZWFkUmlnaHQgfHxcbiAgICAgICAgICAgIHkgPCBoZWFkVG9wIHx8IHkgPiBoZWFkQm90dG9tKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHggPSBNYXRoLmFicyh4IC0gY2VudGVyWCk7XG4gICAgICAgIGNvbnN0IGR5ID0gdXBcbiAgICAgICAgICAgID8gTWF0aC5hYnMoeSAtIGNlbnRlclkpIC8vIHVwIGFycm93XG4gICAgICAgICAgICA6IE1hdGguYWJzKHkgLSBjZW50ZXJZKTsgLy8gZG93biBhcnJvd1xuICAgICAgICByZXR1cm4gZHkgKyB0cmlhbmdsZVRvbGVyYW5jZSA+PSBkeCAvIDI7XG4gICAgfTtcbiAgICByZXR1cm4gaXNJblRyaWFuZ2xlQm91bmRzKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdDaXJjbGUoY3R4LCBjb29yZHMsIHNpemUpIHtcbiAgICBjb25zdCBjaXJjbGVTaXplID0gc2hhcGVTaXplKCdjaXJjbGUnLCBzaXplKTtcbiAgICBjb25zdCBoYWxmU2l6ZSA9IChjaXJjbGVTaXplIC0gMSkgLyAyO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKGNvb3Jkcy5faW50ZXJuYWxfeCwgY29vcmRzLl9pbnRlcm5hbF95LCBoYWxmU2l6ZSAqIGNvb3Jkcy5faW50ZXJuYWxfcGl4ZWxSYXRpbywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICBjdHguZmlsbCgpO1xufVxuZnVuY3Rpb24gaGl0VGVzdENpcmNsZShjZW50ZXJYLCBjZW50ZXJZLCBzaXplLCB4LCB5KSB7XG4gICAgY29uc3QgY2lyY2xlU2l6ZSA9IHNoYXBlU2l6ZSgnY2lyY2xlJywgc2l6ZSk7XG4gICAgY29uc3QgdG9sZXJhbmNlID0gMiArIGNpcmNsZVNpemUgLyAyO1xuICAgIGNvbnN0IHhPZmZzZXQgPSBjZW50ZXJYIC0geDtcbiAgICBjb25zdCB5T2Zmc2V0ID0gY2VudGVyWSAtIHk7XG4gICAgY29uc3QgZGlzdCA9IE1hdGguc3FydCh4T2Zmc2V0ICogeE9mZnNldCArIHlPZmZzZXQgKiB5T2Zmc2V0KTtcbiAgICByZXR1cm4gZGlzdCA8PSB0b2xlcmFuY2U7XG59XG5cbmZ1bmN0aW9uIGRyYXdTcXVhcmUoY3R4LCBjb29yZHMsIHNpemUpIHtcbiAgICBjb25zdCBzcXVhcmVTaXplID0gc2hhcGVTaXplKCdzcXVhcmUnLCBzaXplKTtcbiAgICBjb25zdCBoYWxmU2l6ZSA9ICgoc3F1YXJlU2l6ZSAtIDEpICogY29vcmRzLl9pbnRlcm5hbF9waXhlbFJhdGlvKSAvIDI7XG4gICAgY29uc3QgbGVmdCA9IGNvb3Jkcy5faW50ZXJuYWxfeCAtIGhhbGZTaXplO1xuICAgIGNvbnN0IHRvcCA9IGNvb3Jkcy5faW50ZXJuYWxfeSAtIGhhbGZTaXplO1xuICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHNxdWFyZVNpemUgKiBjb29yZHMuX2ludGVybmFsX3BpeGVsUmF0aW8sIHNxdWFyZVNpemUgKiBjb29yZHMuX2ludGVybmFsX3BpeGVsUmF0aW8pO1xufVxuZnVuY3Rpb24gaGl0VGVzdFNxdWFyZShjZW50ZXJYLCBjZW50ZXJZLCBzaXplLCB4LCB5KSB7XG4gICAgY29uc3Qgc3F1YXJlU2l6ZSA9IHNoYXBlU2l6ZSgnc3F1YXJlJywgc2l6ZSk7XG4gICAgY29uc3QgaGFsZlNpemUgPSAoc3F1YXJlU2l6ZSAtIDEpIC8gMjtcbiAgICBjb25zdCBsZWZ0ID0gY2VudGVyWCAtIGhhbGZTaXplO1xuICAgIGNvbnN0IHRvcCA9IGNlbnRlclkgLSBoYWxmU2l6ZTtcbiAgICByZXR1cm4geCA+PSBsZWZ0ICYmIHggPD0gbGVmdCArIHNxdWFyZVNpemUgJiZcbiAgICAgICAgeSA+PSB0b3AgJiYgeSA8PSB0b3AgKyBzcXVhcmVTaXplO1xufVxuXG5mdW5jdGlvbiBkcmF3VGV4dChjdHgsIHRleHQsIHgsIHksIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8pIHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zY2FsZShob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICBjdHguZmlsbFRleHQodGV4dCwgeCwgeSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGhpdFRlc3RUZXh0KHRleHRYLCB0ZXh0WSwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCB4LCB5KSB7XG4gICAgY29uc3QgaGFsZkhlaWdodCA9IHRleHRIZWlnaHQgLyAyO1xuICAgIHJldHVybiB4ID49IHRleHRYICYmIHggPD0gdGV4dFggKyB0ZXh0V2lkdGggJiZcbiAgICAgICAgeSA+PSB0ZXh0WSAtIGhhbGZIZWlnaHQgJiYgeSA8PSB0ZXh0WSArIGhhbGZIZWlnaHQ7XG59XG5cbmNsYXNzIFNlcmllc01hcmtlcnNSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190ZXh0V2lkdGhDYWNoZSA9IG5ldyBUZXh0V2lkdGhDYWNoZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19mb250U2l6ZSA9IC0xO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19mb250RmFtaWx5ID0gJyc7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnQgPSAnJztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fek9yZGVyID0gJ25vcm1hbCc7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRQYXJhbXMoZm9udFNpemUsIGZvbnRGYW1pbHksIHpPcmRlcikge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZm9udFNpemUgIT09IGZvbnRTaXplIHx8IHRoaXMuX3ByaXZhdGVfX2ZvbnRGYW1pbHkgIT09IGZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2ZvbnQgPSBtYWtlRm9udChmb250U2l6ZSwgZm9udEZhbWlseSk7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX190ZXh0V2lkdGhDYWNoZS5faW50ZXJuYWxfcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX196T3JkZXIgPSB6T3JkZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9oaXRUZXN0KHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGkgPCB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF92aXNpYmxlUmFuZ2UudG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaGl0VGVzdEl0ZW0oaXRlbSwgeCwgeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB6T3JkZXI6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbElkOiBpdGVtLl9pbnRlcm5hbF9leHRlcm5hbElkID8/ICcnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRyYXcodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX196T3JkZXIgPT09ICdhYm92ZVNlcmllcycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQudXNlQml0bWFwQ29vcmRpbmF0ZVNwYWNlKChzY29wZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxfX2RyYXdJbXBsKHNjb3BlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYXdCYWNrZ3JvdW5kKHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fek9yZGVyICE9PSAnYWJvdmVTZXJpZXMnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoc2NvcGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX19kcmF3SW1wbChzY29wZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX2RyYXdJbXBsKHsgY29udGV4dDogY3R4LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2RhdGEgPT09IG51bGwgfHwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBjdHguZm9udCA9IHRoaXMuX3ByaXZhdGVfX2ZvbnQ7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLnRvOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfaXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGl0ZW0uX2ludGVybmFsX3RleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3dpZHRoID0gdGhpcy5fcHJpdmF0ZV9fdGV4dFdpZHRoQ2FjaGUuX2ludGVybmFsX21lYXN1cmVUZXh0KGN0eCwgaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfY29udGVudCk7XG4gICAgICAgICAgICAgICAgaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfaGVpZ2h0ID0gdGhpcy5fcHJpdmF0ZV9fZm9udFNpemU7XG4gICAgICAgICAgICAgICAgaXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfeCA9IGl0ZW0uX2ludGVybmFsX3ggLSBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF93aWR0aCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkcmF3SXRlbShpdGVtLCBjdHgsIGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYml0bWFwU2hhcGVJdGVtQ29vcmRpbmF0ZXMoaXRlbSwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbykge1xuICAgIGNvbnN0IHRpY2tXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoaG9yaXpvbnRhbFBpeGVsUmF0aW8pKTtcbiAgICBjb25zdCBjb3JyZWN0aW9uID0gKHRpY2tXaWR0aCAlIDIpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZXJuYWxfeDogTWF0aC5yb3VuZChpdGVtLl9pbnRlcm5hbF94ICogaG9yaXpvbnRhbFBpeGVsUmF0aW8pICsgY29ycmVjdGlvbixcbiAgICAgICAgX2ludGVybmFsX3k6IGl0ZW0uX2ludGVybmFsX3kgKiB2ZXJ0aWNhbFBpeGVsUmF0aW8sXG4gICAgICAgIF9pbnRlcm5hbF9waXhlbFJhdGlvOiBob3Jpem9udGFsUGl4ZWxSYXRpbyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZHJhd0l0ZW0oaXRlbSwgY3R4LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGl0ZW0uX2ludGVybmFsX2NvbG9yO1xuICAgIGlmIChpdGVtLl9pbnRlcm5hbF90ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZHJhd1RleHQoY3R4LCBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF9jb250ZW50LCBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF94LCBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF95LCBob3Jpem9udGFsUGl4ZWxSYXRpbywgdmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICB9XG4gICAgZHJhd1NoYXBlKGl0ZW0sIGN0eCwgYml0bWFwU2hhcGVJdGVtQ29vcmRpbmF0ZXMoaXRlbSwgaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbykpO1xufVxuZnVuY3Rpb24gZHJhd1NoYXBlKGl0ZW0sIGN0eCwgY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoaXRlbS5faW50ZXJuYWxfc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoaXRlbS5faW50ZXJuYWxfc2hhcGUpIHtcbiAgICAgICAgY2FzZSAnYXJyb3dEb3duJzpcbiAgICAgICAgICAgIGRyYXdBcnJvdyhmYWxzZSwgY3R4LCBjb29yZGluYXRlcywgaXRlbS5faW50ZXJuYWxfc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ2Fycm93VXAnOlxuICAgICAgICAgICAgZHJhd0Fycm93KHRydWUsIGN0eCwgY29vcmRpbmF0ZXMsIGl0ZW0uX2ludGVybmFsX3NpemUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgZHJhd0NpcmNsZShjdHgsIGNvb3JkaW5hdGVzLCBpdGVtLl9pbnRlcm5hbF9zaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgICAgIGRyYXdTcXVhcmUoY3R4LCBjb29yZGluYXRlcywgaXRlbS5faW50ZXJuYWxfc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuc3VyZU5ldmVyKGl0ZW0uX2ludGVybmFsX3NoYXBlKTtcbn1cbmZ1bmN0aW9uIGhpdFRlc3RJdGVtKGl0ZW0sIHgsIHkpIHtcbiAgICBpZiAoaXRlbS5faW50ZXJuYWxfdGV4dCAhPT0gdW5kZWZpbmVkICYmIGhpdFRlc3RUZXh0KGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3gsIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3ksIGl0ZW0uX2ludGVybmFsX3RleHQuX2ludGVybmFsX3dpZHRoLCBpdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF9oZWlnaHQsIHgsIHkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGl0VGVzdFNoYXBlKGl0ZW0sIHgsIHkpO1xufVxuZnVuY3Rpb24gaGl0VGVzdFNoYXBlKGl0ZW0sIHgsIHkpIHtcbiAgICBpZiAoaXRlbS5faW50ZXJuYWxfc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAoaXRlbS5faW50ZXJuYWxfc2hhcGUpIHtcbiAgICAgICAgY2FzZSAnYXJyb3dEb3duJzpcbiAgICAgICAgICAgIHJldHVybiBoaXRUZXN0QXJyb3codHJ1ZSwgaXRlbS5faW50ZXJuYWxfeCwgaXRlbS5faW50ZXJuYWxfeSwgaXRlbS5faW50ZXJuYWxfc2l6ZSwgeCwgeSk7XG4gICAgICAgIGNhc2UgJ2Fycm93VXAnOlxuICAgICAgICAgICAgcmV0dXJuIGhpdFRlc3RBcnJvdyhmYWxzZSwgaXRlbS5faW50ZXJuYWxfeCwgaXRlbS5faW50ZXJuYWxfeSwgaXRlbS5faW50ZXJuYWxfc2l6ZSwgeCwgeSk7XG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgICByZXR1cm4gaGl0VGVzdENpcmNsZShpdGVtLl9pbnRlcm5hbF94LCBpdGVtLl9pbnRlcm5hbF95LCBpdGVtLl9pbnRlcm5hbF9zaXplLCB4LCB5KTtcbiAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgICAgIHJldHVybiBoaXRUZXN0U3F1YXJlKGl0ZW0uX2ludGVybmFsX3gsIGl0ZW0uX2ludGVybmFsX3ksIGl0ZW0uX2ludGVybmFsX3NpemUsIHgsIHkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNQcmljZU1hcmtlcihwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ2F0UHJpY2VUb3AnIHx8IHBvc2l0aW9uID09PSAnYXRQcmljZUJvdHRvbScgfHwgcG9zaXRpb24gPT09ICdhdFByaWNlTWlkZGxlJztcbn1cbmZ1bmN0aW9uIGdldFByaWNlKHNlcmllc0RhdGEsIG1hcmtlcikge1xuICAgIGlmIChpc1ByaWNlTWFya2VyKG1hcmtlci5wb3NpdGlvbikgJiYgbWFya2VyLnByaWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtlci5wcmljZTtcbiAgICB9XG4gICAgaWYgKGlzVmFsdWVEYXRhKHNlcmllc0RhdGEpKSB7XG4gICAgICAgIHJldHVybiBzZXJpZXNEYXRhLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNPaGxjRGF0YShzZXJpZXNEYXRhKSkge1xuICAgICAgICBpZiAobWFya2VyLnBvc2l0aW9uID09PSAnaW5CYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzRGF0YS5jbG9zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyLnBvc2l0aW9uID09PSAnYWJvdmVCYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzRGF0YS5oaWdoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXIucG9zaXRpb24gPT09ICdiZWxvd0JhcicpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNEYXRhLmxvdztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtcywgY29tcGxleGl0eVxuZnVuY3Rpb24gZmlsbFNpemVBbmRZKHJlbmRlcmVySXRlbSwgbWFya2VyLCBzZXJpZXNEYXRhLCBvZmZzZXRzLCB0ZXh0SGVpZ2h0LCBzaGFwZU1hcmdpbiwgc2VyaWVzLCBjaGFydCkge1xuICAgIGNvbnN0IHByaWNlID0gZ2V0UHJpY2Uoc2VyaWVzRGF0YSwgbWFya2VyKTtcbiAgICBpZiAocHJpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlnbm9yZU9mZnNldCA9IGlzUHJpY2VNYXJrZXIobWFya2VyLnBvc2l0aW9uKTtcbiAgICBjb25zdCB0aW1lU2NhbGUgPSBjaGFydC50aW1lU2NhbGUoKTtcbiAgICBjb25zdCBzaXplTXVsdGlwbGllciA9IGlzTnVtYmVyKG1hcmtlci5zaXplKSA/IE1hdGgubWF4KG1hcmtlci5zaXplLCAwKSA6IDE7XG4gICAgY29uc3Qgc2hhcGVTaXplID0gY2FsY3VsYXRlU2hhcGVIZWlnaHQodGltZVNjYWxlLm9wdGlvbnMoKS5iYXJTcGFjaW5nKSAqIHNpemVNdWx0aXBsaWVyO1xuICAgIGNvbnN0IGhhbGZTaXplID0gc2hhcGVTaXplIC8gMjtcbiAgICByZW5kZXJlckl0ZW0uX2ludGVybmFsX3NpemUgPSBzaGFwZVNpemU7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYXJrZXIucG9zaXRpb247XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlICdpbkJhcic6XG4gICAgICAgIGNhc2UgJ2F0UHJpY2VNaWRkbGUnOiB7XG4gICAgICAgICAgICByZW5kZXJlckl0ZW0uX2ludGVybmFsX3kgPSBlbnN1cmVOb3ROdWxsKHNlcmllcy5wcmljZVRvQ29vcmRpbmF0ZShwcmljZSkpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVySXRlbS5faW50ZXJuYWxfdGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJJdGVtLl9pbnRlcm5hbF90ZXh0Ll9pbnRlcm5hbF95ID0gcmVuZGVyZXJJdGVtLl9pbnRlcm5hbF95ICsgaGFsZlNpemUgKyBzaGFwZU1hcmdpbiArIHRleHRIZWlnaHQgKiAoMC41ICsgMC4xIC8qIENvbnN0YW50cy5UZXh0TWFyZ2luICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdhYm92ZUJhcic6XG4gICAgICAgIGNhc2UgJ2F0UHJpY2VUb3AnOiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpZ25vcmVPZmZzZXQgPyAwIDogb2Zmc2V0cy5faW50ZXJuYWxfYWJvdmVCYXI7XG4gICAgICAgICAgICByZW5kZXJlckl0ZW0uX2ludGVybmFsX3kgPSAoZW5zdXJlTm90TnVsbChzZXJpZXMucHJpY2VUb0Nvb3JkaW5hdGUocHJpY2UpKSAtIGhhbGZTaXplIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlckl0ZW0uX2ludGVybmFsX3RleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfeSA9IHJlbmRlcmVySXRlbS5faW50ZXJuYWxfeSAtIGhhbGZTaXplIC0gdGV4dEhlaWdodCAqICgwLjUgKyAwLjEgLyogQ29uc3RhbnRzLlRleHRNYXJnaW4gKi8pO1xuICAgICAgICAgICAgICAgIG9mZnNldHMuX2ludGVybmFsX2Fib3ZlQmFyICs9IHRleHRIZWlnaHQgKiAoMSArIDIgKiAwLjEgLyogQ29uc3RhbnRzLlRleHRNYXJnaW4gKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpZ25vcmVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRzLl9pbnRlcm5hbF9hYm92ZUJhciArPSBzaGFwZVNpemUgKyBzaGFwZU1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdiZWxvd0Jhcic6XG4gICAgICAgIGNhc2UgJ2F0UHJpY2VCb3R0b20nOiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpZ25vcmVPZmZzZXQgPyAwIDogb2Zmc2V0cy5faW50ZXJuYWxfYmVsb3dCYXI7XG4gICAgICAgICAgICByZW5kZXJlckl0ZW0uX2ludGVybmFsX3kgPSAoZW5zdXJlTm90TnVsbChzZXJpZXMucHJpY2VUb0Nvb3JkaW5hdGUocHJpY2UpKSArIGhhbGZTaXplICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlckl0ZW0uX2ludGVybmFsX3RleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfdGV4dC5faW50ZXJuYWxfeSA9IChyZW5kZXJlckl0ZW0uX2ludGVybmFsX3kgKyBoYWxmU2l6ZSArIHNoYXBlTWFyZ2luICsgdGV4dEhlaWdodCAqICgwLjUgKyAwLjEgLyogQ29uc3RhbnRzLlRleHRNYXJnaW4gKi8pKTtcbiAgICAgICAgICAgICAgICBvZmZzZXRzLl9pbnRlcm5hbF9iZWxvd0JhciArPSB0ZXh0SGVpZ2h0ICogKDEgKyAyICogMC4xIC8qIENvbnN0YW50cy5UZXh0TWFyZ2luICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaWdub3JlT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5faW50ZXJuYWxfYmVsb3dCYXIgKz0gc2hhcGVTaXplICsgc2hhcGVNYXJnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbHVlRGF0YShkYXRhKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgcmV0dXJuICd2YWx1ZScgaW4gZGF0YSAmJiB0eXBlb2YgZGF0YS52YWx1ZSA9PT0gJ251bWJlcic7XG59XG5mdW5jdGlvbiBpc09obGNEYXRhKGRhdGEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICByZXR1cm4gJ29wZW4nIGluIGRhdGEgJiYgJ2hpZ2gnIGluIGRhdGEgJiYgJ2xvdycgaW4gZGF0YSAmJiAnY2xvc2UnIGluIGRhdGE7XG59XG5jbGFzcyBTZXJpZXNNYXJrZXJzUGFuZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgY2hhcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2VycyA9IFtdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyID0gbmV3IFNlcmllc01hcmtlcnNSZW5kZXJlcigpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19zZXJpZXMgPSBzZXJpZXM7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0ID0gY2hhcnQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfaXRlbXM6IFtdLFxuICAgICAgICAgICAgX2ludGVybmFsX3Zpc2libGVSYW5nZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHJlbmRlcmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3Nlcmllcy5vcHRpb25zKCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2ludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9fbWFrZVZhbGlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQub3B0aW9ucygpWydsYXlvdXQnXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXIuX2ludGVybmFsX3NldFBhcmFtcyhsYXlvdXQuZm9udFNpemUsIGxheW91dC5mb250RmFtaWx5LCB0aGlzLl9wcml2YXRlX19vcHRpb25zLnpPcmRlcik7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlbmRlcmVyLl9pbnRlcm5hbF9zZXREYXRhKHRoaXMuX3ByaXZhdGVfX2RhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcmVuZGVyZXI7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRNYXJrZXJzKG1hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2VycyA9IG1hcmtlcnM7XG4gICAgICAgIHRoaXMuX2ludGVybmFsX3VwZGF0ZSgnZGF0YScpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKHVwZGF0ZVR5cGUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodXBkYXRlVHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhSW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnRlcm5hbF91cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgek9yZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy56T3JkZXIgPT09ICdhYm92ZVNlcmllcycgPyAndG9wJyA6IHRoaXMuX3ByaXZhdGVfX29wdGlvbnMuek9yZGVyO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfX21ha2VWYWxpZCgpIHtcbiAgICAgICAgY29uc3QgdGltZVNjYWxlID0gdGhpcy5fcHJpdmF0ZV9fY2hhcnQudGltZVNjYWxlKCk7XG4gICAgICAgIGNvbnN0IHNlcmllc01hcmtlcnMgPSB0aGlzLl9wcml2YXRlX19tYXJrZXJzO1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fZGF0YUludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pdGVtcyA9IHNlcmllc01hcmtlcnMubWFwKChtYXJrZXIpID0+ICh7XG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RpbWU6IG1hcmtlci50aW1lLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF94OiAwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF95OiAwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9zaXplOiAwLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9zaGFwZTogbWFya2VyLnNoYXBlLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9jb2xvcjogbWFya2VyLmNvbG9yLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9leHRlcm5hbElkOiBtYXJrZXIuaWQsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX2ludGVybmFsSWQ6IG1hcmtlci5faW50ZXJuYWxfaW50ZXJuYWxJZCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0T3B0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0Lm9wdGlvbnMoKVsnbGF5b3V0J107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHZpc2libGVCYXJzID0gdGltZVNjYWxlLmdldFZpc2libGVMb2dpY2FsUmFuZ2UoKTtcbiAgICAgICAgaWYgKHZpc2libGVCYXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZUJhcnNSYW5nZSA9IG5ldyBSYW5nZUltcGwoTWF0aC5mbG9vcih2aXNpYmxlQmFycy5mcm9tKSwgTWF0aC5jZWlsKHZpc2libGVCYXJzLnRvKSk7XG4gICAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuZGF0YSgpWzBdO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJldlRpbWVJbmRleCA9IE5hTjtcbiAgICAgICAgY29uc3Qgc2hhcGVNYXJnaW4kMSA9IHNoYXBlTWFyZ2luKHRpbWVTY2FsZS5vcHRpb25zKCkuYmFyU3BhY2luZyk7XG4gICAgICAgIGNvbnN0IG9mZnNldHMgPSB7XG4gICAgICAgICAgICBfaW50ZXJuYWxfYWJvdmVCYXI6IHNoYXBlTWFyZ2luJDEsXG4gICAgICAgICAgICBfaW50ZXJuYWxfYmVsb3dCYXI6IHNoYXBlTWFyZ2luJDEsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX3Zpc2libGVSYW5nZSA9IHZpc2libGVUaW1lZFZhbHVlcyh0aGlzLl9wcml2YXRlX19kYXRhLl9pbnRlcm5hbF9pdGVtcywgdmlzaWJsZUJhcnNSYW5nZSwgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLmZyb207IGluZGV4IDwgdGhpcy5fcHJpdmF0ZV9fZGF0YS5faW50ZXJuYWxfdmlzaWJsZVJhbmdlLnRvOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBzZXJpZXNNYXJrZXJzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIudGltZSAhPT0gcHJldlRpbWVJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIG5ldyBiYXIsIHJlc2V0IHN0YWNrIGNvdW50ZXJcbiAgICAgICAgICAgICAgICBvZmZzZXRzLl9pbnRlcm5hbF9hYm92ZUJhciA9IHNoYXBlTWFyZ2luJDE7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5faW50ZXJuYWxfYmVsb3dCYXIgPSBzaGFwZU1hcmdpbiQxO1xuICAgICAgICAgICAgICAgIHByZXZUaW1lSW5kZXggPSBtYXJrZXIudGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVySXRlbSA9IHRoaXMuX3ByaXZhdGVfX2RhdGEuX2ludGVybmFsX2l0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgIHJlbmRlcmVySXRlbS5faW50ZXJuYWxfeCA9IGVuc3VyZU5vdE51bGwodGltZVNjYWxlLmxvZ2ljYWxUb0Nvb3JkaW5hdGUobWFya2VyLnRpbWUpKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIudGV4dCAhPT0gdW5kZWZpbmVkICYmIG1hcmtlci50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlckl0ZW0uX2ludGVybmFsX3RleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9jb250ZW50OiBtYXJrZXIudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgX2ludGVybmFsX3g6IDAsXG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF95OiAwLFxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJuYWxfd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9oZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGFBdCA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5kYXRhQnlJbmRleChtYXJrZXIudGltZSwgMCAvKiBNaXNtYXRjaERpcmVjdGlvbi5Ob25lICovKTtcbiAgICAgICAgICAgIGlmIChkYXRhQXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGxTaXplQW5kWShyZW5kZXJlckl0ZW0sIG1hcmtlciwgZGF0YUF0LCBvZmZzZXRzLCBsYXlvdXRPcHRpb25zLmZvbnRTaXplLCBzaGFwZU1hcmdpbiQxLCB0aGlzLl9wcml2YXRlX19zZXJpZXMsIHRoaXMuX3ByaXZhdGVfX2NoYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zZXJpZXNNYXJrZXJPcHRpb25zRGVmYXVsdHMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbn1cbmNsYXNzIFNlcmllc01hcmtlcnNQcmltaXRpdmUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2luZGV4ZWRNYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGFDaGFuZ2VkSGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NlcmllcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2luc0ludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2lucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRCYXJTcGFjaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjYWxjdWxhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG1lcmdlT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgICB9XG4gICAgYXR0YWNoZWQocGFyYW0pIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjYWxjdWxhdGVNYXJrZXJzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2NoYXJ0ID0gcGFyYW0uY2hhcnQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NlcmllcyA9IHBhcmFtLnNlcmllcztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPSBuZXcgU2VyaWVzTWFya2Vyc1BhbmVWaWV3KHRoaXMuX3ByaXZhdGVfX3NlcmllcywgZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19jaGFydCksIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXF1ZXN0VXBkYXRlID0gcGFyYW0ucmVxdWVzdFVwZGF0ZTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLnN1YnNjcmliZURhdGFDaGFuZ2VkKChzY29wZSkgPT4gdGhpcy5fcHJpdmF0ZV9fb25EYXRhQ2hhbmdlZChzY29wZSkpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fcmVxdWVzdFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGFjaGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fc2VyaWVzICYmIHRoaXMuX3ByaXZhdGVfX2RhdGFDaGFuZ2VkSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLnVuc3Vic2NyaWJlRGF0YUNoYW5nZWQodGhpcy5fcHJpdmF0ZV9fZGF0YUNoYW5nZWRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NlcmllcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YUNoYW5nZWRIYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gICAgX2ludGVybmFsX3NldE1hcmtlcnMobWFya2Vycykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzID0gbWFya2VycztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVjYWxjdWxhdGVNYXJrZXJzKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2F1dG9TY2FsZU1hcmdpbnNJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tYXJrZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWFya2VycztcbiAgICB9XG4gICAgcGFuZVZpZXdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcgPyBbdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXddIDogW107XG4gICAgfVxuICAgIHVwZGF0ZUFsbFZpZXdzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX191cGRhdGVBbGxWaWV3cygpO1xuICAgIH1cbiAgICBoaXRUZXN0KHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcucmVuZGVyZXIoKT8uX2ludGVybmFsX2hpdFRlc3QoeCwgeSkgPz8gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXV0b3NjYWxlSW5mbyhzdGFydFRpbWVQb2ludCwgZW5kVGltZVBvaW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19wYW5lVmlldykge1xuICAgICAgICAgICAgY29uc3QgbWFyZ2lucyA9IHRoaXMuX3ByaXZhdGVfX2dldEF1dG9TY2FsZU1hcmdpbnMoKTtcbiAgICAgICAgICAgIGlmIChtYXJnaW5zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpY2VSYW5nZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luczogbWFyZ2lucyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IG1lcmdlT3B0aW9uc1dpdGhEZWZhdWx0cyh7IC4uLnRoaXMuX3ByaXZhdGVfX29wdGlvbnMsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldEF1dG9TY2FsZU1hcmdpbnMoKSB7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX19jaGFydCk7XG4gICAgICAgIGNvbnN0IGJhclNwYWNpbmcgPSBjaGFydC50aW1lU2NhbGUoKS5vcHRpb25zKCkuYmFyU3BhY2luZztcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX2F1dG9TY2FsZU1hcmdpbnNJbnZhbGlkYXRlZCB8fCBiYXJTcGFjaW5nICE9PSB0aGlzLl9wcml2YXRlX19jYWNoZWRCYXJTcGFjaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19jYWNoZWRCYXJTcGFjaW5nID0gYmFyU3BhY2luZztcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcml2YXRlX19tYXJrZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFwZU1hcmdpbiQxID0gc2hhcGVNYXJnaW4oYmFyU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFyZ2luVmFsdWUgPSBjYWxjdWxhdGVTaGFwZUhlaWdodChiYXJTcGFjaW5nKSAqIDEuNSArIHNoYXBlTWFyZ2luJDEgKiAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuX3ByaXZhdGVfX2dldE1hcmtlclBvc2l0aW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX2F1dG9TY2FsZU1hcmdpbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlOiBjYWxjdWxhdGVBZGp1c3RlZE1hcmdpbihtYXJnaW5WYWx1ZSwgcG9zaXRpb25zLmFib3ZlQmFyLCBwb3NpdGlvbnMuaW5CYXIpLFxuICAgICAgICAgICAgICAgICAgICBiZWxvdzogY2FsY3VsYXRlQWRqdXN0ZWRNYXJnaW4obWFyZ2luVmFsdWUsIHBvc2l0aW9ucy5iZWxvd0JhciwgcG9zaXRpb25zLmluQmFyKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2lucyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19hdXRvU2NhbGVNYXJnaW5zSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fYXV0b1NjYWxlTWFyZ2lucztcbiAgICB9XG4gICAgX3ByaXZhdGVfX2dldE1hcmtlclBvc2l0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX21hcmtlcnNQb3NpdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNQb3NpdGlvbnMgPSB0aGlzLl9wcml2YXRlX19tYXJrZXJzLnJlZHVjZSgoYWNjLCBtYXJrZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY1ttYXJrZXIucG9zaXRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1ttYXJrZXIucG9zaXRpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBpbkJhcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJvdmVCYXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJlbG93QmFyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdFByaWNlVG9wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdFByaWNlQm90dG9tOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdFByaWNlTWlkZGxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlX19tYXJrZXJzUG9zaXRpb25zO1xuICAgIH1cbiAgICBfcHJpdmF0ZV9fcmVjYWxjdWxhdGVNYXJrZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3JlY2FsY3VsYXRpb25SZXF1aXJlZCB8fCAhdGhpcy5fcHJpdmF0ZV9fY2hhcnQgfHwgIXRoaXMuX3ByaXZhdGVfX3Nlcmllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRoaXMuX3ByaXZhdGVfX2NoYXJ0LnRpbWVTY2FsZSgpO1xuICAgICAgICBjb25zdCBzZXJpZXNEYXRhID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzPy5kYXRhKCk7XG4gICAgICAgIGlmICh0aW1lU2NhbGUuZ2V0VmlzaWJsZUxvZ2ljYWxSYW5nZSgpID09IG51bGwgfHwgIXRoaXMuX3ByaXZhdGVfX3NlcmllcyB8fCBzZXJpZXNEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9faW5kZXhlZE1hcmtlcnMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdERhdGFJbmRleCA9IHRpbWVTY2FsZS50aW1lVG9JbmRleChlbnN1cmVOb3ROdWxsKHNlcmllc0RhdGFbMF0udGltZSksIHRydWUpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19pbmRleGVkTWFya2VycyA9IHRoaXMuX3ByaXZhdGVfX21hcmtlcnMubWFwKChtYXJrZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lUG9pbnRJbmRleCA9IHRpbWVTY2FsZS50aW1lVG9JbmRleChtYXJrZXIudGltZSwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hNb2RlID0gdGltZVBvaW50SW5kZXggPCBmaXJzdERhdGFJbmRleCA/IDEgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTmVhcmVzdFJpZ2h0ICovIDogLTEgLyogTWlzbWF0Y2hEaXJlY3Rpb24uTmVhcmVzdExlZnQgKi87XG4gICAgICAgICAgICBjb25zdCBzZXJpZXNEYXRhQnlJbmRleCA9IGVuc3VyZU5vdE51bGwodGhpcy5fcHJpdmF0ZV9fc2VyaWVzKS5kYXRhQnlJbmRleCh0aW1lUG9pbnRJbmRleCwgc2VhcmNoTW9kZSk7XG4gICAgICAgICAgICBjb25zdCBmaW5hbEluZGV4ID0gdGltZVNjYWxlLnRpbWVUb0luZGV4KGVuc3VyZU5vdE51bGwoc2VyaWVzRGF0YUJ5SW5kZXgpLnRpbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vIFlvdSBtdXN0IGV4cGxpY2l0bHkgZGVmaW5lIHRoZSB0eXBlcyBzbyB0aGF0IHRoZSBtaW5pZmljYXRpb24gYnVpbGQgcHJvY2Vzc2VzIHRoZSBmaWVsZCBuYW1lcyBjb3JyZWN0bHlcbiAgICAgICAgICAgIGNvbnN0IGJhc2VNYXJrZXIgPSB7XG4gICAgICAgICAgICAgICAgdGltZTogZmluYWxJbmRleCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogbWFya2VyLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHNoYXBlOiBtYXJrZXIuc2hhcGUsXG4gICAgICAgICAgICAgICAgY29sb3I6IG1hcmtlci5jb2xvcixcbiAgICAgICAgICAgICAgICBpZDogbWFya2VyLmlkLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9pbnRlcm5hbElkOiBpbmRleCxcbiAgICAgICAgICAgICAgICB0ZXh0OiBtYXJrZXIudGV4dCxcbiAgICAgICAgICAgICAgICBzaXplOiBtYXJrZXIuc2l6ZSxcbiAgICAgICAgICAgICAgICBwcmljZTogbWFya2VyLnByaWNlLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9vcmlnaW5hbFRpbWU6IG1hcmtlci50aW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIucG9zaXRpb24gPT09ICdhdFByaWNlVG9wJyB8fFxuICAgICAgICAgICAgICAgIG1hcmtlci5wb3NpdGlvbiA9PT0gJ2F0UHJpY2VCb3R0b20nIHx8XG4gICAgICAgICAgICAgICAgbWFya2VyLnBvc2l0aW9uID09PSAnYXRQcmljZU1pZGRsZScpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLnByaWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmljZSBpcyByZXF1aXJlZCBmb3IgcG9zaXRpb24gJHttYXJrZXIucG9zaXRpb259YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmJhc2VNYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBtYXJrZXIucG9zaXRpb24sIC8vIFR5cGVTY3JpcHQga25vd3MgdGhpcyBpcyBTZXJpZXNNYXJrZXJQcmljZVBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiBtYXJrZXIucHJpY2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmJhc2VNYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBtYXJrZXIucG9zaXRpb24sIC8vIFR5cGVTY3JpcHQga25vd3MgdGhpcyBpcyBTZXJpZXNNYXJrZXJCYXJQb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBwcmljZTogbWFya2VyLnByaWNlLCAvLyBPcHRpb25hbCBmb3IgYmFyIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgX3ByaXZhdGVfX3VwZGF0ZUFsbFZpZXdzKHVwZGF0ZVR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0ZU1hcmtlcnMoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3Ll9pbnRlcm5hbF9zZXRNYXJrZXJzKHRoaXMuX3ByaXZhdGVfX2luZGV4ZWRNYXJrZXJzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3Ll9pbnRlcm5hbF91cGRhdGVPcHRpb25zKHRoaXMuX3ByaXZhdGVfX29wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcGFuZVZpZXcuX2ludGVybmFsX3VwZGF0ZSh1cGRhdGVUeXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJpdmF0ZV9fb25EYXRhQ2hhbmdlZChzY29wZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZWNhbGN1bGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxufVxuXG5jbGFzcyBTZXJpZXNNYXJrZXJzUHJpbWl0aXZlV3JhcHBlciBleHRlbmRzIFNlcmllc1ByaW1pdGl2ZUFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgcHJpbWl0aXZlLCBtYXJrZXJzKSB7XG4gICAgICAgIHN1cGVyKHNlcmllcywgcHJpbWl0aXZlKTtcbiAgICAgICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TWFya2VycyhtYXJrZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRNYXJrZXJzKG1hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS5faW50ZXJuYWxfc2V0TWFya2VycyhtYXJrZXJzKTtcbiAgICB9XG4gICAgbWFya2VycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUuX2ludGVybmFsX21hcmtlcnMoKTtcbiAgICB9XG59XG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc2VyaWVzIG1hcmtlcnMgcHJpbWl0aXZlLlxuICpcbiAqIEBwYXJhbSBzZXJpZXMgLSBUaGUgc2VyaWVzIHRvIHdoaWNoIHRoZSBwcmltaXRpdmUgd2lsbCBiZSBhdHRhY2hlZC5cbiAqXG4gKiBAcGFyYW0gbWFya2VycyAtIEFuIGFycmF5IG9mIG1hcmtlcnMgdG8gYmUgZGlzcGxheWVkIG9uIHRoZSBzZXJpZXMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgc2VyaWVzIG1hcmtlcnMgcGx1Z2luLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgY3JlYXRlU2VyaWVzTWFya2VycyB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XG4gKlxuICpcdGNvbnN0IHNlcmllc01hcmtlcnMgPSBjcmVhdGVTZXJpZXNNYXJrZXJzKFxuICpcdFx0c2VyaWVzLFxuICpcdFx0W1xuICpcdFx0XHR7XG4gKlx0XHRcdFx0Y29sb3I6ICdncmVlbicsXG4gKlx0XHRcdFx0cG9zaXRpb246ICdpbkJhcicsXG4gKiBcdFx0XHRcdHNoYXBlOiAnYXJyb3dEb3duJyxcbiAqXHRcdFx0XHR0aW1lOiAxNTU2ODgwOTAwLFxuICpcdFx0XHR9LFxuICpcdFx0XVxuICpcdCk7XG4gKiAgLy8gYW5kIHRoZW4geW91IGNhbiBtb2RpZnkgdGhlIG1hcmtlcnNcbiAqICAvLyBzZXQgaXQgdG8gZW1wdHkgYXJyYXkgdG8gcmVtb3ZlIGFsbCBtYXJrZXJzXG4gKiAgc2VyaWVzTWFya2Vycy5zZXRNYXJrZXJzKFtdKTtcbiAqXG4gKiAgLy8gYHNlcmllc01hcmtlcnMubWFya2VycygpYCByZXR1cm5zIGN1cnJlbnQgbWFya2Vyc1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlcmllc01hcmtlcnMoc2VyaWVzLCBtYXJrZXJzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IG5ldyBTZXJpZXNNYXJrZXJzUHJpbWl0aXZlV3JhcHBlcihzZXJpZXMsIG5ldyBTZXJpZXNNYXJrZXJzUHJpbWl0aXZlKG9wdGlvbnMgPz8ge30pKTtcbiAgICBpZiAobWFya2Vycykge1xuICAgICAgICB3cmFwcGVyLnNldE1hcmtlcnMobWFya2Vycyk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVyO1xufVxuXG5jbGFzcyBFeHBpcmluZ01hcmtlck1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUNhbGxiYWNrID0gdXBkYXRlQ2FsbGJhY2s7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRNYXJrZXIobWFya2VyLCBrZXksIHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfY2xlYXJNYXJrZXIoa2V5KTtcbiAgICAgICAgaWYgKHRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fdHJpZ2dlclVwZGF0ZSgpO1xuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXJXaXRoVGltZW91dCA9IHtcbiAgICAgICAgICAgICAgICAuLi5tYXJrZXIsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RpbWVvdXRJZDogdGltZW91dElkLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9leHBpcmVzQXQ6IERhdGUubm93KCkgKyB0aW1lb3V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMuc2V0KGtleSwgbWFya2VyV2l0aFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG1hcmtlcnMgd2l0aG91dCB0aW1lb3V0LCB3ZSBzZXQgdGltZW91dElkIGFuZCBleHBpcmVzQXQgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzLnNldChrZXksIHtcbiAgICAgICAgICAgICAgICAuLi5tYXJrZXIsXG4gICAgICAgICAgICAgICAgX2ludGVybmFsX3RpbWVvdXRJZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIF9pbnRlcm5hbF9leHBpcmVzQXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RyaWdnZXJVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2NsZWFyTWFya2VyKGtleSkge1xuICAgICAgICBjb25zdCBtYXJrZXIgPSB0aGlzLl9wcml2YXRlX19tYXJrZXJzLmdldChrZXkpO1xuICAgICAgICBpZiAobWFya2VyICYmIG1hcmtlci5faW50ZXJuYWxfdGltZW91dElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQobWFya2VyLl9pbnRlcm5hbF90aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3RyaWdnZXJVcGRhdGUoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX2NsZWFyQWxsTWFya2VycygpIHtcbiAgICAgICAgZm9yIChjb25zdCBbcG9pbnRdIG9mIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsX2NsZWFyTWFya2VyKHBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW50ZXJuYWxfZ2V0TWFya2VycygpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgYWN0aXZlTWFya2VycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFt0aW1lLCBtYXJrZXJdIG9mIHRoaXMuX3ByaXZhdGVfX21hcmtlcnMpIHtcbiAgICAgICAgICAgIGlmICghbWFya2VyLl9pbnRlcm5hbF9leHBpcmVzQXQgfHwgbWFya2VyLl9pbnRlcm5hbF9leHBpcmVzQXQgPiBub3cpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVNYXJrZXJzLnB1c2goeyB0aW1lOiBtYXJrZXIudGltZSwgc2lnbjogbWFya2VyLnNpZ24sIHZhbHVlOiBtYXJrZXIudmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbF9jbGVhck1hcmtlcih0aW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlTWFya2VycztcbiAgICB9XG4gICAgX2ludGVybmFsX3NldFVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIF9wcml2YXRlX190cmlnZ2VyVXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZV9fdXBkYXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX3VwZGF0ZUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHVwRG93bk1hcmtlcnNQbHVnaW5PcHRpb25EZWZhdWx0cyA9IHtcbiAgICBwb3NpdGl2ZUNvbG9yOiAnIzIyQUI5NCcsXG4gICAgbmVnYXRpdmVDb2xvcjogJyNGNzUyNUYnLFxuICAgIHVwZGF0ZVZpc2liaWxpdHlEdXJhdGlvbjogNTAwMCxcbn07XG5cbmNsYXNzIE1hcmtlcnNQcmltaXRpdmVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgbmV1dHJhbENvbG9yLCBuZWdhdGl2ZUNvbG9yLCBwb3NpdGl2ZUNvbG9yKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19uZXV0cmFsQ29sb3IgPSBuZXV0cmFsQ29sb3I7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX25lZ2F0aXZlQ29sb3IgPSBuZWdhdGl2ZUNvbG9yO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wb3NpdGl2ZUNvbG9yID0gcG9zaXRpdmVDb2xvcjtcbiAgICB9XG4gICAgZHJhdyh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LnVzZUJpdG1hcENvb3JkaW5hdGVTcGFjZSgoc2NvcGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHNjb3BlLmNvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCB0aWNrV2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHNjb3BlLmhvcml6b250YWxQaXhlbFJhdGlvKSk7XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uID0gKHRpY2tXaWR0aCAlIDIpIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IHJhZCA9IDQgLyogQ29uc3RhbnRzLlJhZGl1cyAqLyAqIHNjb3BlLnZlcnRpY2FsUGl4ZWxSYXRpbyArIGNvcnJlY3Rpb247XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19kYXRhLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50cmVYID0gTWF0aC5yb3VuZChpdGVtLl9pbnRlcm5hbF94ICogc2NvcGUuaG9yaXpvbnRhbFBpeGVsUmF0aW8pICsgY29ycmVjdGlvbjtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl9wcml2YXRlX19nZXRDb2xvcihpdGVtLl9pbnRlcm5hbF9zaWduKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhjZW50cmVYLCBpdGVtLl9pbnRlcm5hbF95ICogc2NvcGUudmVydGljYWxQaXhlbFJhdGlvLCByYWQsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5faW50ZXJuYWxfc2lnbikge1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGguZmxvb3IoMiAvKiBDb25zdGFudHMuQXJyb3dMaW5lV2lkdGggKi8gKiBzY29wZS5ob3Jpem9udGFsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygoaXRlbS5faW50ZXJuYWxfeCAtIDQuNyAvKiBDb25zdGFudHMuQXJyb3dTaXplICovKSAqIHNjb3BlLmhvcml6b250YWxQaXhlbFJhdGlvICsgY29ycmVjdGlvbiwgKGl0ZW0uX2ludGVybmFsX3kgLSA3IC8qIENvbnN0YW50cy5BcnJvd09mZnNldCAqLyAqIGl0ZW0uX2ludGVybmFsX3NpZ24pICpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oaXRlbS5faW50ZXJuYWxfeCAqIHNjb3BlLmhvcml6b250YWxQaXhlbFJhdGlvICsgY29ycmVjdGlvbiwgKGl0ZW0uX2ludGVybmFsX3kgLVxuICAgICAgICAgICAgICAgICAgICAgICAgNyAvKiBDb25zdGFudHMuQXJyb3dPZmZzZXQgKi8gKiBpdGVtLl9pbnRlcm5hbF9zaWduIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIDcgLyogQ29uc3RhbnRzLkFycm93T2Zmc2V0ICovICogaXRlbS5faW50ZXJuYWxfc2lnbiAqIDAuNSAvKiBDb25zdGFudHMuVmVydGljYWxTY2FsZSAqLykgKlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUudmVydGljYWxQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbygoaXRlbS5faW50ZXJuYWxfeCArIDQuNyAvKiBDb25zdGFudHMuQXJyb3dTaXplICovKSAqIHNjb3BlLmhvcml6b250YWxQaXhlbFJhdGlvICsgY29ycmVjdGlvbiwgKGl0ZW0uX2ludGVybmFsX3kgLSA3IC8qIENvbnN0YW50cy5BcnJvd09mZnNldCAqLyAqIGl0ZW0uX2ludGVybmFsX3NpZ24pICpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcml2YXRlX19nZXRDb2xvcihzaWduKSB7XG4gICAgICAgIGlmIChzaWduID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbmV1dHJhbENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduID4gMCA/IHRoaXMuX3ByaXZhdGVfX3Bvc2l0aXZlQ29sb3IgOiB0aGlzLl9wcml2YXRlX19uZWdhdGl2ZUNvbG9yO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNBcmVhU3R5bGVPcHRpb25zKG9wdHMsIHNlcmllc1R5cGUpIHtcbiAgICByZXR1cm4gc2VyaWVzVHlwZSA9PT0gJ0FyZWEnO1xufVxuZnVuY3Rpb24gZ2V0TmV1dHJhbENvbG9yKG9wdHMsIHNlcmllc1R5cGUpIHtcbiAgICBpZiAoaXNBcmVhU3R5bGVPcHRpb25zKG9wdHMsIHNlcmllc1R5cGUpKSB7XG4gICAgICAgIHJldHVybiBvcHRzLmxpbmVDb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHMuY29sb3I7XG59XG5jbGFzcyBNYXJrZXJzUHJpbWl0aXZlUGFuZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgdGltZVNjYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9wcml2YXRlX190aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKG1hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fZGF0YSA9IG1hcmtlcnMubWFwKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMucHJpY2VUb0Nvb3JkaW5hdGUobWFya2VyLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB4ID0gZW5zdXJlTm90TnVsbCh0aGlzLl9wcml2YXRlX190aW1lU2NhbGUudGltZVRvQ29vcmRpbmF0ZShtYXJrZXIudGltZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeDogeCxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfeTogeSxcbiAgICAgICAgICAgICAgICBfaW50ZXJuYWxfc2lnbjogbWFya2VyLnNpZ24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihub3ROdWxsKTtcbiAgICB9XG4gICAgcmVuZGVyZXIoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMub3B0aW9ucygpO1xuICAgICAgICBjb25zdCBzZXJpZXNUeXBlID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLnNlcmllc1R5cGUoKTtcbiAgICAgICAgY29uc3QgbmV1dHJhbENvbG9yID0gZ2V0TmV1dHJhbENvbG9yKG9wdGlvbnMsIHNlcmllc1R5cGUpO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtlcnNQcmltaXRpdmVSZW5kZXJlcih0aGlzLl9wcml2YXRlX19kYXRhLCBuZXV0cmFsQ29sb3IsIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMubmVnYXRpdmVDb2xvciwgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucy5wb3NpdGl2ZUNvbG9yKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzTGluZURhdGEoaXRlbSwgdHlwZSkge1xuICAgIHJldHVybiB0eXBlID09PSAnTGluZScgfHwgdHlwZSA9PT0gJ0FyZWEnO1xufVxuY2xhc3MgVXBEb3duTWFya2Vyc1ByaW1pdGl2ZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19jaGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYW5hZ2VkRGF0YVBvaW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc01hbmFnZXIgPSBuZXcgRXhwaXJpbmdNYXJrZXJNYW5hZ2VyKCgpID0+IHRoaXMuX2ludGVybmFsX3JlcXVlc3RVcGRhdGUoKSk7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi51cERvd25NYXJrZXJzUGx1Z2luT3B0aW9uRGVmYXVsdHMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfaW50ZXJuYWxfYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuX3ByaXZhdGVfX29wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbnRlcm5hbF9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXRNYXJrZXJzKG1hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc01hbmFnZXIuX2ludGVybmFsX2NsZWFyQWxsTWFya2VycygpO1xuICAgICAgICBjb25zdCBob3J6QmVoYXZpb3VyID0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3I7XG4gICAgICAgIGlmICghaG9yekJlaGF2aW91cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtlcnMuZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzTWFuYWdlci5faW50ZXJuYWxfc2V0TWFya2VyKG1hcmtlciwgaG9yekJlaGF2aW91ci5rZXkobWFya2VyLnRpbWUpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9tYXJrZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZV9fbWFya2Vyc01hbmFnZXIuX2ludGVybmFsX2dldE1hcmtlcnMoKTtcbiAgICB9XG4gICAgX2ludGVybmFsX3JlcXVlc3RVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3JlcXVlc3RVcGRhdGU/LigpO1xuICAgIH1cbiAgICBhdHRhY2hlZChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyBjaGFydCwgc2VyaWVzLCByZXF1ZXN0VXBkYXRlLCBob3J6U2NhbGVCZWhhdmlvciwgfSA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQgPSBjaGFydDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fc2VyaWVzID0gc2VyaWVzO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvciA9IGhvcnpTY2FsZUJlaGF2aW9yO1xuICAgICAgICBjb25zdCBzZXJpZXNUeXBlID0gdGhpcy5fcHJpdmF0ZV9fc2VyaWVzLnNlcmllc1R5cGUoKTtcbiAgICAgICAgaWYgKHNlcmllc1R5cGUgIT09ICdBcmVhJyAmJiBzZXJpZXNUeXBlICE9PSAnTGluZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXBEb3duTWFya2Vyc1ByaW1pdGl2ZSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgQXJlYSBhbmQgTGluZSBzZXJpZXMgdHlwZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlld3MgPSBbXG4gICAgICAgICAgICBuZXcgTWFya2Vyc1ByaW1pdGl2ZVBhbmVWaWV3KHRoaXMuX3ByaXZhdGVfX3NlcmllcywgdGhpcy5fcHJpdmF0ZV9fY2hhcnQudGltZVNjYWxlKCksIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMpLFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19yZXF1ZXN0VXBkYXRlID0gcmVxdWVzdFVwZGF0ZTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxfcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBkZXRhY2hlZCgpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fY2hhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVfX3NlcmllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZV9fcmVxdWVzdFVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX2ludGVybmFsX2NoYXJ0KCkge1xuICAgICAgICByZXR1cm4gZW5zdXJlRGVmaW5lZCh0aGlzLl9wcml2YXRlX19jaGFydCk7XG4gICAgfVxuICAgIF9pbnRlcm5hbF9zZXJpZXMoKSB7XG4gICAgICAgIHJldHVybiBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX3Nlcmllcyk7XG4gICAgfVxuICAgIHVwZGF0ZUFsbFZpZXdzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19wYW5lVmlld3MuZm9yRWFjaCgocHcpID0+IHB3Ll9pbnRlcm5hbF91cGRhdGUodGhpcy5faW50ZXJuYWxfbWFya2VycygpKSk7XG4gICAgfVxuICAgIHBhbmVWaWV3cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVfX3BhbmVWaWV3cztcbiAgICB9XG4gICAgX2ludGVybmFsX3NldERhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGVfX3Nlcmllcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcmltaXRpdmUgbm90IGF0dGFjaGVkIHRvIHNlcmllcycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmllc1R5cGUgPSB0aGlzLl9wcml2YXRlX19zZXJpZXMuc2VyaWVzVHlwZSgpO1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYW5hZ2VkRGF0YVBvaW50cy5jbGVhcigpO1xuICAgICAgICBjb25zdCBob3J6QmVoYXZpb3VyID0gdGhpcy5fcHJpdmF0ZV9faG9yelNjYWxlQmVoYXZpb3I7XG4gICAgICAgIGlmIChob3J6QmVoYXZpb3VyKSB7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdWxmaWxsZWREYXRhKGQpICYmIGlzTGluZURhdGEoZCwgc2VyaWVzVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpdmF0ZV9fbWFuYWdlZERhdGFQb2ludHMuc2V0KGhvcnpCZWhhdmlvdXIua2V5KGQudGltZSksIGQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZURlZmluZWQodGhpcy5fcHJpdmF0ZV9fc2VyaWVzKS5zZXREYXRhKGRhdGEpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfdXBkYXRlKGRhdGEsIGhpc3RvcmljYWxVcGRhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlX19zZXJpZXMgfHwgIXRoaXMuX3ByaXZhdGVfX2hvcnpTY2FsZUJlaGF2aW9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaW1pdGl2ZSBub3QgYXR0YWNoZWQgdG8gc2VyaWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWVzVHlwZSA9IHRoaXMuX3ByaXZhdGVfX3Nlcmllcy5zZXJpZXNUeXBlKCk7XG4gICAgICAgIGNvbnN0IGhvcnpLZXkgPSB0aGlzLl9wcml2YXRlX19ob3J6U2NhbGVCZWhhdmlvci5rZXkoZGF0YS50aW1lKTtcbiAgICAgICAgaWYgKGlzV2hpdGVzcGFjZURhdGEoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hbmFnZWREYXRhUG9pbnRzLmRlbGV0ZShob3J6S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdWxmaWxsZWREYXRhKGRhdGEpICYmIGlzTGluZURhdGEoZGF0YSwgc2VyaWVzVHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUHJpY2UgPSB0aGlzLl9wcml2YXRlX19tYW5hZ2VkRGF0YVBvaW50cy5nZXQoaG9yektleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdQcmljZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVfX21hcmtlcnNNYW5hZ2VyLl9pbnRlcm5hbF9zZXRNYXJrZXIoe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBkYXRhLnRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzaWduOiBnZXRTaWduKGRhdGEudmFsdWUsIGV4aXN0aW5nUHJpY2UpLFxuICAgICAgICAgICAgICAgIH0sIGhvcnpLZXksIHRoaXMuX3ByaXZhdGVfX29wdGlvbnMudXBkYXRlVmlzaWJpbGl0eUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVEZWZpbmVkKHRoaXMuX3ByaXZhdGVfX3NlcmllcykudXBkYXRlKGRhdGEsIGhpc3RvcmljYWxVcGRhdGUpO1xuICAgIH1cbiAgICBfaW50ZXJuYWxfY2xlYXJNYXJrZXJzKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlX19tYXJrZXJzTWFuYWdlci5faW50ZXJuYWxfY2xlYXJBbGxNYXJrZXJzKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2lnbihuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWUgLSBvbGRWYWx1ZSA+IDAgPyAxIDogLTE7XG59XG5cbmNsYXNzIFNlcmllc1VwRG93bk1hcmtlclByaW1pdGl2ZVdyYXBwZXIgZXh0ZW5kcyBTZXJpZXNQcmltaXRpdmVBZGFwdGVyIHtcbiAgICBzZXREYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsX19wcmltaXRpdmUuX2ludGVybmFsX3NldERhdGEoZGF0YSk7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhLCBoaXN0b3JpY2FsVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlLl9pbnRlcm5hbF91cGRhdGUoZGF0YSwgaGlzdG9yaWNhbFVwZGF0ZSk7XG4gICAgfVxuICAgIG1hcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbF9fcHJpbWl0aXZlLl9pbnRlcm5hbF9tYXJrZXJzKCk7XG4gICAgfVxuICAgIHNldE1hcmtlcnMobWFya2Vycykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS5faW50ZXJuYWxfc2V0TWFya2VycyhtYXJrZXJzKTtcbiAgICB9XG4gICAgY2xlYXJNYXJrZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxfX3ByaW1pdGl2ZS5faW50ZXJuYWxfY2xlYXJNYXJrZXJzKCk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuZCBhdHRhY2hlcyB0aGUgU2VyaWVzIFVwIERvd24gTWFya2VycyBQbHVnaW4uXG4gKlxuICogQHBhcmFtIHNlcmllcyAtIFNlcmllcyB0byB3aGljaCBhdHRhY2ggdGhlIFVwIERvd24gTWFya2VycyBQbHVnaW5cbiAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIFVwIERvd24gTWFya2VycyBQbHVnaW5cbiAqXG4gKiBAcmV0dXJucyBBcGkgZm9yIFNlcmllcyBVcCBEb3duIE1hcmtlciBQbHVnaW4uIHtAbGluayBJU2VyaWVzVXBEb3duTWFya2VyUGx1Z2luQXBpfVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgY3JlYXRlVXBEb3duTWFya2VycywgY3JlYXRlQ2hhcnQsIExpbmVTZXJpZXMgfSBmcm9tICdsaWdodHdlaWdodC1jaGFydHMnO1xuICpcbiAqIGNvbnN0IGNoYXJ0ID0gY3JlYXRlQ2hhcnQoJ2NvbnRhaW5lcicpO1xuICogY29uc3QgbGluZVNlcmllcyA9IGNoYXJ0LmFkZFNlcmllcyhMaW5lU2VyaWVzKTtcbiAqIGNvbnN0IHVwRG93bk1hcmtlcnMgPSBjcmVhdGVVcERvd25NYXJrZXJzKGxpbmVTZXJpZXMsIHtcbiAqICAgICBwb3NpdGl2ZUNvbG9yOiAnIzIyQUI5NCcsXG4gKiAgICAgbmVnYXRpdmVDb2xvcjogJyNGNzUyNUYnLFxuICogICAgIHVwZGF0ZVZpc2liaWxpdHlEdXJhdGlvbjogNTAwMCxcbiAqIH0pO1xuICogLy8gdG8gYWRkIHNvbWUgZGF0YVxuICogdXBEb3duTWFya2Vycy5zZXREYXRhKFxuICogICAgIFtcbiAqICAgICAgICAgeyB0aW1lOiAnMjAyMC0wMi0wMicsIHZhbHVlOiAxMi4zNCB9LFxuICogICAgICAgICAvLy4uLiBtb3JlIGxpbmUgc2VyaWVzIGRhdGFcbiAqICAgICBdXG4gKiApO1xuICogLy8gLi4uIFVwZGF0ZSBzb21lIHZhbHVlc1xuICogdXBEb3duTWFya2Vycy51cGRhdGUoeyB0aW1lOiAnMjAyMC0wMi0wMicsIHZhbHVlOiAxMy41NCB9LCB0cnVlKTtcbiAqIC8vIHRvIHJlbW92ZSBwbHVnaW4gZnJvbSB0aGUgc2VyaWVzXG4gKiB1cERvd25NYXJrZXJzLmRldGFjaCgpO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVwRG93bk1hcmtlcnMoc2VyaWVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB3cmFwcGVyID0gbmV3IFNlcmllc1VwRG93bk1hcmtlclByaW1pdGl2ZVdyYXBwZXIoc2VyaWVzLCBuZXcgVXBEb3duTWFya2Vyc1ByaW1pdGl2ZShvcHRpb25zKSk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwiX2J1aWxkLXRpbWUtY29uc3RhbnRzXCIgLz5cbmNvbnN0IGN1c3RvbVNlcmllc0RlZmF1bHRPcHRpb25zID0ge1xuICAgIC4uLnNlcmllc09wdGlvbnNEZWZhdWx0cyxcbiAgICAuLi5jdXN0b21TdHlsZURlZmF1bHRzJDEsXG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZlcnNpb24gYXMgYSBzdHJpbmcuIEZvciBleGFtcGxlIGAnMy4zLjAnYC5cbiAqL1xuZnVuY3Rpb24gdmVyc2lvbigpIHtcbiAgICByZXR1cm4gXCI1LjAuN1wiO1xufVxuXG5leHBvcnQgeyBhcmVhU2VyaWVzIGFzIEFyZWFTZXJpZXMsIGJhclNlcmllcyBhcyBCYXJTZXJpZXMsIGJhc2VsaW5lU2VyaWVzIGFzIEJhc2VsaW5lU2VyaWVzLCBjYW5kbGVzdGlja1NlcmllcyBhcyBDYW5kbGVzdGlja1NlcmllcywgQ29sb3JUeXBlLCBDcm9zc2hhaXJNb2RlLCBoaXN0b2dyYW1TZXJpZXMgYXMgSGlzdG9ncmFtU2VyaWVzLCBMYXN0UHJpY2VBbmltYXRpb25Nb2RlLCBsaW5lU2VyaWVzIGFzIExpbmVTZXJpZXMsIExpbmVTdHlsZSwgTGluZVR5cGUsIE1pc21hdGNoRGlyZWN0aW9uLCBQcmljZUxpbmVTb3VyY2UsIFByaWNlU2NhbGVNb2RlLCBUaWNrTWFya1R5cGUsIFRyYWNraW5nTW9kZUV4aXRNb2RlLCBjcmVhdGVDaGFydCwgY3JlYXRlQ2hhcnRFeCwgY3JlYXRlSW1hZ2VXYXRlcm1hcmssIGNyZWF0ZU9wdGlvbnNDaGFydCwgY3JlYXRlU2VyaWVzTWFya2VycywgY3JlYXRlVGV4dFdhdGVybWFyaywgY3JlYXRlVXBEb3duTWFya2VycywgY3JlYXRlWWllbGRDdXJ2ZUNoYXJ0LCBjdXN0b21TZXJpZXNEZWZhdWx0T3B0aW9ucywgZGVmYXVsdEhvcnpTY2FsZUJlaGF2aW9yLCBpc0J1c2luZXNzRGF5LCBpc1VUQ1RpbWVzdGFtcCwgdmVyc2lvbiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/image.js":
/*!*********************************************!*\
  !*** ./node_modules/next/dist/api/image.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a)\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=image.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWOztBQUU3QyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGFwaVxcaW1hZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWwnO1xuZXhwb3J0ICogZnJvbSAnLi4vc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbCc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CDO_AN%5C%5Cbtc-dashboard%5C%5Csrc%5C%5Capp%5C%5Chome%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CDO_AN%5C%5Cbtc-dashboard%5C%5Csrc%5C%5Capp%5C%5Chome%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*********************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/home/page.tsx */ \"(app-pages-browser)/./src/app/home/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q0RPX0FOJTVDJTVDYnRjLWRhc2hib2FyZCU1QyU1Q3NyYyU1QyU1Q2FwcCU1QyU1Q2hvbWUlNUMlNUNwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLHdLQUF1RiIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcRE9fQU5cXFxcYnRjLWRhc2hib2FyZFxcXFxzcmNcXFxcYXBwXFxcXGhvbWVcXFxccGFnZS50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CDO_AN%5C%5Cbtc-dashboard%5C%5Csrc%5C%5Capp%5C%5Chome%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nconst _usemergedref = __webpack_require__(/*! ./use-merged-ref */ \"(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\");\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[{\"protocol\":\"https\",\"hostname\":\"upload.wikimedia.org\"}]};\nif (false) {}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img['data-loaded-src'] === src) {\n        return;\n    }\n    img['data-loaded-src'] = src;\n    const p = 'decode' in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== 'empty') {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event('load');\n            Object.defineProperty(event, 'target', {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;\n            if (img.getAttribute('data-nimg') === 'fill') {\n                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === '100vw') {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        'absolute',\n                        'fixed',\n                        'relative'\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(',') + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute('height');\n            const widthModified = img.width.toString() !== img.getAttribute('width');\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    if (Boolean(_react.use)) {\n        // In React 19.0.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;\n    const ownRef = (0, _react.useCallback)((img)=>{\n        if (!img) {\n            return;\n        }\n        if (onError) {\n            // If the image has an error before react hydrates, then the error is lost.\n            // The workaround is to wait until the image is mounted which is after hydration,\n            // then we set the src again to trigger the error handler (if there was an error).\n            // eslint-disable-next-line no-self-assign\n            img.src = img.src;\n        }\n        if (true) {\n            if (!src) {\n                console.error('Image is missing required \"src\" property:', img);\n            }\n            if (img.getAttribute('alt') === null) {\n                console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n            }\n        }\n        if (img.complete) {\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        }\n    }, [\n        src,\n        placeholder,\n        onLoadRef,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        onError,\n        unoptimized,\n        sizesInput\n    ]);\n    const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? 'fill' : '1',\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: ref,\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== 'empty') {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: 'image',\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        var _c_qualities;\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes,\n            qualities\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O3lDQTBXYUE7OztlQUFBQTs7Ozs7OzZFQS9WTjsrRUFDYzsyRUFDSjt5Q0FDVzt5Q0FZTzs2REFDQTtzQ0FDVjt3REFDSztrRkFHSjswQ0FDRztBQUU3Qiw0Q0FBNEM7QUFDNUMsTUFBTUMsWUFBWUMsZ1JBQTZCO0FBRS9DLElBQUksS0FBNkIsRUFBRSxFQUVsQztBQW1CRCwwRUFBMEU7QUFDMUUsaURBQWlEO0FBQ2pELFNBQVNNLGNBQ1BDLEdBQTJCLEVBQzNCQyxXQUE2QixFQUM3QkMsU0FBcUQsRUFDckRDLG9CQUEyRSxFQUMzRUMsZUFBcUMsRUFDckNDLFdBQW9CLEVBQ3BCQyxVQUE4QjtJQUU5QixNQUFNQyxNQUFNUCxPQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxJQUFLTyxHQUFHO0lBQ3BCLElBQUksQ0FBQ1AsT0FBT0EsR0FBRyxDQUFDLGtCQUFrQixLQUFLTyxLQUFLO1FBQzFDO0lBQ0Y7SUFDQVAsR0FBRyxDQUFDLGtCQUFrQixHQUFHTztJQUN6QixNQUFNQyxJQUFJLFlBQVlSLE1BQU1BLElBQUlTLE1BQU0sS0FBS0MsUUFBUUMsT0FBTztJQUMxREgsRUFBRUksS0FBSyxDQUFDLEtBQU8sR0FBR0MsSUFBSSxDQUFDO1FBQ3JCLElBQUksQ0FBQ2IsSUFBSWMsYUFBYSxJQUFJLENBQUNkLElBQUllLFdBQVcsRUFBRTtZQUMxQyx3Q0FBd0M7WUFDeEMsdUJBQXVCO1lBQ3ZCLHNDQUFzQztZQUN0QyxzQkFBc0I7WUFDdEIsdUJBQXVCO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJZCxnQkFBZ0IsU0FBUztZQUMzQkcsZ0JBQWdCO1FBQ2xCO1FBQ0EsSUFBSUYsYUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsVUFBV2MsT0FBTyxFQUFFO1lBQ3RCLCtDQUErQztZQUMvQywwQ0FBMEM7WUFDMUMsMkNBQTJDO1lBQzNDLE1BQU1DLFFBQVEsSUFBSUMsTUFBTTtZQUN4QkMsT0FBT0MsY0FBYyxDQUFDSCxPQUFPLFVBQVU7Z0JBQUVJLFVBQVU7Z0JBQU9DLE9BQU90QjtZQUFJO1lBQ3JFLElBQUl1QixZQUFZO1lBQ2hCLElBQUlDLFVBQVU7WUFDZHRCLFVBQVVjLE9BQU8sQ0FBQztnQkFDaEIsR0FBR0MsS0FBSztnQkFDUlEsYUFBYVI7Z0JBQ2JTLGVBQWUxQjtnQkFDZjJCLFFBQVEzQjtnQkFDUjRCLG9CQUFvQixJQUFNTDtnQkFDMUJNLHNCQUFzQixJQUFNTDtnQkFDNUJNLFNBQVMsS0FBTztnQkFDaEJDLGdCQUFnQjtvQkFDZFIsWUFBWTtvQkFDWk4sTUFBTWMsY0FBYztnQkFDdEI7Z0JBQ0FDLGlCQUFpQjtvQkFDZlIsVUFBVTtvQkFDVlAsTUFBTWUsZUFBZTtnQkFDdkI7WUFDRjtRQUNGO1FBQ0EsSUFBSTdCLHdCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxxQkFBc0JhLE9BQU8sRUFBRTtZQUNqQ2IscUJBQXFCYSxPQUFPLENBQUNoQjtRQUMvQjtRQUNBLElBQUlQLElBQW9CLEVBQW1CO1lBQ3pDLE1BQU15QyxVQUFVLElBQUlDLElBQUk1QixLQUFLLFlBQVk2QixZQUFZLENBQUNDLEdBQUcsQ0FBQyxVQUFVOUI7WUFDcEUsSUFBSVAsSUFBSXNDLFlBQVksQ0FBQyxpQkFBaUIsUUFBUTtnQkFDNUMsSUFBSSxDQUFDakMsZUFBZ0IsRUFBQ0MsY0FBY0EsZUFBZSxRQUFNLEVBQUk7b0JBQzNELElBQUlpQyxxQkFDRnZDLElBQUl3QyxxQkFBcUIsR0FBR0MsS0FBSyxHQUFHN0MsT0FBTzhDLFVBQVU7b0JBQ3ZELElBQUlILHFCQUFxQixLQUFLO3dCQUM1QixJQUFJakMsZUFBZSxTQUFTOzRCQUMxQnFDLENBQUFBLEdBQUFBLFVBQUFBLFFBQVEsRUFDTCxxQkFBa0JULFVBQVE7d0JBRS9CLE9BQU87NEJBQ0xTLENBQUFBLEdBQUFBLFVBQUFBLFFBQUFBLEVBQ0cscUJBQWtCVCxVQUFRO3dCQUUvQjtvQkFDRjtnQkFDRjtnQkFDQSxJQUFJbEMsSUFBSWMsYUFBYSxFQUFFO29CQUNyQixNQUFNLEVBQUU4QixRQUFRLEVBQUUsR0FBR2hELE9BQU9pRCxnQkFBZ0IsQ0FBQzdDLElBQUljLGFBQWE7b0JBQzlELE1BQU1nQyxRQUFRO3dCQUFDO3dCQUFZO3dCQUFTO3FCQUFXO29CQUMvQyxJQUFJLENBQUNBLE1BQU1DLFFBQVEsQ0FBQ0gsV0FBVzt3QkFDN0JELENBQUFBLEdBQUFBLFVBQUFBLFFBQUFBLEVBQ0cscUJBQWtCVCxVQUFRLHdFQUFxRVUsV0FBUyx3QkFBcUJFLE1BQzNIRSxHQUFHLENBQUNDLFFBQ0pDLElBQUksQ0FBQyxPQUFLO29CQUVqQjtnQkFDRjtnQkFDQSxJQUFJbEQsSUFBSW1ELE1BQU0sS0FBSyxHQUFHO29CQUNwQlIsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFDRyxxQkFBa0JULFVBQVE7Z0JBRS9CO1lBQ0Y7WUFFQSxNQUFNa0IsaUJBQ0pwRCxJQUFJbUQsTUFBTSxDQUFDRSxRQUFRLE9BQU9yRCxJQUFJc0MsWUFBWSxDQUFDO1lBQzdDLE1BQU1nQixnQkFBZ0J0RCxJQUFJeUMsS0FBSyxDQUFDWSxRQUFRLE9BQU9yRCxJQUFJc0MsWUFBWSxDQUFDO1lBQ2hFLElBQ0djLGtCQUFrQixDQUFDRSxpQkFDbkIsQ0FBQ0Ysa0JBQWtCRSxlQUNwQjtnQkFDQVgsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFDRyxxQkFBa0JULFVBQVE7WUFFL0I7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTcUIsZ0JBQ1BDLGFBQXNCO0lBRXRCLElBQUlDLFFBQVFDLE9BQUFBLEdBQUcsR0FBRztRQUNoQixrREFBa0Q7UUFDbEQsaURBQWlEO1FBQ2pELG1EQUFtRDtRQUNuRCxPQUFPO1lBQUVGO1FBQWM7SUFDekI7SUFDQSx1REFBdUQ7SUFDdkQsNENBQTRDO0lBQzVDLE9BQU87UUFBRUcsZUFBZUg7SUFBYztBQUN4QztBQUVBLE1BQU1JLGVBQUFBLFdBQUFBLEdBQWVDLENBQUFBLEdBQUFBLE9BQUFBLFVBQUFBLEVBQ25CLFFBd0JFQztRQXZCQSxFQUNFdkQsR0FBRyxFQUNId0QsTUFBTSxFQUNOQyxLQUFLLEVBQ0xiLE1BQU0sRUFDTlYsS0FBSyxFQUNMd0IsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLEtBQUssRUFDTFgsYUFBYSxFQUNidkQsV0FBVyxFQUNYbUUsT0FBTyxFQUNQL0QsV0FBVyxFQUNYZ0UsSUFBSSxFQUNKbkUsU0FBUyxFQUNUQyxvQkFBb0IsRUFDcEJDLGVBQWUsRUFDZmtFLGNBQWMsRUFDZGhFLFVBQVUsRUFDVmlFLE1BQU0sRUFDTkMsT0FBTyxFQUNQLEdBQUdDLE1BQ0o7SUFHRCxNQUFNQyxTQUFTQyxDQUFBQSxHQUFBQSxPQUFBQSxXQUFBQSxFQUNiLENBQUMzRTtRQUNDLElBQUksQ0FBQ0EsS0FBSztZQUNSO1FBQ0Y7UUFDQSxJQUFJd0UsU0FBUztZQUNYLDJFQUEyRTtZQUMzRSxpRkFBaUY7WUFDakYsa0ZBQWtGO1lBQ2xGLDBDQUEwQztZQUMxQ3hFLElBQUlPLEdBQUcsR0FBR1AsSUFBSU8sR0FBRztRQUNuQjtRQUNBLElBQUlkLElBQW9CLEVBQW1CO1lBQ3pDLElBQUksQ0FBQ2MsS0FBSztnQkFDUnFFLFFBQVFDLEtBQUssQ0FBRSw2Q0FBNEM3RTtZQUM3RDtZQUNBLElBQUlBLElBQUlzQyxZQUFZLENBQUMsV0FBVyxNQUFNO2dCQUNwQ3NDLFFBQVFDLEtBQUssQ0FDVjtZQUVMO1FBQ0Y7UUFDQSxJQUFJN0UsSUFBSThFLFFBQVEsRUFBRTtZQUNoQi9FLGNBQ0VDLEtBQ0FDLGFBQ0FDLFdBQ0FDLHNCQUNBQyxpQkFDQUMsYUFDQUM7UUFFSjtJQUNGLEdBQ0E7UUFDRUM7UUFDQU47UUFDQUM7UUFDQUM7UUFDQUM7UUFDQW9FO1FBQ0FuRTtRQUNBQztLQUNEO0lBR0gsTUFBTXlFLE1BQU1DLENBQUFBLEdBQUFBLGNBQUFBLFlBQUFBLEVBQWFsQixjQUFjWTtJQUV2QyxxQkFDRSxxQkFBQzFFLE9BQUFBO1FBQ0UsR0FBR3lFLElBQUk7UUFDUCxHQUFHbEIsZ0JBQWdCQyxjQUFjO1FBQ2xDLHFFQUFxRTtRQUNyRSx3RUFBd0U7UUFDeEUscURBQXFEO1FBQ3JEWSxTQUFTQTtRQUNUM0IsT0FBT0E7UUFDUFUsUUFBUUE7UUFDUmMsVUFBVUE7UUFDVmdCLGFBQVdaLE9BQU8sU0FBUztRQUMzQkgsV0FBV0E7UUFDWEMsT0FBT0E7UUFDUCx1RUFBdUU7UUFDdkUsbUVBQW1FO1FBQ25FLHlFQUF5RTtRQUN6RSwwRUFBMEU7UUFDMUUsMkJBQTJCO1FBQzNCLHNEQUFzRDtRQUN0REgsT0FBT0E7UUFDUEQsUUFBUUE7UUFDUnhELEtBQUtBO1FBQ0x3RSxLQUFLQTtRQUNMUixRQUFRLENBQUN0RDtZQUNQLE1BQU1qQixNQUFNaUIsTUFBTVMsYUFBYTtZQUMvQjNCLGNBQ0VDLEtBQ0FDLGFBQ0FDLFdBQ0FDLHNCQUNBQyxpQkFDQUMsYUFDQUM7UUFFSjtRQUNBa0UsU0FBUyxDQUFDdkQ7WUFDUixxRUFBcUU7WUFDckVxRCxlQUFlO1lBQ2YsSUFBSXJFLGdCQUFnQixTQUFTO2dCQUMzQiwyRUFBMkU7Z0JBQzNFRyxnQkFBZ0I7WUFDbEI7WUFDQSxJQUFJb0UsU0FBUztnQkFDWEEsUUFBUXZEO1lBQ1Y7UUFDRjs7QUFHTjtBQUdGLHNCQUFzQixLQU1yQjtJQU5xQixNQUNwQmtFLFdBQVcsRUFDWEMsYUFBYSxFQUlkLEdBTnFCO0lBT3BCLE1BQU1DLE9BQU87UUFDWEMsSUFBSTtRQUNKQyxhQUFhSCxjQUFjckIsTUFBTTtRQUNqQ3lCLFlBQVlKLGNBQWNwQixLQUFLO1FBQy9CeUIsYUFBYUwsY0FBY0ssV0FBVztRQUN0Q0MsZ0JBQWdCTixjQUFjTSxjQUFjO1FBQzVDLEdBQUduQyxnQkFBZ0I2QixjQUFjNUIsYUFBYSxDQUFDO0lBQ2pEO0lBRUEsSUFBSTJCLGVBQWVRLFVBQUFBLE9BQVEsQ0FBQ0MsT0FBTyxFQUFFO1FBQ25DLG1EQUFtRDtRQUNuREQsVUFBQUEsT0FBUSxDQUFDQyxPQUFPLENBQ2RSLGNBQWM3RSxHQUFHLEVBQ2pCO1FBR0YsT0FBTztJQUNUO0lBRUEscUJBQ0UscUJBQUNzRixNQUFBQSxPQUFJO2tCQUNILG1DQUFDQyxRQUFBQTtZQU9DQyxLQUFJO1lBQ0osc0VBQXNFO1lBQ3RFLHFFQUFxRTtZQUNyRSxzREFBc0Q7WUFDdEQsRUFBRTtZQUNGLDhFQUE4RTtZQUM5RUMsTUFBTVosY0FBY3JCLE1BQU0sR0FBR2tDLFlBQVliLGNBQWM3RSxHQUFHO1lBQ3pELEdBQUc4RSxJQUFJO1dBWk4sWUFDQUQsY0FBYzdFLEdBQUcsR0FDakI2RSxjQUFjckIsTUFBTSxHQUNwQnFCLGNBQWNwQixLQUFLOztBQWE3QjtLQTlDU2tCO0FBcURGLE1BQU0zRixRQUFRc0UsV0FBUnRFLEdBQVFzRSxDQUFBQSxHQUFBQSxPQUFBQSxVQUFBQSxFQUNuQixDQUFDcUMsT0FBT3BDO0lBQ04sTUFBTXFDLGNBQWNDLENBQUFBLEdBQUFBLE9BQUFBLFVBQUFBLEVBQVdDLDRCQUFBQSxhQUFhO0lBQzVDLDBEQUEwRDtJQUMxRCxNQUFNbEIsY0FBYyxDQUFDZ0I7SUFFckIsTUFBTUcsZ0JBQWdCRixDQUFBQSxHQUFBQSxPQUFBQSxVQUFBQSxFQUFXRyxpQ0FBQUEsa0JBQWtCO0lBQ25ELE1BQU1DLFNBQVNDLENBQUFBLEdBQUFBLE9BQUFBLE9BQUFBLEVBQVE7WUFJSEM7UUFIbEIsTUFBTUEsSUFBSWxILGFBQWE4RyxpQkFBaUJLLGFBQUFBLGtCQUFrQjtRQUMxRCxNQUFNQyxXQUFXO2VBQUlGLEVBQUVHLFdBQVc7ZUFBS0gsRUFBRWxCLFVBQVU7U0FBQyxDQUFDc0IsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDO1FBQ3hFLE1BQU1ILGNBQWNILEVBQUVHLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDO1FBQ3JELE1BQU1DLFlBQUFBLENBQVlQLGVBQUFBLEVBQUVPLFNBQUFBLEtBQVMsZ0JBQVhQLGFBQWFJLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQztRQUNsRCxPQUFPO1lBQUUsR0FBR04sQ0FBQztZQUFFRTtZQUFVQztZQUFhSTtRQUFVO0lBQ2xELEdBQUc7UUFBQ1g7S0FBYztJQUVsQixNQUFNLEVBQUUvQixNQUFNLEVBQUUyQyxpQkFBaUIsRUFBRSxHQUFHaEI7SUFDdEMsTUFBTWhHLFlBQVlpSCxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUFPNUM7SUFFekI2QyxDQUFBQSxHQUFBQSxPQUFBQSxTQUFBQSxFQUFVO1FBQ1JsSCxVQUFVYyxPQUFPLEdBQUd1RDtJQUN0QixHQUFHO1FBQUNBO0tBQU87SUFFWCxNQUFNcEUsdUJBQXVCZ0gsQ0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsRUFBT0Q7SUFFcENFLENBQUFBLEdBQUFBLE9BQUFBLFNBQUFBLEVBQVU7UUFDUmpILHFCQUFxQmEsT0FBTyxHQUFHa0c7SUFDakMsR0FBRztRQUFDQTtLQUFrQjtJQUV0QixNQUFNLENBQUNHLGNBQWNqSCxnQkFBZ0IsR0FBR2tILENBQUFBLEdBQUFBLE9BQUFBLFFBQUFBLEVBQVM7SUFDakQsTUFBTSxDQUFDQyxhQUFhakQsZUFBZSxHQUFHZ0QsQ0FBQUEsR0FBQUEsT0FBQUEsUUFBQUEsRUFBUztJQUUvQyxNQUFNLEVBQUVwQixPQUFPZCxhQUFhLEVBQUVvQyxNQUFNQyxPQUFPLEVBQUUsR0FBR0MsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFBWXhCLE9BQU87UUFDakV5QixlQUFBQSxhQUFBQSxPQUFhO1FBQ2JDLFNBQVNwQjtRQUNUYTtRQUNBRTtJQUNGO0lBRUEscUJBQ0U7OzBCQUVJLHFCQUFDM0QsY0FBQUE7Z0JBQ0UsR0FBR3dCLGFBQWE7Z0JBQ2pCL0UsYUFBYW9ILFFBQVFwSCxXQUFXO2dCQUNoQ0osYUFBYXdILFFBQVF4SCxXQUFXO2dCQUNoQ29FLE1BQU1vRCxRQUFRcEQsSUFBSTtnQkFDbEJuRSxXQUFXQTtnQkFDWEMsc0JBQXNCQTtnQkFDdEJDLGlCQUFpQkE7Z0JBQ2pCa0UsZ0JBQWdCQTtnQkFDaEJoRSxZQUFZNEYsTUFBTWxDLEtBQUs7Z0JBQ3ZCZSxLQUFLakI7O1lBR1IyRCxRQUFRSSxRQUFRLGlCQUNmLHFCQUFDM0MsY0FBQUE7Z0JBQ0NDLGFBQWFBO2dCQUNiQyxlQUFlQTtpQkFFZjs7O0FBR1YiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcaW1hZ2UtY29tcG9uZW50LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7XG4gIHVzZVJlZixcbiAgdXNlRWZmZWN0LFxuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlTWVtbyxcbiAgdXNlU3RhdGUsXG4gIGZvcndhcmRSZWYsXG4gIHVzZSxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IEhlYWQgZnJvbSAnLi4vc2hhcmVkL2xpYi9oZWFkJ1xuaW1wb3J0IHsgZ2V0SW1nUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvbGliL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlUHJvcHMsXG4gIEltZ1Byb3BzLFxuICBPbkxvYWQsXG4gIE9uTG9hZGluZ0NvbXBsZXRlLFxuICBQbGFjZWhvbGRlclZhbHVlLFxufSBmcm9tICcuLi9zaGFyZWQvbGliL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlQ29uZmlnQ29tcGxldGUsXG4gIEltYWdlTG9hZGVyUHJvcHMsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgaW1hZ2VDb25maWdEZWZhdWx0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBJbWFnZUNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZSdcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG4vLyBAdHMtaWdub3JlIC0gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGFsaWFzXG5pbXBvcnQgZGVmYXVsdExvYWRlciBmcm9tICduZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXInXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWYgfSBmcm9tICcuL3VzZS1tZXJnZWQtcmVmJ1xuXG4vLyBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgZGVmaW5lIHBsdWdpblxuY29uc3QgY29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFMgYXMgYW55IGFzIEltYWdlQ29uZmlnQ29tcGxldGVcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIDsoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWVcbn1cblxuZXhwb3J0IHR5cGUgeyBJbWFnZUxvYWRlclByb3BzIH1cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyID0gKHA6IEltYWdlTG9hZGVyUHJvcHMpID0+IHN0cmluZ1xuXG50eXBlIEltZ0VsZW1lbnRXaXRoRGF0YVByb3AgPSBIVE1MSW1hZ2VFbGVtZW50ICYge1xuICAnZGF0YS1sb2FkZWQtc3JjJzogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbnR5cGUgSW1hZ2VFbGVtZW50UHJvcHMgPSBJbWdQcm9wcyAmIHtcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbiAgcGxhY2Vob2xkZXI6IFBsYWNlaG9sZGVyVmFsdWVcbiAgb25Mb2FkUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZCB8IHVuZGVmaW5lZD5cbiAgb25Mb2FkaW5nQ29tcGxldGVSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8T25Mb2FkaW5nQ29tcGxldGUgfCB1bmRlZmluZWQ+XG4gIHNldEJsdXJDb21wbGV0ZTogKGI6IGJvb2xlYW4pID0+IHZvaWRcbiAgc2V0U2hvd0FsdFRleHQ6IChiOiBib29sZWFuKSA9PiB2b2lkXG4gIHNpemVzSW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5Nzc3ODMzLzI2NjUzNSBmb3Igd2h5IHdlIHVzZSB0aGlzIHJlZlxuLy8gaGFuZGxlciBpbnN0ZWFkIG9mIHRoZSBpbWcncyBvbkxvYWQgYXR0cmlidXRlLlxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZyhcbiAgaW1nOiBJbWdFbGVtZW50V2l0aERhdGFQcm9wLFxuICBwbGFjZWhvbGRlcjogUGxhY2Vob2xkZXJWYWx1ZSxcbiAgb25Mb2FkUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZCB8IHVuZGVmaW5lZD4sXG4gIG9uTG9hZGluZ0NvbXBsZXRlUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZGluZ0NvbXBsZXRlIHwgdW5kZWZpbmVkPixcbiAgc2V0Qmx1ckNvbXBsZXRlOiAoYjogYm9vbGVhbikgPT4gdm9pZCxcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW4sXG4gIHNpemVzSW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuKSB7XG4gIGNvbnN0IHNyYyA9IGltZz8uc3JjXG4gIGlmICghaW1nIHx8IGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPT09IHNyYykge1xuICAgIHJldHVyblxuICB9XG4gIGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPSBzcmNcbiAgY29uc3QgcCA9ICdkZWNvZGUnIGluIGltZyA/IGltZy5kZWNvZGUoKSA6IFByb21pc2UucmVzb2x2ZSgpXG4gIHAuY2F0Y2goKCkgPT4ge30pLnRoZW4oKCkgPT4ge1xuICAgIGlmICghaW1nLnBhcmVudEVsZW1lbnQgfHwgIWltZy5pc0Nvbm5lY3RlZCkge1xuICAgICAgLy8gRXhpdCBlYXJseSBpbiBjYXNlIG9mIHJhY2UgY29uZGl0aW9uOlxuICAgICAgLy8gLSBvbmxvYWQoKSBpcyBjYWxsZWRcbiAgICAgIC8vIC0gZGVjb2RlKCkgaXMgY2FsbGVkIGJ1dCBpbmNvbXBsZXRlXG4gICAgICAvLyAtIHVubW91bnQgaXMgY2FsbGVkXG4gICAgICAvLyAtIGRlY29kZSgpIGNvbXBsZXRlc1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChwbGFjZWhvbGRlciAhPT0gJ2VtcHR5Jykge1xuICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpXG4gICAgfVxuICAgIGlmIChvbkxvYWRSZWY/LmN1cnJlbnQpIHtcbiAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGhhdmUgdGhlIFN5bnRoZXRpY0V2ZW50IGhlcmUsXG4gICAgICAvLyB3ZSBtdXN0IGNyZWF0ZSBvbmUgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAgICAgIC8vIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXZlbnRzLmh0bWxcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdsb2FkJylcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgJ3RhcmdldCcsIHsgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogaW1nIH0pXG4gICAgICBsZXQgcHJldmVudGVkID0gZmFsc2VcbiAgICAgIGxldCBzdG9wcGVkID0gZmFsc2VcbiAgICAgIG9uTG9hZFJlZi5jdXJyZW50KHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgY3VycmVudFRhcmdldDogaW1nLFxuICAgICAgICB0YXJnZXQ6IGltZyxcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiAoKSA9PiBwcmV2ZW50ZWQsXG4gICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiAoKSA9PiBzdG9wcGVkLFxuICAgICAgICBwZXJzaXN0OiAoKSA9PiB7fSxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9LFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpID0+IHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZVxuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAob25Mb2FkaW5nQ29tcGxldGVSZWY/LmN1cnJlbnQpIHtcbiAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQoaW1nKVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3Qgb3JpZ1NyYyA9IG5ldyBVUkwoc3JjLCAnaHR0cDovL24nKS5zZWFyY2hQYXJhbXMuZ2V0KCd1cmwnKSB8fCBzcmNcbiAgICAgIGlmIChpbWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5pbWcnKSA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgKCFzaXplc0lucHV0IHx8IHNpemVzSW5wdXQgPT09ICcxMDB2dycpKSB7XG4gICAgICAgICAgbGV0IHdpZHRoVmlld3BvcnRSYXRpbyA9XG4gICAgICAgICAgICBpbWcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICAgIGlmICh3aWR0aFZpZXdwb3J0UmF0aW8gPCAwLjYpIHtcbiAgICAgICAgICAgIGlmIChzaXplc0lucHV0ID09PSAnMTAwdncnKSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgcHJvcCBhbmQgXCJzaXplc1wiIHByb3Agb2YgXCIxMDB2d1wiLCBidXQgaW1hZ2UgaXMgbm90IHJlbmRlcmVkIGF0IGZ1bGwgdmlld3BvcnQgd2lkdGguIFBsZWFzZSBhZGp1c3QgXCJzaXplc1wiIHRvIGltcHJvdmUgcGFnZSBwZXJmb3JtYW5jZS4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2Ujc2l6ZXNgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgYnV0IGlzIG1pc3NpbmcgXCJzaXplc1wiIHByb3AuIFBsZWFzZSBhZGQgaXQgdG8gaW1wcm92ZSBwYWdlIHBlcmZvcm1hbmNlLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNzaXplc2BcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1nLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudClcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnLCAncmVsYXRpdmUnXVxuICAgICAgICAgIGlmICghdmFsaWQuaW5jbHVkZXMocG9zaXRpb24pKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtvcmlnU3JjfVwiIGhhcyBcImZpbGxcIiBhbmQgcGFyZW50IGVsZW1lbnQgd2l0aCBpbnZhbGlkIFwicG9zaXRpb25cIi4gUHJvdmlkZWQgXCIke3Bvc2l0aW9ufVwiIHNob3VsZCBiZSBvbmUgb2YgJHt2YWxpZFxuICAgICAgICAgICAgICAgIC5tYXAoU3RyaW5nKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsJyl9LmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltZy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgYW5kIGEgaGVpZ2h0IHZhbHVlIG9mIDAuIFRoaXMgaXMgbGlrZWx5IGJlY2F1c2UgdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSBpbWFnZSBoYXMgbm90IGJlZW4gc3R5bGVkIHRvIGhhdmUgYSBzZXQgaGVpZ2h0LmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVpZ2h0TW9kaWZpZWQgPVxuICAgICAgICBpbWcuaGVpZ2h0LnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpXG4gICAgICBjb25zdCB3aWR0aE1vZGlmaWVkID0gaW1nLndpZHRoLnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJylcbiAgICAgIGlmIChcbiAgICAgICAgKGhlaWdodE1vZGlmaWVkICYmICF3aWR0aE1vZGlmaWVkKSB8fFxuICAgICAgICAoIWhlaWdodE1vZGlmaWVkICYmIHdpZHRoTW9kaWZpZWQpXG4gICAgICApIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtvcmlnU3JjfVwiIGhhcyBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG1vZGlmaWVkLCBidXQgbm90IHRoZSBvdGhlci4gSWYgeW91IHVzZSBDU1MgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHlvdXIgaW1hZ2UsIGFsc28gaW5jbHVkZSB0aGUgc3R5bGVzICd3aWR0aDogXCJhdXRvXCInIG9yICdoZWlnaHQ6IFwiYXV0b1wiJyB0byBtYWludGFpbiB0aGUgYXNwZWN0IHJhdGlvLmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0RHluYW1pY1Byb3BzKFxuICBmZXRjaFByaW9yaXR5Pzogc3RyaW5nXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgaWYgKEJvb2xlYW4odXNlKSkge1xuICAgIC8vIEluIFJlYWN0IDE5LjAuMCBvciBuZXdlciwgd2UgbXVzdCB1c2UgY2FtZWxDYXNlXG4gICAgLy8gcHJvcCB0byBhdm9pZCBcIldhcm5pbmc6IEludmFsaWQgRE9NIHByb3BlcnR5XCIuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI1OTI3XG4gICAgcmV0dXJuIHsgZmV0Y2hQcmlvcml0eSB9XG4gIH1cbiAgLy8gSW4gUmVhY3QgMTguMi4wIG9yIG9sZGVyLCB3ZSBtdXN0IHVzZSBsb3dlcmNhc2UgcHJvcFxuICAvLyB0byBhdm9pZCBcIldhcm5pbmc6IEludmFsaWQgRE9NIHByb3BlcnR5XCIuXG4gIHJldHVybiB7IGZldGNocHJpb3JpdHk6IGZldGNoUHJpb3JpdHkgfVxufVxuXG5jb25zdCBJbWFnZUVsZW1lbnQgPSBmb3J3YXJkUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsLCBJbWFnZUVsZW1lbnRQcm9wcz4oXG4gIChcbiAgICB7XG4gICAgICBzcmMsXG4gICAgICBzcmNTZXQsXG4gICAgICBzaXplcyxcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoLFxuICAgICAgZGVjb2RpbmcsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZSxcbiAgICAgIGZldGNoUHJpb3JpdHksXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIGxvYWRpbmcsXG4gICAgICB1bm9wdGltaXplZCxcbiAgICAgIGZpbGwsXG4gICAgICBvbkxvYWRSZWYsXG4gICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgIHNldFNob3dBbHRUZXh0LFxuICAgICAgc2l6ZXNJbnB1dCxcbiAgICAgIG9uTG9hZCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICBmb3J3YXJkZWRSZWZcbiAgKSA9PiB7XG4gICAgY29uc3Qgb3duUmVmID0gdXNlQ2FsbGJhY2soXG4gICAgICAoaW1nOiBJbWdFbGVtZW50V2l0aERhdGFQcm9wIHwgbnVsbCkgPT4ge1xuICAgICAgICBpZiAoIWltZykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGltYWdlIGhhcyBhbiBlcnJvciBiZWZvcmUgcmVhY3QgaHlkcmF0ZXMsIHRoZW4gdGhlIGVycm9yIGlzIGxvc3QuXG4gICAgICAgICAgLy8gVGhlIHdvcmthcm91bmQgaXMgdG8gd2FpdCB1bnRpbCB0aGUgaW1hZ2UgaXMgbW91bnRlZCB3aGljaCBpcyBhZnRlciBoeWRyYXRpb24sXG4gICAgICAgICAgLy8gdGhlbiB3ZSBzZXQgdGhlIHNyYyBhZ2FpbiB0byB0cmlnZ2VyIHRoZSBlcnJvciBoYW5kbGVyIChpZiB0aGVyZSB3YXMgYW4gZXJyb3IpLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgICAgIGltZy5zcmMgPSBpbWcuc3JjXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5OmAsIGltZylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoJ2FsdCcpID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcImFsdFwiIHByb3BlcnR5LiBQbGVhc2UgYWRkIEFsdGVybmF0aXZlIFRleHQgdG8gZGVzY3JpYmUgdGhlIGltYWdlIGZvciBzY3JlZW4gcmVhZGVycyBhbmQgc2VhcmNoIGVuZ2luZXMuYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgaGFuZGxlTG9hZGluZyhcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkUmVmLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIHNpemVzSW5wdXRcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIHNyYyxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIG9uTG9hZFJlZixcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIHNpemVzSW5wdXQsXG4gICAgICBdXG4gICAgKVxuXG4gICAgY29uc3QgcmVmID0gdXNlTWVyZ2VkUmVmKGZvcndhcmRlZFJlZiwgb3duUmVmKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxpbWdcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIHsuLi5nZXREeW5hbWljUHJvcHMoZmV0Y2hQcmlvcml0eSl9XG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgbG9hZGluZ2AgYmVmb3JlIGBzcmNgIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBwcm9wcyBpbiBvcmRlciB3aGljaCBjYXVzZXMgU2FmYXJpL0ZpcmVmb3ggdG8gbm90IGxhenkgbG9hZCBwcm9wZXJseS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjU4ODNcbiAgICAgICAgbG9hZGluZz17bG9hZGluZ31cbiAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgZGVjb2Rpbmc9e2RlY29kaW5nfVxuICAgICAgICBkYXRhLW5pbWc9e2ZpbGwgPyAnZmlsbCcgOiAnMSd9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgICAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgICAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgICAgIHNpemVzPXtzaXplc31cbiAgICAgICAgc3JjU2V0PXtzcmNTZXR9XG4gICAgICAgIHNyYz17c3JjfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgb25Mb2FkPXsoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBpbWcgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEltZ0VsZW1lbnRXaXRoRGF0YVByb3BcbiAgICAgICAgICBoYW5kbGVMb2FkaW5nKFxuICAgICAgICAgICAgaW1nLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBvbkxvYWRSZWYsXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICAgICAgc2l6ZXNJbnB1dFxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgICAgb25FcnJvcj17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgLy8gaWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIGVuc3VyZSBcImFsdFwiIGlzIHZpc2libGVcbiAgICAgICAgICBzZXRTaG93QWx0VGV4dCh0cnVlKVxuICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICApXG4gIH1cbilcblxuZnVuY3Rpb24gSW1hZ2VQcmVsb2FkKHtcbiAgaXNBcHBSb3V0ZXIsXG4gIGltZ0F0dHJpYnV0ZXMsXG59OiB7XG4gIGlzQXBwUm91dGVyOiBib29sZWFuXG4gIGltZ0F0dHJpYnV0ZXM6IEltZ1Byb3BzXG59KSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgYXM6ICdpbWFnZScsXG4gICAgaW1hZ2VTcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgIGltYWdlU2l6ZXM6IGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgY3Jvc3NPcmlnaW46IGltZ0F0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4sXG4gICAgcmVmZXJyZXJQb2xpY3k6IGltZ0F0dHJpYnV0ZXMucmVmZXJyZXJQb2xpY3ksXG4gICAgLi4uZ2V0RHluYW1pY1Byb3BzKGltZ0F0dHJpYnV0ZXMuZmV0Y2hQcmlvcml0eSksXG4gIH1cblxuICBpZiAoaXNBcHBSb3V0ZXIgJiYgUmVhY3RET00ucHJlbG9hZCkge1xuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjk0MFxuICAgIFJlYWN0RE9NLnByZWxvYWQoXG4gICAgICBpbWdBdHRyaWJ1dGVzLnNyYyxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogdXBncmFkZSB0byBgQHR5cGVzL3JlYWN0LWRvbUAxOC4zLnhgXG4gICAgICBvcHRzXG4gICAgKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxIZWFkPlxuICAgICAgPGxpbmtcbiAgICAgICAga2V5PXtcbiAgICAgICAgICAnX19uaW1nLScgK1xuICAgICAgICAgIGltZ0F0dHJpYnV0ZXMuc3JjICtcbiAgICAgICAgICBpbWdBdHRyaWJ1dGVzLnNyY1NldCArXG4gICAgICAgICAgaW1nQXR0cmlidXRlcy5zaXplc1xuICAgICAgICB9XG4gICAgICAgIHJlbD1cInByZWxvYWRcIlxuICAgICAgICAvLyBOb3RlIGhvdyB3ZSBvbWl0IHRoZSBgaHJlZmAgYXR0cmlidXRlLCBhcyBpdCB3b3VsZCBvbmx5IGJlIHJlbGV2YW50XG4gICAgICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgICAgICAvLyBpdCB3b3VsZCBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjYXR0ci1saW5rLWltYWdlc3Jjc2V0XG4gICAgICAgIGhyZWY9e2ltZ0F0dHJpYnV0ZXMuc3JjU2V0ID8gdW5kZWZpbmVkIDogaW1nQXR0cmlidXRlcy5zcmN9XG4gICAgICAgIHsuLi5vcHRzfVxuICAgICAgLz5cbiAgICA8L0hlYWQ+XG4gIClcbn1cblxuLyoqXG4gKiBUaGUgYEltYWdlYCBjb21wb25lbnQgaXMgdXNlZCB0byBvcHRpbWl6ZSBpbWFnZXMuXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBkb2NzOiBgSW1hZ2VgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2ltYWdlKVxuICovXG5leHBvcnQgY29uc3QgSW1hZ2UgPSBmb3J3YXJkUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsLCBJbWFnZVByb3BzPihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCBwYWdlc1JvdXRlciA9IHVzZUNvbnRleHQoUm91dGVyQ29udGV4dClcbiAgICAvLyBXZSdyZSBpbiB0aGUgYXBwIGRpcmVjdG9yeSBpZiB0aGVyZSBpcyBubyBwYWdlcyByb3V0ZXIuXG4gICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXJcblxuICAgIGNvbnN0IGNvbmZpZ0NvbnRleHQgPSB1c2VDb250ZXh0KEltYWdlQ29uZmlnQ29udGV4dClcbiAgICBjb25zdCBjb25maWcgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBjb25maWdFbnYgfHwgY29uZmlnQ29udGV4dCB8fCBpbWFnZUNvbmZpZ0RlZmF1bHRcbiAgICAgIGNvbnN0IGFsbFNpemVzID0gWy4uLmMuZGV2aWNlU2l6ZXMsIC4uLmMuaW1hZ2VTaXplc10uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICBjb25zdCBkZXZpY2VTaXplcyA9IGMuZGV2aWNlU2l6ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICBjb25zdCBxdWFsaXRpZXMgPSBjLnF1YWxpdGllcz8uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICByZXR1cm4geyAuLi5jLCBhbGxTaXplcywgZGV2aWNlU2l6ZXMsIHF1YWxpdGllcyB9XG4gICAgfSwgW2NvbmZpZ0NvbnRleHRdKVxuXG4gICAgY29uc3QgeyBvbkxvYWQsIG9uTG9hZGluZ0NvbXBsZXRlIH0gPSBwcm9wc1xuICAgIGNvbnN0IG9uTG9hZFJlZiA9IHVzZVJlZihvbkxvYWQpXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgb25Mb2FkUmVmLmN1cnJlbnQgPSBvbkxvYWRcbiAgICB9LCBbb25Mb2FkXSlcblxuICAgIGNvbnN0IG9uTG9hZGluZ0NvbXBsZXRlUmVmID0gdXNlUmVmKG9uTG9hZGluZ0NvbXBsZXRlKVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQgPSBvbkxvYWRpbmdDb21wbGV0ZVxuICAgIH0sIFtvbkxvYWRpbmdDb21wbGV0ZV0pXG5cbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gdXNlU3RhdGUoZmFsc2UpXG4gICAgY29uc3QgW3Nob3dBbHRUZXh0LCBzZXRTaG93QWx0VGV4dF0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICAgIGNvbnN0IHsgcHJvcHM6IGltZ0F0dHJpYnV0ZXMsIG1ldGE6IGltZ01ldGEgfSA9IGdldEltZ1Byb3BzKHByb3BzLCB7XG4gICAgICBkZWZhdWx0TG9hZGVyLFxuICAgICAgaW1nQ29uZjogY29uZmlnLFxuICAgICAgYmx1ckNvbXBsZXRlLFxuICAgICAgc2hvd0FsdFRleHQsXG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICB7XG4gICAgICAgICAgPEltYWdlRWxlbWVudFxuICAgICAgICAgICAgey4uLmltZ0F0dHJpYnV0ZXN9XG4gICAgICAgICAgICB1bm9wdGltaXplZD17aW1nTWV0YS51bm9wdGltaXplZH1cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtpbWdNZXRhLnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgZmlsbD17aW1nTWV0YS5maWxsfVxuICAgICAgICAgICAgb25Mb2FkUmVmPXtvbkxvYWRSZWZ9XG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZj17b25Mb2FkaW5nQ29tcGxldGVSZWZ9XG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGU9e3NldEJsdXJDb21wbGV0ZX1cbiAgICAgICAgICAgIHNldFNob3dBbHRUZXh0PXtzZXRTaG93QWx0VGV4dH1cbiAgICAgICAgICAgIHNpemVzSW5wdXQ9e3Byb3BzLnNpemVzfVxuICAgICAgICAgICAgcmVmPXtmb3J3YXJkZWRSZWZ9XG4gICAgICAgICAgLz5cbiAgICAgICAgfVxuICAgICAgICB7aW1nTWV0YS5wcmlvcml0eSA/IChcbiAgICAgICAgICA8SW1hZ2VQcmVsb2FkXG4gICAgICAgICAgICBpc0FwcFJvdXRlcj17aXNBcHBSb3V0ZXJ9XG4gICAgICAgICAgICBpbWdBdHRyaWJ1dGVzPXtpbWdBdHRyaWJ1dGVzfVxuICAgICAgICAgIC8+XG4gICAgICAgICkgOiBudWxsfVxuICAgICAgPC8+XG4gICAgKVxuICB9XG4pXG4iXSwibmFtZXMiOlsiSW1hZ2UiLCJjb25maWdFbnYiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJ3aW5kb3ciLCJnbG9iYWxUaGlzIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwiaGFuZGxlTG9hZGluZyIsImltZyIsInBsYWNlaG9sZGVyIiwib25Mb2FkUmVmIiwib25Mb2FkaW5nQ29tcGxldGVSZWYiLCJzZXRCbHVyQ29tcGxldGUiLCJ1bm9wdGltaXplZCIsInNpemVzSW5wdXQiLCJzcmMiLCJwIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsInRoZW4iLCJwYXJlbnRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJjdXJyZW50IiwiZXZlbnQiLCJFdmVudCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJ2YWx1ZSIsInByZXZlbnRlZCIsInN0b3BwZWQiLCJuYXRpdmVFdmVudCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsInBlcnNpc3QiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIk5PREVfRU5WIiwib3JpZ1NyYyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImdldCIsImdldEF0dHJpYnV0ZSIsIndpZHRoVmlld3BvcnRSYXRpbyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiaW5uZXJXaWR0aCIsIndhcm5PbmNlIiwicG9zaXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwidmFsaWQiLCJpbmNsdWRlcyIsIm1hcCIsIlN0cmluZyIsImpvaW4iLCJoZWlnaHQiLCJoZWlnaHRNb2RpZmllZCIsInRvU3RyaW5nIiwid2lkdGhNb2RpZmllZCIsImdldER5bmFtaWNQcm9wcyIsImZldGNoUHJpb3JpdHkiLCJCb29sZWFuIiwidXNlIiwiZmV0Y2hwcmlvcml0eSIsIkltYWdlRWxlbWVudCIsImZvcndhcmRSZWYiLCJmb3J3YXJkZWRSZWYiLCJzcmNTZXQiLCJzaXplcyIsImRlY29kaW5nIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJsb2FkaW5nIiwiZmlsbCIsInNldFNob3dBbHRUZXh0Iiwib25Mb2FkIiwib25FcnJvciIsInJlc3QiLCJvd25SZWYiLCJ1c2VDYWxsYmFjayIsImNvbnNvbGUiLCJlcnJvciIsImNvbXBsZXRlIiwicmVmIiwidXNlTWVyZ2VkUmVmIiwiZGF0YS1uaW1nIiwiSW1hZ2VQcmVsb2FkIiwiaXNBcHBSb3V0ZXIiLCJpbWdBdHRyaWJ1dGVzIiwib3B0cyIsImFzIiwiaW1hZ2VTcmNTZXQiLCJpbWFnZVNpemVzIiwiY3Jvc3NPcmlnaW4iLCJyZWZlcnJlclBvbGljeSIsIlJlYWN0RE9NIiwicHJlbG9hZCIsIkhlYWQiLCJsaW5rIiwicmVsIiwiaHJlZiIsInVuZGVmaW5lZCIsInByb3BzIiwicGFnZXNSb3V0ZXIiLCJ1c2VDb250ZXh0IiwiUm91dGVyQ29udGV4dCIsImNvbmZpZ0NvbnRleHQiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJjb25maWciLCJ1c2VNZW1vIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImFsbFNpemVzIiwiZGV2aWNlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJxdWFsaXRpZXMiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsImJsdXJDb21wbGV0ZSIsInVzZVN0YXRlIiwic2hvd0FsdFRleHQiLCJtZXRhIiwiaW1nTWV0YSIsImdldEltZ1Byb3BzIiwiZGVmYXVsdExvYWRlciIsImltZ0NvbmYiLCJwcmlvcml0eSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/client/use-merged-ref.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMergedRef\", ({\n    enumerable: true,\n    get: function() {\n        return useMergedRef;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction useMergedRef(refA, refB) {\n    const cleanupA = (0, _react.useRef)(null);\n    const cleanupB = (0, _react.useRef)(null);\n    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n    // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n    // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),\n    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n    // (because it hasn't been updated for React 19)\n    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n    return (0, _react.useCallback)((current)=>{\n        if (current === null) {\n            const cleanupFnA = cleanupA.current;\n            if (cleanupFnA) {\n                cleanupA.current = null;\n                cleanupFnA();\n            }\n            const cleanupFnB = cleanupB.current;\n            if (cleanupFnB) {\n                cleanupB.current = null;\n                cleanupFnB();\n            }\n        } else {\n            if (refA) {\n                cleanupA.current = applyRef(refA, current);\n            }\n            if (refB) {\n                cleanupB.current = applyRef(refB, current);\n            }\n        }\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        const cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return ()=>refA(null);\n        }\n    } else {\n        refA.current = current;\n        return ()=>{\n            refA.current = null;\n        };\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-merged-ref.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1tZXJnZWQtcmVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0RBU2dCQTs7O2VBQUFBOzs7bUNBVDhCO0FBU3ZDLFNBQVNBLGFBQ2RDLElBQW1CLEVBQ25CQyxJQUFtQjtJQUVuQixNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUM3QyxNQUFNQyxXQUFXRCxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUU3QyxtRkFBbUY7SUFDbkYseUVBQXlFO0lBQ3pFLGlHQUFpRztJQUNqRyw4RkFBOEY7SUFDOUYsZ0RBQWdEO0lBQ2hELG1HQUFtRztJQUNuRyx3RkFBd0Y7SUFDeEYsT0FBT0UsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBQUEsRUFDTCxDQUFDQztRQUNDLElBQUlBLFlBQVksTUFBTTtZQUNwQixNQUFNQyxhQUFhTCxTQUFTSSxPQUFPO1lBQ25DLElBQUlDLFlBQVk7Z0JBQ2RMLFNBQVNJLE9BQU8sR0FBRztnQkFDbkJDO1lBQ0Y7WUFDQSxNQUFNQyxhQUFhSixTQUFTRSxPQUFPO1lBQ25DLElBQUlFLFlBQVk7Z0JBQ2RKLFNBQVNFLE9BQU8sR0FBRztnQkFDbkJFO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSVIsTUFBTTtnQkFDUkUsU0FBU0ksT0FBTyxHQUFHRyxTQUFTVCxNQUFNTTtZQUNwQztZQUNBLElBQUlMLE1BQU07Z0JBQ1JHLFNBQVNFLE9BQU8sR0FBR0csU0FBU1IsTUFBTUs7WUFDcEM7UUFDRjtJQUNGLEdBQ0E7UUFBQ047UUFBTUM7S0FBSztBQUVoQjtBQUVBLFNBQVNRLFNBQ1BULElBQWdDLEVBQ2hDTSxPQUFpQjtJQUVqQixJQUFJLE9BQU9OLFNBQVMsWUFBWTtRQUM5QixNQUFNVSxVQUFVVixLQUFLTTtRQUNyQixJQUFJLE9BQU9JLFlBQVksWUFBWTtZQUNqQyxPQUFPQTtRQUNULE9BQU87WUFDTCxPQUFPLElBQU1WLEtBQUs7UUFDcEI7SUFDRixPQUFPO1FBQ0xBLEtBQUtNLE9BQU8sR0FBR0E7UUFDZixPQUFPO1lBQ0xOLEtBQUtNLE9BQU8sR0FBRztRQUNqQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXGNsaWVudFxcdXNlLW1lcmdlZC1yZWYudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdHlwZSBSZWYgfSBmcm9tICdyZWFjdCdcblxuLy8gVGhpcyBpcyBhIGNvbXBhdGliaWxpdHkgaG9vayB0byBzdXBwb3J0IFJlYWN0IDE4IGFuZCAxOSByZWZzLlxuLy8gSW4gMTksIGEgY2xlYW51cCBmdW5jdGlvbiBmcm9tIHJlZnMgbWF5IGJlIHJldHVybmVkLlxuLy8gSW4gMTgsIHJldHVybmluZyBhIGNsZWFudXAgZnVuY3Rpb24gY3JlYXRlcyBhIHdhcm5pbmcuXG4vLyBTaW5jZSB3ZSB0YWtlIHVzZXJzcGFjZSByZWZzLCB3ZSBkb24ndCBrbm93IGFoZWFkIG9mIHRpbWUgaWYgYSBjbGVhbnVwIGZ1bmN0aW9uIHdpbGwgYmUgcmV0dXJuZWQuXG4vLyBUaGlzIGltcGxlbWVudHMgY2xlYW51cCBmdW5jdGlvbnMgd2l0aCB0aGUgb2xkIGJlaGF2aW9yIGluIDE4LlxuLy8gV2Uga25vdyByZWZzIGFyZSBhbHdheXMgY2FsbGVkIGFsdGVybmF0aW5nIHdpdGggYG51bGxgIGFuZCB0aGVuIGBUYC5cbi8vIFNvIGEgY2FsbCB3aXRoIGBudWxsYCBtZWFucyB3ZSBuZWVkIHRvIGNhbGwgdGhlIHByZXZpb3VzIGNsZWFudXAgZnVuY3Rpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZjxURWxlbWVudD4oXG4gIHJlZkE6IFJlZjxURWxlbWVudD4sXG4gIHJlZkI6IFJlZjxURWxlbWVudD5cbik6IFJlZjxURWxlbWVudD4ge1xuICBjb25zdCBjbGVhbnVwQSA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKVxuICBjb25zdCBjbGVhbnVwQiA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKVxuXG4gIC8vIE5PVEU6IEluIHRoZW9yeSwgd2UgY291bGQgc2tpcCB0aGUgd3JhcHBpbmcgaWYgb25seSBvbmUgb2YgdGhlIHJlZnMgaXMgbm9uLW51bGwuXG4gIC8vICh0aGlzIGhhcHBlbnMgb2Z0ZW4gaWYgdGhlIHVzZXIgZG9lc24ndCBwYXNzIGEgcmVmIHRvIExpbmsvRm9ybS9JbWFnZSlcbiAgLy8gQnV0IHRoaXMgY2FuIGNhdXNlIHVzIHRvIGxlYWsgYSBjbGVhbnVwLXJlZiBpbnRvIHVzZXIgY29kZSAoZS5nLiB2aWEgYDxMaW5rIGxlZ2FjeUJlaGF2aW9yPmApLFxuICAvLyBhbmQgdGhlIHVzZXIgbWlnaHQgcGFzcyB0aGF0IHJlZiBpbnRvIHJlZi1tZXJnaW5nIGxpYnJhcnkgdGhhdCBkb2Vzbid0IHN1cHBvcnQgY2xlYW51cCByZWZzXG4gIC8vIChiZWNhdXNlIGl0IGhhc24ndCBiZWVuIHVwZGF0ZWQgZm9yIFJlYWN0IDE5KVxuICAvLyB3aGljaCBjYW4gdGhlbiBjYXVzZSB0aGluZ3MgdG8gYmxvdyB1cCwgYmVjYXVzZSBhIGNsZWFudXAtcmV0dXJuaW5nIHJlZiBnZXRzIGNhbGxlZCB3aXRoIGBudWxsYC5cbiAgLy8gU28gaW4gcHJhY3RpY2UsIGl0J3Mgc2FmZXIgdG8gYmUgZGVmZW5zaXZlIGFuZCBhbHdheXMgd3JhcCB0aGUgcmVmLCBldmVuIG9uIFJlYWN0IDE5LlxuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgKGN1cnJlbnQ6IFRFbGVtZW50IHwgbnVsbCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2xlYW51cEZuQSA9IGNsZWFudXBBLmN1cnJlbnRcbiAgICAgICAgaWYgKGNsZWFudXBGbkEpIHtcbiAgICAgICAgICBjbGVhbnVwQS5jdXJyZW50ID0gbnVsbFxuICAgICAgICAgIGNsZWFudXBGbkEoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsZWFudXBGbkIgPSBjbGVhbnVwQi5jdXJyZW50XG4gICAgICAgIGlmIChjbGVhbnVwRm5CKSB7XG4gICAgICAgICAgY2xlYW51cEIuY3VycmVudCA9IG51bGxcbiAgICAgICAgICBjbGVhbnVwRm5CKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlZkEpIHtcbiAgICAgICAgICBjbGVhbnVwQS5jdXJyZW50ID0gYXBwbHlSZWYocmVmQSwgY3VycmVudClcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmQikge1xuICAgICAgICAgIGNsZWFudXBCLmN1cnJlbnQgPSBhcHBseVJlZihyZWZCLCBjdXJyZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbcmVmQSwgcmVmQl1cbiAgKVxufVxuXG5mdW5jdGlvbiBhcHBseVJlZjxURWxlbWVudD4oXG4gIHJlZkE6IE5vbk51bGxhYmxlPFJlZjxURWxlbWVudD4+LFxuICBjdXJyZW50OiBURWxlbWVudFxuKSB7XG4gIGlmICh0eXBlb2YgcmVmQSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGNsZWFudXAgPSByZWZBKGN1cnJlbnQpXG4gICAgaWYgKHR5cGVvZiBjbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2xlYW51cFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCkgPT4gcmVmQShudWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWZBLmN1cnJlbnQgPSBjdXJyZW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlZkEuY3VycmVudCA9IG51bGxcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1c2VNZXJnZWRSZWYiLCJyZWZBIiwicmVmQiIsImNsZWFudXBBIiwidXNlUmVmIiwiY2xlYW51cEIiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJjbGVhbnVwRm5BIiwiY2xlYW51cEZuQiIsImFwcGx5UmVmIiwiY2xlYW51cCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixFQUFFLGlEQUFpRCwrQkFBK0IsMkNBQTJDLHdCQUF3QixFQUFFLHlCQUF5QixRQUFRLHVFQUF1RSx3QkFBd0IsMENBQTBDLFNBQVMsdUJBQXVCLHdCQUF3Qix3QkFBd0IsMEZBQTBGLHNCQUFzQixtQkFBbUIscUJBQXFCLHFCQUFxQix3QkFBd0IsdUJBQXVCLDBCQUEwQix3QkFBd0IsWUFBWSxtSkFBbUosbUVBQW1FLDhCQUE4Qix5SEFBeUgsOEJBQThCLHdCQUF3Qiw2RkFBNkYsNkJBQTZCLG1CQUFtQiwwQkFBMEIsb0JBQW9CLGNBQWMscUdBQXFHLHdEQUF3RCxtSkFBbUosNEJBQTRCLG9CQUFvQiw2REFBNkQseUNBQXlDLHVCQUF1Qix3QkFBd0IsOERBQThELGFBQWEsd0VBQXdFLHNCQUFzQixjQUFjLFNBQVMsdUJBQXVCLGtCQUFrQiw2RUFBNkUsdUJBQXVCLDZCQUE2QixxQkFBcUIsd0JBQXdCLGNBQWMsd0NBQXdDLCtCQUErQix1QkFBdUIsbUNBQW1DLHVCQUF1Qix5QkFBeUIsZ0NBQWdDLFNBQVMsMEJBQTBCLDRDQUE0Qyx3QkFBd0Isc0JBQXNCLG1CQUFtQixVQUFVLGVBQWUsU0FBUywwQkFBMEIsdUNBQXVDLHNCQUFzQixZQUFZLElBQUksTUFBTSxjQUFjLFNBQVMsZ0NBQWdDLHdCQUF3Qiw2REFBNkQsMEJBQTBCLDZEQUE2RCxNQUFNLGlDQUFpQyxvQkFBb0IsdUJBQXVCLHNCQUFzQixLQUFLLHdCQUF3QiwwQ0FBMEMsU0FBUyx1QkFBdUIsdUJBQXVCLDBCQUEwQixzQkFBc0IsaUJBQWlCLFNBQVMsZ0JBQWdCLFNBQVMseUJBQXlCLHNEQUFzRCx1QkFBdUIsd0JBQXdCLDZDQUE2Qyw4QkFBOEIsb0JBQW9CLFNBQVMsMkdBQTJHLFdBQVcsdUJBQXVCLFVBQVUsSUFBSSx3QkFBd0IscUNBQXFDLDBEQUEwRCxxQ0FBcUMsbUVBQW1FLG1FQUFtRSw2Q0FBNkMsNkZBQTZGLGtCQUFrQixlQUFlLGVBQWUsNEJBQTRCLElBQUksS0FBSyxnQkFBZ0IsT0FBTyxPQUFPLE9BQU8sZ0JBQWdCLGdCQUFnQixVQUFVLHlDQUF5QyxnQ0FBZ0Msb0pBQW9KLHVCQUF1QixtQ0FBbUMsc0JBQXNCLG1FQUFtRSxpQkFBaUIsdUJBQXVCLE1BQU0sa0JBQWtCLElBQUksUUFBUSxXQUFXLEtBQUssZ0JBQWdCLDRCQUE0QixRQUFRLFFBQVEsV0FBVyxLQUFLLFdBQVcsNkJBQTZCLGlCQUFpQix3QkFBd0IsbUVBQW1FLFlBQVksWUFBWSxVQUFVLHlCQUF5Qix1QkFBdUIsZ0JBQWdCLHFEQUFxRCxvQkFBb0Isd0JBQXdCLDRIQUE0SCxlQUFlLDhDQUE4QyxzQkFBc0IsWUFBWSxNQUFNLEVBQUUsVUFBVSwrQ0FBK0Msb0RBQW9ELCtEQUErRCx1QkFBdUIsNENBQTRDLGNBQWMsa0NBQWtDLHVCQUF1QixTQUFTLDZCQUE2Qiw2QkFBNkIsWUFBWSx1QkFBdUIsSUFBSSxrQkFBa0IsU0FBUyxpQ0FBaUMsY0FBYyxTQUFTLFNBQVMsT0FBTyxPQUFPLFNBQVMsU0FBUyxlQUFlLFlBQVksVUFBVSxvQ0FBb0Msa0RBQWtELHdDQUF3Qyx1REFBdUQsMENBQTBDLGtGQUFrRix5REFBeUQsdUJBQXVCLFNBQVMsZ0NBQWdDLHFCQUFxQixXQUFXLFVBQVUsT0FBTywwQ0FBMEMsa0JBQWtCLFlBQVksa0VBQWtFLFlBQVksSUFBSSxNQUFNLGlCQUFpQixhQUFhLDBDQUEwQyxrQkFBa0IsWUFBWSxrRUFBa0UsWUFBWSxJQUFJLE1BQU0saUJBQWlCLG1CQUFtQixhQUFhLDBDQUEwQyxrQkFBa0IsWUFBWSxrRUFBa0UsWUFBWSxJQUFJLE1BQU0saUJBQWlCLG1CQUFtQixtQkFBbUIsbUJBQW1CLGFBQWEsOENBQThDLGtCQUFrQixrQkFBa0IsbURBQW1ELDJDQUEyQywwREFBMEQsMkNBQTJDLHdFQUF3RSx3QkFBd0IsbUNBQW1DLDRDQUE0QyxTQUFTLDBCQUEwQix1Q0FBdUMsRUFBRSxrQkFBa0IsNEJBQTRCLHdCQUF3QixNQUFNLDZDQUE2QyxxREFBcUQsNkJBQTZCLHVDQUF1Qyx3QkFBd0Isa0hBQWtILGtCQUFrQixJQUFJLGtCQUFrQixlQUFlLGtCQUFrQixJQUFJLGtCQUFrQixjQUFjLHdDQUF3QywyQ0FBMkMsZUFBZSxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsT0FBTyxPQUFPLE9BQU8sT0FBTyxxQkFBcUIsVUFBVSxVQUFVLG9CQUFvQixzQkFBc0IsbUJBQW1CLFlBQVksSUFBSSxLQUFLLGdCQUFnQixPQUFPLE9BQU8sT0FBTyxnQkFBZ0IsZ0JBQWdCLFVBQVUseUNBQXlDLHlCQUF5Qix3QkFBd0IsSUFBSSxJQUFJLHNCQUFzQixhQUFhLHVCQUF1QixjQUFjLEtBQUssbUJBQW1CLGlCQUFpQixvQkFBb0IsZ0JBQWdCLGNBQWMsa0JBQWtCLGFBQWEsU0FBUyxjQUFjLHdCQUF3QixtQkFBbUIsdUJBQXVCLGlCQUFpQixTQUFTLCtCQUErQiw2QkFBNkIsUUFBUSxxREFBcUQsTUFBTSxnREFBZ0QsS0FBSyxxREFBcUQsaUNBQWlDLDREQUE0RCxpQ0FBaUMsUUFBUSxlQUFlLGVBQWUsa0JBQWtCLDBCQUEwQiwyREFBMkQsMkJBQTJCLFNBQVMsSUFBSSxLQUFLLEtBQUssTUFBTSxtQkFBbUIsVUFBVSxZQUFZLEtBQUssNEJBQTRCLE1BQU0sTUFBTSxTQUFTLFFBQVEsSUFBSSxLQUFLLHFDQUFxQyxjQUFjLHdCQUF3QixLQUFLLGlCQUFpQixPQUFPLEtBQUssZUFBZSxRQUFRLEtBQUssS0FBSyxXQUFXLFlBQVksSUFBSSxLQUFLLDRCQUE0QixRQUFRLE9BQU8sZUFBZSxTQUFTLG1EQUFtRCxpQ0FBaUMsaURBQWlELDhDQUE4Qyx5REFBeUQsK0NBQStDLDJCQUEyQixlQUFlLGlCQUFpQixPQUFPLElBQUksS0FBSyxZQUFZLFFBQVEsS0FBSyxlQUFlLFVBQVUsTUFBTSxZQUFZLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLFNBQVMsU0FBUyw0QkFBNEIsbURBQW1ELDZCQUE2Qix5Q0FBeUMsOEJBQThCLDJCQUEyQiw4QkFBOEIsMENBQTBDLDRCQUE0QixzREFBc0QsK0NBQStDLGtCQUFrQixTQUFTLGNBQWMsSUFBSSw0Q0FBNEMsSUFBSSxjQUFjLElBQUkscUJBQXFCLFFBQVEsZ0JBQWdCLFFBQVEsMEJBQTBCLEtBQUssSUFBSSxhQUFhLEtBQUssMkZBQTJGLG9CQUFvQiwwQkFBMEIsMENBQTBDLCtEQUErRCxlQUFlLFlBQVksTUFBTSxFQUFFLFVBQVUsc0NBQXNDLG9EQUFvRCwwQ0FBMEMseURBQXlELDRDQUE0QyxpRkFBaUYseURBQXlELHVCQUF1QixVQUFVLDBDQUEwQyxPQUFPLG1FQUFtRSw0QkFBNEIsd0JBQXdCLDBCQUEwQixLQUFLLHNDQUFzQywwQkFBMEIsdUJBQXVCLFNBQVMsUUFBUSxXQUFXLFdBQVcsV0FBVyxnQ0FBZ0MsV0FBVyxZQUFZLFVBQVUsaUJBQWlCLElBQUksTUFBTSxnQkFBZ0Isa0JBQWtCLGlCQUFpQixVQUFVLEtBQUssTUFBTSxnQkFBZ0IsU0FBUyxpQ0FBaUMsNEJBQTRCLCtCQUErQixLQUFLLE1BQU0sZ0JBQWdCLFNBQVMsU0FBUyxnREFBZ0QsdUNBQXVDLHVCQUF1QixPQUFPLGFBQWEsUUFBUSxJQUFJLGlCQUFpQixTQUFTLDBCQUEwQixlQUFlLFVBQVUsS0FBSyxnQ0FBZ0MsV0FBVyxrQ0FBa0MsZUFBZSxTQUFTLDJDQUEyQyxTQUFTLFFBQVEsV0FBVyxxREFBcUQsU0FBUywyQkFBMkIsU0FBUyx1QkFBdUIsWUFBWSxJQUFJLEtBQUssaUNBQWlDLFNBQVMsNEJBQTRCLFNBQVMsdUJBQXVCLFlBQVksSUFBSSxLQUFLLDZCQUE2QixTQUFTLHlCQUF5QixlQUFlLGVBQWUsb0JBQW9CLFNBQVMsWUFBWSxJQUFJLEtBQUssV0FBVyxTQUFTLDZCQUE2QixtQkFBbUIsU0FBUyxZQUFZLFdBQVcsTUFBTSx3Q0FBd0MsU0FBUywyQ0FBMkMsa0JBQWtCLE1BQU0sc0JBQXNCLFFBQVEsS0FBSyxXQUFXLGFBQWEsSUFBSSxRQUFRLEtBQUssV0FBVyxhQUFhLElBQUksV0FBVyx5QkFBeUIsMENBQTBDLFVBQVUsNEJBQTRCLDJEQUEyRCx1RUFBdUUsdURBQXVELFFBQVEsUUFBUSxtQ0FBbUMsY0FBYyxRQUFRLFFBQVEsdUJBQXVCLGVBQWUsVUFBVSx1REFBdUQsUUFBUSxRQUFRLE9BQU8sNkJBQTZCLGtCQUFrQixRQUFRLHFCQUFxQixpQkFBaUIsVUFBVSxtREFBbUQsUUFBUSxtQ0FBbUMsZ0JBQWdCLHlEQUF5RCxRQUFRLG1DQUFtQyw2QkFBNkIseURBQXlELFFBQVEsbUNBQW1DLDZCQUE2Qix5REFBeUQsUUFBUSxtQ0FBbUMsK0RBQStELHlEQUF5RCxRQUFRLG1DQUFtQyxnRUFBZ0UscURBQXFELFFBQVEsUUFBUSxtQ0FBbUMsY0FBYyxRQUFRLFFBQVEsdUJBQXVCLGVBQWUsT0FBTywyQkFBMkIsVUFBVSxxREFBcUQsUUFBUSxRQUFRLG1DQUFtQyxRQUFRLFFBQVEsa0JBQWtCLHFCQUFxQixpQkFBaUIsT0FBTywyQkFBMkIsVUFBVSxpREFBaUQsUUFBUSxtQ0FBbUMsaUNBQWlDLDBCQUEwQix1REFBdUQsUUFBUSxtQ0FBbUMsMkJBQTJCLCtCQUErQix1REFBdUQsUUFBUSxtQ0FBbUMsMkJBQTJCLCtCQUErQix1REFBdUQsUUFBUSxtQ0FBbUMseURBQXlELHVEQUF1RCxRQUFRLG1DQUFtQyx5REFBeUQsdURBQXVELFFBQVEsbUNBQW1DLGlDQUFpQyx1REFBdUQsUUFBUSxtQ0FBbUMsa0NBQWtDLHlEQUF5RCxRQUFRLG1DQUFtQyxpQ0FBaUMseURBQXlELFFBQVEsbUNBQW1DLGtDQUFrQywrQkFBK0IsMEZBQTBGLHNFQUFzRSwyREFBMkQsMkRBQTJELEtBQUssUUFBUSxRQUFRLE9BQU8sd0JBQXdCLHlCQUF5QixRQUFRLFFBQVEsY0FBYyx1QkFBdUIsa0JBQWtCLFlBQVksMkRBQTJELEtBQUssUUFBUSxRQUFRLE9BQU8sd0JBQXdCLHlCQUF5QixVQUFVLFFBQVEsZ0JBQWdCLHdCQUF3QixrQkFBa0IsWUFBWSx1REFBdUQsS0FBSyxRQUFRLGlDQUFpQyxjQUFjLFlBQVksNkRBQTZELEtBQUssUUFBUSxtQ0FBbUMsY0FBYyxnQkFBZ0IsWUFBWSw2REFBNkQsS0FBSyxRQUFRLG1DQUFtQyxjQUFjLGdCQUFnQixZQUFZLDZEQUE2RCxLQUFLLFFBQVEsd0NBQXdDLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGNBQWMsWUFBWSw2REFBNkQsS0FBSyxRQUFRLHdDQUF3QyxlQUFlLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLFlBQVkseURBQXlELEtBQUssUUFBUSxPQUFPLHdCQUF3Qiw0QkFBNEIsUUFBUSxRQUFRLFFBQVEsY0FBYyx1QkFBdUIsZ0NBQWdDLElBQUkseUJBQXlCLFlBQVkseURBQXlELEtBQUssUUFBUSxPQUFPLHdCQUF3Qiw0QkFBNEIsVUFBVSxRQUFRLFFBQVEsZ0JBQWdCLHdCQUF3QixnQ0FBZ0MsSUFBSSx5QkFBeUIsWUFBWSxxREFBcUQsS0FBSyxRQUFRLG9DQUFvQyxpQkFBaUIsY0FBYyxZQUFZLDJEQUEyRCxLQUFLLFFBQVEsd0NBQXdDLGNBQWMsZ0JBQWdCLFlBQVksMkRBQTJELEtBQUssUUFBUSx3Q0FBd0MsY0FBYyxnQkFBZ0IsWUFBWSwyREFBMkQsS0FBSyxRQUFRLGtEQUFrRCxjQUFjLGdCQUFnQixpQkFBaUIsaUJBQWlCLFlBQVksMkRBQTJELEtBQUssUUFBUSxrREFBa0Qsd0JBQXdCLGVBQWUsaUJBQWlCLGdCQUFnQixnQkFBZ0IsWUFBWSxtQ0FBbUMsMkRBQTJELGtEQUFrRCwrQkFBK0IsS0FBSyxRQUFRLE9BQU8saUVBQWlFLHNCQUFzQixXQUFXLDJEQUEyRCxvQ0FBb0MsMkRBQTJELHFDQUFxQyxnQ0FBZ0MsS0FBSyxRQUFRLE9BQU8sbUVBQW1FLHNCQUFzQixXQUFXLDZEQUE2RCxxQ0FBcUMsNkRBQTZELHNDQUFzQyw2Q0FBNkMsMEVBQTBFLFVBQVUsMkJBQTJCLDBCQUEwQixVQUFVLGdCQUFnQixrQkFBa0IsMENBQTBDLFFBQVEsa0RBQWtELGtFQUFrRSx1REFBdUQsK0JBQStCLG1CQUFtQixlQUFlLFVBQVUsa0VBQWtFLHVCQUF1Qiw0QkFBNEIsY0FBYyxLQUFLLEtBQUssa0JBQWtCLEtBQUssc0RBQXNELFVBQVUsNkNBQTZDLHdCQUF3Qix3QkFBd0IsSUFBSSxJQUFJLGNBQWMsNkJBQTZCLElBQUksY0FBYyx1Q0FBdUMsaURBQWlELCtDQUErQyw0Q0FBNEMsaUJBQWlCLHNCQUFzQixvQ0FBb0MsTUFBTSw2QkFBNkIsUUFBUSw4QkFBOEIsWUFBWSxzQ0FBc0MsMkNBQTJDLFNBQVMsWUFBWSxRQUFRLGtDQUFrQyxVQUFVLE1BQU0sd0JBQXdCLFFBQVEsSUFBSSxLQUFLLFdBQVcsS0FBSyw0Q0FBNEMsZUFBZSxVQUFVLHlFQUF5RSxRQUFRLE1BQU0sS0FBSyxrQkFBa0IsYUFBYSwwQkFBMEIsd0JBQXdCLGtCQUFrQix5QkFBeUIsdUJBQXVCLHNCQUFzQixRQUFRLFNBQVMsMEJBQTBCLGNBQWMsTUFBTSxlQUFlLFdBQVcsU0FBUyxZQUFZLElBQUksS0FBSyxrQkFBa0IscUJBQXFCLE9BQU8sWUFBWSxpQ0FBaUMsU0FBUyxpQkFBaUIsaUNBQWlDLFNBQVMsSUFBSSxTQUFTLFlBQVksaUNBQWlDLElBQUksU0FBUyw4QkFBOEIsV0FBVyxpQ0FBaUMsT0FBTyxVQUFVLGtCQUFrQixVQUFVLGdCQUFnQixrQkFBa0IsMEJBQTBCLGlCQUFpQixrQkFBa0IsdUNBQXVDLG1CQUFtQixrQkFBa0Isb0RBQW9ELEtBQUssdUNBQXVDLFNBQVMseUJBQXlCLFNBQVMsWUFBWSxXQUFXLEtBQUssNEJBQTRCLFNBQVMsNkJBQTZCLFVBQVUsU0FBUyxZQUFZLFdBQVcsS0FBSyxrQkFBa0Isa0JBQWtCLE9BQU8sUUFBUSxVQUFVLFVBQVUsU0FBUywwQkFBMEIscUNBQXFDLDZCQUE2QixZQUFZLElBQUksS0FBSyxvQ0FBb0MsWUFBWSxTQUFTLHlCQUF5QiwyR0FBMkcsd0JBQXdCLGFBQWEsaUJBQWlCLHlCQUF5QixxQkFBcUIsWUFBWSxLQUFLLEtBQUssV0FBVyxZQUFZLEtBQUssS0FBSyxrQkFBa0IsU0FBUyxHQUFHO0FBQ3p4dkI7QUFDQSwyQkFBMkIsUUFBUSxjQUFjLGVBQWUsV0FBVyxTQUFTLGNBQWMsYUFBYSxhQUFhLEtBQUssY0FBYyxPQUFPLEtBQUssS0FBSyxJQUFJLDJCQUEyQixjQUFjLE9BQU8sS0FBSyxLQUFLLElBQUksMkJBQTJCLFVBQVUsTUFBTSxlQUFlLCtCQUErQixLQUFLLGtCQUFrQixNQUFNLGtDQUFrQyw4QkFBOEIsVUFBVSxjQUFjLGVBQWUsV0FBVywrQ0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGNvbXBpbGVkXFxidWZmZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs2NzU6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw3MjpmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi92YXIgZj10KDY3NSk7dmFyIG49dCg3ODMpO3ZhciBpPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO3IuQnVmZmVyPUJ1ZmZlcjtyLlNsb3dCdWZmZXI9U2xvd0J1ZmZlcjtyLklOU1BFQ1RfTUFYX0JZVEVTPTUwO3ZhciBvPTIxNDc0ODM2NDc7ci5rTWF4TGVuZ3RoPW87QnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dHlwZWRBcnJheVN1cHBvcnQoKTtpZighQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQmJnR5cGVvZiBjb25zb2xlIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PT1cImZ1bmN0aW9uXCIpe2NvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgXCIrXCJgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKX1mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTt2YXIgcj17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihlLHIpO3JldHVybiBlLmZvbygpPT09NDJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcInBhcmVudFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXR9fSk7ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGUpe2lmKGU+byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gQnVmZmVyKGUscix0KXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX1yZXR1cm4gYWxsb2NVbnNhZmUoZSl9cmV0dXJuIGZyb20oZSxyLHQpfUJ1ZmZlci5wb29sU2l6ZT04MTkyO2Z1bmN0aW9uIGZyb20oZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZyb21TdHJpbmcoZSxyKX1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGU9PW51bGwpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLEFycmF5QnVmZmVyKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmKGlzSW5zdGFuY2UoZSxTaGFyZWRBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXZhciBmPWUudmFsdWVPZiYmZS52YWx1ZU9mKCk7aWYoZiE9bnVsbCYmZiE9PWUpe3JldHVybiBCdWZmZXIuZnJvbShmLHIsdCl9dmFyIG49ZnJvbU9iamVjdChlKTtpZihuKXJldHVybiBuO2lmKHR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV09PT1cImZ1bmN0aW9uXCIpe3JldHVybiBCdWZmZXIuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KX10aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9QnVmZmVyLmZyb209ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBmcm9tKGUscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsVWludDhBcnJheSk7ZnVuY3Rpb24gYXNzZXJ0U2l6ZShlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKX1lbHNlIGlmKGU8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9fWZ1bmN0aW9uIGFsbG9jKGUscix0KXthc3NlcnRTaXplKGUpO2lmKGU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoZSl9aWYociE9PXVuZGVmaW5lZCl7cmV0dXJuIHR5cGVvZiB0PT09XCJzdHJpbmdcIj9jcmVhdGVCdWZmZXIoZSkuZmlsbChyLHQpOmNyZWF0ZUJ1ZmZlcihlKS5maWxsKHIpfXJldHVybiBjcmVhdGVCdWZmZXIoZSl9QnVmZmVyLmFsbG9jPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gYWxsb2MoZSxyLHQpfTtmdW5jdGlvbiBhbGxvY1Vuc2FmZShlKXthc3NlcnRTaXplKGUpO3JldHVybiBjcmVhdGVCdWZmZXIoZTwwPzA6Y2hlY2tlZChlKXwwKX1CdWZmZXIuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtCdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07ZnVuY3Rpb24gZnJvbVN0cmluZyhlLHIpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8cj09PVwiXCIpe3I9XCJ1dGY4XCJ9aWYoIUJ1ZmZlci5pc0VuY29kaW5nKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcil9dmFyIHQ9Ynl0ZUxlbmd0aChlLHIpfDA7dmFyIGY9Y3JlYXRlQnVmZmVyKHQpO3ZhciBuPWYud3JpdGUoZSxyKTtpZihuIT09dCl7Zj1mLnNsaWNlKDAsbil9cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbUFycmF5TGlrZShlKXt2YXIgcj1lLmxlbmd0aDwwPzA6Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7Zm9yKHZhciBmPTA7ZjxyO2YrPTEpe3RbZl09ZVtmXSYyNTV9cmV0dXJuIHR9ZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGUscix0KXtpZihyPDB8fGUuYnl0ZUxlbmd0aDxyKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX1pZihlLmJ5dGVMZW5ndGg8cisodHx8MCkpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfXZhciBmO2lmKHI9PT11bmRlZmluZWQmJnQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSl9ZWxzZSBpZih0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUscil9ZWxzZXtmPW5ldyBVaW50OEFycmF5KGUscix0KX1PYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn1mdW5jdGlvbiBmcm9tT2JqZWN0KGUpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7dmFyIHI9Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7aWYodC5sZW5ndGg9PT0wKXtyZXR1cm4gdH1lLmNvcHkodCwwLDAscik7cmV0dXJuIHR9aWYoZS5sZW5ndGghPT11bmRlZmluZWQpe2lmKHR5cGVvZiBlLmxlbmd0aCE9PVwibnVtYmVyXCJ8fG51bWJlcklzTmFOKGUubGVuZ3RoKSl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKX1yZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlLnR5cGU9PT1cIkJ1ZmZlclwiJiZBcnJheS5pc0FycmF5KGUuZGF0YSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUuZGF0YSl9fWZ1bmN0aW9uIGNoZWNrZWQoZSl7aWYoZT49byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIFwiK1wic2l6ZTogMHhcIitvLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKX1yZXR1cm4gZXwwfWZ1bmN0aW9uIFNsb3dCdWZmZXIoZSl7aWYoK2UhPWUpe2U9MH1yZXR1cm4gQnVmZmVyLmFsbG9jKCtlKX1CdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24gaXNCdWZmZXIoZSl7cmV0dXJuIGUhPW51bGwmJmUuX2lzQnVmZmVyPT09dHJ1ZSYmZSE9PUJ1ZmZlci5wcm90b3R5cGV9O0J1ZmZlci5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCk7aWYoaXNJbnN0YW5jZShyLFVpbnQ4QXJyYXkpKXI9QnVmZmVyLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpO2lmKCFCdWZmZXIuaXNCdWZmZXIoZSl8fCFCdWZmZXIuaXNCdWZmZXIocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKX1pZihlPT09cilyZXR1cm4gMDt2YXIgdD1lLmxlbmd0aDt2YXIgZj1yLmxlbmd0aDtmb3IodmFyIG49MCxpPU1hdGgubWluKHQsZik7bjxpOysrbil7aWYoZVtuXSE9PXJbbl0pe3Q9ZVtuXTtmPXJbbl07YnJlYWt9fWlmKHQ8ZilyZXR1cm4tMTtpZihmPHQpcmV0dXJuIDE7cmV0dXJuIDB9O0J1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uIGlzRW5jb2RpbmcoZSl7c3dpdGNoKFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07QnVmZmVyLmNvbmNhdD1mdW5jdGlvbiBjb25jYXQoZSxyKXtpZighQXJyYXkuaXNBcnJheShlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aWYoZS5sZW5ndGg9PT0wKXtyZXR1cm4gQnVmZmVyLmFsbG9jKDApfXZhciB0O2lmKHI9PT11bmRlZmluZWQpe3I9MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyKz1lW3RdLmxlbmd0aH19dmFyIGY9QnVmZmVyLmFsbG9jVW5zYWZlKHIpO3ZhciBuPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7dmFyIGk9ZVt0XTtpZihpc0luc3RhbmNlKGksVWludDhBcnJheSkpe2k9QnVmZmVyLmZyb20oaSl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihpKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aS5jb3B5KGYsbik7bis9aS5sZW5ndGh9cmV0dXJuIGZ9O2Z1bmN0aW9uIGJ5dGVMZW5ndGgoZSxyKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3JldHVybiBlLmxlbmd0aH1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcikpe3JldHVybiBlLmJ5dGVMZW5ndGh9aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfXZhciB0PWUubGVuZ3RoO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09dHJ1ZTtpZighZiYmdD09PTApcmV0dXJuIDA7dmFyIG49ZmFsc2U7Zm9yKDs7KXtzd2l0Y2gocil7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdDtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFRvQnl0ZXMoZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0KjI7Y2FzZVwiaGV4XCI6cmV0dXJuIHQ+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRUb0J5dGVzKGUpLmxlbmd0aDtkZWZhdWx0OmlmKG4pe3JldHVybiBmPy0xOnV0ZjhUb0J5dGVzKGUpLmxlbmd0aH1yPShcIlwiK3IpLnRvTG93ZXJDYXNlKCk7bj10cnVlfX19QnVmZmVyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtmdW5jdGlvbiBzbG93VG9TdHJpbmcoZSxyLHQpe3ZhciBmPWZhbHNlO2lmKHI9PT11bmRlZmluZWR8fHI8MCl7cj0wfWlmKHI+dGhpcy5sZW5ndGgpe3JldHVyblwiXCJ9aWYodD09PXVuZGVmaW5lZHx8dD50aGlzLmxlbmd0aCl7dD10aGlzLmxlbmd0aH1pZih0PD0wKXtyZXR1cm5cIlwifXQ+Pj49MDtyPj4+PTA7aWYodDw9cil7cmV0dXJuXCJcIn1pZighZSllPVwidXRmOFwiO3doaWxlKHRydWUpe3N3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4U2xpY2UodGhpcyxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4U2xpY2UodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpU2xpY2UodGhpcyxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMscix0KTtkZWZhdWx0OmlmKGYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2U9KGUrXCJcIikudG9Mb3dlckNhc2UoKTtmPXRydWV9fX1CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlcj10cnVlO2Z1bmN0aW9uIHN3YXAoZSxyLHQpe3ZhciBmPWVbcl07ZVtyXT1lW3RdO2VbdF09Zn1CdWZmZXIucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbiBzd2FwMTYoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTIhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz0yKXtzd2FwKHRoaXMscixyKzEpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbiBzd2FwMzIoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz00KXtzd2FwKHRoaXMscixyKzMpO3N3YXAodGhpcyxyKzEscisyKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24gc3dhcDY0KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU4IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9OCl7c3dhcCh0aGlzLHIscis3KTtzd2FwKHRoaXMscisxLHIrNik7c3dhcCh0aGlzLHIrMixyKzUpO3N3YXAodGhpcyxyKzMscis0KX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGU9PT0wKXJldHVyblwiXCI7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHV0ZjhTbGljZSh0aGlzLDAsZSk7cmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0J1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbiBlcXVhbHMoZSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih0aGlzPT09ZSlyZXR1cm4gdHJ1ZTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxlKT09PTB9O0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7dmFyIGU9XCJcIjt2YXIgdD1yLklOU1BFQ1RfTUFYX0JZVEVTO2U9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpO2lmKHRoaXMubGVuZ3RoPnQpZSs9XCIgLi4uIFwiO3JldHVyblwiPEJ1ZmZlciBcIitlK1wiPlwifTtpZihpKXtCdWZmZXIucHJvdG90eXBlW2ldPUJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdH1CdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIsdCxmLG4pe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSl7ZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKHI9PT11bmRlZmluZWQpe3I9MH1pZih0PT09dW5kZWZpbmVkKXt0PWU/ZS5sZW5ndGg6MH1pZihmPT09dW5kZWZpbmVkKXtmPTB9aWYobj09PXVuZGVmaW5lZCl7bj10aGlzLmxlbmd0aH1pZihyPDB8fHQ+ZS5sZW5ndGh8fGY8MHx8bj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYoZj49biYmcj49dCl7cmV0dXJuIDB9aWYoZj49bil7cmV0dXJuLTF9aWYocj49dCl7cmV0dXJuIDF9cj4+Pj0wO3Q+Pj49MDtmPj4+PTA7bj4+Pj0wO2lmKHRoaXM9PT1lKXJldHVybiAwO3ZhciBpPW4tZjt2YXIgbz10LXI7dmFyIHU9TWF0aC5taW4oaSxvKTt2YXIgYT10aGlzLnNsaWNlKGYsbik7dmFyIHM9ZS5zbGljZShyLHQpO2Zvcih2YXIgaD0wO2g8dTsrK2gpe2lmKGFbaF0hPT1zW2hdKXtpPWFbaF07bz1zW2hdO2JyZWFrfX1pZihpPG8pcmV0dXJuLTE7aWYobzxpKXJldHVybiAxO3JldHVybiAwfTtmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihlLHIsdCxmLG4pe2lmKGUubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PTB9ZWxzZSBpZih0PjIxNDc0ODM2NDcpe3Q9MjE0NzQ4MzY0N31lbHNlIGlmKHQ8LTIxNDc0ODM2NDgpe3Q9LTIxNDc0ODM2NDh9dD0rdDtpZihudW1iZXJJc05hTih0KSl7dD1uPzA6ZS5sZW5ndGgtMX1pZih0PDApdD1lLmxlbmd0aCt0O2lmKHQ+PWUubGVuZ3RoKXtpZihuKXJldHVybi0xO2Vsc2UgdD1lLmxlbmd0aC0xfWVsc2UgaWYodDwwKXtpZihuKXQ9MDtlbHNlIHJldHVybi0xfWlmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7cj1CdWZmZXIuZnJvbShyLGYpfWlmKEJ1ZmZlci5pc0J1ZmZlcihyKSl7aWYoci5sZW5ndGg9PT0wKXtyZXR1cm4tMX1yZXR1cm4gYXJyYXlJbmRleE9mKGUscix0LGYsbil9ZWxzZSBpZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe3I9ciYyNTU7aWYodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PT1cImZ1bmN0aW9uXCIpe2lmKG4pe3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZSxyLHQpfWVsc2V7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoZSxyLHQpfX1yZXR1cm4gYXJyYXlJbmRleE9mKGUsW3JdLHQsZixuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pe3ZhciBpPTE7dmFyIG89ZS5sZW5ndGg7dmFyIHU9ci5sZW5ndGg7aWYoZiE9PXVuZGVmaW5lZCl7Zj1TdHJpbmcoZikudG9Mb3dlckNhc2UoKTtpZihmPT09XCJ1Y3MyXCJ8fGY9PT1cInVjcy0yXCJ8fGY9PT1cInV0ZjE2bGVcInx8Zj09PVwidXRmLTE2bGVcIil7aWYoZS5sZW5ndGg8Mnx8ci5sZW5ndGg8Mil7cmV0dXJuLTF9aT0yO28vPTI7dS89Mjt0Lz0yfX1mdW5jdGlvbiByZWFkKGUscil7aWYoaT09PTEpe3JldHVybiBlW3JdfWVsc2V7cmV0dXJuIGUucmVhZFVJbnQxNkJFKHIqaSl9fXZhciBhO2lmKG4pe3ZhciBzPS0xO2ZvcihhPXQ7YTxvO2ErKyl7aWYocmVhZChlLGEpPT09cmVhZChyLHM9PT0tMT8wOmEtcykpe2lmKHM9PT0tMSlzPWE7aWYoYS1zKzE9PT11KXJldHVybiBzKml9ZWxzZXtpZihzIT09LTEpYS09YS1zO3M9LTF9fX1lbHNle2lmKHQrdT5vKXQ9by11O2ZvcihhPXQ7YT49MDthLS0pe3ZhciBoPXRydWU7Zm9yKHZhciBjPTA7Yzx1O2MrKyl7aWYocmVhZChlLGErYykhPT1yZWFkKHIsYykpe2g9ZmFsc2U7YnJlYWt9fWlmKGgpcmV0dXJuIGF9fXJldHVybi0xfUJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24gaW5jbHVkZXMoZSxyLHQpe3JldHVybiB0aGlzLmluZGV4T2YoZSxyLHQpIT09LTF9O0J1ZmZlci5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbiBpbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCx0cnVlKX07QnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbiBsYXN0SW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsZmFsc2UpfTtmdW5jdGlvbiBoZXhXcml0ZShlLHIsdCxmKXt0PU51bWJlcih0KXx8MDt2YXIgbj1lLmxlbmd0aC10O2lmKCFmKXtmPW59ZWxzZXtmPU51bWJlcihmKTtpZihmPm4pe2Y9bn19dmFyIGk9ci5sZW5ndGg7aWYoZj5pLzIpe2Y9aS8yfWZvcih2YXIgbz0wO288ZjsrK28pe3ZhciB1PXBhcnNlSW50KHIuc3Vic3RyKG8qMiwyKSwxNik7aWYobnVtYmVySXNOYU4odSkpcmV0dXJuIG87ZVt0K29dPXV9cmV0dXJuIG99ZnVuY3Rpb24gdXRmOFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfWZ1bmN0aW9uIGFzY2lpV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiBsYXRpbjFXcml0ZShlLHIsdCxmKXtyZXR1cm4gYXNjaWlXcml0ZShlLHIsdCxmKX1mdW5jdGlvbiBiYXNlNjRXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiB1Y3MyV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbiB3cml0ZShlLHIsdCxmKXtpZihyPT09dW5kZWZpbmVkKXtmPVwidXRmOFwiO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYodD09PXVuZGVmaW5lZCYmdHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZihpc0Zpbml0ZShyKSl7cj1yPj4+MDtpZihpc0Zpbml0ZSh0KSl7dD10Pj4+MDtpZihmPT09dW5kZWZpbmVkKWY9XCJ1dGY4XCJ9ZWxzZXtmPXQ7dD11bmRlZmluZWR9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIil9dmFyIG49dGhpcy5sZW5ndGgtcjtpZih0PT09dW5kZWZpbmVkfHx0Pm4pdD1uO2lmKGUubGVuZ3RoPjAmJih0PDB8fHI8MCl8fHI+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIil9aWYoIWYpZj1cInV0ZjhcIjt2YXIgaT1mYWxzZTtmb3IoOzspe3N3aXRjaChmKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHVjczJXcml0ZSh0aGlzLGUscix0KTtkZWZhdWx0OmlmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpO2Y9KFwiXCIrZikudG9Mb3dlckNhc2UoKTtpPXRydWV9fX07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGUscix0KXtpZihyPT09MCYmdD09PWUubGVuZ3RoKXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUpfWVsc2V7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHIsdCkpfX1mdW5jdGlvbiB1dGY4U2xpY2UoZSxyLHQpe3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7dmFyIGY9W107dmFyIG49cjt3aGlsZShuPHQpe3ZhciBpPWVbbl07dmFyIG89bnVsbDt2YXIgdT1pPjIzOT80Omk+MjIzPzM6aT4xOTE/MjoxO2lmKG4rdTw9dCl7dmFyIGEscyxoLGM7c3dpdGNoKHUpe2Nhc2UgMTppZihpPDEyOCl7bz1pfWJyZWFrO2Nhc2UgMjphPWVbbisxXTtpZigoYSYxOTIpPT09MTI4KXtjPShpJjMxKTw8NnxhJjYzO2lmKGM+MTI3KXtvPWN9fWJyZWFrO2Nhc2UgMzphPWVbbisxXTtzPWVbbisyXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTJ8KGEmNjMpPDw2fHMmNjM7aWYoYz4yMDQ3JiYoYzw1NTI5Nnx8Yz41NzM0Mykpe289Y319YnJlYWs7Y2FzZSA0OmE9ZVtuKzFdO3M9ZVtuKzJdO2g9ZVtuKzNdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihoJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxOHwoYSY2Myk8PDEyfChzJjYzKTw8NnxoJjYzO2lmKGM+NjU1MzUmJmM8MTExNDExMil7bz1jfX19fWlmKG89PT1udWxsKXtvPTY1NTMzO3U9MX1lbHNlIGlmKG8+NjU1MzUpe28tPTY1NTM2O2YucHVzaChvPj4+MTAmMTAyM3w1NTI5Nik7bz01NjMyMHxvJjEwMjN9Zi5wdXNoKG8pO24rPXV9cmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShmKX12YXIgdT00MDk2O2Z1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShlKXt2YXIgcj1lLmxlbmd0aDtpZihyPD11KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSl9dmFyIHQ9XCJcIjt2YXIgZj0wO3doaWxlKGY8cil7dCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShmLGYrPXUpKX1yZXR1cm4gdH1mdW5jdGlvbiBhc2NpaVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dJjEyNyl9cmV0dXJuIGZ9ZnVuY3Rpb24gbGF0aW4xU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0pfXJldHVybiBmfWZ1bmN0aW9uIGhleFNsaWNlKGUscix0KXt2YXIgZj1lLmxlbmd0aDtpZighcnx8cjwwKXI9MDtpZighdHx8dDwwfHx0PmYpdD1mO3ZhciBuPVwiXCI7Zm9yKHZhciBpPXI7aTx0OysraSl7bis9c1tlW2ldXX1yZXR1cm4gbn1mdW5jdGlvbiB1dGYxNmxlU2xpY2UoZSxyLHQpe3ZhciBmPWUuc2xpY2Uocix0KTt2YXIgbj1cIlwiO2Zvcih2YXIgaT0wO2k8Zi5sZW5ndGg7aSs9Mil7bis9U3RyaW5nLmZyb21DaGFyQ29kZShmW2ldK2ZbaSsxXSoyNTYpfXJldHVybiBufUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24gc2xpY2UoZSxyKXt2YXIgdD10aGlzLmxlbmd0aDtlPX5+ZTtyPXI9PT11bmRlZmluZWQ/dDp+fnI7aWYoZTwwKXtlKz10O2lmKGU8MCllPTB9ZWxzZSBpZihlPnQpe2U9dH1pZihyPDApe3IrPXQ7aWYocjwwKXI9MH1lbHNlIGlmKHI+dCl7cj10fWlmKHI8ZSlyPWU7dmFyIGY9dGhpcy5zdWJhcnJheShlLHIpO09iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfTtmdW5jdGlvbiBjaGVja09mZnNldChlLHIsdCl7aWYoZSUxIT09MHx8ZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24gcmVhZFVJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uIHJlYWRVSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCl7Y2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKX12YXIgZj10aGlzW2UrLS1yXTt2YXIgbj0xO3doaWxlKHI+MCYmKG4qPTI1Nikpe2YrPXRoaXNbZSstLXJdKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uIHJlYWRVSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24gcmVhZFVJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OH07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24gcmVhZFVJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDw4fHRoaXNbZSsxXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24gcmVhZFVJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybih0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2KSt0aGlzW2UrM10qMTY3NzcyMTZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uIHJlYWRVSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXSoxNjc3NzIxNisodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24gcmVhZEludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufW4qPTEyODtpZihmPj1uKWYtPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24gcmVhZEludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj1yO3ZhciBuPTE7dmFyIGk9dGhpc1tlKy0tZl07d2hpbGUoZj4wJiYobio9MjU2KSl7aSs9dGhpc1tlKy0tZl0qbn1uKj0xMjg7aWYoaT49bilpLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24gcmVhZEludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7aWYoISh0aGlzW2VdJjEyOCkpcmV0dXJuIHRoaXNbZV07cmV0dXJuKDI1NS10aGlzW2VdKzEpKi0xfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uIHJlYWRJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uIHJlYWRJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uIHJlYWRJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24gcmVhZEludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbiByZWFkRmxvYXRMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uIHJlYWRGbG9hdEJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbiByZWFkRG91YmxlTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSw1Miw4KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24gcmVhZERvdWJsZUJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDUyLDgpfTtmdW5jdGlvbiBjaGVja0ludChlLHIsdCxmLG4saSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihyPm58fHI8aSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbiB3cml0ZVVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPTE7dmFyIG89MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsrbzx0JiYoaSo9MjU2KSl7dGhpc1tyK29dPWUvaSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbiB3cml0ZVVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPXQtMTt2YXIgbz0xO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXt0aGlzW3IraV09ZS9vJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24gd3JpdGVVSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMjU1LDApO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlVUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24gd3JpdGVVSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3IrM109ZT4+PjI0O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlVUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbiB3cml0ZUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPTA7dmFyIG89MTt2YXIgdT0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytpPHQmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraS0xXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uIHdyaXRlSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9dC0xO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2krMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uIHdyaXRlSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMTI3LC0xMjgpO2lmKGU8MCllPTI1NStlKzE7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbiB3cml0ZUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24gd3JpdGVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrM109ZT4+PjI0O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7aWYoZTwwKWU9NDI5NDk2NzI5NStlKzE7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O2Z1bmN0aW9uIGNoZWNrSUVFRTc1NChlLHIsdCxmLG4saSl7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiB3cml0ZUZsb2F0KGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsNCwzNDAyODIzNDY2Mzg1Mjg4NmUyMiwtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpfW4ud3JpdGUoZSxyLHQsZiwyMyw0KTtyZXR1cm4gdCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uIHdyaXRlRmxvYXRMRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24gd3JpdGVGbG9hdEJFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscixmYWxzZSx0KX07ZnVuY3Rpb24gd3JpdGVEb3VibGUoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw4LDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKX1uLndyaXRlKGUscix0LGYsNTIsOCk7cmV0dXJuIHQrOH1CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24gd3JpdGVEb3VibGVMRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbiB3cml0ZURvdWJsZUJFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsZmFsc2UsdCl9O0J1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KGUscix0LGYpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZighdCl0PTA7aWYoIWYmJmYhPT0wKWY9dGhpcy5sZW5ndGg7aWYocj49ZS5sZW5ndGgpcj1lLmxlbmd0aDtpZighcilyPTA7aWYoZj4wJiZmPHQpZj10O2lmKGY9PT10KXJldHVybiAwO2lmKGUubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKHI8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpfWlmKHQ8MHx8dD49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoZjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7aWYoZj50aGlzLmxlbmd0aClmPXRoaXMubGVuZ3RoO2lmKGUubGVuZ3RoLXI8Zi10KXtmPWUubGVuZ3RoLXIrdH12YXIgbj1mLXQ7aWYodGhpcz09PWUmJnR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluPT09XCJmdW5jdGlvblwiKXt0aGlzLmNvcHlXaXRoaW4ocix0LGYpfWVsc2UgaWYodGhpcz09PWUmJnQ8ciYmcjxmKXtmb3IodmFyIGk9bi0xO2k+PTA7LS1pKXtlW2krcl09dGhpc1tpK3RdfX1lbHNle1VpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheSh0LGYpLHIpfXJldHVybiBufTtCdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24gZmlsbChlLHIsdCxmKXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3I9MDt0PXRoaXMubGVuZ3RofWVsc2UgaWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD10aGlzLmxlbmd0aH1pZihmIT09dW5kZWZpbmVkJiZ0eXBlb2YgZiE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpfWlmKHR5cGVvZiBmPT09XCJzdHJpbmdcIiYmIUJ1ZmZlci5pc0VuY29kaW5nKGYpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZil9aWYoZS5sZW5ndGg9PT0xKXt2YXIgbj1lLmNoYXJDb2RlQXQoMCk7aWYoZj09PVwidXRmOFwiJiZuPDEyOHx8Zj09PVwibGF0aW4xXCIpe2U9bn19fWVsc2UgaWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtlPWUmMjU1fWVsc2UgaWYodHlwZW9mIGU9PT1cImJvb2xlYW5cIil7ZT1OdW1iZXIoZSl9aWYocjwwfHx0aGlzLmxlbmd0aDxyfHx0aGlzLmxlbmd0aDx0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKX1pZih0PD1yKXtyZXR1cm4gdGhpc31yPXI+Pj4wO3Q9dD09PXVuZGVmaW5lZD90aGlzLmxlbmd0aDp0Pj4+MDtpZighZSllPTA7dmFyIGk7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtmb3IoaT1yO2k8dDsrK2kpe3RoaXNbaV09ZX19ZWxzZXt2YXIgbz1CdWZmZXIuaXNCdWZmZXIoZSk/ZTpCdWZmZXIuZnJvbShlLGYpO3ZhciB1PW8ubGVuZ3RoO2lmKHU9PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpfWZvcihpPTA7aTx0LXI7KytpKXt0aGlzW2krcl09b1tpJXVdfX1yZXR1cm4gdGhpc307dmFyIGE9L1teKy8wLTlBLVphLXotX10vZztmdW5jdGlvbiBiYXNlNjRjbGVhbihlKXtlPWUuc3BsaXQoXCI9XCIpWzBdO2U9ZS50cmltKCkucmVwbGFjZShhLFwiXCIpO2lmKGUubGVuZ3RoPDIpcmV0dXJuXCJcIjt3aGlsZShlLmxlbmd0aCU0IT09MCl7ZT1lK1wiPVwifXJldHVybiBlfWZ1bmN0aW9uIHV0ZjhUb0J5dGVzKGUscil7cj1yfHxJbmZpbml0eTt2YXIgdDt2YXIgZj1lLmxlbmd0aDt2YXIgbj1udWxsO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZjsrK28pe3Q9ZS5jaGFyQ29kZUF0KG8pO2lmKHQ+NTUyOTUmJnQ8NTczNDQpe2lmKCFuKXtpZih0PjU2MzE5KXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lbHNlIGlmKG8rMT09PWYpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfW49dDtjb250aW51ZX1pZih0PDU2MzIwKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtuPXQ7Y29udGludWV9dD0obi01NTI5Njw8MTB8dC01NjMyMCkrNjU1MzZ9ZWxzZSBpZihuKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KX1uPW51bGw7aWYodDwxMjgpe2lmKChyLT0xKTwwKWJyZWFrO2kucHVzaCh0KX1lbHNlIGlmKHQ8MjA0OCl7aWYoKHItPTIpPDApYnJlYWs7aS5wdXNoKHQ+PjZ8MTkyLHQmNjN8MTI4KX1lbHNlIGlmKHQ8NjU1MzYpe2lmKChyLT0zKTwwKWJyZWFrO2kucHVzaCh0Pj4xMnwyMjQsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2UgaWYodDwxMTE0MTEyKXtpZigoci09NCk8MClicmVhaztpLnB1c2godD4+MTh8MjQwLHQ+PjEyJjYzfDEyOCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIil9fXJldHVybiBpfWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhlKXt2YXIgcj1bXTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCl7ci5wdXNoKGUuY2hhckNvZGVBdCh0KSYyNTUpfXJldHVybiByfWZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKGUscil7dmFyIHQsZixuO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXtpZigoci09Mik8MClicmVhazt0PWUuY2hhckNvZGVBdChvKTtmPXQ+Pjg7bj10JTI1NjtpLnB1c2gobik7aS5wdXNoKGYpfXJldHVybiBpfWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoZSl7cmV0dXJuIGYudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oZSkpfWZ1bmN0aW9uIGJsaXRCdWZmZXIoZSxyLHQsZil7Zm9yKHZhciBuPTA7bjxmOysrbil7aWYobit0Pj1yLmxlbmd0aHx8bj49ZS5sZW5ndGgpYnJlYWs7cltuK3RdPWVbbl19cmV0dXJuIG59ZnVuY3Rpb24gaXNJbnN0YW5jZShlLHIpe3JldHVybiBlIGluc3RhbmNlb2Ygcnx8ZSE9bnVsbCYmZS5jb25zdHJ1Y3RvciE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWU9PT1yLm5hbWV9ZnVuY3Rpb24gbnVtYmVySXNOYU4oZSl7cmV0dXJuIGUhPT1lfXZhciBzPWZ1bmN0aW9uKCl7dmFyIGU9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7dmFyIHI9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciB0PTA7dDwxNjsrK3Qpe3ZhciBmPXQqMTY7Zm9yKHZhciBuPTA7bjwxNjsrK24pe3JbZituXT1lW3RdK2Vbbl19fXJldHVybiByfSgpfSw3ODM6ZnVuY3Rpb24oZSxyKXtcbi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5yLnJlYWQ9ZnVuY3Rpb24oZSxyLHQsZixuKXt2YXIgaSxvO3ZhciB1PW4qOC1mLTE7dmFyIGE9KDE8PHUpLTE7dmFyIHM9YT4+MTt2YXIgaD0tNzt2YXIgYz10P24tMTowO3ZhciBsPXQ/LTE6MTt2YXIgcD1lW3IrY107Yys9bDtpPXAmKDE8PC1oKS0xO3A+Pj0taDtoKz11O2Zvcig7aD4wO2k9aSoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fW89aSYoMTw8LWgpLTE7aT4+PS1oO2grPWY7Zm9yKDtoPjA7bz1vKjI1NitlW3IrY10sYys9bCxoLT04KXt9aWYoaT09PTApe2k9MS1zfWVsc2UgaWYoaT09PWEpe3JldHVybiBvP05hTjoocD8tMToxKSpJbmZpbml0eX1lbHNle289bytNYXRoLnBvdygyLGYpO2k9aS1zfXJldHVybihwPy0xOjEpKm8qTWF0aC5wb3coMixpLWYpfTtyLndyaXRlPWZ1bmN0aW9uKGUscix0LGYsbixpKXt2YXIgbyx1LGE7dmFyIHM9aSo4LW4tMTt2YXIgaD0oMTw8cyktMTt2YXIgYz1oPj4xO3ZhciBsPW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjA7dmFyIHA9Zj8wOmktMTt2YXIgeT1mPzE6LTE7dmFyIGc9cjwwfHxyPT09MCYmMS9yPDA/MTowO3I9TWF0aC5hYnMocik7aWYoaXNOYU4ocil8fHI9PT1JbmZpbml0eSl7dT1pc05hTihyKT8xOjA7bz1ofWVsc2V7bz1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTtpZihyKihhPU1hdGgucG93KDIsLW8pKTwxKXtvLS07YSo9Mn1pZihvK2M+PTEpe3IrPWwvYX1lbHNle3IrPWwqTWF0aC5wb3coMiwxLWMpfWlmKHIqYT49Mil7bysrO2EvPTJ9aWYobytjPj1oKXt1PTA7bz1ofWVsc2UgaWYobytjPj0xKXt1PShyKmEtMSkqTWF0aC5wb3coMixuKTtvPW8rY31lbHNle3U9cipNYXRoLnBvdygyLGMtMSkqTWF0aC5wb3coMixuKTtvPTB9fWZvcig7bj49ODtlW3QrcF09dSYyNTUscCs9eSx1Lz0yNTYsbi09OCl7fW89bzw8bnx1O3MrPW47Zm9yKDtzPjA7ZVt0K3BdPW8mMjU1LHArPXksby89MjU2LHMtPTgpe31lW3QrcC15XXw9ZyoxMjh9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgZj1yW3RdO2lmKGYhPT11bmRlZmluZWQpe3JldHVybiBmLmV4cG9ydHN9dmFyIG49clt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgclt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDcyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/picomatch/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxlQUFlLHFCQUFxQix1REFBdUQseUNBQXlDLGtDQUFrQyxVQUFVLE9BQU8sZ0JBQWdCLE9BQU8sV0FBVyxPQUFPLE9BQU8sb0JBQW9CLGNBQWMsZ0NBQWdDLGlEQUFpRCxHQUFHLDBCQUEwQixnQkFBZ0IsMkJBQTJCLG9CQUFvQixTQUFTLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFlBQVksU0FBUyx3TUFBd00sU0FBUyx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMkJBQTJCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLFNBQVMseUxBQXlMLGFBQWEsRUFBRSw4RUFBOEUsV0FBVyxzRUFBc0UscURBQXFELHlDQUF5QyxnR0FBZ0csNEVBQTRFLHVDQUF1QyxtM0JBQW0zQixPQUFPLEtBQUssMENBQTBDLE9BQU8sR0FBRyxNQUFNLG1DQUFtQyxNQUFNLGtDQUFrQyxNQUFNLGtDQUFrQyxNQUFNLGlDQUFpQyxjQUFjLHNCQUFzQixlQUFlLGVBQWUsY0FBYyxNQUFNLHlHQUF5RyxHQUFHLDBCQUEwQixzQ0FBc0MsNkJBQTZCLFNBQVMsWUFBWSxZQUFZLEdBQUcsSUFBSSxjQUFjLFNBQVMsK0NBQStDLFVBQVUsb0NBQW9DLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSwrQkFBK0Isb0JBQW9CLHdCQUF3Qix5Q0FBeUMsVUFBVSxTQUFTLE1BQU0sZ0VBQWdFLGVBQWUsUUFBUSx1Q0FBdUMsRUFBRSxvQ0FBb0MsRUFBRSxHQUFHLFNBQVMsMENBQTBDLFlBQVksMEJBQTBCLCtCQUErQiwwQkFBMEIsTUFBTSwwSkFBMEosR0FBRyxzQkFBc0IsRUFBRSxRQUFRLEVBQUUsRUFBRSxVQUFVLFFBQVEsbUJBQW1CLGtCQUFrQixrQ0FBa0MsY0FBYyxNQUFNLEVBQUUsR0FBRywrQkFBK0Isb0JBQW9CLFNBQVMsdUtBQXVLLHNCQUFzQixXQUFXLFdBQVcsV0FBVyxXQUFXLFFBQVEsTUFBTSw0QkFBNEIsbUNBQW1DLHVDQUF1Qyx1Q0FBdUMsMkJBQTJCLGNBQWMsWUFBWSxpQkFBaUIsMENBQTBDLGtCQUFrQixrQkFBa0IsUUFBUSwyQ0FBMkMsSUFBSSxVQUFVLElBQUksWUFBWSxhQUFhLGVBQWUsVUFBVSxhQUFhLG9CQUFvQixPQUFPLFdBQVcsb0JBQW9CLE9BQU8sU0FBUyxlQUFlLHdCQUF3Qix5REFBeUQsd0VBQXdFLCtDQUErQyw0Q0FBNEMsY0FBYyxZQUFZLFdBQVcsb0JBQW9CLCtCQUErQiw2QkFBNkIsK0JBQStCLHdDQUF3QyxxQ0FBcUMsaUJBQWlCLE9BQU8sU0FBUyxVQUFVLEtBQUssMEJBQTBCLFNBQVMsK0JBQStCLFNBQVMsa0JBQWtCLGtCQUFrQixrQ0FBa0Msb0JBQW9CLE1BQU0sb0NBQW9DLEVBQUUsTUFBTSw2Q0FBNkMsRUFBRSxXQUFXLHVCQUF1QixpQ0FBaUMsTUFBTSxzQkFBc0IsUUFBUSxxREFBcUQsY0FBYyw0Q0FBNEMsaUJBQWlCLEVBQUUsRUFBRSxtRUFBbUUsaUJBQWlCLHFCQUFxQixTQUFTLGNBQWMsRUFBRSxHQUFHLEVBQUUsR0FBRyx3QkFBd0IsdUJBQXVCLE1BQU0sMkNBQTJDLEVBQUUscUJBQXFCLDBDQUEwQyxjQUFjLFlBQVksbUNBQW1DLGFBQWEsT0FBTyxTQUFTLFlBQVksTUFBTSxxQ0FBcUMsVUFBVSxtQ0FBbUMsMEJBQTBCLFlBQVksMEJBQTBCLFlBQVksTUFBTSxvQkFBb0IsU0FBUyxnQkFBZ0IsRUFBRSxFQUFFLEdBQUcsYUFBYSxzQkFBc0Isc0JBQXNCLEtBQUssMERBQTBELDZCQUE2QixXQUFXLFNBQVMsNkJBQTZCLFNBQVMsY0FBYyxNQUFNLGFBQWEsU0FBUyxhQUFhLFlBQVksMkJBQTJCLFNBQVMsa0JBQWtCLEdBQUcsU0FBUyxPQUFPLFFBQVEsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLGlDQUFpQyxRQUFRLHFCQUFxQixjQUFjLFdBQVcsWUFBWSxTQUFTLHNCQUFzQixNQUFNLEtBQUssT0FBTyxtQkFBbUIsTUFBTSxvQkFBb0IsRUFBRSxVQUFVLDJEQUEyRCw2QkFBNkIseUJBQXlCLG9CQUFvQixhQUFhLG9CQUFvQixpQ0FBaUMsMkJBQTJCLDJCQUEyQixhQUFhLE1BQU0sWUFBWSxpQkFBaUIsSUFBSSxnQ0FBZ0MsV0FBVyxZQUFZLDJDQUEyQyxPQUFPLEVBQUUsRUFBRSw2Q0FBNkMsT0FBTyxFQUFFLEVBQUUsMkNBQTJDLE1BQU0sV0FBVyxRQUFRLFFBQVEsRUFBRSxTQUFTLDBCQUEwQixtQkFBbUIsV0FBVyxRQUFRLFFBQVEsRUFBRSxTQUFTLFlBQVksMEJBQTBCLHdCQUF3QixNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSxvQkFBb0IsTUFBTSxxQkFBcUIsRUFBRSxTQUFTLFlBQVksMENBQTBDLGtEQUFrRCxzQkFBc0IsNkJBQTZCLHNCQUFzQixTQUFTLE1BQU0sK0NBQStDLEVBQUUsb0JBQW9CLFNBQVMsWUFBWSxtREFBbUQsZ0RBQWdELGtEQUFrRCxPQUFPLEVBQUUsRUFBRSxLQUFLLHNCQUFzQixNQUFNLHVCQUF1QixFQUFFLFNBQVMsWUFBWSxrRUFBa0UsTUFBTSxnQ0FBZ0MsRUFBRSxFQUFFLEVBQUUsU0FBUyxtQkFBbUIsNEJBQTRCLGtEQUFrRCxNQUFNLGdDQUFnQyxFQUFFLEVBQUUsRUFBRSxTQUFTLHNCQUFzQix5QkFBeUIsaURBQWlELE1BQU0sRUFBRSxFQUFFLFdBQVcsUUFBUSxRQUFRLEVBQUUsa0RBQWtELFNBQVMsK0JBQStCLDJDQUEyQyw2QkFBNkIsWUFBWSxVQUFVLFNBQVMsWUFBWSxFQUFFLEVBQUUsRUFBRSxHQUFHLFFBQVEsR0FBRyxrQkFBa0IsU0FBUyxTQUFTLHFCQUFxQixvQkFBb0IsU0FBUyx5RkFBeUYsVUFBVSxRQUFRLFNBQVMsU0FBUyxHQUFHLHNCQUFzQix5QkFBeUIsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLFVBQVUsa0JBQWtCLGtCQUFrQixXQUFXLHFCQUFxQixLQUFLLEtBQUssUUFBUSx3QkFBd0IsTUFBTSx1QkFBdUIsdUJBQXVCLG1CQUFtQixpQkFBaUIsa0NBQWtDLHdDQUF3QyxzQ0FBc0MscUJBQXFCLEVBQUUsUUFBUSxFQUFFLFdBQVcsa0JBQWtCLDZCQUE2QixNQUFNLDhCQUE4QixFQUFFLG9CQUFvQixRQUFRLFNBQVMsWUFBWSxlQUFlLDJCQUEyQixNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSxRQUFRLHNCQUFzQixnQ0FBZ0MsYUFBYSxNQUFNLE1BQU0sOEJBQThCLEVBQUUsU0FBUyxZQUFZLHdDQUF3QyxrQkFBa0IsY0FBYyxZQUFZLFFBQVEsSUFBSSxTQUFTLE1BQU0sOEJBQThCLEVBQUUsU0FBUyxZQUFZLCtCQUErQiw0QkFBNEIsc0JBQXNCLGNBQWMsWUFBWSxXQUFXLFlBQVksU0FBUyw0REFBNEQsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLE1BQU0sNEJBQTRCLEVBQUUsU0FBUyxZQUFZLHlCQUF5QixrREFBa0QsdUJBQXVCLFNBQVMsd0JBQXdCLFlBQVksUUFBUSxpRkFBaUYsT0FBTyxFQUFFLEVBQUUsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLHFEQUFxRCxNQUFNLDhCQUE4QixFQUFFLFNBQVMsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLFlBQVksa0NBQWtDLHFDQUFxQyx3QkFBd0IsVUFBVSxtQ0FBbUMsU0FBUyxVQUFVLFlBQVksOENBQThDLHNCQUFzQixTQUFTLHNDQUFzQyxNQUFNLDZCQUE2QixFQUFFLFNBQVMsNEVBQTRFLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSw4Q0FBOEMsTUFBTSx5Q0FBeUMsRUFBRSxTQUFTLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxZQUFZLHFCQUFxQixPQUFPLEVBQUUsRUFBRSw0QkFBNEIsTUFBTSxRQUFRLHFCQUFxQixNQUFNLG9CQUFvQixFQUFFLFNBQVMsNENBQTRDLGNBQWMsWUFBWSxXQUFXLFdBQVcsaUJBQWlCLGdCQUFnQixXQUFXLFNBQVMsa0JBQWtCLDBDQUEwQyxzQkFBc0IsU0FBUyxvQkFBb0Isd0JBQXdCLFdBQVcsU0FBUyxlQUFlLGVBQWUseUNBQXlDLGtEQUFrRCwwQ0FBMEMsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLHlEQUF5RCxzREFBc0QsaUNBQWlDLE1BQU0sOEJBQThCLEVBQUUsU0FBUyw0QkFBNEIscUJBQXFCLGVBQWUsTUFBTSxhQUFhLGlCQUFpQiwwQkFBMEIsa0JBQWtCLFdBQVcscUJBQXFCLGtCQUFrQixnQkFBZ0IsV0FBVyxTQUFTLHFEQUFxRCx1REFBdUQsZUFBZSxTQUFTLEVBQUUsa0JBQWtCLGlEQUFpRCxXQUFXLGdCQUFnQiw0QkFBNEIsV0FBVyxTQUFTLHNEQUFzRCw4QkFBOEIsdURBQXVELGVBQWUsU0FBUyxFQUFFLGtCQUFrQixZQUFZLFlBQVksRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxXQUFXLDRCQUE0QixnQkFBZ0IsZUFBZSxNQUFNLGlDQUFpQyxFQUFFLFNBQVMsK0JBQStCLGtCQUFrQixXQUFXLGlCQUFpQixFQUFFLEdBQUcsWUFBWSxFQUFFLEVBQUUsR0FBRyxrQkFBa0IsZ0JBQWdCLGVBQWUsTUFBTSxpQ0FBaUMsRUFBRSxTQUFTLDRDQUE0QyxrQkFBa0IscUJBQXFCLFdBQVcsbUJBQW1CLGdCQUFnQixXQUFXLFNBQVMsU0FBUyw4QkFBOEIsa0JBQWtCLGVBQWUscUNBQXFDLG9CQUFvQixRQUFRLFNBQVMsOERBQThELFdBQVcsUUFBUSxTQUFTLHdEQUF3RCxtQkFBbUIsWUFBWSxZQUFZLHNCQUFzQixZQUFZLFlBQVksS0FBSyxZQUFZLFlBQVksY0FBYyxZQUFZLGFBQWEsUUFBUSxvQkFBb0IsNkVBQTZFLG9DQUFvQyxzQkFBc0Isa0JBQWtCLDZFQUE2RSxvQ0FBb0Msb0JBQW9CLGtCQUFrQix5RUFBeUUsSUFBSSxpQ0FBaUMsR0FBRyxvQkFBb0Isa0VBQWtFLE1BQU0sc0NBQXNDLEVBQUUsR0FBRyxFQUFFLHVCQUF1QixZQUFZLHlCQUF5QiwwQ0FBMEMsYUFBYSxxQkFBcUIsVUFBVSx3QkFBd0IsU0FBUyxNQUFNLGdFQUFnRSxpQkFBaUIsUUFBUSx1Q0FBdUMsRUFBRSxvQ0FBb0MsRUFBRSxHQUFHLFVBQVUsTUFBTSwrR0FBK0csd0JBQXdCLGtCQUFrQixrQkFBa0IsMEJBQTBCLFNBQVMseUJBQXlCLDRCQUE0QixjQUFjLE1BQU0sRUFBRSxHQUFHLG1CQUFtQixnQ0FBZ0MsVUFBVSxFQUFFLFFBQVEsRUFBRSxFQUFFLFVBQVUsU0FBUyxpQkFBaUIsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSw4QkFBOEIsdUJBQXVCLEVBQUUsRUFBRSxZQUFZLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLHlCQUF5QixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLHdCQUF3QixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxTQUFTLGlDQUFpQyxhQUFhLHFCQUFxQixhQUFhLG1CQUFtQiw0QkFBNEIsZ0JBQWdCLDhCQUE4QixNQUFNLEVBQUUsR0FBRyxVQUFVLGdCQUFnQixlQUFlLGVBQWUsZUFBZSxjQUFjLGVBQWUsNERBQTRELGdDQUFnQyxxQkFBcUIscUNBQXFDLHVCQUF1QixrQkFBa0IsYUFBYSxjQUFjLGNBQWMsb0JBQW9CLHVDQUF1QyxvQ0FBb0MsaUVBQWlFLGNBQWMsa0JBQWtCLG9FQUFvRSxnQkFBZ0IsZUFBZSx3QkFBd0IsYUFBYSxTQUFTLDZDQUE2QyxrQ0FBa0MsNEJBQTRCLE1BQU0sMkJBQTJCLHVCQUF1QixlQUFlLEVBQUUsU0FBUyxtRUFBbUUsbUNBQW1DLGNBQWMsY0FBYyxnQkFBZ0IsaUJBQWlCLGlCQUFpQixtQ0FBbUMsY0FBYyxnQkFBZ0IsaUJBQWlCLGtDQUFrQyxhQUFhLGlCQUFpQixNQUFNLGdCQUFnQixnQkFBZ0IsdUJBQXVCLGVBQWUsR0FBRyxJQUFJLHdCQUF3QixxREFBcUQsV0FBVyxPQUFPLHlCQUF5QixjQUFjLDRDQUE0QyxZQUFZLGtCQUFrQixjQUFjLFdBQVcsUUFBUSxnQ0FBZ0MsMENBQTBDLCtCQUErQixLQUFLLGFBQWEsT0FBTyxzQ0FBc0MsOEJBQThCLG9EQUFvRCw4QkFBOEIsNkNBQTZDLHdCQUF3Qiw0REFBNEQsWUFBWSxxQkFBcUIsR0FBRyw2QkFBNkIsNENBQTRDLGFBQWEsZ0JBQWdCLGNBQWMsMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxTQUFTLEdBQUcsRUFBRSxFQUFFLHdCQUF3QixTQUFTLEVBQUUsTUFBTSwrQkFBK0IsYUFBYSxVQUFVLFVBQVUsd0JBQXdCLG9CQUFvQiw0QkFBNEIsbURBQW1ELE9BQU8sOEJBQThCLGtEQUFrRCwwQkFBMEIsY0FBYyxTQUFTLHFDQUFxQywwQkFBMEIsSUFBSSxjQUFjLGdEQUFnRCxTQUFTLDZCQUE2QixhQUFhLHNCQUFzQixvQkFBb0IsZUFBZSxjQUFjLE1BQU0sK1NBQStTLFFBQVEsc0NBQXNDLGdCQUFnQixzQkFBc0Isa0NBQWtDLG1CQUFtQixjQUFjLG1CQUFtQiwyQ0FBMkMsV0FBVyxXQUFXLFdBQVcsUUFBUSxTQUFTLFFBQVEsUUFBUSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFFBQVEsTUFBTSxNQUFNLE9BQU8sK0JBQStCLG1CQUFtQixpQ0FBaUMsbUJBQW1CLElBQUksMEJBQTBCLFdBQVcsWUFBWSxNQUFNLFVBQVUscUJBQXFCLFlBQVksVUFBVSxPQUFPLFNBQVMsb0JBQW9CLElBQUksbUNBQW1DLFVBQVUscUJBQXFCLFVBQVUsU0FBUyxVQUFVLElBQUksU0FBUyx1Q0FBdUMsaUJBQWlCLGdCQUFnQixPQUFPLGFBQWEsU0FBUyxNQUFNLG9CQUFvQixpQkFBaUIsZ0JBQWdCLE9BQU8sYUFBYSxTQUFTLE1BQU0sVUFBVSxJQUFJLFVBQVUsUUFBUSxpQkFBaUIsT0FBTyxRQUFRLGFBQWEsU0FBUyxNQUFNLFVBQVUsVUFBVSxVQUFVLEdBQUcsK0JBQStCLHFCQUFxQixtQkFBbUIsS0FBSyxTQUFTLE1BQU0sU0FBUyxtQkFBbUIsMENBQTBDLHlCQUF5QixnQkFBZ0IsbUJBQW1CLE9BQU8saUJBQWlCLE9BQU8sYUFBYSxtQ0FBbUMsVUFBVSxxQkFBcUIsWUFBWSxTQUFTLFVBQVUsZ0JBQWdCLE9BQU8sT0FBTyxTQUFTLE9BQU8sVUFBVSw2QkFBNkIsZ0JBQWdCLE9BQU8sYUFBYSxTQUFTLE1BQU0sVUFBVSxnQkFBZ0IsT0FBTyxhQUFhLFNBQVMsTUFBTSxVQUFVLG1DQUFtQyxVQUFVLHFCQUFxQixVQUFVLFNBQVMsVUFBVSxtQkFBbUIsZ0JBQWdCLE9BQU8sT0FBTyxhQUFhLFNBQVMsTUFBTSxvQ0FBb0MsaUJBQWlCLElBQUksU0FBUyw0QkFBNEIsZ0JBQWdCLGFBQWEsbUNBQW1DLFVBQVUscUJBQXFCLFlBQVksU0FBUyxVQUFVLE9BQU8sT0FBTyxTQUFTLE1BQU0sYUFBYSxPQUFPLGFBQWEsU0FBUyxPQUFPLG1CQUFtQixRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsUUFBUSxlQUFlLGFBQWEsS0FBSyxxQkFBcUIsZUFBZSxhQUFhLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJLDhCQUE4Qiw4Q0FBOEMsaUJBQWlCLHNCQUFzQiw4QkFBOEIsZ0JBQWdCLDBCQUEwQixTQUFTLDJIQUEySCxvQkFBb0IsYUFBYSx3QkFBd0IsVUFBVSxXQUFXLG9DQUFvQyxNQUFNLFlBQVksV0FBVyxLQUFLLGdCQUFnQixhQUFhLHFCQUFxQixhQUFhLGlCQUFpQixtQkFBbUIsYUFBYSxLQUFLLGFBQWEsWUFBWSx1QkFBdUIsa0JBQWtCLFVBQVUsSUFBSSxvQkFBb0IscUJBQXFCLFVBQVUsYUFBYSxzQkFBc0IscUJBQXFCLGlDQUFpQyxZQUFZLFVBQVUsVUFBVSxlQUFlLGNBQWMsTUFBTSw4RkFBOEYsUUFBUSwrREFBK0QsNkJBQTZCLGtEQUFrRCxxQ0FBcUMscUNBQXFDLHVEQUF1RCx1QkFBdUIsMkJBQTJCLG1CQUFtQiw4Q0FBOEMsU0FBUyxhQUFhLElBQUksV0FBVyxHQUFHLHNCQUFzQixJQUFJLFFBQVEsdUJBQXVCLGFBQWEsY0FBYyxVQUFVLG9CQUFvQixLQUFLLElBQUksMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLHFCQUFxQixZQUFZLEVBQUUsT0FBTyxVQUFVLGVBQWUsVUFBVSxHQUFHLElBQUksK0JBQStCLHNCQUFzQixXQUFXLHFCQUFxQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccGljb21hdGNoXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17MTcwOih0LGUsdSk9Pntjb25zdCBuPXUoNTEwKTtjb25zdCBpc1dpbmRvd3M9KCk9PntpZih0eXBlb2YgbmF2aWdhdG9yIT09XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yLnBsYXRmb3JtKXtjb25zdCB0PW5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJ3aW4zMlwifHx0PT09XCJ3aW5kb3dzXCJ9aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLnBsYXRmb3JtKXtyZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIn1yZXR1cm4gZmFsc2V9O2Z1bmN0aW9uIHBpY29tYXRjaCh0LGUsdT1mYWxzZSl7aWYoZSYmKGUud2luZG93cz09PW51bGx8fGUud2luZG93cz09PXVuZGVmaW5lZCkpe2U9ey4uLmUsd2luZG93czppc1dpbmRvd3MoKX19cmV0dXJuIG4odCxlLHUpfU9iamVjdC5hc3NpZ24ocGljb21hdGNoLG4pO3QuZXhwb3J0cz1waWNvbWF0Y2h9LDE1NDp0PT57Y29uc3QgZT1cIlxcXFxcXFxcL1wiO2NvbnN0IHU9YFteJHtlfV1gO2NvbnN0IG49XCJcXFxcLlwiO2NvbnN0IG89XCJcXFxcK1wiO2NvbnN0IHM9XCJcXFxcP1wiO2NvbnN0IHI9XCJcXFxcL1wiO2NvbnN0IGE9XCIoPz0uKVwiO2NvbnN0IGk9XCJbXi9dXCI7Y29uc3QgYz1gKD86JHtyfXwkKWA7Y29uc3QgcD1gKD86Xnwke3J9KWA7Y29uc3QgbD1gJHtufXsxLDJ9JHtjfWA7Y29uc3QgZj1gKD8hJHtufSlgO2NvbnN0IEE9YCg/ISR7cH0ke2x9KWA7Y29uc3QgXz1gKD8hJHtufXswLDF9JHtjfSlgO2NvbnN0IFI9YCg/ISR7bH0pYDtjb25zdCBFPWBbXi4ke3J9XWA7Y29uc3QgaD1gJHtpfSo/YDtjb25zdCBnPVwiL1wiO2NvbnN0IGI9e0RPVF9MSVRFUkFMOm4sUExVU19MSVRFUkFMOm8sUU1BUktfTElURVJBTDpzLFNMQVNIX0xJVEVSQUw6cixPTkVfQ0hBUjphLFFNQVJLOmksRU5EX0FOQ0hPUjpjLERPVFNfU0xBU0g6bCxOT19ET1Q6ZixOT19ET1RTOkEsTk9fRE9UX1NMQVNIOl8sTk9fRE9UU19TTEFTSDpSLFFNQVJLX05PX0RPVDpFLFNUQVI6aCxTVEFSVF9BTkNIT1I6cCxTRVA6Z307Y29uc3QgQz17Li4uYixTTEFTSF9MSVRFUkFMOmBbJHtlfV1gLFFNQVJLOnUsU1RBUjpgJHt1fSo/YCxET1RTX1NMQVNIOmAke259ezEsMn0oPzpbJHtlfV18JClgLE5PX0RPVDpgKD8hJHtufSlgLE5PX0RPVFM6YCg/ISg/Ol58WyR7ZX1dKSR7bn17MSwyfSg/Olske2V9XXwkKSlgLE5PX0RPVF9TTEFTSDpgKD8hJHtufXswLDF9KD86WyR7ZX1dfCQpKWAsTk9fRE9UU19TTEFTSDpgKD8hJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke2V9XWAsU1RBUlRfQU5DSE9SOmAoPzpefFske2V9XSlgLEVORF9BTkNIT1I6YCg/Olske2V9XXwkKWAsU0VQOlwiXFxcXFwifTtjb25zdCB5PXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O3QuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTp5LFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksZXh0Z2xvYkNoYXJzKHQpe3JldHVybntcIiFcIjp7dHlwZTpcIm5lZ2F0ZVwiLG9wZW46XCIoPzooPyEoPzpcIixjbG9zZTpgKSkke3QuU1RBUn0pYH0sXCI/XCI6e3R5cGU6XCJxbWFya1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIik/XCJ9LFwiK1wiOnt0eXBlOlwicGx1c1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIikrXCJ9LFwiKlwiOnt0eXBlOlwic3RhclwiLG9wZW46XCIoPzpcIixjbG9zZTpcIikqXCJ9LFwiQFwiOnt0eXBlOlwiYXRcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpXCJ9fX0sZ2xvYkNoYXJzKHQpe3JldHVybiB0PT09dHJ1ZT9DOmJ9fX0sNjk3Oih0LGUsdSk9Pntjb25zdCBuPXUoMTU0KTtjb25zdCBvPXUoOTYpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6cixSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzphLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjppLFJFUExBQ0VNRU5UUzpjfT1uO2NvbnN0IGV4cGFuZFJhbmdlPSh0LGUpPT57aWYodHlwZW9mIGUuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlLmV4cGFuZFJhbmdlKC4uLnQsZSl9dC5zb3J0KCk7Y29uc3QgdT1gWyR7dC5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cCh1KX1jYXRjaChlKXtyZXR1cm4gdC5tYXAoKHQ9Pm8uZXNjYXBlUmVnZXgodCkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHV9O2NvbnN0IHN5bnRheEVycm9yPSh0LGUpPT5gTWlzc2luZyAke3R9OiBcIiR7ZX1cIiAtIHVzZSBcIlxcXFxcXFxcJHtlfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KHQsZSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX10PWNbdF18fHQ7Y29uc3QgdT17Li4uZX07Y29uc3QgcD10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7bGV0IGw9dC5sZW5ndGg7aWYobD5wKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke3B9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnUucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgXz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgUj1uLmdsb2JDaGFycyh1LndpbmRvd3MpO2NvbnN0IEU9bi5leHRnbG9iQ2hhcnMoUik7Y29uc3R7RE9UX0xJVEVSQUw6aCxQTFVTX0xJVEVSQUw6ZyxTTEFTSF9MSVRFUkFMOmIsT05FX0NIQVI6QyxET1RTX1NMQVNIOnksTk9fRE9UOiQsTk9fRE9UX1NMQVNIOngsTk9fRE9UU19TTEFTSDpTLFFNQVJLOkgsUU1BUktfTk9fRE9UOnYsU1RBUjpkLFNUQVJUX0FOQ0hPUjpMfT1SO2NvbnN0IGdsb2JzdGFyPXQ9PmAoJHtffSg/Oig/ISR7TH0ke3QuZG90P3k6aH0pLikqPylgO2NvbnN0IFQ9dS5kb3Q/XCJcIjokO2NvbnN0IE89dS5kb3Q/SDp2O2xldCBrPXUuYmFzaD09PXRydWU/Z2xvYnN0YXIodSk6ZDtpZih1LmNhcHR1cmUpe2s9YCgke2t9KWB9aWYodHlwZW9mIHUubm9leHQ9PT1cImJvb2xlYW5cIil7dS5ub2V4dGdsb2I9dS5ub2V4dH1jb25zdCBtPXtpbnB1dDp0LGluZGV4Oi0xLHN0YXJ0OjAsZG90OnUuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O3Q9by5yZW1vdmVQcmVmaXgodCxtKTtsPXQubGVuZ3RoO2NvbnN0IHc9W107Y29uc3QgTj1bXTtjb25zdCBJPVtdO2xldCBCPWY7bGV0IEc7Y29uc3QgZW9zPSgpPT5tLmluZGV4PT09bC0xO2NvbnN0IEQ9bS5wZWVrPShlPTEpPT50W20uaW5kZXgrZV07Y29uc3QgTT1tLmFkdmFuY2U9KCk9PnRbKyttLmluZGV4XXx8XCJcIjtjb25zdCByZW1haW5pbmc9KCk9PnQuc2xpY2UobS5pbmRleCsxKTtjb25zdCBjb25zdW1lPSh0PVwiXCIsZT0wKT0+e20uY29uc3VtZWQrPXQ7bS5pbmRleCs9ZX07Y29uc3QgYXBwZW5kPXQ9PnttLm91dHB1dCs9dC5vdXRwdXQhPW51bGw/dC5vdXRwdXQ6dC52YWx1ZTtjb25zdW1lKHQudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgdD0xO3doaWxlKEQoKT09PVwiIVwiJiYoRCgyKSE9PVwiKFwifHxEKDMpPT09XCI/XCIpKXtNKCk7bS5zdGFydCsrO3QrK31pZih0JTI9PT0wKXtyZXR1cm4gZmFsc2V9bS5uZWdhdGVkPXRydWU7bS5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9dD0+e21bdF0rKztJLnB1c2godCl9O2NvbnN0IGRlY3JlbWVudD10PT57bVt0XS0tO0kucG9wKCl9O2NvbnN0IHB1c2g9dD0+e2lmKEIudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgZT1tLmJyYWNlcz4wJiYodC50eXBlPT09XCJjb21tYVwifHx0LnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHU9dC5leHRnbG9iPT09dHJ1ZXx8dy5sZW5ndGgmJih0LnR5cGU9PT1cInBpcGVcInx8dC50eXBlPT09XCJwYXJlblwiKTtpZih0LnR5cGUhPT1cInNsYXNoXCImJnQudHlwZSE9PVwicGFyZW5cIiYmIWUmJiF1KXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLm91dHB1dC5sZW5ndGgpO0IudHlwZT1cInN0YXJcIjtCLnZhbHVlPVwiKlwiO0Iub3V0cHV0PWs7bS5vdXRwdXQrPUIub3V0cHV0fX1pZih3Lmxlbmd0aCYmdC50eXBlIT09XCJwYXJlblwiKXt3W3cubGVuZ3RoLTFdLmlubmVyKz10LnZhbHVlfWlmKHQudmFsdWV8fHQub3V0cHV0KWFwcGVuZCh0KTtpZihCJiZCLnR5cGU9PT1cInRleHRcIiYmdC50eXBlPT09XCJ0ZXh0XCIpe0Iub3V0cHV0PShCLm91dHB1dHx8Qi52YWx1ZSkrdC52YWx1ZTtCLnZhbHVlKz10LnZhbHVlO3JldHVybn10LnByZXY9QjtBLnB1c2godCk7Qj10fTtjb25zdCBleHRnbG9iT3Blbj0odCxlKT0+e2NvbnN0IG49ey4uLkVbZV0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1CO24ucGFyZW5zPW0ucGFyZW5zO24ub3V0cHV0PW0ub3V0cHV0O2NvbnN0IG89KHUuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6dCx2YWx1ZTplLG91dHB1dDptLm91dHB1dD9cIlwiOkN9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6TSgpLG91dHB1dDpvfSk7dy5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9dD0+e2xldCBuPXQuY2xvc2UrKHUuY2FwdHVyZT9cIilcIjpcIlwiKTtsZXQgbztpZih0LnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgcz1rO2lmKHQuaW5uZXImJnQuaW5uZXIubGVuZ3RoPjEmJnQuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtzPWdsb2JzdGFyKHUpfWlmKHMhPT1rfHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe249dC5jbG9zZT1gKSQpKSR7c31gfWlmKHQuaW5uZXIuaW5jbHVkZXMoXCIqXCIpJiYobz1yZW1haW5pbmcoKSkmJi9eXFwuW15cXFxcLy5dKyQvLnRlc3Qobykpe2NvbnN0IHU9cGFyc2Uobyx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KS5vdXRwdXQ7bj10LmNsb3NlPWApJHt1fSkke3N9KWB9aWYodC5wcmV2LnR5cGU9PT1cImJvc1wiKXttLm5lZ2F0ZWRFeHRnbG9iPXRydWV9fXB1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpHLG91dHB1dDpufSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpfTtpZih1LmZhc3RwYXRocyE9PWZhbHNlJiYhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdCh0KSl7bGV0IG49ZmFsc2U7bGV0IHM9dC5yZXBsYWNlKGksKCh0LGUsdSxvLHMscik9PntpZihvPT09XCJcXFxcXCIpe249dHJ1ZTtyZXR1cm4gdH1pZihvPT09XCI/XCIpe2lmKGUpe3JldHVybiBlK28rKHM/SC5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfWlmKHI9PT0wKXtyZXR1cm4gTysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9cmV0dXJuIEgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIuXCIpe3JldHVybiBoLnJlcGVhdCh1Lmxlbmd0aCl9aWYobz09PVwiKlwiKXtpZihlKXtyZXR1cm4gZStvKyhzP2s6XCJcIil9cmV0dXJuIGt9cmV0dXJuIGU/dDpgXFxcXCR7dH1gfSkpO2lmKG49PT10cnVlKXtpZih1LnVuZXNjYXBlPT09dHJ1ZSl7cz1zLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1lbHNle3M9cy5yZXBsYWNlKC9cXFxcKy9nLCh0PT50Lmxlbmd0aCUyPT09MD9cIlxcXFxcXFxcXCI6dD9cIlxcXFxcIjpcIlwiKSl9fWlmKHM9PT10JiZ1LmNvbnRhaW5zPT09dHJ1ZSl7bS5vdXRwdXQ9dDtyZXR1cm4gbX1tLm91dHB1dD1vLndyYXBPdXRwdXQocyxtLGUpO3JldHVybiBtfXdoaWxlKCFlb3MoKSl7Rz1NKCk7aWYoRz09PVwiXFwwXCIpe2NvbnRpbnVlfWlmKEc9PT1cIlxcXFxcIil7Y29uc3QgdD1EKCk7aWYodD09PVwiL1wiJiZ1LmJhc2ghPT10cnVlKXtjb250aW51ZX1pZih0PT09XCIuXCJ8fHQ9PT1cIjtcIil7Y29udGludWV9aWYoIXQpe0crPVwiXFxcXFwiO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWNvbnN0IGU9L15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7bGV0IG49MDtpZihlJiZlWzBdLmxlbmd0aD4yKXtuPWVbMF0ubGVuZ3RoO20uaW5kZXgrPW47aWYobiUyIT09MCl7Rys9XCJcXFxcXCJ9fWlmKHUudW5lc2NhcGU9PT10cnVlKXtHPU0oKX1lbHNle0crPU0oKX1pZihtLmJyYWNrZXRzPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9fWlmKG0uYnJhY2tldHM+MCYmKEchPT1cIl1cInx8Qi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7aWYodS5wb3NpeCE9PWZhbHNlJiZHPT09XCI6XCIpe2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZih0LmluY2x1ZGVzKFwiW1wiKSl7Qi5wb3NpeD10cnVlO2lmKHQuaW5jbHVkZXMoXCI6XCIpKXtjb25zdCB0PUIudmFsdWUubGFzdEluZGV4T2YoXCJbXCIpO2NvbnN0IGU9Qi52YWx1ZS5zbGljZSgwLHQpO2NvbnN0IHU9Qi52YWx1ZS5zbGljZSh0KzIpO2NvbnN0IG49clt1XTtpZihuKXtCLnZhbHVlPWUrbjttLmJhY2t0cmFjaz10cnVlO00oKTtpZighZi5vdXRwdXQmJkEuaW5kZXhPZihCKT09PTEpe2Yub3V0cHV0PUN9Y29udGludWV9fX19aWYoRz09PVwiW1wiJiZEKCkhPT1cIjpcInx8Rz09PVwiLVwiJiZEKCk9PT1cIl1cIil7Rz1gXFxcXCR7R31gfWlmKEc9PT1cIl1cIiYmKEIudmFsdWU9PT1cIltcInx8Qi52YWx1ZT09PVwiW15cIikpe0c9YFxcXFwke0d9YH1pZih1LnBvc2l4PT09dHJ1ZSYmRz09PVwiIVwiJiZCLnZhbHVlPT09XCJbXCIpe0c9XCJeXCJ9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihtLnF1b3Rlcz09PTEmJkchPT0nXCInKXtHPW8uZXNjYXBlUmVnZXgoRyk7Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09J1wiJyl7bS5xdW90ZXM9bS5xdW90ZXM9PT0xPzA6MTtpZih1LmtlZXBRdW90ZXM9PT10cnVlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KX1jb250aW51ZX1pZihHPT09XCIoXCIpe2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiKVwiKXtpZihtLnBhcmVucz09PTAmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCIoXCIpKX1jb25zdCB0PXdbdy5sZW5ndGgtMV07aWYodCYmbS5wYXJlbnM9PT10LnBhcmVucysxKXtleHRnbG9iQ2xvc2Uody5wb3AoKSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6RyxvdXRwdXQ6bS5wYXJlbnM/XCIpXCI6XCJcXFxcKVwifSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpO2NvbnRpbnVlfWlmKEc9PT1cIltcIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHwhcmVtYWluaW5nKCkuaW5jbHVkZXMoXCJdXCIpKXtpZih1Lm5vYnJhY2tldCE9PXRydWUmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKX1HPWBcXFxcJHtHfWB9ZWxzZXtpbmNyZW1lbnQoXCJicmFja2V0c1wiKX1wdXNoKHt0eXBlOlwiYnJhY2tldFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCJdXCIpe2lmKHUubm9icmFja2V0PT09dHJ1ZXx8QiYmQi50eXBlPT09XCJicmFja2V0XCImJkIudmFsdWUubGVuZ3RoPT09MSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpgXFxcXCR7R31gfSk7Y29udGludWV9aWYobS5icmFja2V0cz09PTApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCJbXCIpKX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1kZWNyZW1lbnQoXCJicmFja2V0c1wiKTtjb25zdCB0PUIudmFsdWUuc2xpY2UoMSk7aWYoQi5wb3NpeCE9PXRydWUmJnRbMF09PT1cIl5cIiYmIXQuaW5jbHVkZXMoXCIvXCIpKXtHPWAvJHtHfWB9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtpZih1LmxpdGVyYWxCcmFja2V0cz09PWZhbHNlfHxvLmhhc1JlZ2V4Q2hhcnModCkpe2NvbnRpbnVlfWNvbnN0IGU9by5lc2NhcGVSZWdleChCLnZhbHVlKTttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLnZhbHVlLmxlbmd0aCk7aWYodS5saXRlcmFsQnJhY2tldHM9PT10cnVlKXttLm91dHB1dCs9ZTtCLnZhbHVlPWU7Y29udGludWV9Qi52YWx1ZT1gKCR7X30ke2V9fCR7Qi52YWx1ZX0pYDttLm91dHB1dCs9Qi52YWx1ZTtjb250aW51ZX1pZihHPT09XCJ7XCImJnUubm9icmFjZSE9PXRydWUpe2luY3JlbWVudChcImJyYWNlc1wiKTtjb25zdCB0PXt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDpcIihcIixvdXRwdXRJbmRleDptLm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6bS50b2tlbnMubGVuZ3RofTtOLnB1c2godCk7cHVzaCh0KTtjb250aW51ZX1pZihHPT09XCJ9XCIpe2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtpZih1Lm5vYnJhY2U9PT10cnVlfHwhdCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpHfSk7Y29udGludWV9bGV0IGU9XCIpXCI7aWYodC5kb3RzPT09dHJ1ZSl7Y29uc3QgdD1BLnNsaWNlKCk7Y29uc3Qgbj1bXTtmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7QS5wb3AoKTtpZih0W2VdLnR5cGU9PT1cImJyYWNlXCIpe2JyZWFrfWlmKHRbZV0udHlwZSE9PVwiZG90c1wiKXtuLnVuc2hpZnQodFtlXS52YWx1ZSl9fWU9ZXhwYW5kUmFuZ2Uobix1KTttLmJhY2t0cmFjaz10cnVlfWlmKHQuY29tbWEhPT10cnVlJiZ0LmRvdHMhPT10cnVlKXtjb25zdCB1PW0ub3V0cHV0LnNsaWNlKDAsdC5vdXRwdXRJbmRleCk7Y29uc3Qgbj1tLnRva2Vucy5zbGljZSh0LnRva2Vuc0luZGV4KTt0LnZhbHVlPXQub3V0cHV0PVwiXFxcXHtcIjtHPWU9XCJcXFxcfVwiO20ub3V0cHV0PXU7Zm9yKGNvbnN0IHQgb2Ygbil7bS5vdXRwdXQrPXQub3V0cHV0fHx0LnZhbHVlfX1wdXNoKHt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDplfSk7ZGVjcmVtZW50KFwiYnJhY2VzXCIpO04ucG9wKCk7Y29udGludWV9aWYoRz09PVwifFwiKXtpZih3Lmxlbmd0aD4wKXt3W3cubGVuZ3RoLTFdLmNvbmRpdGlvbnMrK31wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIsXCIpe2xldCB0PUc7Y29uc3QgZT1OW04ubGVuZ3RoLTFdO2lmKGUmJklbSS5sZW5ndGgtMV09PT1cImJyYWNlc1wiKXtlLmNvbW1hPXRydWU7dD1cInxcIn1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTpHLG91dHB1dDp0fSk7Y29udGludWV9aWYoRz09PVwiL1wiKXtpZihCLnR5cGU9PT1cImRvdFwiJiZtLmluZGV4PT09bS5zdGFydCsxKXttLnN0YXJ0PW0uaW5kZXgrMTttLmNvbnN1bWVkPVwiXCI7bS5vdXRwdXQ9XCJcIjtBLnBvcCgpO0I9Zjtjb250aW51ZX1wdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpHLG91dHB1dDpifSk7Y29udGludWV9aWYoRz09PVwiLlwiKXtpZihtLmJyYWNlcz4wJiZCLnR5cGU9PT1cImRvdFwiKXtpZihCLnZhbHVlPT09XCIuXCIpQi5vdXRwdXQ9aDtjb25zdCB0PU5bTi5sZW5ndGgtMV07Qi50eXBlPVwiZG90c1wiO0Iub3V0cHV0Kz1HO0IudmFsdWUrPUc7dC5kb3RzPXRydWU7Y29udGludWV9aWYobS5icmFjZXMrbS5wYXJlbnM9PT0wJiZCLnR5cGUhPT1cImJvc1wiJiZCLnR5cGUhPT1cInNsYXNoXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6aH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9aWYoRz09PVwiP1wiKXtjb25zdCB0PUImJkIudmFsdWU9PT1cIihcIjtpZighdCYmdS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInFtYXJrXCIsRyk7Y29udGludWV9aWYoQiYmQi50eXBlPT09XCJwYXJlblwiKXtjb25zdCB0PUQoKTtsZXQgZT1HO2lmKEIudmFsdWU9PT1cIihcIiYmIS9bIT08Ol0vLnRlc3QodCl8fHQ9PT1cIjxcIiYmIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSl7ZT1gXFxcXCR7R31gfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKHUuZG90IT09dHJ1ZSYmKEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJib3NcIikpe3B1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0OnZ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpHLG91dHB1dDpIfSk7Y29udGludWV9aWYoRz09PVwiIVwiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiKXtpZihEKDIpIT09XCI/XCJ8fCEvWyE9PDpdLy50ZXN0KEQoMykpKXtleHRnbG9iT3BlbihcIm5lZ2F0ZVwiLEcpO2NvbnRpbnVlfX1pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmbS5pbmRleD09PTApe25lZ2F0ZSgpO2NvbnRpbnVlfX1pZihHPT09XCIrXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJwbHVzXCIsRyk7Y29udGludWV9aWYoQiYmQi52YWx1ZT09PVwiKFwifHx1LnJlZ2V4PT09ZmFsc2Upe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6RyxvdXRwdXQ6Z30pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImJyYWNrZXRcInx8Qi50eXBlPT09XCJwYXJlblwifHxCLnR5cGU9PT1cImJyYWNlXCIpfHxtLnBhcmVucz4wKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkd9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOmd9KTtjb250aW51ZX1pZihHPT09XCJAXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7cHVzaCh7dHlwZTpcImF0XCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHIT09XCIqXCIpe2lmKEc9PT1cIiRcInx8Rz09PVwiXlwiKXtHPWBcXFxcJHtHfWB9Y29uc3QgdD1hLmV4ZWMocmVtYWluaW5nKCkpO2lmKHQpe0crPXRbMF07bS5pbmRleCs9dFswXS5sZW5ndGh9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiZ2xvYnN0YXJcInx8Qi5zdGFyPT09dHJ1ZSkpe0IudHlwZT1cInN0YXJcIjtCLnN0YXI9dHJ1ZTtCLnZhbHVlKz1HO0Iub3V0cHV0PWs7bS5iYWNrdHJhY2s9dHJ1ZTttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1sZXQgZT1yZW1haW5pbmcoKTtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJi9eXFwoW14/XS8udGVzdChlKSl7ZXh0Z2xvYk9wZW4oXCJzdGFyXCIsRyk7Y29udGludWV9aWYoQi50eXBlPT09XCJzdGFyXCIpe2lmKHUubm9nbG9ic3Rhcj09PXRydWUpe2NvbnN1bWUoRyk7Y29udGludWV9Y29uc3Qgbj1CLnByZXY7Y29uc3Qgbz1uLnByZXY7Y29uc3Qgcz1uLnR5cGU9PT1cInNsYXNoXCJ8fG4udHlwZT09PVwiYm9zXCI7Y29uc3Qgcj1vJiYoby50eXBlPT09XCJzdGFyXCJ8fG8udHlwZT09PVwiZ2xvYnN0YXJcIik7aWYodS5iYXNoPT09dHJ1ZSYmKCFzfHxlWzBdJiZlWzBdIT09XCIvXCIpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1jb25zdCBhPW0uYnJhY2VzPjAmJihuLnR5cGU9PT1cImNvbW1hXCJ8fG4udHlwZT09PVwiYnJhY2VcIik7Y29uc3QgaT13Lmxlbmd0aCYmKG4udHlwZT09PVwicGlwZVwifHxuLnR5cGU9PT1cInBhcmVuXCIpO2lmKCFzJiZuLnR5cGUhPT1cInBhcmVuXCImJiFhJiYhaSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9d2hpbGUoZS5zbGljZSgwLDMpPT09XCIvKipcIil7Y29uc3QgdT10W20uaW5kZXgrNF07aWYodSYmdSE9PVwiL1wiKXticmVha31lPWUuc2xpY2UoMyk7Y29uc3VtZShcIi8qKlwiLDMpfWlmKG4udHlwZT09PVwiYm9zXCImJmVvcygpKXtCLnR5cGU9XCJnbG9ic3RhclwiO0IudmFsdWUrPUc7Qi5vdXRwdXQ9Z2xvYnN0YXIodSk7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJiFyJiZlb3MoKSl7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K0Iub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KSsodS5zdHJpY3RTbGFzaGVzP1wiKVwiOlwifCQpXCIpO0IudmFsdWUrPUc7bS5nbG9ic3Rhcj10cnVlO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDtjb25zdW1lKEcpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe2NvbnN0IHQ9ZVsxXSE9PXZvaWQgMD9cInwkXCI6XCJcIjttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWAke2dsb2JzdGFyKHUpfSR7Yn18JHtifSR7dH0pYDtCLnZhbHVlKz1HO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHK00oKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1pZihuLnR5cGU9PT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1gKD86Xnwke2J9fCR7Z2xvYnN0YXIodSl9JHtifSlgO20ub3V0cHV0PUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfW0ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KTtCLnZhbHVlKz1HO20ub3V0cHV0Kz1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPXt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0Omt9O2lmKHUuYmFzaD09PXRydWUpe24ub3V0cHV0PVwiLio/XCI7aWYoQi50eXBlPT09XCJib3NcInx8Qi50eXBlPT09XCJzbGFzaFwiKXtuLm91dHB1dD1UK24ub3V0cHV0fXB1c2gobik7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCIpJiZ1LnJlZ2V4PT09dHJ1ZSl7bi5vdXRwdXQ9RztwdXNoKG4pO2NvbnRpbnVlfWlmKG0uaW5kZXg9PT1tLnN0YXJ0fHxCLnR5cGU9PT1cInNsYXNoXCJ8fEIudHlwZT09PVwiZG90XCIpe2lmKEIudHlwZT09PVwiZG90XCIpe20ub3V0cHV0Kz14O0Iub3V0cHV0Kz14fWVsc2UgaWYodS5kb3Q9PT10cnVlKXttLm91dHB1dCs9UztCLm91dHB1dCs9U31lbHNle20ub3V0cHV0Kz1UO0Iub3V0cHV0Kz1UfWlmKEQoKSE9PVwiKlwiKXttLm91dHB1dCs9QztCLm91dHB1dCs9Q319cHVzaChuKX13aGlsZShtLmJyYWNrZXRzPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIltcIik7ZGVjcmVtZW50KFwiYnJhY2tldHNcIil9d2hpbGUobS5wYXJlbnM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiKVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiKFwiKTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9d2hpbGUobS5icmFjZXM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwifVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwie1wiKTtkZWNyZW1lbnQoXCJicmFjZXNcIil9aWYodS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSYmKEIudHlwZT09PVwic3RhclwifHxCLnR5cGU9PT1cImJyYWNrZXRcIikpe3B1c2goe3R5cGU6XCJtYXliZV9zbGFzaFwiLHZhbHVlOlwiXCIsb3V0cHV0OmAke2J9P2B9KX1pZihtLmJhY2t0cmFjaz09PXRydWUpe20ub3V0cHV0PVwiXCI7Zm9yKGNvbnN0IHQgb2YgbS50b2tlbnMpe20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2lmKHQuc3VmZml4KXttLm91dHB1dCs9dC5zdWZmaXh9fX1yZXR1cm4gbX07cGFyc2UuZmFzdHBhdGhzPSh0LGUpPT57Y29uc3QgdT17Li4uZX07Y29uc3Qgcj10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7Y29uc3QgYT10Lmxlbmd0aDtpZihhPnIpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2F9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cn1gKX10PWNbdF18fHQ7Y29uc3R7RE9UX0xJVEVSQUw6aSxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6bCxET1RTX1NMQVNIOmYsTk9fRE9UOkEsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6UixTVEFSOkUsU1RBUlRfQU5DSE9SOmh9PW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgZz11LmRvdD9fOkE7Y29uc3QgYj11LmRvdD9SOkE7Y29uc3QgQz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgeT17bmVnYXRlZDpmYWxzZSxwcmVmaXg6XCJcIn07bGV0ICQ9dS5iYXNoPT09dHJ1ZT9cIi4qP1wiOkU7aWYodS5jYXB0dXJlKXskPWAoJHskfSlgfWNvbnN0IGdsb2JzdGFyPXQ9PntpZih0Lm5vZ2xvYnN0YXI9PT10cnVlKXJldHVybiAkO3JldHVybmAoJHtDfSg/Oig/ISR7aH0ke3QuZG90P2Y6aX0pLikqPylgfTtjb25zdCBjcmVhdGU9dD0+e3N3aXRjaCh0KXtjYXNlXCIqXCI6cmV0dXJuYCR7Z30ke2x9JHskfWA7Y2FzZVwiLipcIjpyZXR1cm5gJHtpfSR7bH0keyR9YDtjYXNlXCIqLipcIjpyZXR1cm5gJHtnfSR7JH0ke2l9JHtsfSR7JH1gO2Nhc2VcIiovKlwiOnJldHVybmAke2d9JHskfSR7cH0ke2x9JHtifSR7JH1gO2Nhc2VcIioqXCI6cmV0dXJuIGcrZ2xvYnN0YXIodSk7Y2FzZVwiKiovKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHtsfSR7JH1gO2Nhc2VcIioqLyouKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKiovLipcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtpfSR7bH0keyR9YDtkZWZhdWx0Ontjb25zdCBlPS9eKC4qPylcXC4oXFx3KykkLy5leGVjKHQpO2lmKCFlKXJldHVybjtjb25zdCB1PWNyZWF0ZShlWzFdKTtpZighdSlyZXR1cm47cmV0dXJuIHUraStlWzJdfX19O2NvbnN0IHg9by5yZW1vdmVQcmVmaXgodCx5KTtsZXQgUz1jcmVhdGUoeCk7aWYoUyYmdS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSl7Uys9YCR7cH0/YH1yZXR1cm4gU307dC5leHBvcnRzPXBhcnNlfSw1MTA6KHQsZSx1KT0+e2NvbnN0IG49dSg3MTYpO2NvbnN0IG89dSg2OTcpO2NvbnN0IHM9dSg5Nik7Y29uc3Qgcj11KDE1NCk7Y29uc3QgaXNPYmplY3Q9dD0+dCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtjb25zdCBwaWNvbWF0Y2g9KHQsZSx1PWZhbHNlKT0+e2lmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IG49dC5tYXAoKHQ9PnBpY29tYXRjaCh0LGUsdSkpKTtjb25zdCBhcnJheU1hdGNoZXI9dD0+e2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IHU9ZSh0KTtpZih1KXJldHVybiB1fXJldHVybiBmYWxzZX07cmV0dXJuIGFycmF5TWF0Y2hlcn1jb25zdCBuPWlzT2JqZWN0KHQpJiZ0LnRva2VucyYmdC5pbnB1dDtpZih0PT09XCJcInx8dHlwZW9mIHQhPT1cInN0cmluZ1wiJiYhbil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IG89ZXx8e307Y29uc3Qgcz1vLndpbmRvd3M7Y29uc3Qgcj1uP3BpY29tYXRjaC5jb21waWxlUmUodCxlKTpwaWNvbWF0Y2gubWFrZVJlKHQsZSxmYWxzZSx0cnVlKTtjb25zdCBhPXIuc3RhdGU7ZGVsZXRlIHIuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYoby5pZ25vcmUpe2NvbnN0IHQ9ey4uLmUsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2goby5pZ25vcmUsdCx1KX1jb25zdCBtYXRjaGVyPSh1LG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDppLG1hdGNoOmMsb3V0cHV0OnB9PXBpY29tYXRjaC50ZXN0KHUscixlLHtnbG9iOnQscG9zaXg6c30pO2NvbnN0IGw9e2dsb2I6dCxzdGF0ZTphLHJlZ2V4OnIscG9zaXg6cyxpbnB1dDp1LG91dHB1dDpwLG1hdGNoOmMsaXNNYXRjaDppfTtpZih0eXBlb2Ygby5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7by5vblJlc3VsdChsKX1pZihpPT09ZmFsc2Upe2wuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9sOmZhbHNlfWlmKGlzSWdub3JlZCh1KSl7aWYodHlwZW9mIG8ub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe28ub25JZ25vcmUobCl9bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYodHlwZW9mIG8ub25NYXRjaD09PVwiZnVuY3Rpb25cIil7by5vbk1hdGNoKGwpfXJldHVybiBuP2w6dHJ1ZX07aWYodSl7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0odCxlLHUse2dsb2I6bixwb3NpeDpvfT17fSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZih0PT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHI9dXx8e307Y29uc3QgYT1yLmZvcm1hdHx8KG8/cy50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgaT10PT09bjtsZXQgYz1pJiZhP2EodCk6dDtpZihpPT09ZmFsc2Upe2M9YT9hKHQpOnQ7aT1jPT09bn1pZihpPT09ZmFsc2V8fHIuY2FwdHVyZT09PXRydWUpe2lmKHIubWF0Y2hCYXNlPT09dHJ1ZXx8ci5iYXNlbmFtZT09PXRydWUpe2k9cGljb21hdGNoLm1hdGNoQmFzZSh0LGUsdSxvKX1lbHNle2k9ZS5leGVjKGMpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGkpLG1hdGNoOmksb3V0cHV0OmN9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPSh0LGUsdSk9Pntjb25zdCBuPWUgaW5zdGFuY2VvZiBSZWdFeHA/ZTpwaWNvbWF0Y2gubWFrZVJlKGUsdSk7cmV0dXJuIG4udGVzdChzLmJhc2VuYW1lKHQpKX07cGljb21hdGNoLmlzTWF0Y2g9KHQsZSx1KT0+cGljb21hdGNoKGUsdSkodCk7cGljb21hdGNoLnBhcnNlPSh0LGUpPT57aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdC5tYXAoKHQ9PnBpY29tYXRjaC5wYXJzZSh0LGUpKSk7cmV0dXJuIG8odCx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KHQsZSk9Pm4odCxlKTtwaWNvbWF0Y2guY29tcGlsZVJlPSh0LGUsdT1mYWxzZSxuPWZhbHNlKT0+e2lmKHU9PT10cnVlKXtyZXR1cm4gdC5vdXRwdXR9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8uY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCByPW8uY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgYT1gJHtzfSg/OiR7dC5vdXRwdXR9KSR7cn1gO2lmKHQmJnQubmVnYXRlZD09PXRydWUpe2E9YF4oPyEke2F9KS4qJGB9Y29uc3QgaT1waWNvbWF0Y2gudG9SZWdleChhLGUpO2lmKG49PT10cnVlKXtpLnN0YXRlPXR9cmV0dXJuIGl9O3BpY29tYXRjaC5tYWtlUmU9KHQsZT17fSx1PWZhbHNlLG49ZmFsc2UpPT57aWYoIXR8fHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1sZXQgcz17bmVnYXRlZDpmYWxzZSxmYXN0cGF0aHM6dHJ1ZX07aWYoZS5mYXN0cGF0aHMhPT1mYWxzZSYmKHRbMF09PT1cIi5cInx8dFswXT09PVwiKlwiKSl7cy5vdXRwdXQ9by5mYXN0cGF0aHModCxlKX1pZighcy5vdXRwdXQpe3M9byh0LGUpfXJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHMsZSx1LG4pfTtwaWNvbWF0Y2gudG9SZWdleD0odCxlKT0+e3RyeXtjb25zdCB1PWV8fHt9O3JldHVybiBuZXcgUmVnRXhwKHQsdS5mbGFnc3x8KHUubm9jYXNlP1wiaVwiOlwiXCIpKX1jYXRjaCh0KXtpZihlJiZlLmRlYnVnPT09dHJ1ZSl0aHJvdyB0O3JldHVybi8kXi99fTtwaWNvbWF0Y2guY29uc3RhbnRzPXI7dC5leHBvcnRzPXBpY29tYXRjaH0sNzE2Oih0LGUsdSk9Pntjb25zdCBuPXUoOTYpO2NvbnN0e0NIQVJfQVNURVJJU0s6byxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpyLENIQVJfQ09NTUE6YSxDSEFSX0RPVDppLENIQVJfRVhDTEFNQVRJT05fTUFSSzpjLENIQVJfRk9SV0FSRF9TTEFTSDpwLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpsLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpfLENIQVJfUVVFU1RJT05fTUFSSzpSLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6RSxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmgsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpnfT11KDE1NCk7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPXQ9PnQ9PT1wfHx0PT09cjtjb25zdCBkZXB0aD10PT57aWYodC5pc1ByZWZpeCE9PXRydWUpe3QuZGVwdGg9dC5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPSh0LGUpPT57Y29uc3QgdT1lfHx7fTtjb25zdCBiPXQubGVuZ3RoLTE7Y29uc3QgQz11LnBhcnRzPT09dHJ1ZXx8dS5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IHk9W107Y29uc3QgJD1bXTtjb25zdCB4PVtdO2xldCBTPXQ7bGV0IEg9LTE7bGV0IHY9MDtsZXQgZD0wO2xldCBMPWZhbHNlO2xldCBUPWZhbHNlO2xldCBPPWZhbHNlO2xldCBrPWZhbHNlO2xldCBtPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBJPWZhbHNlO2xldCBCPWZhbHNlO2xldCBHPWZhbHNlO2xldCBEPTA7bGV0IE07bGV0IFA7bGV0IEs9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Yjtjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57TT1QO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxiKXtQPWFkdmFuY2UoKTtsZXQgdDtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7aWYoUD09PWwpe3c9dHJ1ZX1jb250aW51ZX1pZih3PT09dHJ1ZXx8UD09PWwpe0QrKzt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWwpe0QrKztjb250aW51ZX1pZih3IT09dHJ1ZSYmUD09PWkmJihQPWFkdmFuY2UoKSk9PT1pKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHchPT10cnVlJiZQPT09YSl7TD1LLmlzQnJhY2U9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09RSl7RC0tO2lmKEQ9PT0wKXt3PWZhbHNlO0w9Sy5pc0JyYWNlPXRydWU7Rz10cnVlO2JyZWFrfX19aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1wKXt5LnB1c2goSCk7JC5wdXNoKEspO0s9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKEc9PT10cnVlKWNvbnRpbnVlO2lmKE09PT1pJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfWQ9SCsxO2NvbnRpbnVlfWlmKHUubm9leHQhPT10cnVlKXtjb25zdCB0PVA9PT1ffHxQPT09c3x8UD09PW98fFA9PT1SfHxQPT09YztpZih0PT09dHJ1ZSYmcGVlaygpPT09Zil7Tz1LLmlzR2xvYj10cnVlO2s9Sy5pc0V4dGdsb2I9dHJ1ZTtHPXRydWU7aWYoUD09PWMmJkg9PT12KXtCPXRydWV9aWYoQz09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1oKXtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoUD09PW8pe2lmKE09PT1vKW09Sy5pc0dsb2JzdGFyPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PVIpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJih0PWFkdmFuY2UoKSkpe2lmKHQ9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYodD09PWcpe1Q9Sy5pc0JyYWNrZXQ9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodS5ub25lZ2F0ZSE9PXRydWUmJlA9PT1jJiZIPT09dil7ST1LLm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYodS5ub3BhcmVuIT09dHJ1ZSYmUD09PWYpe089Sy5pc0dsb2I9dHJ1ZTtpZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09Zil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe0c9dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTz09PXRydWUpe0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHUubm9leHQ9PT10cnVlKXtrPWZhbHNlO089ZmFsc2V9bGV0IFU9UztsZXQgWD1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtYPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7ZC09dn1pZihVJiZPPT09dHJ1ZSYmZD4wKXtVPVMuc2xpY2UoMCxkKTtGPVMuc2xpY2UoZCl9ZWxzZSBpZihPPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYodS51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJk49PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpYLGlucHV0OnQsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6TCxpc0JyYWNrZXQ6VCxpc0dsb2I6Tyxpc0V4dGdsb2I6ayxpc0dsb2JzdGFyOm0sbmVnYXRlZDpJLG5lZ2F0ZWRFeHRnbG9iOkJ9O2lmKHUudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoUCkpeyQucHVzaChLKX1RLnRva2Vucz0kfWlmKHUucGFydHM9PT10cnVlfHx1LnRva2Vucz09PXRydWUpe2xldCBlO2ZvcihsZXQgbj0wO248eS5sZW5ndGg7bisrKXtjb25zdCBvPWU/ZSsxOnY7Y29uc3Qgcz15W25dO2NvbnN0IHI9dC5zbGljZShvLHMpO2lmKHUudG9rZW5zKXtpZihuPT09MCYmdiE9PTApeyRbbl0uaXNQcmVmaXg9dHJ1ZTskW25dLnZhbHVlPVh9ZWxzZXskW25dLnZhbHVlPXJ9ZGVwdGgoJFtuXSk7US5tYXhEZXB0aCs9JFtuXS5kZXB0aH1pZihuIT09MHx8ciE9PVwiXCIpe3gucHVzaChyKX1lPXN9aWYoZSYmZSsxPHQubGVuZ3RoKXtjb25zdCBuPXQuc2xpY2UoZSsxKTt4LnB1c2gobik7aWYodS50b2tlbnMpeyRbJC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCgkWyQubGVuZ3RoLTFdKTtRLm1heERlcHRoKz0kWyQubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9eTtRLnBhcnRzPXh9cmV0dXJuIFF9O3QuZXhwb3J0cz1zY2FufSw5NjoodCxlLHUpPT57Y29uc3R7UkVHRVhfQkFDS1NMQVNIOm4sUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDpvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6cyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDpyfT11KDE1NCk7ZS5pc09iamVjdD10PT50IT09bnVsbCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtlLmhhc1JlZ2V4Q2hhcnM9dD0+cy50ZXN0KHQpO2UuaXNSZWdleENoYXI9dD0+dC5sZW5ndGg9PT0xJiZlLmhhc1JlZ2V4Q2hhcnModCk7ZS5lc2NhcGVSZWdleD10PT50LnJlcGxhY2UocixcIlxcXFwkMVwiKTtlLnRvUG9zaXhTbGFzaGVzPXQ9PnQucmVwbGFjZShuLFwiL1wiKTtlLnJlbW92ZUJhY2tzbGFzaGVzPXQ9PnQucmVwbGFjZShvLCh0PT50PT09XCJcXFxcXCI/XCJcIjp0KSk7ZS5lc2NhcGVMYXN0PSh0LHUsbik9Pntjb25zdCBvPXQubGFzdEluZGV4T2YodSxuKTtpZihvPT09LTEpcmV0dXJuIHQ7aWYodFtvLTFdPT09XCJcXFxcXCIpcmV0dXJuIGUuZXNjYXBlTGFzdCh0LHUsby0xKTtyZXR1cm5gJHt0LnNsaWNlKDAsbyl9XFxcXCR7dC5zbGljZShvKX1gfTtlLnJlbW92ZVByZWZpeD0odCxlPXt9KT0+e2xldCB1PXQ7aWYodS5zdGFydHNXaXRoKFwiLi9cIikpe3U9dS5zbGljZSgyKTtlLnByZWZpeD1cIi4vXCJ9cmV0dXJuIHV9O2Uud3JhcE91dHB1dD0odCxlPXt9LHU9e30pPT57Y29uc3Qgbj11LmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgbz11LmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke3R9KSR7b31gO2lmKGUubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfTtlLmJhc2VuYW1lPSh0LHt3aW5kb3dzOmV9PXt9KT0+e2NvbnN0IHU9dC5zcGxpdChlPy9bXFxcXC9dLzpcIi9cIik7Y29uc3Qgbj11W3UubGVuZ3RoLTFdO2lmKG49PT1cIlwiKXtyZXR1cm4gdVt1Lmxlbmd0aC0yXX1yZXR1cm4gbn19fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHUpe3ZhciBuPWVbdV07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3VdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXt0W3VdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSBlW3VdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB1PV9fbmNjd3Bja19yZXF1aXJlX18oMTcwKTttb2R1bGUuZXhwb3J0cz11fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      \"react-stack-bottom-frame\": function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React[\"react-stack-bottom-frame\"].bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0XFxjanNcXHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBzZWxmLFxuICAgICAgc291cmNlLFxuICAgICAgb3duZXIsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganN4REVWSW1wbChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGRlYnVnU3RhY2ssXG4gICAgICAgIGRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgbm9kZS5fc3RvcmUgJiZcbiAgICAgICAgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgIH1cbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gUmVhY3RbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICB2YXIgdHJhY2tBY3R1YWxPd25lciA9XG4gICAgICAgIDFlNCA+IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzKys7XG4gICAgICByZXR1cm4ganN4REVWSW1wbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3RcXGpzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = 'AmpStateContext';\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzRFQUZLO0FBRVgsTUFBTUEsa0JBQXNDQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQW9CLEVBQW1CO0lBQ3pDSCxnQkFBZ0JNLFdBQVcsR0FBRztBQUNoQyIsInNvdXJjZXMiOlsiQzpcXHNyY1xcc2hhcmVkXFxsaWJcXGFtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEFtcFN0YXRlQ29udGV4dDogUmVhY3QuQ29udGV4dDxhbnk+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgQW1wU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0FtcFN0YXRlQ29udGV4dCdcbn1cbiJdLCJuYW1lcyI6WyJBbXBTdGF0ZUNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkaXNwbGF5TmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWTtJQUFBLE1BQzFCQyxXQUFXLEtBQUssRUFDaEJDLFNBQVMsS0FBSyxFQUNkQyxXQUFXLEtBQUssRUFDakIsR0FKMkIsbUJBSXhCLENBQUMsSUFKdUI7SUFLMUIsT0FBT0YsWUFBYUMsVUFBVUM7QUFDaEMiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXHNoYXJlZFxcbGliXFxhbXAtbW9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNJbkFtcE1vZGUoe1xuICBhbXBGaXJzdCA9IGZhbHNlLFxuICBoeWJyaWQgPSBmYWxzZSxcbiAgaGFzUXVlcnkgPSBmYWxzZSxcbn0gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW1wRmlyc3QgfHwgKGh5YnJpZCAmJiBoYXNRdWVyeSlcbn1cbiJdLCJuYW1lcyI6WyJpc0luQW1wTW9kZSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    'lazy',\n    'eager',\n    undefined\n];\n// Object-fit values that are not valid background-size values\nconst INVALID_BACKGROUND_SIZE_VALUES = [\n    '-moz-initial',\n    'fill',\n    'none',\n    'scale-down',\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return !!src && typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === 'undefined') {\n        return x;\n    }\n    if (typeof x === 'number') {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: 'w'\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: 'w'\n        };\n    }\n    if (typeof width !== 'number') {\n        return {\n            widths: deviceSizes,\n            kind: 'w'\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: 'x'\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === 'w' ? '100vw' : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === 'w' ? w : i + 1) + kind).join(', '),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = 'empty', blurDataURL, fetchPriority, decoding = 'async', layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if ('allSizes' in c) {\n        config = c;\n    } else {\n        var _c_qualities;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes,\n            qualities\n        };\n    }\n    if (typeof defaultLoader === 'undefined') {\n        throw Object.defineProperty(new Error('images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config'), \"__NEXT_ERROR_CODE\", {\n            value: \"E163\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = '__next_img_default' in loader;\n    if (isDefaultLoader) {\n        if (config.loader === 'custom') {\n            throw Object.defineProperty(new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\"), \"__NEXT_ERROR_CODE\", {\n                value: \"E252\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === 'fill') {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: '100%',\n                height: 'auto'\n            },\n            responsive: {\n                width: '100%',\n                height: 'auto'\n            }\n        };\n        const layoutToSizes = {\n            responsive: '100vw',\n            fill: '100vw'\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = '';\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw Object.defineProperty(new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData)), \"__NEXT_ERROR_CODE\", {\n                value: \"E460\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw Object.defineProperty(new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData)), \"__NEXT_ERROR_CODE\", {\n                value: \"E48\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === 'string' ? src : staticSrc;\n    let isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');\n    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && !config.dangerouslyAllowSVG && src.split('?', 1)[0].endsWith('.svg')) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === 'export' && isDefaultLoader && !unoptimized) {\n            throw Object.defineProperty(new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\"), \"__NEXT_ERROR_CODE\", {\n                value: \"E500\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E96\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (height) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E115\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== 'absolute') {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E216\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== '100%') {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E73\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== '100%') {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E404\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            } else {\n                if (typeof widthInt === 'undefined') {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" is missing required \"width\" property.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E451\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                } else if (isNaN(widthInt)) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E66\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (typeof heightInt === 'undefined') {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" is missing required \"height\" property.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E397\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                } else if (isNaN(heightInt)) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E444\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/^[\\x00-\\x20]/.test(src)) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E176\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/[\\x00-\\x20]$/.test(src)) {\n                    throw Object.defineProperty(new Error('Image with src \"' + src + '\" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E21\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw Object.defineProperty(new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(',') + \".\"), \"__NEXT_ERROR_CODE\", {\n                value: \"E357\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (priority && loading === 'lazy') {\n            throw Object.defineProperty(new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E218\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {\n            throw Object.defineProperty(new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".'), \"__NEXT_ERROR_CODE\", {\n                value: \"E431\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (placeholder !== 'empty') {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === 'blur' && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                'jpeg',\n                'png',\n                'webp',\n                'avif'\n            ] // should match next-image-loader\n            ;\n            throw Object.defineProperty(new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(',') + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'), \"__NEXT_ERROR_CODE\", {\n                value: \"E371\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if ('ref' in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if ( true && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || '';\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === 'empty' && !lcpImage.src.startsWith('data:') && !lcpImage.src.startsWith('blob:')) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: 'largest-contentful-paint',\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: 'absolute',\n        height: '100%',\n        width: '100%',\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: 'transparent'\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || '',\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    const backgroundSize = !INVALID_BACKGROUND_SIZE_VALUES.includes(imgStyle.objectFit) ? imgStyle.objectFit : imgStyle.objectFit === 'fill' ? '100% 100%' // the background-size equivalent of `fill`\n     : 'cover';\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize,\n        backgroundPosition: imgStyle.objectPosition || '50% 50%',\n        backgroundRepeat: 'no-repeat',\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === 'blur' && (blurDataURL == null ? void 0 : blurDataURL.startsWith('/'))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (true) {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? 'lazy' : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding,\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7K0NBaVFnQkE7OztlQUFBQTs7O3NDQWpRUzswQ0FDTzt5Q0FDRztBQStFbkMsTUFBTUMsdUJBQXVCO0lBQUM7SUFBUTtJQUFTQztDQUFVO0FBRXpELDhEQUE4RDtBQUM5RCxNQUFNQyxpQ0FBaUM7SUFDckM7SUFDQTtJQUNBO0lBQ0E7SUFDQUQ7Q0FDRDtBQTRCRCxTQUFTRSxnQkFDUEMsR0FBb0M7SUFFcEMsT0FBUUEsSUFBc0JDLE9BQU8sS0FBS0o7QUFDNUM7QUFFQSxTQUFTSyxrQkFDUEYsR0FBb0M7SUFFcEMsT0FBUUEsSUFBd0JBLEdBQUcsS0FBS0g7QUFDMUM7QUFFQSxTQUFTTSxlQUFlSCxHQUEwQjtJQUNoRCxPQUNFLENBQUMsQ0FBQ0EsT0FDRixPQUFPQSxRQUFRLFlBQ2RELENBQUFBLGdCQUFnQkMsUUFDZkUsa0JBQWtCRixJQUFBQSxDQUFtQjtBQUUzQztNQUVNSSxVQUFVLElBQUlDO0FBSXBCLElBQUlDO0FBRUosU0FBU0MsT0FBT0MsQ0FBVTtJQUN4QixJQUFJLE9BQU9BLE1BQU0sYUFBYTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxPQUFPQSxNQUFNLFVBQVU7UUFDekIsT0FBT0MsT0FBT0MsUUFBUSxDQUFDRixLQUFLQSxJQUFJRztJQUNsQztJQUNBLElBQUksT0FBT0gsTUFBTSxZQUFZLFdBQVdJLElBQUksQ0FBQ0osSUFBSTtRQUMvQyxPQUFPSyxTQUFTTCxHQUFHO0lBQ3JCO0lBQ0EsT0FBT0c7QUFDVDtBQUVBLFNBQVNHLFVBQ1AsS0FBc0MsRUFDdENDLEtBQXlCLEVBQ3pCQyxLQUF5QjtJQUZ6QixNQUFFQyxXQUFXLEVBQUVDLFFBQVEsRUFBZSxHQUF0QztJQUlBLElBQUlGLE9BQU87UUFDVCx5REFBeUQ7UUFDekQsTUFBTUcsa0JBQWtCO1FBQ3hCLE1BQU1DLGVBQWUsRUFBRTtRQUN2QixJQUFLLElBQUlDLE9BQVFBLFFBQVFGLGdCQUFnQkcsSUFBSSxDQUFDTixRQUFTSyxNQUFPO1lBQzVERCxhQUFhRyxJQUFJLENBQUNWLFNBQVNRLEtBQUssQ0FBQyxFQUFFO1FBQ3JDO1FBQ0EsSUFBSUQsYUFBYUksTUFBTSxFQUFFO1lBQ3ZCLE1BQU1DLGdCQUFnQkMsS0FBS0MsR0FBRyxJQUFJUCxnQkFBZ0I7WUFDbEQsT0FBTztnQkFDTFEsUUFBUVYsU0FBU1csTUFBTSxDQUFDLENBQUNDLElBQU1BLEtBQUtiLFdBQVcsQ0FBQyxFQUFFLEdBQUdRO2dCQUNyRE0sTUFBTTtZQUNSO1FBQ0Y7UUFDQSxPQUFPO1lBQUVILFFBQVFWO1lBQVVhLE1BQU07UUFBSTtJQUN2QztJQUNBLElBQUksT0FBT2hCLFVBQVUsVUFBVTtRQUM3QixPQUFPO1lBQUVhLFFBQVFYO1lBQWFjLE1BQU07UUFBSTtJQUMxQztJQUVBLE1BQU1ILFNBQVM7V0FDVixJQUFJSSxJQUNMLHFFQUNxRTtRQUNyRSxrRUFBa0U7UUFDbEUsb0VBQW9FO1FBQ3BFLHVFQUF1RTtRQUN2RSxzRUFBc0U7UUFDdEUsdUNBQXVDO1FBQ3ZDLHFJQUFxSTtRQUNySTtZQUFDakI7WUFBT0EsUUFBUSxFQUFFLGFBQWE7U0FBRyxDQUFDa0IsR0FBRyxDQUNwQyxDQUFDQyxJQUFNaEIsU0FBU2lCLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxLQUFLRixNQUFNaEIsUUFBUSxDQUFDQSxTQUFTTSxNQUFNLEdBQUcsRUFBRTtLQUd6RTtJQUNELE9BQU87UUFBRUk7UUFBUUcsTUFBTTtJQUFJO0FBQzdCO0FBa0JBLFNBQVNNLGlCQUFpQixLQVFSO0lBUlEsTUFDeEJDLE1BQU0sRUFDTnRDLEdBQUcsRUFDSHVDLFdBQVcsRUFDWHhCLEtBQUssRUFDTHlCLE9BQU8sRUFDUHhCLEtBQUssRUFDTHlCLE1BQU0sRUFDVSxHQVJRO0lBU3hCLElBQUlGLGFBQWE7UUFDZixPQUFPO1lBQUV2QztZQUFLMEMsUUFBUTdDO1lBQVdtQixPQUFPbkI7UUFBVTtJQUNwRDtJQUVBLE1BQU0sRUFBRStCLE1BQU0sRUFBRUcsSUFBSSxFQUFFLEdBQUdqQixVQUFVd0IsUUFBUXZCLE9BQU9DO0lBQ2xELE1BQU0yQixPQUFPZixPQUFPSixNQUFNLEdBQUc7SUFFN0IsT0FBTztRQUNMUixPQUFPLENBQUNBLFNBQVNlLFNBQVMsTUFBTSxVQUFVZjtRQUMxQzBCLFFBQVFkLE9BQ0xLLEdBQUcsQ0FDRixDQUFDQyxHQUFHVSxJQUNDSCxPQUFPO2dCQUFFSDtnQkFBUXRDO2dCQUFLd0M7Z0JBQVN6QixPQUFPbUI7WUFBRSxLQUFHLE1BQzVDSCxVQUFTLE1BQU1HLElBQUlVLEtBQUksSUFDdEJiLE1BRU5jLElBQUksQ0FBQztRQUVSLHVFQUF1RTtRQUN2RSxtRUFBbUU7UUFDbkUseUVBQXlFO1FBQ3pFLDBFQUEwRTtRQUMxRSwyQkFBMkI7UUFDM0Isc0RBQXNEO1FBQ3REN0MsS0FBS3lDLE9BQU87WUFBRUg7WUFBUXRDO1lBQUt3QztZQUFTekIsT0FBT2EsTUFBTSxDQUFDZSxLQUFLO1FBQUM7SUFDMUQ7QUFDRjtBQUtPLFNBQVNoRCxZQUNkLEtBeUJhLEVBQ2JtRCxNQUtDO0lBL0JELE1BQ0U5QyxHQUFHLEVBQ0hnQixLQUFLLEVBQ0x1QixjQUFjLEtBQUssRUFDbkJRLFdBQVcsS0FBSyxFQUNoQkMsT0FBTyxFQUNQQyxTQUFTLEVBQ1RULE9BQU8sRUFDUHpCLEtBQUssRUFDTG1DLE1BQU0sRUFDTkMsT0FBTyxLQUFLLEVBQ1pDLEtBQUssRUFDTEMsV0FBVyxFQUNYQyxNQUFNLEVBQ05DLGlCQUFpQixFQUNqQkMsY0FBYyxPQUFPLEVBQ3JCQyxXQUFXLEVBQ1hDLGFBQWEsRUFDYkMsV0FBVyxPQUFPLEVBQ2xCQyxNQUFNLEVBQ05DLFNBQVMsRUFDVEMsY0FBYyxFQUNkQyxZQUFZLEVBQ1pDLFFBQVEsRUFDUixHQUFHQyxNQUNRLEdBekJiO0lBeUNBLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsYUFBYSxFQUFFLEdBQUd2QjtJQUM5RCxJQUFJUjtJQUNKLElBQUlnQyxJQUFJSixXQUFXSyxhQUFBQSxrQkFBa0I7SUFDckMsSUFBSSxjQUFjRCxHQUFHO1FBQ25CaEMsU0FBU2dDO0lBQ1gsT0FBTztZQUdhQTtRQUZsQixNQUFNcEQsV0FBVztlQUFJb0QsRUFBRXJELFdBQVc7ZUFBS3FELEVBQUVFLFVBQVU7U0FBQyxDQUFDQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUM7UUFDeEUsTUFBTTFELGNBQWNxRCxFQUFFckQsV0FBVyxDQUFDd0QsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDO1FBQ3JELE1BQU1DLFlBQUFBLENBQVlOLGVBQUFBLEVBQUVNLFNBQUFBLEtBQVMsZ0JBQVhOLGFBQWFHLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQztRQUNsRHJDLFNBQVM7WUFBRSxHQUFHZ0MsQ0FBQztZQUFFcEQ7WUFBVUQ7WUFBYTJEO1FBQVU7SUFDcEQ7SUFFQSxJQUFJLE9BQU9QLGtCQUFrQixhQUFhO1FBQ3hDLE1BQU0scUJBRUwsQ0FGSyxJQUFJUSxNQUNSLDBJQURJO21CQUFBO3dCQUFBOzBCQUFBO1FBRU47SUFDRjtJQUNBLElBQUlwQyxTQUFnQ3dCLEtBQUt4QixNQUFNLElBQUk0QjtJQUVuRCxzREFBc0Q7SUFDdEQsT0FBT0osS0FBS3hCLE1BQU07SUFDbEIsT0FBUXdCLEtBQWF2QixNQUFNO0lBRTNCLDZDQUE2QztJQUM3QyxvREFBb0Q7SUFDcEQsTUFBTW9DLGtCQUFrQix3QkFBd0JyQztJQUVoRCxJQUFJcUMsaUJBQWlCO1FBQ25CLElBQUl4QyxPQUFPRyxNQUFNLEtBQUssVUFBVTtZQUM5QixNQUFNLHFCQUdMLENBSEssSUFBSW9DLE1BQ1AscUJBQWtCN0UsTUFBSSxnQ0FDcEIsNEVBRkM7dUJBQUE7NEJBQUE7OEJBQUE7WUFHTjtRQUNGO0lBQ0YsT0FBTztRQUNMLDhDQUE4QztRQUM5QywrQ0FBK0M7UUFDL0MsaURBQWlEO1FBQ2pELE1BQU0rRSxvQkFBb0J0QztRQUMxQkEsU0FBUyxDQUFDdUM7WUFDUixNQUFNLEVBQUUxQyxRQUFRMkMsQ0FBQyxFQUFFLEdBQUdDLE1BQU0sR0FBR0Y7WUFDL0IsT0FBT0Qsa0JBQWtCRztRQUMzQjtJQUNGO0lBRUEsSUFBSXRCLFFBQVE7UUFDVixJQUFJQSxXQUFXLFFBQVE7WUFDckJULE9BQU87UUFDVDtRQUNBLE1BQU1nQyxnQkFBb0U7WUFDeEVDLFdBQVc7Z0JBQUVDLFVBQVU7Z0JBQVFuQyxRQUFRO1lBQU87WUFDOUNvQyxZQUFZO2dCQUFFdkUsT0FBTztnQkFBUW1DLFFBQVE7WUFBTztRQUM5QztRQUNBLE1BQU1xQyxnQkFBb0Q7WUFDeERELFlBQVk7WUFDWm5DLE1BQU07UUFDUjtRQUNBLE1BQU1xQyxjQUFjTCxhQUFhLENBQUN2QixPQUFPO1FBQ3pDLElBQUk0QixhQUFhO1lBQ2ZwQyxRQUFRO2dCQUFFLEdBQUdBLEtBQUs7Z0JBQUUsR0FBR29DLFdBQVc7WUFBQztRQUNyQztRQUNBLE1BQU1DLGNBQWNGLGFBQWEsQ0FBQzNCLE9BQU87UUFDekMsSUFBSTZCLGVBQWUsQ0FBQ3pFLE9BQU87WUFDekJBLFFBQVF5RTtRQUNWO0lBQ0Y7SUFFQSxJQUFJQyxZQUFZO0lBQ2hCLElBQUlDLFdBQVdwRixPQUFPUTtJQUN0QixJQUFJNkUsWUFBWXJGLE9BQU8yQztJQUN2QixJQUFJMkM7SUFDSixJQUFJQztJQUNKLElBQUkzRixlQUFlSCxNQUFNO1FBQ3ZCLE1BQU0rRixrQkFBa0JoRyxnQkFBZ0JDLE9BQU9BLElBQUlDLE9BQU8sR0FBR0Q7UUFFN0QsSUFBSSxDQUFDK0YsZ0JBQWdCL0YsR0FBRyxFQUFFO1lBQ3hCLE1BQU0scUJBSUwsQ0FKSyxJQUFJNkUsTUFDUCxnSkFBNkltQixLQUFLQyxTQUFTLENBQzFKRixtQkFGRTt1QkFBQTs0QkFBQTs4QkFBQTtZQUlOO1FBQ0Y7UUFDQSxJQUFJLENBQUNBLGdCQUFnQjdDLE1BQU0sSUFBSSxDQUFDNkMsZ0JBQWdCaEYsS0FBSyxFQUFFO1lBQ3JELE1BQU0scUJBSUwsQ0FKSyxJQUFJOEQsTUFDUCw2SkFBMEptQixLQUFLQyxTQUFTLENBQ3ZLRixtQkFGRTt1QkFBQTs0QkFBQTs4QkFBQTtZQUlOO1FBQ0Y7UUFFQUYsWUFBWUUsZ0JBQWdCRixTQUFTO1FBQ3JDQyxhQUFhQyxnQkFBZ0JELFVBQVU7UUFDdkNyQyxjQUFjQSxlQUFlc0MsZ0JBQWdCdEMsV0FBVztRQUN4RGlDLFlBQVlLLGdCQUFnQi9GLEdBQUc7UUFFL0IsSUFBSSxDQUFDbUQsTUFBTTtZQUNULElBQUksQ0FBQ3dDLFlBQVksQ0FBQ0MsV0FBVztnQkFDM0JELFdBQVdJLGdCQUFnQmhGLEtBQUs7Z0JBQ2hDNkUsWUFBWUcsZ0JBQWdCN0MsTUFBTTtZQUNwQyxPQUFPLElBQUl5QyxZQUFZLENBQUNDLFdBQVc7Z0JBQ2pDLE1BQU1NLFFBQVFQLFdBQVdJLGdCQUFnQmhGLEtBQUs7Z0JBQzlDNkUsWUFBWWxFLEtBQUt5RSxLQUFLLENBQUNKLGdCQUFnQjdDLE1BQU0sR0FBR2dEO1lBQ2xELE9BQU8sSUFBSSxDQUFDUCxZQUFZQyxXQUFXO2dCQUNqQyxNQUFNTSxRQUFRTixZQUFZRyxnQkFBZ0I3QyxNQUFNO2dCQUNoRHlDLFdBQVdqRSxLQUFLeUUsS0FBSyxDQUFDSixnQkFBZ0JoRixLQUFLLEdBQUdtRjtZQUNoRDtRQUNGO0lBQ0Y7SUFDQWxHLE1BQU0sT0FBT0EsUUFBUSxXQUFXQSxNQUFNMEY7SUFFdEMsSUFBSVUsU0FDRixDQUFDckQsWUFBYUMsQ0FBQUEsWUFBWSxVQUFVLE9BQU9BLFlBQVksWUFBVTtJQUNuRSxJQUFJLENBQUNoRCxPQUFPQSxJQUFJcUcsVUFBVSxDQUFDLFlBQVlyRyxJQUFJcUcsVUFBVSxDQUFDLFVBQVU7UUFDOUQsdUVBQXVFO1FBQ3ZFOUQsY0FBYztRQUNkNkQsU0FBUztJQUNYO0lBQ0EsSUFBSTlELE9BQU9DLFdBQVcsRUFBRTtRQUN0QkEsY0FBYztJQUNoQjtJQUNBLElBQ0V1QyxtQkFDQSxDQUFDeEMsT0FBT2dFLG1CQUFtQixJQUMzQnRHLElBQUl1RyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDQyxRQUFRLENBQUMsU0FDOUI7UUFDQSx5REFBeUQ7UUFDekQsK0NBQStDO1FBQy9DakUsY0FBYztJQUNoQjtJQUVBLE1BQU1rRSxhQUFhbEcsT0FBT2lDO0lBRTFCLElBQUlrRSxJQUFvQixFQUFtQjtRQUN6QyxJQUFJcEUsT0FBT3VFLE1BQU0sS0FBSyxZQUFZL0IsbUJBQW1CLENBQUN2QyxhQUFhO1lBQ2pFLE1BQU0scUJBTUwsQ0FOSyxJQUFJc0MsTUFDUCwyWkFERzt1QkFBQTs0QkFBQTs4QkFBQTtZQU1OO1FBQ0Y7UUFDQSxJQUFJLENBQUM3RSxLQUFLO1lBQ1IsaURBQWlEO1lBQ2pELCtDQUErQztZQUMvQywyQ0FBMkM7WUFDM0N1QyxjQUFjO1FBQ2hCLE9BQU87WUFDTCxJQUFJWSxNQUFNO2dCQUNSLElBQUlwQyxPQUFPO29CQUNULE1BQU0scUJBRUwsQ0FGSyxJQUFJOEQsTUFDUCxxQkFBa0I3RSxNQUFJLHVFQURuQjsrQkFBQTtvQ0FBQTtzQ0FBQTtvQkFFTjtnQkFDRjtnQkFDQSxJQUFJa0QsUUFBUTtvQkFDVixNQUFNLHFCQUVMLENBRkssSUFBSTJCLE1BQ1AscUJBQWtCN0UsTUFBSSx3RUFEbkI7K0JBQUE7b0NBQUE7c0NBQUE7b0JBRU47Z0JBQ0Y7Z0JBQ0EsSUFBSW9ELENBQUFBLFNBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE1BQU8wRCxRQUFBQSxLQUFZMUQsTUFBTTBELFFBQVEsS0FBSyxZQUFZO29CQUNwRCxNQUFNLHFCQUVMLENBRkssSUFBSWpDLE1BQ1AscUJBQWtCN0UsTUFBSSxnSUFEbkI7K0JBQUE7b0NBQUE7c0NBQUE7b0JBRU47Z0JBQ0Y7Z0JBQ0EsSUFBSW9ELENBQUFBLFNBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE1BQU9yQyxLQUFBQSxLQUFTcUMsTUFBTXJDLEtBQUssS0FBSyxRQUFRO29CQUMxQyxNQUFNLHFCQUVMLENBRkssSUFBSThELE1BQ1AscUJBQWtCN0UsTUFBSSxzSEFEbkI7K0JBQUE7b0NBQUE7c0NBQUE7b0JBRU47Z0JBQ0Y7Z0JBQ0EsSUFBSW9ELENBQUFBLFNBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE1BQU9GLE1BQUFBLEtBQVVFLE1BQU1GLE1BQU0sS0FBSyxRQUFRO29CQUM1QyxNQUFNLHFCQUVMLENBRkssSUFBSTJCLE1BQ1AscUJBQWtCN0UsTUFBSSx3SEFEbkI7K0JBQUE7b0NBQUE7c0NBQUE7b0JBRU47Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMLElBQUksT0FBTzJGLGFBQWEsYUFBYTtvQkFDbkMsTUFBTSxxQkFFTCxDQUZLLElBQUlkLE1BQ1AscUJBQWtCN0UsTUFBSSw0Q0FEbkI7K0JBQUE7b0NBQUE7c0NBQUE7b0JBRU47Z0JBQ0YsT0FBTyxJQUFJK0csTUFBTXBCLFdBQVc7b0JBQzFCLE1BQU0scUJBRUwsQ0FGSyxJQUFJZCxNQUNQLHFCQUFrQjdFLE1BQUksc0ZBQW1GZSxRQUFNLE9BRDVHOytCQUFBO29DQUFBO3NDQUFBO29CQUVOO2dCQUNGO2dCQUNBLElBQUksT0FBTzZFLGNBQWMsYUFBYTtvQkFDcEMsTUFBTSxxQkFFTCxDQUZLLElBQUlmLE1BQ1AscUJBQWtCN0UsTUFBSSw2Q0FEbkI7K0JBQUE7b0NBQUE7c0NBQUE7b0JBRU47Z0JBQ0YsT0FBTyxJQUFJK0csTUFBTW5CLFlBQVk7b0JBQzNCLE1BQU0scUJBRUwsQ0FGSyxJQUFJZixNQUNQLHFCQUFrQjdFLE1BQUksdUZBQW9Ga0QsU0FBTyxPQUQ5RzsrQkFBQTtvQ0FBQTtzQ0FBQTtvQkFFTjtnQkFDRjtnQkFDQSw0Q0FBNEM7Z0JBQzVDLElBQUksZUFBZXRDLElBQUksQ0FBQ1osTUFBTTtvQkFDNUIsTUFBTSxxQkFFTCxDQUZLLElBQUk2RSxNQUNQLHFCQUFrQjdFLE1BQUksOEhBRG5COytCQUFBO29DQUFBO3NDQUFBO29CQUVOO2dCQUNGO2dCQUNBLDRDQUE0QztnQkFDNUMsSUFBSSxlQUFlWSxJQUFJLENBQUNaLE1BQU07b0JBQzVCLE1BQU0scUJBRUwsQ0FGSyxJQUFJNkUsTUFDUCxxQkFBa0I3RSxNQUFJLDBIQURuQjsrQkFBQTtvQ0FBQTtzQ0FBQTtvQkFFTjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUNKLHFCQUFxQm9ILFFBQVEsQ0FBQ2hFLFVBQVU7WUFDM0MsTUFBTSxxQkFJTCxDQUpLLElBQUk2QixNQUNQLHFCQUFrQjdFLE1BQUksaURBQThDZ0QsVUFBUSx3QkFBcUJwRCxxQkFBcUJxQyxHQUFHLENBQ3hIZ0YsUUFDQXBFLElBQUksQ0FBQyxPQUFLLE1BSFI7dUJBQUE7NEJBQUE7OEJBQUE7WUFJTjtRQUNGO1FBQ0EsSUFBSUUsWUFBWUMsWUFBWSxRQUFRO1lBQ2xDLE1BQU0scUJBRUwsQ0FGSyxJQUFJNkIsTUFDUCxxQkFBa0I3RSxNQUFJLHNGQURuQjt1QkFBQTs0QkFBQTs4QkFBQTtZQUVOO1FBQ0Y7UUFDQSxJQUNFd0QsZ0JBQWdCLFdBQ2hCQSxnQkFBZ0IsVUFDaEIsQ0FBQ0EsWUFBWTZDLFVBQVUsQ0FBQyxnQkFDeEI7WUFDQSxNQUFNLHFCQUVMLENBRkssSUFBSXhCLE1BQ1AscUJBQWtCN0UsTUFBSSwyQ0FBd0N3RCxjQUFZLE9BRHZFO3VCQUFBOzRCQUFBOzhCQUFBO1lBRU47UUFDRjtRQUNBLElBQUlBLGdCQUFnQixTQUFTO1lBQzNCLElBQUltQyxZQUFZQyxhQUFhRCxXQUFXQyxZQUFZLE1BQU07Z0JBQ3hEc0IsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFDRyxxQkFBa0JsSCxNQUFJO1lBRTNCO1FBQ0Y7UUFDQSxJQUFJd0QsZ0JBQWdCLFVBQVUsQ0FBQ0MsYUFBYTtZQUMxQyxNQUFNMEQsaUJBQWlCO2dCQUFDO2dCQUFRO2dCQUFPO2dCQUFRO2FBQU8sQ0FBQyxpQ0FBaUM7O1lBRXhGLE1BQU0scUJBU0wsQ0FUSyxJQUFJdEMsTUFDUCxxQkFBa0I3RSxNQUFJLDZUQUdrRW1ILGVBQWV0RSxJQUFJLENBQ3hHLE9BQ0EsK0xBTkE7dUJBQUE7NEJBQUE7OEJBQUE7WUFTTjtRQUNGO1FBQ0EsSUFBSSxTQUFTb0IsTUFBTTtZQUNqQmlELENBQUFBLEdBQUFBLFVBQUFBLFFBQUFBLEVBQ0cscUJBQWtCbEgsTUFBSTtRQUUzQjtRQUVBLElBQUksQ0FBQ3VDLGVBQWUsQ0FBQ3VDLGlCQUFpQjtZQUNwQyxNQUFNc0MsU0FBUzNFLE9BQU87Z0JBQ3BCSDtnQkFDQXRDO2dCQUNBZSxPQUFPNEUsWUFBWTtnQkFDbkJuRCxTQUFTaUUsY0FBYztZQUN6QjtZQUNBLElBQUlZO1lBQ0osSUFBSTtnQkFDRkEsTUFBTSxJQUFJQyxJQUFJRjtZQUNoQixFQUFFLE9BQU9HLEtBQUssQ0FBQztZQUNmLElBQUlILFdBQVdwSCxPQUFRcUgsT0FBT0EsSUFBSUcsUUFBUSxLQUFLeEgsT0FBTyxDQUFDcUgsSUFBSUksTUFBTSxFQUFHO2dCQUNsRVAsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFDRyxxQkFBa0JsSCxNQUFJLDRIQUNwQjtZQUVQO1FBQ0Y7UUFFQSxJQUFJdUQsbUJBQW1CO1lBQ3JCMkQsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBUSxFQUNMLHFCQUFrQmxILE1BQUk7UUFFM0I7UUFFQSxLQUFLLE1BQU0sQ0FBQzBILFdBQVdDLFlBQVksSUFBSUMsT0FBT0MsT0FBTyxDQUFDO1lBQ3BEakU7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7UUFDRixHQUFJO1lBQ0YsSUFBSTJELGFBQWE7Z0JBQ2ZULENBQUFBLEdBQUFBLFVBQUFBLFFBQUFBLEVBQ0cscUJBQWtCbEgsTUFBSSx3QkFBcUIwSCxZQUFVLDBDQUNuRDtZQUVQO1FBQ0Y7UUFFQSxJQUNFLEtBQTZCLElBQzdCLENBQUNwSCxnQkFDRHdILE9BQU9DLG1CQUFtQixFQUMxQjtZQUNBekgsZUFBZSxJQUFJeUgsb0JBQW9CLENBQUNDO2dCQUN0QyxLQUFLLE1BQU1DLFNBQVNELFVBQVVFLFVBQVUsR0FBSTt3QkFFM0JEO29CQURmLDBFQUEwRTtvQkFDMUUsTUFBTUUsU0FBU0YsQ0FBQUEsU0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsaUJBQUFBLE1BQU9HLE9BQUFBLEtBQU8sZ0JBQWRILGVBQWdCakksR0FBQUEsS0FBTztvQkFDdEMsTUFBTXFJLFdBQVdqSSxRQUFRa0ksR0FBRyxDQUFDSDtvQkFDN0IsSUFDRUUsWUFDQSxDQUFDQSxTQUFTdEYsUUFBUSxJQUNsQnNGLFNBQVM3RSxXQUFXLEtBQUssV0FDekIsQ0FBQzZFLFNBQVNySSxHQUFHLENBQUNxRyxVQUFVLENBQUMsWUFDekIsQ0FBQ2dDLFNBQVNySSxHQUFHLENBQUNxRyxVQUFVLENBQUMsVUFDekI7d0JBQ0EsaURBQWlEO3dCQUNqRGEsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBUSxFQUNMLHFCQUFrQm1CLFNBQVNySSxHQUFHLEdBQUMsOEhBQzdCO29CQUVQO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJO2dCQUNGTSxhQUFhaUksT0FBTyxDQUFDO29CQUNuQkMsTUFBTTtvQkFDTkMsVUFBVTtnQkFDWjtZQUNGLEVBQUUsT0FBT2xCLEtBQUs7Z0JBQ1osb0NBQW9DO2dCQUNwQ21CLFFBQVFDLEtBQUssQ0FBQ3BCO1lBQ2hCO1FBQ0Y7SUFDRjtJQUNBLE1BQU1xQixXQUFXaEIsT0FBT2lCLE1BQU0sQ0FDNUIxRixPQUNJO1FBQ0UyRCxVQUFVO1FBQ1Y1RCxRQUFRO1FBQ1JuQyxPQUFPO1FBQ1ArSCxNQUFNO1FBQ05DLEtBQUs7UUFDTEMsT0FBTztRQUNQQyxRQUFRO1FBQ1JwRjtRQUNBQztJQUNGLElBQ0EsQ0FBQyxHQUNMSyxjQUFjLENBQUMsSUFBSTtRQUFFK0UsT0FBTztJQUFjLEdBQzFDOUY7SUFHRixNQUFNK0Ysa0JBQ0osQ0FBQy9FLGdCQUFnQlosZ0JBQWdCLFVBQzdCQSxnQkFBZ0IsU0FDYiwyQ0FBd0M0RixDQUFBQSxHQUFBQSxjQUFBQSxlQUFBQSxFQUFnQjtRQUN2RHpEO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FyQyxhQUFhQSxlQUFlO1FBQzVCSSxXQUFXK0UsU0FBUy9FLFNBQVM7SUFDL0IsS0FBRyxPQUNGLFVBQU9MLGNBQVksS0FBSSx1QkFBdUI7T0FDakQ7SUFFTixNQUFNNkYsaUJBQWlCLENBQUN2SiwrQkFBK0JrSCxRQUFRLENBQzdENEIsU0FBUy9FLFNBQVMsSUFFaEIrRSxTQUFTL0UsU0FBUyxHQUNsQitFLFNBQVMvRSxTQUFTLEtBQUssU0FDckIsWUFBWSwyQ0FBMkM7T0FDdkQ7SUFFTixJQUFJeUYsbUJBQXFDSCxrQkFDckM7UUFDRUU7UUFDQUUsb0JBQW9CWCxTQUFTOUUsY0FBYyxJQUFJO1FBQy9DMEYsa0JBQWtCO1FBQ2xCTDtJQUNGLElBQ0EsQ0FBQztJQUVMLElBQUl6QyxJQUFvQixFQUFvQjtRQUMxQyxJQUNFNEMsaUJBQWlCSCxlQUFlLElBQ2hDM0YsZ0JBQWdCLFdBQ2hCQyxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxZQUFhNEMsVUFBVSxDQUFDLE9BQ3hCO1lBQ0EsOEVBQThFO1lBQzlFLGdGQUFnRjtZQUNoRixxRkFBcUY7WUFDckZpRCxpQkFBaUJILGVBQWUsR0FBSSxVQUFPMUYsY0FBWTtRQUN6RDtJQUNGO0lBRUEsTUFBTWdHLGdCQUFnQnBILGlCQUFpQjtRQUNyQ0M7UUFDQXRDO1FBQ0F1QztRQUNBeEIsT0FBTzRFO1FBQ1BuRCxTQUFTaUU7UUFDVHpGO1FBQ0F5QjtJQUNGO0lBRUEsSUFBSWlFLElBQW9CLEVBQW1CO1FBQ3pDLElBQUksSUFBNkIsRUFBRTtZQUNqQyxJQUFJZ0Q7WUFDSixJQUFJO2dCQUNGQSxVQUFVLElBQUlwQyxJQUFJbUMsY0FBY3pKLEdBQUc7WUFDckMsRUFBRSxPQUFPMkosR0FBRztnQkFDVkQsVUFBVSxJQUFJcEMsSUFBSW1DLGNBQWN6SixHQUFHLEVBQUU4SCxPQUFPOEIsUUFBUSxDQUFDQyxJQUFJO1lBQzNEO1lBQ0F6SixRQUFRMEosR0FBRyxDQUFDSixRQUFRRyxJQUFJLEVBQUU7Z0JBQUU3SjtnQkFBSytDO2dCQUFVUztZQUFZO1FBQ3pEO0lBQ0Y7SUFFQSxNQUFNdUcsUUFBa0I7UUFDdEIsR0FBRzlGLElBQUk7UUFDUGpCLFNBQVNvRCxTQUFTLFNBQVNwRDtRQUMzQlU7UUFDQTNDLE9BQU80RTtRQUNQekMsUUFBUTBDO1FBQ1JqQztRQUNBVjtRQUNBRyxPQUFPO1lBQUUsR0FBR3dGLFFBQVE7WUFBRSxHQUFHVSxnQkFBZ0I7UUFBQztRQUMxQ3RJLE9BQU95SSxjQUFjekksS0FBSztRQUMxQjBCLFFBQVErRyxjQUFjL0csTUFBTTtRQUM1QjFDLEtBQUtxRCxlQUFlb0csY0FBY3pKLEdBQUc7SUFDdkM7SUFDQSxNQUFNZ0ssT0FBTztRQUFFekg7UUFBYVE7UUFBVVM7UUFBYUw7SUFBSztJQUN4RCxPQUFPO1FBQUU0RztRQUFPQztJQUFLO0FBQ3ZCIiwic291cmNlcyI6WyJDOlxcc3JjXFxzaGFyZWRcXGxpYlxcZ2V0LWltZy1wcm9wcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4vdXRpbHMvd2Fybi1vbmNlJ1xuaW1wb3J0IHsgZ2V0SW1hZ2VCbHVyU3ZnIH0gZnJvbSAnLi9pbWFnZS1ibHVyLXN2ZydcbmltcG9ydCB7IGltYWdlQ29uZmlnRGVmYXVsdCB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHR5cGUge1xuICBJbWFnZUNvbmZpZ0NvbXBsZXRlLFxuICBJbWFnZUxvYWRlclByb3BzLFxuICBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZyxcbn0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5cbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgSlNYIH0gZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSW1hZ2VEYXRhIHtcbiAgc3JjOiBzdHJpbmdcbiAgaGVpZ2h0OiBudW1iZXJcbiAgd2lkdGg6IG51bWJlclxuICBibHVyRGF0YVVSTD86IHN0cmluZ1xuICBibHVyV2lkdGg/OiBudW1iZXJcbiAgYmx1ckhlaWdodD86IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY1JlcXVpcmUge1xuICBkZWZhdWx0OiBTdGF0aWNJbWFnZURhdGFcbn1cblxuZXhwb3J0IHR5cGUgU3RhdGljSW1wb3J0ID0gU3RhdGljUmVxdWlyZSB8IFN0YXRpY0ltYWdlRGF0YVxuXG5leHBvcnQgdHlwZSBJbWFnZVByb3BzID0gT21pdDxcbiAgSlNYLkludHJpbnNpY0VsZW1lbnRzWydpbWcnXSxcbiAgJ3NyYycgfCAnc3JjU2V0JyB8ICdyZWYnIHwgJ2FsdCcgfCAnd2lkdGgnIHwgJ2hlaWdodCcgfCAnbG9hZGluZydcbj4gJiB7XG4gIHNyYzogc3RyaW5nIHwgU3RhdGljSW1wb3J0XG4gIGFsdDogc3RyaW5nXG4gIHdpZHRoPzogbnVtYmVyIHwgYCR7bnVtYmVyfWBcbiAgaGVpZ2h0PzogbnVtYmVyIHwgYCR7bnVtYmVyfWBcbiAgZmlsbD86IGJvb2xlYW5cbiAgbG9hZGVyPzogSW1hZ2VMb2FkZXJcbiAgcXVhbGl0eT86IG51bWJlciB8IGAke251bWJlcn1gXG4gIHByaW9yaXR5PzogYm9vbGVhblxuICBsb2FkaW5nPzogTG9hZGluZ1ZhbHVlXG4gIHBsYWNlaG9sZGVyPzogUGxhY2Vob2xkZXJWYWx1ZVxuICBibHVyRGF0YVVSTD86IHN0cmluZ1xuICB1bm9wdGltaXplZD86IGJvb2xlYW5cbiAgb3ZlcnJpZGVTcmM/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgb25Mb2FkYCBpbnN0ZWFkLlxuICAgKiBAc2VlIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvaW1hZ2Ujb25sb2FkXG4gICAqL1xuICBvbkxvYWRpbmdDb21wbGV0ZT86IE9uTG9hZGluZ0NvbXBsZXRlXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGZpbGxgIHByb3AgaW5zdGVhZCBvZiBgbGF5b3V0PVwiZmlsbFwiYCBvciBjaGFuZ2UgaW1wb3J0IHRvIGBuZXh0L2xlZ2FjeS9pbWFnZWAuXG4gICAqIEBzZWUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2xlZ2FjeS9pbWFnZVxuICAgKi9cbiAgbGF5b3V0Pzogc3RyaW5nXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHN0eWxlYCBwcm9wIGluc3RlYWQuXG4gICAqL1xuICBvYmplY3RGaXQ/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgc3R5bGVgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9iamVjdFBvc2l0aW9uPzogc3RyaW5nXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIHByb3AgZG9lcyBub3QgZG8gYW55dGhpbmcuXG4gICAqL1xuICBsYXp5Qm91bmRhcnk/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgcHJvcCBkb2VzIG5vdCBkbyBhbnl0aGluZy5cbiAgICovXG4gIGxhenlSb290Pzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEltZ1Byb3BzID0gT21pdDxJbWFnZVByb3BzLCAnc3JjJyB8ICdsb2FkZXInPiAmIHtcbiAgbG9hZGluZzogTG9hZGluZ1ZhbHVlXG4gIHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgaGVpZ2h0OiBudW1iZXIgfCB1bmRlZmluZWRcbiAgc3R5bGU6IE5vbk51bGxhYmxlPEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW1nJ11bJ3N0eWxlJ10+XG4gIHNpemVzOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgc3JjU2V0OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgc3JjOiBzdHJpbmdcbn1cblxuY29uc3QgVkFMSURfTE9BRElOR19WQUxVRVMgPSBbJ2xhenknLCAnZWFnZXInLCB1bmRlZmluZWRdIGFzIGNvbnN0XG5cbi8vIE9iamVjdC1maXQgdmFsdWVzIHRoYXQgYXJlIG5vdCB2YWxpZCBiYWNrZ3JvdW5kLXNpemUgdmFsdWVzXG5jb25zdCBJTlZBTElEX0JBQ0tHUk9VTkRfU0laRV9WQUxVRVMgPSBbXG4gICctbW96LWluaXRpYWwnLFxuICAnZmlsbCcsXG4gICdub25lJyxcbiAgJ3NjYWxlLWRvd24nLFxuICB1bmRlZmluZWQsXG5dXG50eXBlIExvYWRpbmdWYWx1ZSA9ICh0eXBlb2YgVkFMSURfTE9BRElOR19WQUxVRVMpW251bWJlcl1cbnR5cGUgSW1hZ2VDb25maWcgPSBJbWFnZUNvbmZpZ0NvbXBsZXRlICYge1xuICBhbGxTaXplczogbnVtYmVyW11cbiAgb3V0cHV0PzogJ3N0YW5kYWxvbmUnIHwgJ2V4cG9ydCdcbn1cblxuZXhwb3J0IHR5cGUgSW1hZ2VMb2FkZXIgPSAocDogSW1hZ2VMb2FkZXJQcm9wcykgPT4gc3RyaW5nXG5cbi8vIERvIG5vdCBleHBvcnQgLSB0aGlzIGlzIGFuIGludGVybmFsIHR5cGUgb25seVxuLy8gYmVjYXVzZSBgbmV4dC5jb25maWcuanNgIGlzIG9ubHkgbWVhbnQgZm9yIHRoZVxuLy8gYnVpbHQtaW4gbG9hZGVycywgbm90IGZvciBhIGN1c3RvbSBsb2FkZXIoKSBwcm9wLlxudHlwZSBJbWFnZUxvYWRlcldpdGhDb25maWcgPSAocDogSW1hZ2VMb2FkZXJQcm9wc1dpdGhDb25maWcpID0+IHN0cmluZ1xuXG5leHBvcnQgdHlwZSBQbGFjZWhvbGRlclZhbHVlID0gJ2JsdXInIHwgJ2VtcHR5JyB8IGBkYXRhOmltYWdlLyR7c3RyaW5nfWBcbmV4cG9ydCB0eXBlIE9uTG9hZCA9IFJlYWN0LlJlYWN0RXZlbnRIYW5kbGVyPEhUTUxJbWFnZUVsZW1lbnQ+IHwgdW5kZWZpbmVkXG5leHBvcnQgdHlwZSBPbkxvYWRpbmdDb21wbGV0ZSA9IChpbWc6IEhUTUxJbWFnZUVsZW1lbnQpID0+IHZvaWRcblxuZXhwb3J0IHR5cGUgUGxhY2Vob2xkZXJTdHlsZSA9IFBhcnRpYWw8XG4gIFBpY2s8XG4gICAgQ1NTUHJvcGVydGllcyxcbiAgICB8ICdiYWNrZ3JvdW5kU2l6ZSdcbiAgICB8ICdiYWNrZ3JvdW5kUG9zaXRpb24nXG4gICAgfCAnYmFja2dyb3VuZFJlcGVhdCdcbiAgICB8ICdiYWNrZ3JvdW5kSW1hZ2UnXG4gID5cbj5cblxuZnVuY3Rpb24gaXNTdGF0aWNSZXF1aXJlKFxuICBzcmM6IFN0YXRpY1JlcXVpcmUgfCBTdGF0aWNJbWFnZURhdGFcbik6IHNyYyBpcyBTdGF0aWNSZXF1aXJlIHtcbiAgcmV0dXJuIChzcmMgYXMgU3RhdGljUmVxdWlyZSkuZGVmYXVsdCAhPT0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljSW1hZ2VEYXRhKFxuICBzcmM6IFN0YXRpY1JlcXVpcmUgfCBTdGF0aWNJbWFnZURhdGFcbik6IHNyYyBpcyBTdGF0aWNJbWFnZURhdGEge1xuICByZXR1cm4gKHNyYyBhcyBTdGF0aWNJbWFnZURhdGEpLnNyYyAhPT0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljSW1wb3J0KHNyYzogc3RyaW5nIHwgU3RhdGljSW1wb3J0KTogc3JjIGlzIFN0YXRpY0ltcG9ydCB7XG4gIHJldHVybiAoXG4gICAgISFzcmMgJiZcbiAgICB0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJlxuICAgIChpc1N0YXRpY1JlcXVpcmUoc3JjIGFzIFN0YXRpY0ltcG9ydCkgfHxcbiAgICAgIGlzU3RhdGljSW1hZ2VEYXRhKHNyYyBhcyBTdGF0aWNJbXBvcnQpKVxuICApXG59XG5cbmNvbnN0IGFsbEltZ3MgPSBuZXcgTWFwPFxuICBzdHJpbmcsXG4gIHsgc3JjOiBzdHJpbmc7IHByaW9yaXR5OiBib29sZWFuOyBwbGFjZWhvbGRlcjogUGxhY2Vob2xkZXJWYWx1ZSB9XG4+KClcbmxldCBwZXJmT2JzZXJ2ZXI6IFBlcmZvcm1hbmNlT2JzZXJ2ZXIgfCB1bmRlZmluZWRcblxuZnVuY3Rpb24gZ2V0SW50KHg6IHVua25vd24pOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAodHlwZW9mIHggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHhcbiAgfVxuICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh4KSA/IHggOiBOYU5cbiAgfVxuICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnICYmIC9eWzAtOV0rJC8udGVzdCh4KSkge1xuICAgIHJldHVybiBwYXJzZUludCh4LCAxMClcbiAgfVxuICByZXR1cm4gTmFOXG59XG5cbmZ1bmN0aW9uIGdldFdpZHRocyhcbiAgeyBkZXZpY2VTaXplcywgYWxsU2l6ZXMgfTogSW1hZ2VDb25maWcsXG4gIHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gIHNpemVzOiBzdHJpbmcgfCB1bmRlZmluZWRcbik6IHsgd2lkdGhzOiBudW1iZXJbXTsga2luZDogJ3cnIHwgJ3gnIH0ge1xuICBpZiAoc2l6ZXMpIHtcbiAgICAvLyBGaW5kIGFsbCB0aGUgXCJ2d1wiIHBlcmNlbnQgc2l6ZXMgdXNlZCBpbiB0aGUgc2l6ZXMgcHJvcFxuICAgIGNvbnN0IHZpZXdwb3J0V2lkdGhSZSA9IC8oXnxcXHMpKDE/XFxkP1xcZCl2dy9nXG4gICAgY29uc3QgcGVyY2VudFNpemVzID0gW11cbiAgICBmb3IgKGxldCBtYXRjaDsgKG1hdGNoID0gdmlld3BvcnRXaWR0aFJlLmV4ZWMoc2l6ZXMpKTsgbWF0Y2gpIHtcbiAgICAgIHBlcmNlbnRTaXplcy5wdXNoKHBhcnNlSW50KG1hdGNoWzJdKSlcbiAgICB9XG4gICAgaWYgKHBlcmNlbnRTaXplcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNtYWxsZXN0UmF0aW8gPSBNYXRoLm1pbiguLi5wZXJjZW50U2l6ZXMpICogMC4wMVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGhzOiBhbGxTaXplcy5maWx0ZXIoKHMpID0+IHMgPj0gZGV2aWNlU2l6ZXNbMF0gKiBzbWFsbGVzdFJhdGlvKSxcbiAgICAgICAga2luZDogJ3cnLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB3aWR0aHM6IGFsbFNpemVzLCBraW5kOiAndycgfVxuICB9XG4gIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHsgd2lkdGhzOiBkZXZpY2VTaXplcywga2luZDogJ3cnIH1cbiAgfVxuXG4gIGNvbnN0IHdpZHRocyA9IFtcbiAgICAuLi5uZXcgU2V0KFxuICAgICAgLy8gPiBUaGlzIG1lYW5zIHRoYXQgbW9zdCBPTEVEIHNjcmVlbnMgdGhhdCBzYXkgdGhleSBhcmUgM3ggcmVzb2x1dGlvbixcbiAgICAgIC8vID4gYXJlIGFjdHVhbGx5IDN4IGluIHRoZSBncmVlbiBjb2xvciwgYnV0IG9ubHkgMS41eCBpbiB0aGUgcmVkIGFuZFxuICAgICAgLy8gPiBibHVlIGNvbG9ycy4gU2hvd2luZyBhIDN4IHJlc29sdXRpb24gaW1hZ2UgaW4gdGhlIGFwcCB2cyBhIDJ4XG4gICAgICAvLyA+IHJlc29sdXRpb24gaW1hZ2Ugd2lsbCBiZSB2aXN1YWxseSB0aGUgc2FtZSwgdGhvdWdoIHRoZSAzeCBpbWFnZVxuICAgICAgLy8gPiB0YWtlcyBzaWduaWZpY2FudGx5IG1vcmUgZGF0YS4gRXZlbiB0cnVlIDN4IHJlc29sdXRpb24gc2NyZWVucyBhcmVcbiAgICAgIC8vID4gd2FzdGVmdWwgYXMgdGhlIGh1bWFuIGV5ZSBjYW5ub3Qgc2VlIHRoYXQgbGV2ZWwgb2YgZGV0YWlsIHdpdGhvdXRcbiAgICAgIC8vID4gc29tZXRoaW5nIGxpa2UgYSBtYWduaWZ5aW5nIGdsYXNzLlxuICAgICAgLy8gaHR0cHM6Ly9ibG9nLnR3aXR0ZXIuY29tL2VuZ2luZWVyaW5nL2VuX3VzL3RvcGljcy9pbmZyYXN0cnVjdHVyZS8yMDE5L2NhcHBpbmctaW1hZ2UtZmlkZWxpdHktb24tdWx0cmEtaGlnaC1yZXNvbHV0aW9uLWRldmljZXMuaHRtbFxuICAgICAgW3dpZHRoLCB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovXS5tYXAoXG4gICAgICAgICh3KSA9PiBhbGxTaXplcy5maW5kKChwKSA9PiBwID49IHcpIHx8IGFsbFNpemVzW2FsbFNpemVzLmxlbmd0aCAtIDFdXG4gICAgICApXG4gICAgKSxcbiAgXVxuICByZXR1cm4geyB3aWR0aHMsIGtpbmQ6ICd4JyB9XG59XG5cbnR5cGUgR2VuSW1nQXR0cnNEYXRhID0ge1xuICBjb25maWc6IEltYWdlQ29uZmlnXG4gIHNyYzogc3RyaW5nXG4gIHVub3B0aW1pemVkOiBib29sZWFuXG4gIGxvYWRlcjogSW1hZ2VMb2FkZXJXaXRoQ29uZmlnXG4gIHdpZHRoPzogbnVtYmVyXG4gIHF1YWxpdHk/OiBudW1iZXJcbiAgc2l6ZXM/OiBzdHJpbmdcbn1cblxudHlwZSBHZW5JbWdBdHRyc1Jlc3VsdCA9IHtcbiAgc3JjOiBzdHJpbmdcbiAgc3JjU2V0OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgc2l6ZXM6IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgY29uZmlnLFxuICBzcmMsXG4gIHVub3B0aW1pemVkLFxuICB3aWR0aCxcbiAgcXVhbGl0eSxcbiAgc2l6ZXMsXG4gIGxvYWRlcixcbn06IEdlbkltZ0F0dHJzRGF0YSk6IEdlbkltZ0F0dHJzUmVzdWx0IHtcbiAgaWYgKHVub3B0aW1pemVkKSB7XG4gICAgcmV0dXJuIHsgc3JjLCBzcmNTZXQ6IHVuZGVmaW5lZCwgc2l6ZXM6IHVuZGVmaW5lZCB9XG4gIH1cblxuICBjb25zdCB7IHdpZHRocywga2luZCB9ID0gZ2V0V2lkdGhzKGNvbmZpZywgd2lkdGgsIHNpemVzKVxuICBjb25zdCBsYXN0ID0gd2lkdGhzLmxlbmd0aCAtIDFcblxuICByZXR1cm4ge1xuICAgIHNpemVzOiAhc2l6ZXMgJiYga2luZCA9PT0gJ3cnID8gJzEwMHZ3JyA6IHNpemVzLFxuICAgIHNyY1NldDogd2lkdGhzXG4gICAgICAubWFwKFxuICAgICAgICAodywgaSkgPT5cbiAgICAgICAgICBgJHtsb2FkZXIoeyBjb25maWcsIHNyYywgcXVhbGl0eSwgd2lkdGg6IHcgfSl9ICR7XG4gICAgICAgICAgICBraW5kID09PSAndycgPyB3IDogaSArIDFcbiAgICAgICAgICB9JHtraW5kfWBcbiAgICAgIClcbiAgICAgIC5qb2luKCcsICcpLFxuXG4gICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAvLyBhdHRyaWJ1dGVzIGluIG9yZGVyLiBJZiB3ZSBrZWVwIGBzcmNgIHRoZSBmaXJzdCBvbmUsIFNhZmFyaSB3aWxsXG4gICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgLy8gYW5kIGBzaXplc2AgYXJlIGRlZmluZWQuXG4gICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgc3JjOiBsb2FkZXIoeyBjb25maWcsIHNyYywgcXVhbGl0eSwgd2lkdGg6IHdpZHRoc1tsYXN0XSB9KSxcbiAgfVxufVxuXG4vKipcbiAqIEEgc2hhcmVkIGZ1bmN0aW9uLCB1c2VkIG9uIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIsIHRvIGdlbmVyYXRlIHRoZSBwcm9wcyBmb3IgPGltZz4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWdQcm9wcyhcbiAge1xuICAgIHNyYyxcbiAgICBzaXplcyxcbiAgICB1bm9wdGltaXplZCA9IGZhbHNlLFxuICAgIHByaW9yaXR5ID0gZmFsc2UsXG4gICAgbG9hZGluZyxcbiAgICBjbGFzc05hbWUsXG4gICAgcXVhbGl0eSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZmlsbCA9IGZhbHNlLFxuICAgIHN0eWxlLFxuICAgIG92ZXJyaWRlU3JjLFxuICAgIG9uTG9hZCxcbiAgICBvbkxvYWRpbmdDb21wbGV0ZSxcbiAgICBwbGFjZWhvbGRlciA9ICdlbXB0eScsXG4gICAgYmx1ckRhdGFVUkwsXG4gICAgZmV0Y2hQcmlvcml0eSxcbiAgICBkZWNvZGluZyA9ICdhc3luYycsXG4gICAgbGF5b3V0LFxuICAgIG9iamVjdEZpdCxcbiAgICBvYmplY3RQb3NpdGlvbixcbiAgICBsYXp5Qm91bmRhcnksXG4gICAgbGF6eVJvb3QsXG4gICAgLi4ucmVzdFxuICB9OiBJbWFnZVByb3BzLFxuICBfc3RhdGU6IHtcbiAgICBkZWZhdWx0TG9hZGVyOiBJbWFnZUxvYWRlcldpdGhDb25maWdcbiAgICBpbWdDb25mOiBJbWFnZUNvbmZpZ0NvbXBsZXRlXG4gICAgc2hvd0FsdFRleHQ/OiBib29sZWFuXG4gICAgYmx1ckNvbXBsZXRlPzogYm9vbGVhblxuICB9XG4pOiB7XG4gIHByb3BzOiBJbWdQcm9wc1xuICBtZXRhOiB7XG4gICAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbiAgICBwcmlvcml0eTogYm9vbGVhblxuICAgIHBsYWNlaG9sZGVyOiBOb25OdWxsYWJsZTxJbWFnZVByb3BzWydwbGFjZWhvbGRlciddPlxuICAgIGZpbGw6IGJvb2xlYW5cbiAgfVxufSB7XG4gIGNvbnN0IHsgaW1nQ29uZiwgc2hvd0FsdFRleHQsIGJsdXJDb21wbGV0ZSwgZGVmYXVsdExvYWRlciB9ID0gX3N0YXRlXG4gIGxldCBjb25maWc6IEltYWdlQ29uZmlnXG4gIGxldCBjID0gaW1nQ29uZiB8fCBpbWFnZUNvbmZpZ0RlZmF1bHRcbiAgaWYgKCdhbGxTaXplcycgaW4gYykge1xuICAgIGNvbmZpZyA9IGMgYXMgSW1hZ2VDb25maWdcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhbGxTaXplcyA9IFsuLi5jLmRldmljZVNpemVzLCAuLi5jLmltYWdlU2l6ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgIGNvbnN0IGRldmljZVNpemVzID0gYy5kZXZpY2VTaXplcy5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICBjb25zdCBxdWFsaXRpZXMgPSBjLnF1YWxpdGllcz8uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgY29uZmlnID0geyAuLi5jLCBhbGxTaXplcywgZGV2aWNlU2l6ZXMsIHF1YWxpdGllcyB9XG4gIH1cblxuICBpZiAodHlwZW9mIGRlZmF1bHRMb2FkZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2ltYWdlcy5sb2FkZXJGaWxlIGRldGVjdGVkIGJ1dCB0aGUgZmlsZSBpcyBtaXNzaW5nIGRlZmF1bHQgZXhwb3J0LlxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1pbWFnZXMtY29uZmlnJ1xuICAgIClcbiAgfVxuICBsZXQgbG9hZGVyOiBJbWFnZUxvYWRlcldpdGhDb25maWcgPSByZXN0LmxvYWRlciB8fCBkZWZhdWx0TG9hZGVyXG5cbiAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPiBlbGVtZW50XG4gIGRlbGV0ZSByZXN0LmxvYWRlclxuICBkZWxldGUgKHJlc3QgYXMgYW55KS5zcmNTZXRcblxuICAvLyBUaGlzIHNwZWNpYWwgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlIHVzZXJcbiAgLy8gZGlkbid0IGRlZmluZSBhIFwibG9hZGVyXCIgcHJvcCBvciBcImxvYWRlclwiIGNvbmZpZy5cbiAgY29uc3QgaXNEZWZhdWx0TG9hZGVyID0gJ19fbmV4dF9pbWdfZGVmYXVsdCcgaW4gbG9hZGVyXG5cbiAgaWYgKGlzRGVmYXVsdExvYWRlcikge1xuICAgIGlmIChjb25maWcubG9hZGVyID09PSAnY3VzdG9tJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC5gICtcbiAgICAgICAgICBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyYFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgdXNlciBkZWZpbmVkIGEgXCJsb2FkZXJcIiBwcm9wIG9yIGNvbmZpZy5cbiAgICAvLyBTaW5jZSB0aGUgY29uZmlnIG9iamVjdCBpcyBpbnRlcm5hbCBvbmx5LCB3ZVxuICAgIC8vIG11c3Qgbm90IHBhc3MgaXQgdG8gdGhlIHVzZXItZGVmaW5lZCBcImxvYWRlclwiLlxuICAgIGNvbnN0IGN1c3RvbUltYWdlTG9hZGVyID0gbG9hZGVyIGFzIEltYWdlTG9hZGVyXG4gICAgbG9hZGVyID0gKG9iaikgPT4ge1xuICAgICAgY29uc3QgeyBjb25maWc6IF8sIC4uLm9wdHMgfSA9IG9ialxuICAgICAgcmV0dXJuIGN1c3RvbUltYWdlTG9hZGVyKG9wdHMpXG4gICAgfVxuICB9XG5cbiAgaWYgKGxheW91dCkge1xuICAgIGlmIChsYXlvdXQgPT09ICdmaWxsJykge1xuICAgICAgZmlsbCA9IHRydWVcbiAgICB9XG4gICAgY29uc3QgbGF5b3V0VG9TdHlsZTogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHVuZGVmaW5lZD4gPSB7XG4gICAgICBpbnRyaW5zaWM6IHsgbWF4V2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnYXV0bycgfSxcbiAgICAgIHJlc3BvbnNpdmU6IHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnYXV0bycgfSxcbiAgICB9XG4gICAgY29uc3QgbGF5b3V0VG9TaXplczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiA9IHtcbiAgICAgIHJlc3BvbnNpdmU6ICcxMDB2dycsXG4gICAgICBmaWxsOiAnMTAwdncnLFxuICAgIH1cbiAgICBjb25zdCBsYXlvdXRTdHlsZSA9IGxheW91dFRvU3R5bGVbbGF5b3V0XVxuICAgIGlmIChsYXlvdXRTdHlsZSkge1xuICAgICAgc3R5bGUgPSB7IC4uLnN0eWxlLCAuLi5sYXlvdXRTdHlsZSB9XG4gICAgfVxuICAgIGNvbnN0IGxheW91dFNpemVzID0gbGF5b3V0VG9TaXplc1tsYXlvdXRdXG4gICAgaWYgKGxheW91dFNpemVzICYmICFzaXplcykge1xuICAgICAgc2l6ZXMgPSBsYXlvdXRTaXplc1xuICAgIH1cbiAgfVxuXG4gIGxldCBzdGF0aWNTcmMgPSAnJ1xuICBsZXQgd2lkdGhJbnQgPSBnZXRJbnQod2lkdGgpXG4gIGxldCBoZWlnaHRJbnQgPSBnZXRJbnQoaGVpZ2h0KVxuICBsZXQgYmx1cldpZHRoOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgbGV0IGJsdXJIZWlnaHQ6IG51bWJlciB8IHVuZGVmaW5lZFxuICBpZiAoaXNTdGF0aWNJbXBvcnQoc3JjKSkge1xuICAgIGNvbnN0IHN0YXRpY0ltYWdlRGF0YSA9IGlzU3RhdGljUmVxdWlyZShzcmMpID8gc3JjLmRlZmF1bHQgOiBzcmNcblxuICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLnNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBzcmMuIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgc3RhdGljSW1hZ2VEYXRhXG4gICAgICAgICl9YFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgfHwgIXN0YXRpY0ltYWdlRGF0YS53aWR0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBoZWlnaHQgYW5kIHdpZHRoLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHN0YXRpY0ltYWdlRGF0YVxuICAgICAgICApfWBcbiAgICAgIClcbiAgICB9XG5cbiAgICBibHVyV2lkdGggPSBzdGF0aWNJbWFnZURhdGEuYmx1cldpZHRoXG4gICAgYmx1ckhlaWdodCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVySGVpZ2h0XG4gICAgYmx1ckRhdGFVUkwgPSBibHVyRGF0YVVSTCB8fCBzdGF0aWNJbWFnZURhdGEuYmx1ckRhdGFVUkxcbiAgICBzdGF0aWNTcmMgPSBzdGF0aWNJbWFnZURhdGEuc3JjXG5cbiAgICBpZiAoIWZpbGwpIHtcbiAgICAgIGlmICghd2lkdGhJbnQgJiYgIWhlaWdodEludCkge1xuICAgICAgICB3aWR0aEludCA9IHN0YXRpY0ltYWdlRGF0YS53aWR0aFxuICAgICAgICBoZWlnaHRJbnQgPSBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0XG4gICAgICB9IGVsc2UgaWYgKHdpZHRoSW50ICYmICFoZWlnaHRJbnQpIHtcbiAgICAgICAgY29uc3QgcmF0aW8gPSB3aWR0aEludCAvIHN0YXRpY0ltYWdlRGF0YS53aWR0aFxuICAgICAgICBoZWlnaHRJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgKiByYXRpbylcbiAgICAgIH0gZWxzZSBpZiAoIXdpZHRoSW50ICYmIGhlaWdodEludCkge1xuICAgICAgICBjb25zdCByYXRpbyA9IGhlaWdodEludCAvIHN0YXRpY0ltYWdlRGF0YS5oZWlnaHRcbiAgICAgICAgd2lkdGhJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS53aWR0aCAqIHJhdGlvKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzcmMgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHNyYyA6IHN0YXRpY1NyY1xuXG4gIGxldCBpc0xhenkgPVxuICAgICFwcmlvcml0eSAmJiAobG9hZGluZyA9PT0gJ2xhenknIHx8IHR5cGVvZiBsb2FkaW5nID09PSAndW5kZWZpbmVkJylcbiAgaWYgKCFzcmMgfHwgc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgfHwgc3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6JykpIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJJc1xuICAgIHVub3B0aW1pemVkID0gdHJ1ZVxuICAgIGlzTGF6eSA9IGZhbHNlXG4gIH1cbiAgaWYgKGNvbmZpZy51bm9wdGltaXplZCkge1xuICAgIHVub3B0aW1pemVkID0gdHJ1ZVxuICB9XG4gIGlmIChcbiAgICBpc0RlZmF1bHRMb2FkZXIgJiZcbiAgICAhY29uZmlnLmRhbmdlcm91c2x5QWxsb3dTVkcgJiZcbiAgICBzcmMuc3BsaXQoJz8nLCAxKVswXS5lbmRzV2l0aCgnLnN2ZycpXG4gICkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSB0byBtYWtlIHN2ZyBzZXJ2ZSBhcy1pcyB0byBhdm9pZCBwcm94eWluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJ1aWx0LWluIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gIH1cblxuICBjb25zdCBxdWFsaXR5SW50ID0gZ2V0SW50KHF1YWxpdHkpXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoY29uZmlnLm91dHB1dCA9PT0gJ2V4cG9ydCcgJiYgaXNEZWZhdWx0TG9hZGVyICYmICF1bm9wdGltaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2UgT3B0aW1pemF0aW9uIHVzaW5nIHRoZSBkZWZhdWx0IGxvYWRlciBpcyBub3QgY29tcGF0aWJsZSB3aXRoIFxcYHsgb3V0cHV0OiAnZXhwb3J0JyB9XFxgLlxuICBQb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgLSBSZW1vdmUgXFxgeyBvdXRwdXQ6ICdleHBvcnQnIH1cXGAgYW5kIHJ1biBcIm5leHQgc3RhcnRcIiB0byBydW4gc2VydmVyIG1vZGUgaW5jbHVkaW5nIHRoZSBJbWFnZSBPcHRpbWl6YXRpb24gQVBJLlxuICAgIC0gQ29uZmlndXJlIFxcYHsgaW1hZ2VzOiB7IHVub3B0aW1pemVkOiB0cnVlIH0gfVxcYCBpbiBcXGBuZXh0LmNvbmZpZy5qc1xcYCB0byBkaXNhYmxlIHRoZSBJbWFnZSBPcHRpbWl6YXRpb24gQVBJLlxuICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2V4cG9ydC1pbWFnZS1hcGlgXG4gICAgICApXG4gICAgfVxuICAgIGlmICghc3JjKSB7XG4gICAgICAvLyBSZWFjdCBkb2Vzbid0IHNob3cgdGhlIHN0YWNrIHRyYWNlIGFuZCB0aGVyZSdzXG4gICAgICAvLyBubyBgc3JjYCB0byBoZWxwIGlkZW50aWZ5IHdoaWNoIGltYWdlLCBzbyB3ZVxuICAgICAgLy8gaW5zdGVhZCBjb25zb2xlLmVycm9yKHJlZikgZHVyaW5nIG1vdW50LlxuICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwid2lkdGhcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJoZWlnaHRcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGU/LnBvc2l0aW9uICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUucG9zaXRpb25cIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHBvc2l0aW9uIGFic29sdXRlIC0gaXQgY2Fubm90IGJlIG1vZGlmaWVkLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlPy53aWR0aCAmJiBzdHlsZS53aWR0aCAhPT0gJzEwMCUnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUud2lkdGhcIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHdpZHRoIDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGU/LmhlaWdodCAmJiBzdHlsZS5oZWlnaHQgIT09ICcxMDAlJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLmhlaWdodFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgaGVpZ2h0IDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aEludCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBtaXNzaW5nIHJlcXVpcmVkIFwid2lkdGhcIiBwcm9wZXJ0eS5gXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHdpZHRoSW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCIke3dpZHRofVwiLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHRJbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgbWlzc2luZyByZXF1aXJlZCBcImhlaWdodFwiIHByb3BlcnR5LmBcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oaGVpZ2h0SW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwiaGVpZ2h0XCIgcHJvcGVydHkuIEV4cGVjdGVkIGEgbnVtZXJpYyB2YWx1ZSBpbiBwaXhlbHMgYnV0IHJlY2VpdmVkIFwiJHtoZWlnaHR9XCIuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgICBpZiAoL15bXFx4MDAtXFx4MjBdLy50ZXN0KHNyYykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBjYW5ub3Qgc3RhcnQgd2l0aCBhIHNwYWNlIG9yIGNvbnRyb2wgY2hhcmFjdGVyLiBVc2Ugc3JjLnRyaW1TdGFydCgpIHRvIHJlbW92ZSBpdCBvciBlbmNvZGVVUklDb21wb25lbnQoc3JjKSB0byBrZWVwIGl0LmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgICAgaWYgKC9bXFx4MDAtXFx4MjBdJC8udGVzdChzcmMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgY2Fubm90IGVuZCB3aXRoIGEgc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXIuIFVzZSBzcmMudHJpbUVuZCgpIHRvIHJlbW92ZSBpdCBvciBlbmNvZGVVUklDb21wb25lbnQoc3JjKSB0byBrZWVwIGl0LmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFWQUxJRF9MT0FESU5HX1ZBTFVFUy5pbmNsdWRlcyhsb2FkaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xvYWRpbmd9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xPQURJTkdfVkFMVUVTLm1hcChcbiAgICAgICAgICBTdHJpbmdcbiAgICAgICAgKS5qb2luKCcsJyl9LmBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5ICYmIGxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcInByaW9yaXR5XCIgYW5kIFwibG9hZGluZz0nbGF6eSdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gXG4gICAgICApXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHBsYWNlaG9sZGVyICE9PSAnZW1wdHknICYmXG4gICAgICBwbGFjZWhvbGRlciAhPT0gJ2JsdXInICYmXG4gICAgICAhcGxhY2Vob2xkZXIuc3RhcnRzV2l0aCgnZGF0YTppbWFnZS8nKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHkgXCIke3BsYWNlaG9sZGVyfVwiLmBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHBsYWNlaG9sZGVyICE9PSAnZW1wdHknKSB7XG4gICAgICBpZiAod2lkdGhJbnQgJiYgaGVpZ2h0SW50ICYmIHdpZHRoSW50ICogaGVpZ2h0SW50IDwgMTYwMCkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBzbWFsbGVyIHRoYW4gNDB4NDAuIENvbnNpZGVyIHJlbW92aW5nIHRoZSBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5gXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBsYWNlaG9sZGVyID09PSAnYmx1cicgJiYgIWJsdXJEYXRhVVJMKSB7XG4gICAgICBjb25zdCBWQUxJRF9CTFVSX0VYVCA9IFsnanBlZycsICdwbmcnLCAnd2VicCcsICdhdmlmJ10gLy8gc2hvdWxkIG1hdGNoIG5leHQtaW1hZ2UtbG9hZGVyXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwicGxhY2Vob2xkZXI9J2JsdXInXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cbiAgICAgICAgUG9zc2libGUgc29sdXRpb25zOlxuICAgICAgICAgIC0gQWRkIGEgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LCB0aGUgY29udGVudHMgc2hvdWxkIGJlIGEgc21hbGwgRGF0YSBVUkwgdG8gcmVwcmVzZW50IHRoZSBpbWFnZVxuICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICR7VkFMSURfQkxVUl9FWFQuam9pbihcbiAgICAgICAgICAgICcsJ1xuICAgICAgICAgICl9IChhbmltYXRlZCBpbWFnZXMgbm90IHN1cHBvcnRlZClcbiAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxuICAgICAgICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3BsYWNlaG9sZGVyLWJsdXItZGF0YS11cmxgXG4gICAgICApXG4gICAgfVxuICAgIGlmICgncmVmJyBpbiByZXN0KSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgdXNpbmcgdW5zdXBwb3J0ZWQgXCJyZWZcIiBwcm9wZXJ0eS4gQ29uc2lkZXIgdXNpbmcgdGhlIFwib25Mb2FkXCIgcHJvcGVydHkgaW5zdGVhZC5gXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKCF1bm9wdGltaXplZCAmJiAhaXNEZWZhdWx0TG9hZGVyKSB7XG4gICAgICBjb25zdCB1cmxTdHIgPSBsb2FkZXIoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIHNyYyxcbiAgICAgICAgd2lkdGg6IHdpZHRoSW50IHx8IDQwMCxcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NSxcbiAgICAgIH0pXG4gICAgICBsZXQgdXJsOiBVUkwgfCB1bmRlZmluZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwodXJsU3RyKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgaWYgKHVybFN0ciA9PT0gc3JjIHx8ICh1cmwgJiYgdXJsLnBhdGhuYW1lID09PSBzcmMgJiYgIXVybC5zZWFyY2gpKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBhIFwibG9hZGVyXCIgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgd2lkdGguIFBsZWFzZSBpbXBsZW1lbnQgaXQgb3IgdXNlIHRoZSBcInVub3B0aW1pemVkXCIgcHJvcGVydHkgaW5zdGVhZC5gICtcbiAgICAgICAgICAgIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXItd2lkdGhgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob25Mb2FkaW5nQ29tcGxldGUpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyB1c2luZyBkZXByZWNhdGVkIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eS4gUGxlYXNlIHVzZSB0aGUgXCJvbkxvYWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmBcbiAgICAgIClcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtsZWdhY3lLZXksIGxlZ2FjeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh7XG4gICAgICBsYXlvdXQsXG4gICAgICBvYmplY3RGaXQsXG4gICAgICBvYmplY3RQb3NpdGlvbixcbiAgICAgIGxhenlCb3VuZGFyeSxcbiAgICAgIGxhenlSb290LFxuICAgIH0pKSB7XG4gICAgICBpZiAobGVnYWN5VmFsdWUpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGxlZ2FjeSBwcm9wIFwiJHtsZWdhY3lLZXl9XCIuIERpZCB5b3UgZm9yZ2V0IHRvIHJ1biB0aGUgY29kZW1vZD9gICtcbiAgICAgICAgICAgIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdXBncmFkZS10by0xM2BcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAhcGVyZk9ic2VydmVyICYmXG4gICAgICB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlclxuICAgICkge1xuICAgICAgcGVyZk9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGVudHJ5TGlzdCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbWlzc2luZyBcIkxhcmdlc3RDb250ZW50ZnVsUGFpbnRcIiBjbGFzcyB3aXRoIFwiZWxlbWVudFwiIHByb3BcbiAgICAgICAgICBjb25zdCBpbWdTcmMgPSBlbnRyeT8uZWxlbWVudD8uc3JjIHx8ICcnXG4gICAgICAgICAgY29uc3QgbGNwSW1hZ2UgPSBhbGxJbWdzLmdldChpbWdTcmMpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGNwSW1hZ2UgJiZcbiAgICAgICAgICAgICFsY3BJbWFnZS5wcmlvcml0eSAmJlxuICAgICAgICAgICAgbGNwSW1hZ2UucGxhY2Vob2xkZXIgPT09ICdlbXB0eScgJiZcbiAgICAgICAgICAgICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aCgnZGF0YTonKSAmJlxuICAgICAgICAgICAgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdibG9iOicpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtsY3BJbWFnZS5zcmN9XCIgd2FzIGRldGVjdGVkIGFzIHRoZSBMYXJnZXN0IENvbnRlbnRmdWwgUGFpbnQgKExDUCkuIFBsZWFzZSBhZGQgdGhlIFwicHJpb3JpdHlcIiBwcm9wZXJ0eSBpZiB0aGlzIGltYWdlIGlzIGFib3ZlIHRoZSBmb2xkLmAgK1xuICAgICAgICAgICAgICAgIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNwcmlvcml0eWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0cnkge1xuICAgICAgICBwZXJmT2JzZXJ2ZXIub2JzZXJ2ZSh7XG4gICAgICAgICAgdHlwZTogJ2xhcmdlc3QtY29udGVudGZ1bC1wYWludCcsXG4gICAgICAgICAgYnVmZmVyZWQ6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gTG9nIGVycm9yIGJ1dCBkb24ndCBjcmFzaCB0aGUgYXBwXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBpbWdTdHlsZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgZmlsbFxuICAgICAgPyB7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgb2JqZWN0Rml0LFxuICAgICAgICAgIG9iamVjdFBvc2l0aW9uLFxuICAgICAgICB9XG4gICAgICA6IHt9LFxuICAgIHNob3dBbHRUZXh0ID8ge30gOiB7IGNvbG9yOiAndHJhbnNwYXJlbnQnIH0sXG4gICAgc3R5bGVcbiAgKVxuXG4gIGNvbnN0IGJhY2tncm91bmRJbWFnZSA9XG4gICAgIWJsdXJDb21wbGV0ZSAmJiBwbGFjZWhvbGRlciAhPT0gJ2VtcHR5J1xuICAgICAgPyBwbGFjZWhvbGRlciA9PT0gJ2JsdXInXG4gICAgICAgID8gYHVybChcImRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCR7Z2V0SW1hZ2VCbHVyU3ZnKHtcbiAgICAgICAgICAgIHdpZHRoSW50LFxuICAgICAgICAgICAgaGVpZ2h0SW50LFxuICAgICAgICAgICAgYmx1cldpZHRoLFxuICAgICAgICAgICAgYmx1ckhlaWdodCxcbiAgICAgICAgICAgIGJsdXJEYXRhVVJMOiBibHVyRGF0YVVSTCB8fCAnJywgLy8gYXNzdW1lIG5vdCB1bmRlZmluZWRcbiAgICAgICAgICAgIG9iamVjdEZpdDogaW1nU3R5bGUub2JqZWN0Rml0LFxuICAgICAgICAgIH0pfVwiKWBcbiAgICAgICAgOiBgdXJsKFwiJHtwbGFjZWhvbGRlcn1cIilgIC8vIGFzc3VtZSBgZGF0YTppbWFnZS9gXG4gICAgICA6IG51bGxcblxuICBjb25zdCBiYWNrZ3JvdW5kU2l6ZSA9ICFJTlZBTElEX0JBQ0tHUk9VTkRfU0laRV9WQUxVRVMuaW5jbHVkZXMoXG4gICAgaW1nU3R5bGUub2JqZWN0Rml0XG4gIClcbiAgICA/IGltZ1N0eWxlLm9iamVjdEZpdFxuICAgIDogaW1nU3R5bGUub2JqZWN0Rml0ID09PSAnZmlsbCdcbiAgICAgID8gJzEwMCUgMTAwJScgLy8gdGhlIGJhY2tncm91bmQtc2l6ZSBlcXVpdmFsZW50IG9mIGBmaWxsYFxuICAgICAgOiAnY292ZXInXG5cbiAgbGV0IHBsYWNlaG9sZGVyU3R5bGU6IFBsYWNlaG9sZGVyU3R5bGUgPSBiYWNrZ3JvdW5kSW1hZ2VcbiAgICA/IHtcbiAgICAgICAgYmFja2dyb3VuZFNpemUsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogaW1nU3R5bGUub2JqZWN0UG9zaXRpb24gfHwgJzUwJSA1MCUnLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiAnbm8tcmVwZWF0JyxcbiAgICAgICAgYmFja2dyb3VuZEltYWdlLFxuICAgICAgfVxuICAgIDoge31cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAoXG4gICAgICBwbGFjZWhvbGRlclN0eWxlLmJhY2tncm91bmRJbWFnZSAmJlxuICAgICAgcGxhY2Vob2xkZXIgPT09ICdibHVyJyAmJlxuICAgICAgYmx1ckRhdGFVUkw/LnN0YXJ0c1dpdGgoJy8nKVxuICAgICkge1xuICAgICAgLy8gRHVyaW5nIGBuZXh0IGRldmAsIHdlIGRvbid0IHdhbnQgdG8gZ2VuZXJhdGUgYmx1ciBwbGFjZWhvbGRlcnMgd2l0aCB3ZWJwYWNrXG4gICAgICAvLyBiZWNhdXNlIGl0IGNhbiBkZWxheSBzdGFydGluZyB0aGUgZGV2IHNlcnZlci4gSW5zdGVhZCwgYG5leHQtaW1hZ2UtbG9hZGVyLmpzYFxuICAgICAgLy8gd2lsbCBpbmxpbmUgYSBzcGVjaWFsIHVybCB0byBsYXppbHkgZ2VuZXJhdGUgdGhlIGJsdXIgcGxhY2Vob2xkZXIgYXQgcmVxdWVzdCB0aW1lLlxuICAgICAgcGxhY2Vob2xkZXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKFwiJHtibHVyRGF0YVVSTH1cIilgXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgIGNvbmZpZyxcbiAgICBzcmMsXG4gICAgdW5vcHRpbWl6ZWQsXG4gICAgd2lkdGg6IHdpZHRoSW50LFxuICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQsXG4gICAgc2l6ZXMsXG4gICAgbG9hZGVyLFxuICB9KVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZXQgZnVsbFVybDogVVJMXG4gICAgICB0cnkge1xuICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgfVxuICAgICAgYWxsSW1ncy5zZXQoZnVsbFVybC5ocmVmLCB7IHNyYywgcHJpb3JpdHksIHBsYWNlaG9sZGVyIH0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcHJvcHM6IEltZ1Byb3BzID0ge1xuICAgIC4uLnJlc3QsXG4gICAgbG9hZGluZzogaXNMYXp5ID8gJ2xhenknIDogbG9hZGluZyxcbiAgICBmZXRjaFByaW9yaXR5LFxuICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICBoZWlnaHQ6IGhlaWdodEludCxcbiAgICBkZWNvZGluZyxcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGU6IHsgLi4uaW1nU3R5bGUsIC4uLnBsYWNlaG9sZGVyU3R5bGUgfSxcbiAgICBzaXplczogaW1nQXR0cmlidXRlcy5zaXplcyxcbiAgICBzcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgIHNyYzogb3ZlcnJpZGVTcmMgfHwgaW1nQXR0cmlidXRlcy5zcmMsXG4gIH1cbiAgY29uc3QgbWV0YSA9IHsgdW5vcHRpbWl6ZWQsIHByaW9yaXR5LCBwbGFjZWhvbGRlciwgZmlsbCB9XG4gIHJldHVybiB7IHByb3BzLCBtZXRhIH1cbn1cbiJdLCJuYW1lcyI6WyJnZXRJbWdQcm9wcyIsIlZBTElEX0xPQURJTkdfVkFMVUVTIiwidW5kZWZpbmVkIiwiSU5WQUxJRF9CQUNLR1JPVU5EX1NJWkVfVkFMVUVTIiwiaXNTdGF0aWNSZXF1aXJlIiwic3JjIiwiZGVmYXVsdCIsImlzU3RhdGljSW1hZ2VEYXRhIiwiaXNTdGF0aWNJbXBvcnQiLCJhbGxJbWdzIiwiTWFwIiwicGVyZk9ic2VydmVyIiwiZ2V0SW50IiwieCIsIk51bWJlciIsImlzRmluaXRlIiwiTmFOIiwidGVzdCIsInBhcnNlSW50IiwiZ2V0V2lkdGhzIiwid2lkdGgiLCJzaXplcyIsImRldmljZVNpemVzIiwiYWxsU2l6ZXMiLCJ2aWV3cG9ydFdpZHRoUmUiLCJwZXJjZW50U2l6ZXMiLCJtYXRjaCIsImV4ZWMiLCJwdXNoIiwibGVuZ3RoIiwic21hbGxlc3RSYXRpbyIsIk1hdGgiLCJtaW4iLCJ3aWR0aHMiLCJmaWx0ZXIiLCJzIiwia2luZCIsIlNldCIsIm1hcCIsInciLCJmaW5kIiwicCIsImdlbmVyYXRlSW1nQXR0cnMiLCJjb25maWciLCJ1bm9wdGltaXplZCIsInF1YWxpdHkiLCJsb2FkZXIiLCJzcmNTZXQiLCJsYXN0IiwiaSIsImpvaW4iLCJfc3RhdGUiLCJwcmlvcml0eSIsImxvYWRpbmciLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJmaWxsIiwic3R5bGUiLCJvdmVycmlkZVNyYyIsIm9uTG9hZCIsIm9uTG9hZGluZ0NvbXBsZXRlIiwicGxhY2Vob2xkZXIiLCJibHVyRGF0YVVSTCIsImZldGNoUHJpb3JpdHkiLCJkZWNvZGluZyIsImxheW91dCIsIm9iamVjdEZpdCIsIm9iamVjdFBvc2l0aW9uIiwibGF6eUJvdW5kYXJ5IiwibGF6eVJvb3QiLCJyZXN0IiwiaW1nQ29uZiIsInNob3dBbHRUZXh0IiwiYmx1ckNvbXBsZXRlIiwiZGVmYXVsdExvYWRlciIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJpbWFnZVNpemVzIiwic29ydCIsImEiLCJiIiwicXVhbGl0aWVzIiwiRXJyb3IiLCJpc0RlZmF1bHRMb2FkZXIiLCJjdXN0b21JbWFnZUxvYWRlciIsIm9iaiIsIl8iLCJvcHRzIiwibGF5b3V0VG9TdHlsZSIsImludHJpbnNpYyIsIm1heFdpZHRoIiwicmVzcG9uc2l2ZSIsImxheW91dFRvU2l6ZXMiLCJsYXlvdXRTdHlsZSIsImxheW91dFNpemVzIiwic3RhdGljU3JjIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0Iiwic3RhdGljSW1hZ2VEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsInJhdGlvIiwicm91bmQiLCJpc0xhenkiLCJzdGFydHNXaXRoIiwiZGFuZ2Vyb3VzbHlBbGxvd1NWRyIsInNwbGl0IiwiZW5kc1dpdGgiLCJxdWFsaXR5SW50IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwib3V0cHV0IiwicG9zaXRpb24iLCJpc05hTiIsImluY2x1ZGVzIiwiU3RyaW5nIiwid2Fybk9uY2UiLCJWQUxJRF9CTFVSX0VYVCIsInVybFN0ciIsInVybCIsIlVSTCIsImVyciIsInBhdGhuYW1lIiwic2VhcmNoIiwibGVnYWN5S2V5IiwibGVnYWN5VmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwid2luZG93IiwiUGVyZm9ybWFuY2VPYnNlcnZlciIsImVudHJ5TGlzdCIsImVudHJ5IiwiZ2V0RW50cmllcyIsImltZ1NyYyIsImVsZW1lbnQiLCJsY3BJbWFnZSIsImdldCIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJpbWdTdHlsZSIsImFzc2lnbiIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiZ2V0SW1hZ2VCbHVyU3ZnIiwiYmFja2dyb3VuZFNpemUiLCJwbGFjZWhvbGRlclN0eWxlIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFJlcGVhdCIsImltZ0F0dHJpYnV0ZXMiLCJmdWxsVXJsIiwiZSIsImxvY2F0aW9uIiwiaHJlZiIsInNldCIsInByb3BzIiwibWV0YSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    defaultHead: function() {\n        return defaultHead;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        }, \"charset\")\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }, \"viewport\"));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === 'string' || typeof child === 'number') {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    'name',\n    'httpEquiv',\n    'charSet',\n    'itemProp'\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf('$') + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case 'title':\n            case 'base':\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case 'meta':\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === 'charSet') {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {\n                const srcMessage = c.props['src'] ? '<script> tag with src=\"' + c.props['src'] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props['href'] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQXVNQSxPQUFtQjtlQUFuQjs7SUExTGdCQSxXQUFXO2VBQVhBOzs7Ozs7NkVBWDRCO2lGQUN6QjtxREFDYTs2REFDRztxQ0FDUDtzQ0FDSDtBQU1sQixTQUFTQSxZQUFZQyxTQUFpQjtJQUFqQkEsSUFBQUEsY0FBQUEsS0FBQUEsR0FBQUEsWUFBWTtJQUN0QyxNQUFNQyxPQUFPO3NCQUFDLHFCQUFDQyxRQUFBQTtZQUFLQyxTQUFRO1dBQVk7S0FBYTtJQUNyRCxJQUFJLENBQUNILFdBQVc7UUFDZEMsS0FBS0csSUFBSSxlQUNQLHFCQUFDRixRQUFBQTtZQUFLRyxNQUFLO1lBQVdDLFNBQVE7V0FBeUI7SUFFM0Q7SUFDQSxPQUFPTDtBQUNUO0FBRUEsU0FBU00saUJBQ1BDLElBQW9DLEVBQ3BDQyxLQUEyQztJQUUzQyw4RkFBOEY7SUFDOUYsSUFBSSxPQUFPQSxVQUFVLFlBQVksT0FBT0EsVUFBVSxVQUFVO1FBQzFELE9BQU9EO0lBQ1Q7SUFDQSxrQ0FBa0M7SUFDbEMsSUFBSUMsTUFBTUMsSUFBSSxLQUFLQyxPQUFBQSxPQUFLLENBQUNDLFFBQVEsRUFBRTtRQUNqQyxPQUFPSixLQUFLSyxNQUFNLENBQ2hCLE9BQ0FGLE9BQUssQ0FBQ0csUUFBUSxDQUFDQyxPQUFPLENBQUNOLE1BQU1PLEtBQUssQ0FBQ0MsUUFBUSxFQUFFQyxNQUFNLENBQ2pELENBRUVDLGNBQ0FDO1lBRUEsSUFDRSxPQUFPQSxrQkFBa0IsWUFDekIsT0FBT0Esa0JBQWtCLFVBQ3pCO2dCQUNBLE9BQU9EO1lBQ1Q7WUFDQSxPQUFPQSxhQUFhTixNQUFNLENBQUNPO1FBQzdCLEdBQ0EsRUFBRTtJQUdSO0lBQ0EsT0FBT1osS0FBS0ssTUFBTSxDQUFDSjtBQUNyQjtBQUVBLE1BQU1ZLFlBQVk7SUFBQztJQUFRO0lBQWE7SUFBVztDQUFXO0FBRTlEOzs7O0FBSUEsR0FDQSxTQUFTQztJQUNQLE1BQU1DLE9BQU8sSUFBSUM7SUFDakIsTUFBTUMsT0FBTyxJQUFJRDtJQUNqQixNQUFNRSxZQUFZLElBQUlGO0lBQ3RCLE1BQU1HLGlCQUFzRCxDQUFDO0lBRTdELE9BQU8sQ0FBQ0M7UUFDTixJQUFJQyxXQUFXO1FBQ2YsSUFBSUMsU0FBUztRQUViLElBQUlGLEVBQUVHLEdBQUcsSUFBSSxPQUFPSCxFQUFFRyxHQUFHLEtBQUssWUFBWUgsRUFBRUcsR0FBRyxDQUFDQyxPQUFPLENBQUMsT0FBTyxHQUFHO1lBQ2hFRixTQUFTO1lBQ1QsTUFBTUMsTUFBTUgsRUFBRUcsR0FBRyxDQUFDRSxLQUFLLENBQUNMLEVBQUVHLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLE9BQU87WUFDN0MsSUFBSVQsS0FBS1csR0FBRyxDQUFDSCxNQUFNO2dCQUNqQkYsV0FBVztZQUNiLE9BQU87Z0JBQ0xOLEtBQUtZLEdBQUcsQ0FBQ0o7WUFDWDtRQUNGO1FBRUEsd0NBQXdDO1FBQ3hDLE9BQVFILEVBQUVsQixJQUFJO1lBQ1osS0FBSztZQUNMLEtBQUs7Z0JBQ0gsSUFBSWUsS0FBS1MsR0FBRyxDQUFDTixFQUFFbEIsSUFBSSxHQUFHO29CQUNwQm1CLFdBQVc7Z0JBQ2IsT0FBTztvQkFDTEosS0FBS1UsR0FBRyxDQUFDUCxFQUFFbEIsSUFBSTtnQkFDakI7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILElBQUssSUFBSTBCLElBQUksR0FBR0MsTUFBTWhCLFVBQVVpQixNQUFNLEVBQUVGLElBQUlDLEtBQUtELElBQUs7b0JBQ3BELE1BQU1HLFdBQVdsQixTQUFTLENBQUNlLEVBQUU7b0JBQzdCLElBQUksQ0FBQ1IsRUFBRVosS0FBSyxDQUFDd0IsY0FBYyxDQUFDRCxXQUFXO29CQUV2QyxJQUFJQSxhQUFhLFdBQVc7d0JBQzFCLElBQUliLFVBQVVRLEdBQUcsQ0FBQ0ssV0FBVzs0QkFDM0JWLFdBQVc7d0JBQ2IsT0FBTzs0QkFDTEgsVUFBVVMsR0FBRyxDQUFDSTt3QkFDaEI7b0JBQ0YsT0FBTzt3QkFDTCxNQUFNRSxXQUFXYixFQUFFWixLQUFLLENBQUN1QixTQUFTO3dCQUNsQyxNQUFNRyxhQUFhZixjQUFjLENBQUNZLFNBQVMsSUFBSSxJQUFJZjt3QkFDbkQsSUFBS2UsQ0FBQUEsYUFBYSxVQUFVLENBQUNULE1BQUFBLENBQUssSUFBTVksV0FBV1IsR0FBRyxDQUFDTyxXQUFXOzRCQUNoRVosV0FBVzt3QkFDYixPQUFPOzRCQUNMYSxXQUFXUCxHQUFHLENBQUNNOzRCQUNmZCxjQUFjLENBQUNZLFNBQVMsR0FBR0c7d0JBQzdCO29CQUNGO2dCQUNGO2dCQUNBO1FBQ0o7UUFFQSxPQUFPYjtJQUNUO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTYyxpQkFDUEMsb0JBQW9ELEVBQ3BENUIsS0FBUTtJQUVSLE1BQU0sRUFBRWhCLFNBQVMsRUFBRSxHQUFHZ0I7SUFDdEIsT0FBTzRCLHFCQUNKMUIsTUFBTSxDQUFDWCxrQkFBa0IsRUFBRSxFQUMzQnNDLE9BQU8sR0FDUGhDLE1BQU0sQ0FBQ2QsWUFBWUMsV0FBVzZDLE9BQU8sSUFDckNDLE1BQU0sQ0FBQ3hCLFVBQ1B1QixPQUFPLEdBQ1BFLEdBQUcsQ0FBQyxDQUFDQyxHQUE0Qlo7UUFDaEMsTUFBTUwsTUFBTWlCLEVBQUVqQixHQUFHLElBQUlLO1FBQ3JCLElBQ0VhLEtBRVVqRCxFQUNWLEVBa0JEO1FBQ0QsSUFBSWlELElBQW9CLEVBQW9CO1lBQzFDLHlEQUF5RDtZQUN6RCxJQUFJRCxFQUFFdEMsSUFBSSxLQUFLLFlBQVlzQyxFQUFFaEMsS0FBSyxDQUFDLE9BQU8sS0FBSyx1QkFBdUI7Z0JBQ3BFLE1BQU0yQyxhQUFhWCxFQUFFaEMsS0FBSyxDQUFDLE1BQU0sR0FDNUIsNEJBQXlCZ0MsRUFBRWhDLEtBQUssQ0FBQyxNQUFNLEdBQUMsTUFDeEM7Z0JBQ0w0QyxDQUFBQSxHQUFBQSxVQUFBQSxRQUFBQSxFQUNHLG1EQUFnREQsYUFBVztZQUVoRSxPQUFPLElBQUlYLEVBQUV0QyxJQUFJLEtBQUssVUFBVXNDLEVBQUVoQyxLQUFLLENBQUMsTUFBTSxLQUFLLGNBQWM7Z0JBQy9ENEMsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFDRyx3RkFBcUZaLEVBQUVoQyxLQUFLLENBQUMsT0FBTyxHQUFDO1lBRTFHO1FBQ0Y7UUFDQSxxQkFBT0wsT0FBQUEsT0FBSyxDQUFDK0MsWUFBWSxDQUFDVixHQUFHO1lBQUVqQjtRQUFJO0lBQ3JDO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRCxjQUFjLEtBQTJDO0lBQTNDLE1BQUVkLFFBQVEsRUFBaUMsR0FBM0M7SUFDWixNQUFNNkMsV0FBV0MsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0MseUJBQUFBLGVBQWU7SUFDM0MsTUFBTUMsY0FBY0YsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0csaUNBQUFBLGtCQUFrQjtJQUNqRCxxQkFDRSxxQkFBQ0MsWUFBQUEsT0FBTTtRQUNMQyx5QkFBeUJ6QjtRQUN6QnNCLGFBQWFBO1FBQ2JqRSxXQUFXcUUsQ0FBQUEsR0FBQUEsU0FBQUEsV0FBQUEsRUFBWVA7a0JBRXRCN0M7O0FBR1A7S0FaUzRDO01BY1QsV0FBZUEiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXHNoYXJlZFxcbGliXFxoZWFkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgRWZmZWN0IGZyb20gJy4vc2lkZS1lZmZlY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGlzSW5BbXBNb2RlIH0gZnJvbSAnLi9hbXAtbW9kZSdcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi91dGlscy93YXJuLW9uY2UnXG5cbnR5cGUgV2l0aEluQW1wTW9kZSA9IHtcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlID0gZmFsc2UpOiBKU1guRWxlbWVudFtdIHtcbiAgY29uc3QgaGVhZCA9IFs8bWV0YSBjaGFyU2V0PVwidXRmLThcIiBrZXk9XCJjaGFyc2V0XCIgLz5dXG4gIGlmICghaW5BbXBNb2RlKSB7XG4gICAgaGVhZC5wdXNoKFxuICAgICAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aFwiIGtleT1cInZpZXdwb3J0XCIgLz5cbiAgICApXG4gIH1cbiAgcmV0dXJuIGhlYWRcbn1cblxuZnVuY3Rpb24gb25seVJlYWN0RWxlbWVudChcbiAgbGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBjaGlsZDogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVtYmVyIHwgc3RyaW5nXG4pOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4ge1xuICAvLyBSZWFjdCBjaGlsZHJlbiBjYW4gYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiIGluIHRoaXMgY2FzZSB3ZSBpZ25vcmUgdGhlbSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICAvLyBBZGRzIHN1cHBvcnQgZm9yIFJlYWN0LkZyYWdtZW50XG4gIGlmIChjaGlsZC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgIHJldHVybiBsaXN0LmNvbmNhdChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQHR5cGVzL3JlYWN0IGRvZXMgbm90IHJlbW92ZSBmcmFnbWVudHMgYnV0IHRoaXMgY291bGQgYWxzbyByZXR1cm4gUmVhY3RQb3J0YWxbXVxuICAgICAgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0eXBlcy9yZWFjdCBkb2VzIG5vdCByZW1vdmUgZnJhZ21lbnRzIGJ1dCB0aGlzIGNvdWxkIGFsc28gcmV0dXJuIFJlYWN0UG9ydGFsW11cbiAgICAgICAgKFxuICAgICAgICAgIGZyYWdtZW50TGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgICAgICAgIGZyYWdtZW50Q2hpbGQ6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bWJlciB8IHN0cmluZ1xuICAgICAgICApOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4gPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpXG4gICAgICAgIH0sXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgKVxuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChjaGlsZClcbn1cblxuY29uc3QgTUVUQVRZUEVTID0gWyduYW1lJywgJ2h0dHBFcXVpdicsICdjaGFyU2V0JywgJ2l0ZW1Qcm9wJ11cblxuLypcbiByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGZpbHRlcmluZyBoZWFkIGNoaWxkIGVsZW1lbnRzXG4gd2hpY2ggc2hvdWxkbid0IGJlIGR1cGxpY2F0ZWQsIGxpa2UgPHRpdGxlLz5cbiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgZGVkdXBsaWNhdGVkIGBrZXlgIHByb3BlcnRpZXNcbiovXG5mdW5jdGlvbiB1bmlxdWUoKSB7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KClcbiAgY29uc3QgdGFncyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhVHlwZXMgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YUNhdGVnb3JpZXM6IHsgW21ldGF0eXBlOiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge31cblxuICByZXR1cm4gKGg6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgbGV0IGlzVW5pcXVlID0gdHJ1ZVxuICAgIGxldCBoYXNLZXkgPSBmYWxzZVxuXG4gICAgaWYgKGgua2V5ICYmIHR5cGVvZiBoLmtleSAhPT0gJ251bWJlcicgJiYgaC5rZXkuaW5kZXhPZignJCcpID4gMCkge1xuICAgICAgaGFzS2V5ID0gdHJ1ZVxuICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSlcbiAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChoLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdzLmFkZChoLnR5cGUpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTUVUQVRZUEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbWV0YXR5cGUgPSBNRVRBVFlQRVNbaV1cbiAgICAgICAgICBpZiAoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKSBjb250aW51ZVxuXG4gICAgICAgICAgaWYgKG1ldGF0eXBlID09PSAnY2hhclNldCcpIHtcbiAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKVxuICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gJ25hbWUnIHx8ICFoYXNLZXkpICYmIGNhdGVnb3JpZXMuaGFzKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSlcbiAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBpc1VuaXF1ZVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkQ2hpbGRyZW5FbGVtZW50cyBMaXN0IG9mIGNoaWxkcmVuIG9mIDxIZWFkPlxuICovXG5mdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzPFQgZXh0ZW5kcyB7fSAmIFdpdGhJbkFtcE1vZGU+KFxuICBoZWFkQ2hpbGRyZW5FbGVtZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBwcm9wczogVFxuKSB7XG4gIGNvbnN0IHsgaW5BbXBNb2RlIH0gPSBwcm9wc1xuICByZXR1cm4gaGVhZENoaWxkcmVuRWxlbWVudHNcbiAgICAucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKVxuICAgIC5yZXZlcnNlKClcbiAgICAuY29uY2F0KGRlZmF1bHRIZWFkKGluQW1wTW9kZSkucmV2ZXJzZSgpKVxuICAgIC5maWx0ZXIodW5pcXVlKCkpXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAoKGM6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+LCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGlcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmXG4gICAgICAgICFpbkFtcE1vZGVcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYy50eXBlID09PSAnbGluaycgJiZcbiAgICAgICAgICBjLnByb3BzWydocmVmJ10gJiZcbiAgICAgICAgICAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICBbJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzJywgJ2h0dHBzOi8vdXNlLnR5cGVraXQubmV0LyddLnNvbWUoXG4gICAgICAgICAgICAodXJsKSA9PiBjLnByb3BzWydocmVmJ10uc3RhcnRzV2l0aCh1cmwpXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHsgLi4uKGMucHJvcHMgfHwge30pIH1cbiAgICAgICAgICBuZXdQcm9wc1snZGF0YS1ocmVmJ10gPSBuZXdQcm9wc1snaHJlZiddXG4gICAgICAgICAgbmV3UHJvcHNbJ2hyZWYnXSA9IHVuZGVmaW5lZFxuXG4gICAgICAgICAgLy8gQWRkIHRoaXMgYXR0cmlidXRlIHRvIG1ha2UgaXQgZWFzeSB0byBpZGVudGlmeSBvcHRpbWl6ZWQgdGFnc1xuICAgICAgICAgIG5ld1Byb3BzWydkYXRhLW9wdGltaXplZC1mb250cyddID0gdHJ1ZVxuXG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCBuZXdQcm9wcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIC8vIG9taXQgSlNPTi1MRCBzdHJ1Y3R1cmVkIGRhdGEgc25pcHBldHMgZnJvbSB0aGUgd2FybmluZ1xuICAgICAgICBpZiAoYy50eXBlID09PSAnc2NyaXB0JyAmJiBjLnByb3BzWyd0eXBlJ10gIT09ICdhcHBsaWNhdGlvbi9sZCtqc29uJykge1xuICAgICAgICAgIGNvbnN0IHNyY01lc3NhZ2UgPSBjLnByb3BzWydzcmMnXVxuICAgICAgICAgICAgPyBgPHNjcmlwdD4gdGFnIHdpdGggc3JjPVwiJHtjLnByb3BzWydzcmMnXX1cImBcbiAgICAgICAgICAgIDogYGlubGluZSA8c2NyaXB0PmBcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIGBEbyBub3QgYWRkIDxzY3JpcHQ+IHRhZ3MgdXNpbmcgbmV4dC9oZWFkIChzZWUgJHtzcmNNZXNzYWdlfSkuIFVzZSBuZXh0L3NjcmlwdCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXNjcmlwdC10YWdzLWluLWhlYWQtY29tcG9uZW50YFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChjLnR5cGUgPT09ICdsaW5rJyAmJiBjLnByb3BzWydyZWwnXSA9PT0gJ3N0eWxlc2hlZXQnKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBgRG8gbm90IGFkZCBzdHlsZXNoZWV0cyB1c2luZyBuZXh0L2hlYWQgKHNlZSA8bGluayByZWw9XCJzdHlsZXNoZWV0XCI+IHRhZyB3aXRoIGhyZWY9XCIke2MucHJvcHNbJ2hyZWYnXX1cIikuIFVzZSBEb2N1bWVudCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXN0eWxlc2hlZXRzLWluLWhlYWQtY29tcG9uZW50YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCB7IGtleSB9KVxuICAgIH0pXG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi9cbmZ1bmN0aW9uIEhlYWQoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICBjb25zdCBhbXBTdGF0ZSA9IHVzZUNvbnRleHQoQW1wU3RhdGVDb250ZXh0KVxuICBjb25zdCBoZWFkTWFuYWdlciA9IHVzZUNvbnRleHQoSGVhZE1hbmFnZXJDb250ZXh0KVxuICByZXR1cm4gKFxuICAgIDxFZmZlY3RcbiAgICAgIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlPXtyZWR1Y2VDb21wb25lbnRzfVxuICAgICAgaGVhZE1hbmFnZXI9e2hlYWRNYW5hZ2VyfVxuICAgICAgaW5BbXBNb2RlPXtpc0luQW1wTW9kZShhbXBTdGF0ZSl9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvRWZmZWN0PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRcbiJdLCJuYW1lcyI6WyJkZWZhdWx0SGVhZCIsImluQW1wTW9kZSIsImhlYWQiLCJtZXRhIiwiY2hhclNldCIsInB1c2giLCJuYW1lIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJ0eXBlIiwiUmVhY3QiLCJGcmFnbWVudCIsImNvbmNhdCIsIkNoaWxkcmVuIiwidG9BcnJheSIsInByb3BzIiwiY2hpbGRyZW4iLCJyZWR1Y2UiLCJmcmFnbWVudExpc3QiLCJmcmFnbWVudENoaWxkIiwiTUVUQVRZUEVTIiwidW5pcXVlIiwia2V5cyIsIlNldCIsInRhZ3MiLCJtZXRhVHlwZXMiLCJtZXRhQ2F0ZWdvcmllcyIsImgiLCJpc1VuaXF1ZSIsImhhc0tleSIsImtleSIsImluZGV4T2YiLCJzbGljZSIsImhhcyIsImFkZCIsImkiLCJsZW4iLCJsZW5ndGgiLCJtZXRhdHlwZSIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwicmVkdWNlQ29tcG9uZW50cyIsImhlYWRDaGlsZHJlbkVsZW1lbnRzIiwicmV2ZXJzZSIsImZpbHRlciIsIm1hcCIsImMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJfX05FWFRfT1BUSU1JWkVfRk9OVFMiLCJzb21lIiwidXJsIiwic3RhcnRzV2l0aCIsIm5ld1Byb3BzIiwidW5kZWZpbmVkIiwiY2xvbmVFbGVtZW50Iiwic3JjTWVzc2FnZSIsIndhcm5PbmNlIiwiSGVhZCIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsIkFtcFN0YXRlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiRWZmZWN0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJpc0luQW1wTW9kZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : '';\n    const preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OzttREFDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCLEtBYy9CO0lBZCtCLE1BQzlCQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsU0FBUyxFQVFWLEdBZCtCO0lBZTlCLE1BQU1DLE1BQU07SUFDWixNQUFNQyxXQUFXTCxZQUFZQSxZQUFZLEtBQUtGO0lBQzlDLE1BQU1RLFlBQVlMLGFBQWFBLGFBQWEsS0FBS0Y7SUFFakQsTUFBTVEsVUFDSkYsWUFBWUMsWUFBYSxrQkFBZUQsV0FBUyxNQUFHQyxZQUFVLE1BQUs7SUFDckUsTUFBTUUsc0JBQXNCRCxVQUN4QixTQUNBSixjQUFjLFlBQ1osYUFDQUEsY0FBYyxVQUNaLG1CQUNBO0lBRVIsT0FBUSwrQ0FBNENJLFVBQVEsOEZBQTJGSCxNQUFJLG9RQUFpUUEsTUFBSSxnR0FBNkZJLHNCQUFvQix3Q0FBcUNOLGNBQVk7QUFDcGtCIiwic291cmNlcyI6WyJDOlxcc3JjXFxzaGFyZWRcXGxpYlxcaW1hZ2UtYmx1ci1zdmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIHNoYXJlZCBmdW5jdGlvbiwgdXNlZCBvbiBib3RoIGNsaWVudCBhbmQgc2VydmVyLCB0byBnZW5lcmF0ZSBhIFNWRyBibHVyIHBsYWNlaG9sZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1hZ2VCbHVyU3ZnKHtcbiAgd2lkdGhJbnQsXG4gIGhlaWdodEludCxcbiAgYmx1cldpZHRoLFxuICBibHVySGVpZ2h0LFxuICBibHVyRGF0YVVSTCxcbiAgb2JqZWN0Rml0LFxufToge1xuICB3aWR0aEludD86IG51bWJlclxuICBoZWlnaHRJbnQ/OiBudW1iZXJcbiAgYmx1cldpZHRoPzogbnVtYmVyXG4gIGJsdXJIZWlnaHQ/OiBudW1iZXJcbiAgYmx1ckRhdGFVUkw6IHN0cmluZ1xuICBvYmplY3RGaXQ/OiBzdHJpbmdcbn0pOiBzdHJpbmcge1xuICBjb25zdCBzdGQgPSAyMFxuICBjb25zdCBzdmdXaWR0aCA9IGJsdXJXaWR0aCA/IGJsdXJXaWR0aCAqIDQwIDogd2lkdGhJbnRcbiAgY29uc3Qgc3ZnSGVpZ2h0ID0gYmx1ckhlaWdodCA/IGJsdXJIZWlnaHQgKiA0MCA6IGhlaWdodEludFxuXG4gIGNvbnN0IHZpZXdCb3ggPVxuICAgIHN2Z1dpZHRoICYmIHN2Z0hlaWdodCA/IGB2aWV3Qm94PScwIDAgJHtzdmdXaWR0aH0gJHtzdmdIZWlnaHR9J2AgOiAnJ1xuICBjb25zdCBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gdmlld0JveFxuICAgID8gJ25vbmUnXG4gICAgOiBvYmplY3RGaXQgPT09ICdjb250YWluJ1xuICAgICAgPyAneE1pZFlNaWQnXG4gICAgICA6IG9iamVjdEZpdCA9PT0gJ2NvdmVyJ1xuICAgICAgICA/ICd4TWlkWU1pZCBzbGljZSdcbiAgICAgICAgOiAnbm9uZSdcblxuICByZXR1cm4gYCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnICR7dmlld0JveH0lM0UlM0NmaWx0ZXIgaWQ9J2InIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQiclM0UlM0NmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JyR7c3RkfScvJTNFJTNDZmVDb2xvck1hdHJpeCB2YWx1ZXM9JzEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEwMCAtMScgcmVzdWx0PSdzJy8lM0UlM0NmZUZsb29kIHg9JzAnIHk9JzAnIHdpZHRoPScxMDAlMjUnIGhlaWdodD0nMTAwJTI1Jy8lM0UlM0NmZUNvbXBvc2l0ZSBvcGVyYXRvcj0nb3V0JyBpbj0ncycvJTNFJTNDZmVDb21wb3NpdGUgaW4yPSdTb3VyY2VHcmFwaGljJy8lM0UlM0NmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JyR7c3RkfScvJTNFJTNDL2ZpbHRlciUzRSUzQ2ltYWdlIHdpZHRoPScxMDAlMjUnIGhlaWdodD0nMTAwJTI1JyB4PScwJyB5PScwJyBwcmVzZXJ2ZUFzcGVjdFJhdGlvPScke3ByZXNlcnZlQXNwZWN0UmF0aW99JyBzdHlsZT0nZmlsdGVyOiB1cmwoJTIzYik7JyBocmVmPScke2JsdXJEYXRhVVJMfScvJTNFJTNDL3N2ZyUzRWBcbn1cbiJdLCJuYW1lcyI6WyJnZXRJbWFnZUJsdXJTdmciLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJibHVyRGF0YVVSTCIsIm9iamVjdEZpdCIsInN0ZCIsInN2Z1dpZHRoIiwic3ZnSGVpZ2h0Iiwidmlld0JveCIsInByZXNlcnZlQXNwZWN0UmF0aW8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = 'ImageConfigContext';\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUlhQTs7O2VBQUFBOzs7OzRFQUpLO3lDQUVpQjtBQUU1QixNQUFNQSxxQkFDWEMsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQXNCQyxhQUFBQSxrQkFBa0I7QUFFN0QsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNKLG1CQUFtQk8sV0FBVyxHQUFHO0FBQ25DIiwic291cmNlcyI6WyJDOlxcc3JjXFxzaGFyZWRcXGxpYlxcaW1hZ2UtY29uZmlnLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBJbWFnZUNvbmZpZ0NvbXBsZXRlIH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBpbWFnZUNvbmZpZ0RlZmF1bHQgfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcblxuZXhwb3J0IGNvbnN0IEltYWdlQ29uZmlnQ29udGV4dCA9XG4gIFJlYWN0LmNyZWF0ZUNvbnRleHQ8SW1hZ2VDb25maWdDb21wbGV0ZT4oaW1hZ2VDb25maWdEZWZhdWx0KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBJbWFnZUNvbmZpZ0NvbnRleHQuZGlzcGxheU5hbWUgPSAnSW1hZ2VDb25maWdDb250ZXh0J1xufVxuIl0sIm5hbWVzIjpbIkltYWdlQ29uZmlnQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsImltYWdlQ29uZmlnRGVmYXVsdCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    'default',\n    'imgix',\n    'cloudinary',\n    'akamai',\n    'custom'\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: '/_next/image',\n    loader: 'default',\n    loaderFile: '',\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        'image/webp'\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: 'attachment',\n    localPatterns: undefined,\n    remotePatterns: [],\n    qualities: undefined,\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQWFBLGFBQWE7ZUFBYkE7O0lBaUlBQyxrQkFBa0I7ZUFBbEJBOzs7QUFqSU4sTUFBTUQsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQTJITSxNQUFNQyxxQkFBMEM7SUFDckRDLGFBQWE7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDMURDLFlBQVk7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFLO0tBQUk7SUFDL0NDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUFDO0tBQWE7SUFDdkJDLHFCQUFxQjtJQUNyQkMsdUJBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLGVBQWVDO0lBQ2ZDLGdCQUFnQixFQUFFO0lBQ2xCQyxXQUFXRjtJQUNYRyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXHNoYXJlZFxcbGliXFxpbWFnZS1jb25maWcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFZBTElEX0xPQURFUlMgPSBbXG4gICdkZWZhdWx0JyxcbiAgJ2ltZ2l4JyxcbiAgJ2Nsb3VkaW5hcnknLFxuICAnYWthbWFpJyxcbiAgJ2N1c3RvbScsXG5dIGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIExvYWRlclZhbHVlID0gKHR5cGVvZiBWQUxJRF9MT0FERVJTKVtudW1iZXJdXG5cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyUHJvcHMgPSB7XG4gIHNyYzogc3RyaW5nXG4gIHdpZHRoOiBudW1iZXJcbiAgcXVhbGl0eT86IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZyA9IEltYWdlTG9hZGVyUHJvcHMgJiB7XG4gIGNvbmZpZzogUmVhZG9ubHk8SW1hZ2VDb25maWc+XG59XG5cbmV4cG9ydCB0eXBlIExvY2FsUGF0dGVybiA9IHtcbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIG9yIHdpbGRjYXJkLlxuICAgKiBTaW5nbGUgYCpgIG1hdGNoZXMgYSBzaW5nbGUgcGF0aCBzZWdtZW50LlxuICAgKiBEb3VibGUgYCoqYCBtYXRjaGVzIGFueSBudW1iZXIgb2YgcGF0aCBzZWdtZW50cy5cbiAgICovXG4gIHBhdGhuYW1lPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIHF1ZXJ5IHN0cmluZyBzdWNoIGFzIGA/dj0xYCBvclxuICAgKiBlbXB0eSBzdHJpbmcgbWVhbmluZyBubyBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBzZWFyY2g/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVtb3RlUGF0dGVybiA9IHtcbiAgLyoqXG4gICAqIE11c3QgYmUgYGh0dHBgIG9yIGBodHRwc2AuXG4gICAqL1xuICBwcm90b2NvbD86ICdodHRwJyB8ICdodHRwcydcblxuICAvKipcbiAgICogQ2FuIGJlIGxpdGVyYWwgb3Igd2lsZGNhcmQuXG4gICAqIFNpbmdsZSBgKmAgbWF0Y2hlcyBhIHNpbmdsZSBzdWJkb21haW4uXG4gICAqIERvdWJsZSBgKipgIG1hdGNoZXMgYW55IG51bWJlciBvZiBzdWJkb21haW5zLlxuICAgKi9cbiAgaG9zdG5hbWU6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBDYW4gYmUgbGl0ZXJhbCBwb3J0IHN1Y2ggYXMgYDgwODBgIG9yIGVtcHR5IHN0cmluZ1xuICAgKiBtZWFuaW5nIG5vIHBvcnQuXG4gICAqL1xuICBwb3J0Pzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIG9yIHdpbGRjYXJkLlxuICAgKiBTaW5nbGUgYCpgIG1hdGNoZXMgYSBzaW5nbGUgcGF0aCBzZWdtZW50LlxuICAgKiBEb3VibGUgYCoqYCBtYXRjaGVzIGFueSBudW1iZXIgb2YgcGF0aCBzZWdtZW50cy5cbiAgICovXG4gIHBhdGhuYW1lPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIHF1ZXJ5IHN0cmluZyBzdWNoIGFzIGA/dj0xYCBvclxuICAgKiBlbXB0eSBzdHJpbmcgbWVhbmluZyBubyBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBzZWFyY2g/OiBzdHJpbmdcbn1cblxudHlwZSBJbWFnZUZvcm1hdCA9ICdpbWFnZS9hdmlmJyB8ICdpbWFnZS93ZWJwJ1xuXG4vKipcbiAqIEltYWdlIGNvbmZpZ3VyYXRpb25zXG4gKlxuICogQHNlZSBbSW1hZ2UgY29uZmlndXJhdGlvbiBvcHRpb25zXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjY29uZmlndXJhdGlvbi1vcHRpb25zKVxuICovXG5leHBvcnQgdHlwZSBJbWFnZUNvbmZpZ0NvbXBsZXRlID0ge1xuICAvKiogQHNlZSBbRGV2aWNlIHNpemVzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNkZXZpY2Utc2l6ZXMpICovXG4gIGRldmljZVNpemVzOiBudW1iZXJbXVxuXG4gIC8qKiBAc2VlIFtJbWFnZSBzaXppbmcgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vb3B0aW1pemluZy9pbWFnZXMjaW1hZ2Utc2l6aW5nKSAqL1xuICBpbWFnZVNpemVzOiBudW1iZXJbXVxuXG4gIC8qKiBAc2VlIFtJbWFnZSBsb2FkZXJzIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9sZWdhY3kvaW1hZ2UjbG9hZGVyKSAqL1xuICBsb2FkZXI6IExvYWRlclZhbHVlXG5cbiAgLyoqIEBzZWUgW0ltYWdlIGxvYWRlciBjb25maWd1cmF0aW9uXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvbGVnYWN5L2ltYWdlI2xvYWRlci1jb25maWd1cmF0aW9uKSAqL1xuICBwYXRoOiBzdHJpbmdcblxuICAvKiogQHNlZSBbSW1hZ2UgbG9hZGVyIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNsb2FkZXItY29uZmlndXJhdGlvbikgKi9cbiAgbG9hZGVyRmlsZTogc3RyaW5nXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgcmVtb3RlUGF0dGVybnNgIGluc3RlYWQuXG4gICAqL1xuICBkb21haW5zOiBzdHJpbmdbXVxuXG4gIC8qKiBAc2VlIFtEaXNhYmxlIHN0YXRpYyBpbWFnZSBpbXBvcnQgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2Rpc2FibGUtc3RhdGljLWltcG9ydHMpICovXG4gIGRpc2FibGVTdGF0aWNJbWFnZXM6IGJvb2xlYW5cblxuICAvKiogQHNlZSBbQ2FjaGUgYmVoYXZpb3JdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNjYWNoaW5nLWJlaGF2aW9yKSAqL1xuICBtaW5pbXVtQ2FjaGVUVEw6IG51bWJlclxuXG4gIC8qKiBAc2VlIFtBY2NlcHRhYmxlIGZvcm1hdHNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNhY2NlcHRhYmxlLWZvcm1hdHMpICovXG4gIGZvcm1hdHM6IEltYWdlRm9ybWF0W11cblxuICAvKiogQHNlZSBbRGFuZ2Vyb3VzbHkgQWxsb3cgU1ZHXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjZGFuZ2Vyb3VzbHktYWxsb3ctc3ZnKSAqL1xuICBkYW5nZXJvdXNseUFsbG93U1ZHOiBib29sZWFuXG5cbiAgLyoqIEBzZWUgW0Rhbmdlcm91c2x5IEFsbG93IFNWR10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2Rhbmdlcm91c2x5LWFsbG93LXN2ZykgKi9cbiAgY29udGVudFNlY3VyaXR5UG9saWN5OiBzdHJpbmdcblxuICAvKiogQHNlZSBbRGFuZ2Vyb3VzbHkgQWxsb3cgU1ZHXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjZGFuZ2Vyb3VzbHktYWxsb3ctc3ZnKSAqL1xuICBjb250ZW50RGlzcG9zaXRpb25UeXBlOiAnaW5saW5lJyB8ICdhdHRhY2htZW50J1xuXG4gIC8qKiBAc2VlIFtSZW1vdGUgUGF0dGVybnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNyZW1vdGVwYXR0ZXJucykgKi9cbiAgcmVtb3RlUGF0dGVybnM6IEFycmF5PFVSTCB8IFJlbW90ZVBhdHRlcm4+XG5cbiAgLyoqIEBzZWUgW1JlbW90ZSBQYXR0ZXJuc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2xvY2FsUGF0dGVybnMpICovXG4gIGxvY2FsUGF0dGVybnM6IExvY2FsUGF0dGVybltdIHwgdW5kZWZpbmVkXG5cbiAgLyoqIEBzZWUgW1F1YWxpdGllc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3F1YWxpdGllcykgKi9cbiAgcXVhbGl0aWVzOiBudW1iZXJbXSB8IHVuZGVmaW5lZFxuXG4gIC8qKiBAc2VlIFtVbm9wdGltaXplZF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3Vub3B0aW1pemVkKSAqL1xuICB1bm9wdGltaXplZDogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBJbWFnZUNvbmZpZyA9IFBhcnRpYWw8SW1hZ2VDb25maWdDb21wbGV0ZT5cblxuZXhwb3J0IGNvbnN0IGltYWdlQ29uZmlnRGVmYXVsdDogSW1hZ2VDb25maWdDb21wbGV0ZSA9IHtcbiAgZGV2aWNlU2l6ZXM6IFs2NDAsIDc1MCwgODI4LCAxMDgwLCAxMjAwLCAxOTIwLCAyMDQ4LCAzODQwXSxcbiAgaW1hZ2VTaXplczogWzE2LCAzMiwgNDgsIDY0LCA5NiwgMTI4LCAyNTYsIDM4NF0sXG4gIHBhdGg6ICcvX25leHQvaW1hZ2UnLFxuICBsb2FkZXI6ICdkZWZhdWx0JyxcbiAgbG9hZGVyRmlsZTogJycsXG4gIGRvbWFpbnM6IFtdLFxuICBkaXNhYmxlU3RhdGljSW1hZ2VzOiBmYWxzZSxcbiAgbWluaW11bUNhY2hlVFRMOiA2MCxcbiAgZm9ybWF0czogWydpbWFnZS93ZWJwJ10sXG4gIGRhbmdlcm91c2x5QWxsb3dTVkc6IGZhbHNlLFxuICBjb250ZW50U2VjdXJpdHlQb2xpY3k6IGBzY3JpcHQtc3JjICdub25lJzsgZnJhbWUtc3JjICdub25lJzsgc2FuZGJveDtgLFxuICBjb250ZW50RGlzcG9zaXRpb25UeXBlOiAnYXR0YWNobWVudCcsXG4gIGxvY2FsUGF0dGVybnM6IHVuZGVmaW5lZCwgLy8gZGVmYXVsdDogYWxsb3cgYWxsIGxvY2FsIGltYWdlc1xuICByZW1vdGVQYXR0ZXJuczogW10sIC8vIGRlZmF1bHQ6IGFsbG93IG5vIHJlbW90ZSBpbWFnZXNcbiAgcXVhbGl0aWVzOiB1bmRlZmluZWQsIC8vIGRlZmF1bHQ6IGFsbG93IGFsbCBxdWFsaXRpZXNcbiAgdW5vcHRpbWl6ZWQ6IGZhbHNlLFxufVxuIl0sIm5hbWVzIjpbIlZBTElEX0xPQURFUlMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJwYXRoIiwibG9hZGVyIiwibG9hZGVyRmlsZSIsImRvbWFpbnMiLCJkaXNhYmxlU3RhdGljSW1hZ2VzIiwibWluaW11bUNhY2hlVFRMIiwiZm9ybWF0cyIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJjb250ZW50U2VjdXJpdHlQb2xpY3kiLCJjb250ZW50RGlzcG9zaXRpb25UeXBlIiwibG9jYWxQYXR0ZXJucyIsInVuZGVmaW5lZCIsInJlbW90ZVBhdHRlcm5zIiwicXVhbGl0aWVzIiwidW5vcHRpbWl6ZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    getImageProps: function() {\n        return getImageProps;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nfunction getImageProps(imgProps) {\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[{\"protocol\":\"https\",\"hostname\":\"upload.wikimedia.org\"}]}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n}\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpQ0EsT0FBb0I7ZUFBcEI7O0lBakJnQkEsYUFBYTtlQUFiQTs7Ozt5Q0FiWTs0Q0FDTjtrRkFHSTtBQVNuQixTQUFTQSxjQUFjQyxRQUFvQjtJQUNoRCxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFBQSxFQUFZRixVQUFVO1FBQ3RDRyxlQUFBQSxhQUFBQSxPQUFhO1FBQ2IsNENBQTRDO1FBQzVDQyxTQUFTQyxnUkFBNkI7SUFDeEM7SUFDQSx1RUFBdUU7SUFDdkUsd0VBQXdFO0lBQ3hFLHdEQUF3RDtJQUN4RCxLQUFLLE1BQU0sQ0FBQ0csS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNWLE9BQVE7UUFDaEQsSUFBSVEsVUFBVUcsV0FBVztZQUN2QixPQUFPWCxLQUFLLENBQUNPLElBQTBCO1FBQ3pDO0lBQ0Y7SUFDQSxPQUFPO1FBQUVQO0lBQU07QUFDakI7TUFFQSxXQUFlWSxnQkFBQUEsS0FBSyIsInNvdXJjZXMiOlsiQzpcXHNyY1xcc2hhcmVkXFxsaWJcXGltYWdlLWV4dGVybmFsLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEltYWdlQ29uZmlnQ29tcGxldGUsIEltYWdlTG9hZGVyUHJvcHMgfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcbmltcG9ydCB0eXBlIHsgSW1hZ2VQcm9wcywgSW1hZ2VMb2FkZXIsIFN0YXRpY0ltYWdlRGF0YSB9IGZyb20gJy4vZ2V0LWltZy1wcm9wcydcblxuaW1wb3J0IHsgZ2V0SW1nUHJvcHMgfSBmcm9tICcuL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgeyBJbWFnZSB9IGZyb20gJy4uLy4uL2NsaWVudC9pbWFnZS1jb21wb25lbnQnXG5cbi8vIEB0cy1pZ25vcmUgLSBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgYWxpYXNcbmltcG9ydCBkZWZhdWx0TG9hZGVyIGZyb20gJ25leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWxvYWRlcidcblxuLyoqXG4gKiBGb3IgbW9yZSBhZHZhbmNlZCB1c2UgY2FzZXMsIHlvdSBjYW4gY2FsbCBgZ2V0SW1hZ2VQcm9wcygpYFxuICogdG8gZ2V0IHRoZSBwcm9wcyB0aGF0IHdvdWxkIGJlIHBhc3NlZCB0byB0aGUgdW5kZXJseWluZyBgPGltZz5gIGVsZW1lbnQsXG4gKiBhbmQgaW5zdGVhZCBwYXNzIHRvIHRoZW0gdG8gYW5vdGhlciBjb21wb25lbnQsIHN0eWxlLCBjYW52YXMsIGV0Yy5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIGRvY3M6IGBnZXRJbWFnZVByb3BzYF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9pbWFnZSNnZXRpbWFnZXByb3BzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1hZ2VQcm9wcyhpbWdQcm9wczogSW1hZ2VQcm9wcykge1xuICBjb25zdCB7IHByb3BzIH0gPSBnZXRJbWdQcm9wcyhpbWdQcm9wcywge1xuICAgIGRlZmF1bHRMb2FkZXIsXG4gICAgLy8gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGRlZmluZSBwbHVnaW5cbiAgICBpbWdDb25mOiBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUyBhcyBhbnkgYXMgSW1hZ2VDb25maWdDb21wbGV0ZSxcbiAgfSlcbiAgLy8gTm9ybWFsbHkgd2UgZG9uJ3QgY2FyZSBhYm91dCB1bmRlZmluZWQgcHJvcHMgYmVjYXVzZSB3ZSBwYXNzIHRvIEpTWCxcbiAgLy8gYnV0IHRoaXMgZXhwb3J0ZWQgZnVuY3Rpb24gY291bGQgYmUgdXNlZCBieSB0aGUgZW5kIHVzZXIgZm9yIGFueXRoaW5nXG4gIC8vIHNvIHdlIGRlbGV0ZSB1bmRlZmluZWQgcHJvcHMgdG8gY2xlYW4gaXQgdXAgYSBsaXR0bGUuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgcHJvcHNba2V5IGFzIGtleW9mIHR5cGVvZiBwcm9wc11cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgcHJvcHMgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVxuXG5leHBvcnQgdHlwZSB7IEltYWdlUHJvcHMsIEltYWdlTG9hZGVyUHJvcHMsIEltYWdlTG9hZGVyLCBTdGF0aWNJbWFnZURhdGEgfVxuIl0sIm5hbWVzIjpbImdldEltYWdlUHJvcHMiLCJpbWdQcm9wcyIsInByb3BzIiwiZ2V0SW1nUHJvcHMiLCJkZWZhdWx0TG9hZGVyIiwiaW1nQ29uZiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSU1BR0VfT1BUUyIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInVuZGVmaW5lZCIsIkltYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst DEFAULT_Q = 75;\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    var _config_qualities;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push('src');\n        if (!width) missingValues.push('width');\n        if (missingValues.length > 0) {\n            throw Object.defineProperty(new Error(\"Next Image Optimization requires \" + missingValues.join(', ') + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            })), \"__NEXT_ERROR_CODE\", {\n                value: \"E188\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (src.startsWith('//')) {\n            throw Object.defineProperty(new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'), \"__NEXT_ERROR_CODE\", {\n                value: \"E360\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (src.startsWith('/') && config.localPatterns) {\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasLocalMatch } = __webpack_require__(/*! ./match-local-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js\");\n                if (!hasLocalMatch(config.localPatterns, src)) {\n                    throw Object.defineProperty(new Error(\"Invalid src prop (\" + src + \") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E426\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw Object.defineProperty(new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E63\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasRemoteMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw Object.defineProperty(new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E231\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n        if (quality && config.qualities && !config.qualities.includes(quality)) {\n            throw Object.defineProperty(new Error(\"Invalid quality prop (\" + quality + \") on `next/image` does not match `images.qualities` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-qualities\"), \"__NEXT_ERROR_CODE\", {\n                value: \"E623\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    const q = quality || ((_config_qualities = config.qualities) == null ? void 0 : _config_qualities.reduce((prev, cur)=>Math.abs(cur - DEFAULT_Q) < Math.abs(prev - DEFAULT_Q) ? cur : prev)) || DEFAULT_Q;\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + q + (src.startsWith('/_next/static/media/') && false ? 0 : '');\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0F1R0E7OztlQUFBOzs7QUFyR0EsTUFBTUEsWUFBWTtBQUVsQixTQUFTQyxjQUFjLEtBS007SUFMTixNQUNyQkMsTUFBTSxFQUNOQyxHQUFHLEVBQ0hDLEtBQUssRUFDTEMsT0FBTyxFQUNvQixHQUxOO1FBbUZuQkg7SUE3RUYsSUFBSUksSUFBb0IsRUFBbUI7UUFDekMsTUFBTUcsZ0JBQWdCLEVBQUU7UUFFeEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ04sS0FBS00sY0FBY0MsSUFBSSxDQUFDO1FBQzdCLElBQUksQ0FBQ04sT0FBT0ssY0FBY0MsSUFBSSxDQUFDO1FBRS9CLElBQUlELGNBQWNFLE1BQU0sR0FBRyxHQUFHO1lBQzVCLE1BQU0scUJBTUwsQ0FOSyxJQUFJQyxNQUNQLHNDQUFtQ0gsY0FBY0ksSUFBSSxDQUNwRCxRQUNBLGdHQUErRkMsS0FBS0MsU0FBUyxDQUM3RztnQkFBRVo7Z0JBQUtDO2dCQUFPQztZQUFRLEtBSnBCO3VCQUFBOzRCQUFBOzhCQUFBO1lBTU47UUFDRjtRQUVBLElBQUlGLElBQUlhLFVBQVUsQ0FBQyxPQUFPO1lBQ3hCLE1BQU0scUJBRUwsQ0FGSyxJQUFJSixNQUNQLDBCQUF1QlQsTUFBSSwyR0FEeEI7dUJBQUE7NEJBQUE7OEJBQUE7WUFFTjtRQUNGO1FBRUEsSUFBSUEsSUFBSWEsVUFBVSxDQUFDLFFBQVFkLE9BQU9lLGFBQWEsRUFBRTtZQUMvQyxJQUNFWCxJQUVtQyxFQUNuQztnQkFDQSx1RUFBdUU7Z0JBQ3ZFLE1BQU0sRUFBRWEsYUFBYSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDLDZHQUF1QjtnQkFDekQsSUFBSSxDQUFDRCxjQUFjakIsT0FBT2UsYUFBYSxFQUFFZCxNQUFNO29CQUM3QyxNQUFNLHFCQUdMLENBSEssSUFBSVMsTUFDUCx1QkFBb0JULE1BQUksa0dBQ3RCLDBGQUZDOytCQUFBO29DQUFBO3NDQUFBO29CQUdOO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQ0EsSUFBSWEsVUFBVSxDQUFDLFFBQVNkLENBQUFBLE9BQU9tQixPQUFPLElBQUluQixPQUFPb0IsY0FBQUEsR0FBaUI7WUFDckUsSUFBSUM7WUFDSixJQUFJO2dCQUNGQSxZQUFZLElBQUlDLElBQUlyQjtZQUN0QixFQUFFLE9BQU9zQixLQUFLO2dCQUNaQyxRQUFRQyxLQUFLLENBQUNGO2dCQUNkLE1BQU0scUJBRUwsQ0FGSyxJQUFJYixNQUNQLDBCQUF1QlQsTUFBSSxrSUFEeEI7MkJBQUE7Z0NBQUE7a0NBQUE7Z0JBRU47WUFDRjtZQUVBLElBQ0VHLElBRW1DLEVBQ25DO2dCQUNBLHVFQUF1RTtnQkFDdkUsTUFBTSxFQUFFc0IsY0FBYyxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDLCtHQUF3QjtnQkFDM0QsSUFBSSxDQUFDUSxlQUFlMUIsT0FBT21CLE9BQU8sRUFBRW5CLE9BQU9vQixjQUFjLEVBQUVDLFlBQVk7b0JBQ3JFLE1BQU0scUJBR0wsQ0FISyxJQUFJWCxNQUNQLHVCQUFvQlQsTUFBSSxrQ0FBaUNvQixVQUFVTSxRQUFRLEdBQUMsZ0VBQzFFLGlGQUZDOytCQUFBO29DQUFBO3NDQUFBO29CQUdOO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLElBQUl4QixXQUFXSCxPQUFPNEIsU0FBUyxJQUFJLENBQUM1QixPQUFPNEIsU0FBUyxDQUFDQyxRQUFRLENBQUMxQixVQUFVO1lBQ3RFLE1BQU0scUJBR0wsQ0FISyxJQUFJTyxNQUNQLDJCQUF3QlAsVUFBUSw4RkFDOUIsc0ZBRkM7dUJBQUE7NEJBQUE7OEJBQUE7WUFHTjtRQUNGO0lBQ0Y7SUFFQSxNQUFNMkIsSUFDSjNCLFdBQUFBLENBQUFBLENBQ0FILG9CQUFBQSxPQUFPNEIsU0FBQUEsS0FBUyxnQkFBaEI1QixrQkFBa0IrQixNQUFNLENBQUMsQ0FBQ0MsTUFBTUMsTUFDOUJDLEtBQUtDLEdBQUcsQ0FBQ0YsTUFBTW5DLGFBQWFvQyxLQUFLQyxHQUFHLENBQUNILE9BQU9sQyxhQUFhbUMsTUFBTUQsS0FBQUEsS0FFakVsQztJQUVGLE9BQVVFLE9BQU9vQyxJQUFJLEdBQUMsVUFBT0MsbUJBQW1CcEMsT0FBSyxRQUFLQyxRQUFNLFFBQUs0QixJQUNuRTdCLENBQUFBLElBQUlhLFVBQVUsQ0FBQywyQkFBMkJWLEtBQThCLEdBQ25FLENBQXFDLEdBQ3RDLEdBQUM7QUFFVDtBQUVBLCtEQUErRDtBQUMvRCwyREFBMkQ7QUFDM0RMLGNBQWN3QyxrQkFBa0IsR0FBRztNQUVuQyxXQUFleEMiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXHNoYXJlZFxcbGliXFxpbWFnZS1sb2FkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZyB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuXG5jb25zdCBERUZBVUxUX1EgPSA3NVxuXG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHtcbiAgY29uZmlnLFxuICBzcmMsXG4gIHdpZHRoLFxuICBxdWFsaXR5LFxufTogSW1hZ2VMb2FkZXJQcm9wc1dpdGhDb25maWcpOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IG1pc3NpbmdWYWx1ZXMgPSBbXVxuXG4gICAgLy8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBidXQgbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgaWYgKCFzcmMpIG1pc3NpbmdWYWx1ZXMucHVzaCgnc3JjJylcbiAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3dpZHRoJylcblxuICAgIGlmIChtaXNzaW5nVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5leHQgSW1hZ2UgT3B0aW1pemF0aW9uIHJlcXVpcmVzICR7bWlzc2luZ1ZhbHVlcy5qb2luKFxuICAgICAgICAgICcsICdcbiAgICAgICAgKX0gdG8gYmUgcHJvdmlkZWQuIE1ha2Ugc3VyZSB5b3UgcGFzcyB0aGVtIGFzIHByb3BzIHRvIHRoZSBcXGBuZXh0L2ltYWdlXFxgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgeyBzcmMsIHdpZHRoLCBxdWFsaXR5IH1cbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMICgvLykgbXVzdCBiZSBjaGFuZ2VkIHRvIGFuIGFic29sdXRlIFVSTCAoaHR0cDovLyBvciBodHRwczovLylgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvJykgJiYgY29uZmlnLmxvY2FsUGF0dGVybnMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSAnZWRnZSdcbiAgICAgICkge1xuICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICBjb25zdCB7IGhhc0xvY2FsTWF0Y2ggfSA9IHJlcXVpcmUoJy4vbWF0Y2gtbG9jYWwtcGF0dGVybicpXG4gICAgICAgIGlmICghaGFzTG9jYWxNYXRjaChjb25maWcubG9jYWxQYXR0ZXJucywgc3JjKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHNyYyBwcm9wICgke3NyY30pIG9uIFxcYG5leHQvaW1hZ2VcXGAgZG9lcyBub3QgbWF0Y2ggXFxgaW1hZ2VzLmxvY2FsUGF0dGVybnNcXGAgY29uZmlndXJlZCBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArXG4gICAgICAgICAgICAgIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1sb2NhbHBhdHRlcm5zYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoJy8nKSAmJiAoY29uZmlnLmRvbWFpbnMgfHwgY29uZmlnLnJlbW90ZVBhdHRlcm5zKSkge1xuICAgICAgbGV0IHBhcnNlZFNyYzogVVJMXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgaWYgdXNpbmcgcmVsYXRpdmUgaW1hZ2UgaXQgbXVzdCBzdGFydCB3aXRoIGEgbGVhZGluZyBzbGFzaCBcIi9cIiBvciBiZSBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSAnZWRnZSdcbiAgICAgICkge1xuICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICBjb25zdCB7IGhhc1JlbW90ZU1hdGNoIH0gPSByZXF1aXJlKCcuL21hdGNoLXJlbW90ZS1wYXR0ZXJuJylcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVNYXRjaChjb25maWcuZG9tYWlucywgY29uZmlnLnJlbW90ZVBhdHRlcm5zLCBwYXJzZWRTcmMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgc3JjIHByb3AgKCR7c3JjfSkgb24gXFxgbmV4dC9pbWFnZVxcYCwgaG9zdG5hbWUgXCIke3BhcnNlZFNyYy5ob3N0bmFtZX1cIiBpcyBub3QgY29uZmlndXJlZCB1bmRlciBpbWFnZXMgaW4geW91ciBcXGBuZXh0LmNvbmZpZy5qc1xcYFxcbmAgK1xuICAgICAgICAgICAgICBgU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11bmNvbmZpZ3VyZWQtaG9zdGBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocXVhbGl0eSAmJiBjb25maWcucXVhbGl0aWVzICYmICFjb25maWcucXVhbGl0aWVzLmluY2x1ZGVzKHF1YWxpdHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHF1YWxpdHkgcHJvcCAoJHtxdWFsaXR5fSkgb24gXFxgbmV4dC9pbWFnZVxcYCBkb2VzIG5vdCBtYXRjaCBcXGBpbWFnZXMucXVhbGl0aWVzXFxgIGNvbmZpZ3VyZWQgaW4geW91ciBcXGBuZXh0LmNvbmZpZy5qc1xcYFxcbmAgK1xuICAgICAgICAgIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1xdWFsaXRpZXNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcSA9XG4gICAgcXVhbGl0eSB8fFxuICAgIGNvbmZpZy5xdWFsaXRpZXM/LnJlZHVjZSgocHJldiwgY3VyKSA9PlxuICAgICAgTWF0aC5hYnMoY3VyIC0gREVGQVVMVF9RKSA8IE1hdGguYWJzKHByZXYgLSBERUZBVUxUX1EpID8gY3VyIDogcHJldlxuICAgICkgfHxcbiAgICBERUZBVUxUX1FcblxuICByZXR1cm4gYCR7Y29uZmlnLnBhdGh9P3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChzcmMpfSZ3PSR7d2lkdGh9JnE9JHtxfSR7XG4gICAgc3JjLnN0YXJ0c1dpdGgoJy9fbmV4dC9zdGF0aWMvbWVkaWEvJykgJiYgcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEXG4gICAgICA/IGAmZHBsPSR7cHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEfWBcbiAgICAgIDogJydcbiAgfWBcbn1cblxuLy8gV2UgdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBpbXBvcnQgaXMgdGhlIGRlZmF1bHQgbG9hZGVyXG4vLyBvciBhIGN1c3RvbSBsb2FkZXIgZGVmaW5lZCBieSB0aGUgdXNlciBpbiBuZXh0LmNvbmZpZy5qc1xuZGVmYXVsdExvYWRlci5fX25leHRfaW1nX2RlZmF1bHQgPSB0cnVlXG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRMb2FkZXJcbiJdLCJuYW1lcyI6WyJERUZBVUxUX1EiLCJkZWZhdWx0TG9hZGVyIiwiY29uZmlnIiwic3JjIiwid2lkdGgiLCJxdWFsaXR5IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJsZW5ndGgiLCJFcnJvciIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnRzV2l0aCIsImxvY2FsUGF0dGVybnMiLCJORVhUX1JVTlRJTUUiLCJoYXNMb2NhbE1hdGNoIiwicmVxdWlyZSIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsIlVSTCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImhhc1JlbW90ZU1hdGNoIiwiaG9zdG5hbWUiLCJxdWFsaXRpZXMiLCJpbmNsdWRlcyIsInEiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyIiwiTWF0aCIsImFicyIsInBhdGgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJfX25leHRfaW1nX2RlZmF1bHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-local-pattern.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasLocalMatch: function() {\n        return hasLocalMatch;\n    },\n    matchLocalPattern: function() {\n        return matchLocalPattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchLocalPattern(pattern, url) {\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasLocalMatch(localPatterns, urlPathAndQuery) {\n    if (!localPatterns) {\n        // if the user didn't define \"localPatterns\", we allow all local images\n        return true;\n    }\n    const url = new URL(urlPathAndQuery, 'http://n');\n    return localPatterns.some((p)=>matchLocalPattern(p, url));\n} //# sourceMappingURL=match-local-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1sb2NhbC1wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWtCZ0JBLGFBQWE7ZUFBYkE7O0lBZEFDLGlCQUFpQjtlQUFqQkE7Ozt1Q0FITztBQUdoQixTQUFTQSxrQkFBa0JDLE9BQXFCLEVBQUVDLEdBQVE7SUFDL0QsSUFBSUQsUUFBUUUsTUFBTSxLQUFLQyxXQUFXO1FBQ2hDLElBQUlILFFBQVFFLE1BQU0sS0FBS0QsSUFBSUMsTUFBTSxFQUFFO1lBQ2pDLE9BQU87UUFDVDtJQUNGO1FBRVlGO0lBQVosSUFBSSxDQUFDSSxDQUFBQSxHQUFBQSxXQUFBQSxNQUFBQSxFQUFPSixDQUFBQSxvQkFBQUEsUUFBUUssUUFBQUEsS0FBUSxPQUFoQkwsb0JBQW9CLE1BQU07UUFBRU0sS0FBSztJQUFLLEdBQUdDLElBQUksQ0FBQ04sSUFBSUksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNQLGNBQ2RVLGFBQXlDLEVBQ3pDQyxlQUF1QjtJQUV2QixJQUFJLENBQUNELGVBQWU7UUFDbEIsdUVBQXVFO1FBQ3ZFLE9BQU87SUFDVDtJQUNBLE1BQU1QLE1BQU0sSUFBSVMsSUFBSUQsaUJBQWlCO0lBQ3JDLE9BQU9ELGNBQWNHLElBQUksQ0FBQyxDQUFDQyxJQUFNYixrQkFBa0JhLEdBQUdYO0FBQ3hEIiwic291cmNlcyI6WyJDOlxcc3JjXFxzaGFyZWRcXGxpYlxcbWF0Y2gtbG9jYWwtcGF0dGVybi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IExvY2FsUGF0dGVybiB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgbWFrZVJlIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3BpY29tYXRjaCdcblxuLy8gTW9kaWZ5aW5nIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGFsc28gbW9kaWZ5IHdyaXRlSW1hZ2VzTWFuaWZlc3QoKVxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoTG9jYWxQYXR0ZXJuKHBhdHRlcm46IExvY2FsUGF0dGVybiwgdXJsOiBVUkwpOiBib29sZWFuIHtcbiAgaWYgKHBhdHRlcm4uc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocGF0dGVybi5zZWFyY2ggIT09IHVybC5zZWFyY2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmICghbWFrZVJlKHBhdHRlcm4ucGF0aG5hbWUgPz8gJyoqJywgeyBkb3Q6IHRydWUgfSkudGVzdCh1cmwucGF0aG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzTG9jYWxNYXRjaChcbiAgbG9jYWxQYXR0ZXJuczogTG9jYWxQYXR0ZXJuW10gfCB1bmRlZmluZWQsXG4gIHVybFBhdGhBbmRRdWVyeTogc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgaWYgKCFsb2NhbFBhdHRlcm5zKSB7XG4gICAgLy8gaWYgdGhlIHVzZXIgZGlkbid0IGRlZmluZSBcImxvY2FsUGF0dGVybnNcIiwgd2UgYWxsb3cgYWxsIGxvY2FsIGltYWdlc1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxQYXRoQW5kUXVlcnksICdodHRwOi8vbicpXG4gIHJldHVybiBsb2NhbFBhdHRlcm5zLnNvbWUoKHApID0+IG1hdGNoTG9jYWxQYXR0ZXJuKHAsIHVybCkpXG59XG4iXSwibmFtZXMiOlsiaGFzTG9jYWxNYXRjaCIsIm1hdGNoTG9jYWxQYXR0ZXJuIiwicGF0dGVybiIsInVybCIsInNlYXJjaCIsInVuZGVmaW5lZCIsIm1ha2VSZSIsInBhdGhuYW1lIiwiZG90IiwidGVzdCIsImxvY2FsUGF0dGVybnMiLCJ1cmxQYXRoQW5kUXVlcnkiLCJVUkwiLCJzb21lIiwicCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasRemoteMatch: function() {\n        return hasRemoteMatch;\n    },\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        if (pattern.protocol.replace(/:$/, '') !== url.protocol.replace(/:$/, '')) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw Object.defineProperty(new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern)), \"__NEXT_ERROR_CODE\", {\n            value: \"E410\",\n            enumerable: false,\n            configurable: true\n        });\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    // Should be the same as writeImagesManifest()\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasRemoteMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUEyQ2dCQSxjQUFjO2VBQWRBOztJQXZDQUMsa0JBQWtCO2VBQWxCQTs7O3VDQUhPO0FBR2hCLFNBQVNBLG1CQUNkQyxPQUE0QixFQUM1QkMsR0FBUTtJQUVSLElBQUlELFFBQVFFLFFBQVEsS0FBS0MsV0FBVztRQUNsQyxJQUFJSCxRQUFRRSxRQUFRLENBQUNFLE9BQU8sQ0FBQyxNQUFNLFFBQVFILElBQUlDLFFBQVEsQ0FBQ0UsT0FBTyxDQUFDLE1BQU0sS0FBSztZQUN6RSxPQUFPO1FBQ1Q7SUFDRjtJQUNBLElBQUlKLFFBQVFLLElBQUksS0FBS0YsV0FBVztRQUM5QixJQUFJSCxRQUFRSyxJQUFJLEtBQUtKLElBQUlJLElBQUksRUFBRTtZQUM3QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUlMLFFBQVFNLFFBQVEsS0FBS0gsV0FBVztRQUNsQyxNQUFNLHFCQUVMLENBRkssSUFBSUksTUFDUCwrQ0FBNENDLEtBQUtDLFNBQVMsQ0FBQ1QsV0FEeEQ7bUJBQUE7d0JBQUE7MEJBQUE7UUFFTjtJQUNGLE9BQU87UUFDTCxJQUFJLENBQUNVLENBQUFBLEdBQUFBLFdBQUFBLE1BQUFBLEVBQU9WLFFBQVFNLFFBQVEsRUFBRUssSUFBSSxDQUFDVixJQUFJSyxRQUFRLEdBQUc7WUFDaEQsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJTixRQUFRWSxNQUFNLEtBQUtULFdBQVc7UUFDaEMsSUFBSUgsUUFBUVksTUFBTSxLQUFLWCxJQUFJVyxNQUFNLEVBQUU7WUFDakMsT0FBTztRQUNUO0lBQ0Y7UUFHWVo7SUFEWiw4Q0FBOEM7SUFDOUMsSUFBSSxDQUFDVSxDQUFBQSxHQUFBQSxXQUFBQSxNQUFBQSxFQUFPVixDQUFBQSxvQkFBQUEsUUFBUWEsUUFBQUEsS0FBUSxPQUFoQmIsb0JBQW9CLE1BQU07UUFBRWMsS0FBSztJQUFLLEdBQUdILElBQUksQ0FBQ1YsSUFBSVksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNmLGVBQ2RpQixPQUFpQixFQUNqQkMsY0FBMEMsRUFDMUNmLEdBQVE7SUFFUixPQUNFYyxRQUFRRSxJQUFJLENBQUMsQ0FBQ0MsU0FBV2pCLElBQUlLLFFBQVEsS0FBS1ksV0FDMUNGLGVBQWVDLElBQUksQ0FBQyxDQUFDRSxJQUFNcEIsbUJBQW1Cb0IsR0FBR2xCO0FBRXJEIiwic291cmNlcyI6WyJDOlxcc3JjXFxzaGFyZWRcXGxpYlxcbWF0Y2gtcmVtb3RlLXBhdHRlcm4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBSZW1vdGVQYXR0ZXJuIH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBtYWtlUmUgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoJ1xuXG4vLyBNb2RpZnlpbmcgdGhpcyBmdW5jdGlvbiBzaG91bGQgYWxzbyBtb2RpZnkgd3JpdGVJbWFnZXNNYW5pZmVzdCgpXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hSZW1vdGVQYXR0ZXJuKFxuICBwYXR0ZXJuOiBSZW1vdGVQYXR0ZXJuIHwgVVJMLFxuICB1cmw6IFVSTFxuKTogYm9vbGVhbiB7XG4gIGlmIChwYXR0ZXJuLnByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocGF0dGVybi5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSAhPT0gdXJsLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdXJsLnBvcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmhvc3RuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUGF0dGVybiBzaG91bGQgZGVmaW5lIGhvc3RuYW1lIGJ1dCBmb3VuZFxcbiR7SlNPTi5zdHJpbmdpZnkocGF0dGVybil9YFxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBpZiAoIW1ha2VSZShwYXR0ZXJuLmhvc3RuYW1lKS50ZXN0KHVybC5ob3N0bmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXR0ZXJuLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBhdHRlcm4uc2VhcmNoICE9PSB1cmwuc2VhcmNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBTaG91bGQgYmUgdGhlIHNhbWUgYXMgd3JpdGVJbWFnZXNNYW5pZmVzdCgpXG4gIGlmICghbWFrZVJlKHBhdHRlcm4ucGF0aG5hbWUgPz8gJyoqJywgeyBkb3Q6IHRydWUgfSkudGVzdCh1cmwucGF0aG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzUmVtb3RlTWF0Y2goXG4gIGRvbWFpbnM6IHN0cmluZ1tdLFxuICByZW1vdGVQYXR0ZXJuczogQXJyYXk8UmVtb3RlUGF0dGVybiB8IFVSTD4sXG4gIHVybDogVVJMXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBkb21haW5zLnNvbWUoKGRvbWFpbikgPT4gdXJsLmhvc3RuYW1lID09PSBkb21haW4pIHx8XG4gICAgcmVtb3RlUGF0dGVybnMuc29tZSgocCkgPT4gbWF0Y2hSZW1vdGVQYXR0ZXJuKHAsIHVybCkpXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJoYXNSZW1vdGVNYXRjaCIsIm1hdGNoUmVtb3RlUGF0dGVybiIsInBhdHRlcm4iLCJ1cmwiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsInJlcGxhY2UiLCJwb3J0IiwiaG9zdG5hbWUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYWtlUmUiLCJ0ZXN0Iiwic2VhcmNoIiwicGF0aG5hbWUiLCJkb3QiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = 'RouterContext';\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzRFQUhLO0FBR1gsTUFBTUEsZ0JBQWdCQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNILGNBQWNNLFdBQVcsR0FBRztBQUM5QiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcc2hhcmVkXFxsaWJcXHJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcblxuZXhwb3J0IGNvbnN0IFJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PE5leHRSb3V0ZXIgfCBudWxsPihudWxsKVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1JvdXRlckNvbnRleHQnXG59XG4iXSwibmFtZXMiOlsiUm91dGVyQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst isServer = \"object\" === 'undefined';\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect({\n        \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n            return ({\n                \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n                    var _headManager_mountedInstances;\n                    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n                }\n            })[\"SideEffect.useClientOnlyLayoutEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyLayoutEffect\"]);\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect({\n        \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n            return ({\n                \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n                    if (headManager) {\n                        headManager._pendingUpdate = emitChange;\n                    }\n                }\n            })[\"SideEffect.useClientOnlyLayoutEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyLayoutEffect\"]);\n    useClientOnlyEffect({\n        \"SideEffect.useClientOnlyEffect\": ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n            return ({\n                \"SideEffect.useClientOnlyEffect\": ()=>{\n                    if (headManager && headManager._pendingUpdate) {\n                        headManager._pendingUpdate();\n                        headManager._pendingUpdate = null;\n                    }\n                }\n            })[\"SideEffect.useClientOnlyEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyEffect\"]);\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7bUNBbkJ1QztBQWUvRCxNQUFNQyxXQUFXLE9BQU9DLE1BQVc7QUFDbkMsTUFBTUMsNEJBQTRCRixXQUFXLEtBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxNQUFNQyxzQkFBc0JKLFdBQVcsS0FBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLG9CQUFvQkMsS0FBc0I7O0lBQ3ZELE1BQU0sRUFBRUMsV0FBVyxFQUFFQyx1QkFBdUIsRUFBRSxHQUFHRjtJQUVqRCxTQUFTRztRQUNQLElBQUlGLGVBQWVBLFlBQVlHLGdCQUFnQixFQUFFO1lBQy9DLE1BQU1DLGVBQWVDLE9BQUFBLFFBQVEsQ0FBQ0MsT0FBTyxDQUNuQ0MsTUFBTUMsSUFBSSxDQUFDUixZQUFZRyxnQkFBZ0IsRUFBMEJNLE1BQU0sQ0FDckVDO1lBR0pWLFlBQVlXLFVBQVUsQ0FBQ1Ysd0JBQXdCRyxjQUFjTDtRQUMvRDtJQUNGO0lBRUEsSUFBSU4sVUFBVTtZQUNaTztRQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQUFBLEtBQWdCLGdCQUE3QkgsOEJBQStCWSxHQUFHLENBQUNiLE1BQU1jLFFBQVE7UUFDakRYO0lBQ0Y7O2dEQUUwQjtnQkFDeEJGO1lBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtZQUNqRDt3REFBTzt3QkFDTGI7b0JBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JjLE1BQU0sQ0FBQ2YsTUFBTWMsUUFBUTtnQkFDdEQ7O1FBQ0Y7O0lBRUEsa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjs7Z0RBQ3pEO1lBQ3hCLElBQUliLGFBQWE7Z0JBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7WUFDL0I7WUFDQTt3REFBTztvQkFDTCxJQUFJRixhQUFhO3dCQUNmQSxZQUFZZSxjQUFjLEdBQUdiO29CQUMvQjtnQkFDRjs7UUFDRjs7OzBDQUVvQjtZQUNsQixJQUFJRixlQUFlQSxZQUFZZSxjQUFjLEVBQUU7Z0JBQzdDZixZQUFZZSxjQUFjO2dCQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1lBQy9CO1lBQ0E7a0RBQU87b0JBQ0wsSUFBSWYsZUFBZUEsWUFBWWUsY0FBYyxFQUFFO3dCQUM3Q2YsWUFBWWUsY0FBYzt3QkFDMUJmLFlBQVllLGNBQWMsR0FBRztvQkFDL0I7Z0JBQ0Y7O1FBQ0Y7O0lBRUEsT0FBTztBQUNUOzs7UUFyQ0VwQjtRQVlBQTtRQVdBRTs7O0tBMUNzQkwiLCJzb3VyY2VzIjpbIkM6XFxzcmNcXHNoYXJlZFxcbGliXFxzaWRlLWVmZmVjdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDaGlsZHJlbiwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5cbnR5cGUgU3RhdGUgPSBKU1guRWxlbWVudFtdIHwgdW5kZWZpbmVkXG5cbmV4cG9ydCB0eXBlIFNpZGVFZmZlY3RQcm9wcyA9IHtcbiAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6IDxUIGV4dGVuZHMge30+KFxuICAgIGNvbXBvbmVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICBwcm9wczogVFxuICApID0+IFN0YXRlXG4gIGhhbmRsZVN0YXRlQ2hhbmdlPzogKHN0YXRlOiBTdGF0ZSkgPT4gdm9pZFxuICBoZWFkTWFuYWdlcjogYW55XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxufVxuXG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG5jb25zdCB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKSA9PiB7fSA6IHVzZUxheW91dEVmZmVjdFxuY29uc3QgdXNlQ2xpZW50T25seUVmZmVjdCA9IGlzU2VydmVyID8gKCkgPT4ge30gOiB1c2VFZmZlY3RcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2lkZUVmZmVjdChwcm9wczogU2lkZUVmZmVjdFByb3BzKSB7XG4gIGNvbnN0IHsgaGVhZE1hbmFnZXIsIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIH0gPSBwcm9wc1xuXG4gIGZ1bmN0aW9uIGVtaXRDaGFuZ2UoKSB7XG4gICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpIHtcbiAgICAgIGNvbnN0IGhlYWRFbGVtZW50cyA9IENoaWxkcmVuLnRvQXJyYXkoXG4gICAgICAgIEFycmF5LmZyb20oaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcyBhcyBTZXQ8UmVhY3QuUmVhY3ROb2RlPikuZmlsdGVyKFxuICAgICAgICAgIEJvb2xlYW5cbiAgICAgICAgKVxuICAgICAgKSBhcyBSZWFjdC5SZWFjdEVsZW1lbnRbXVxuICAgICAgaGVhZE1hbmFnZXIudXBkYXRlSGVhZChyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZShoZWFkRWxlbWVudHMsIHByb3BzKSlcbiAgICB9XG4gIH1cblxuICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICBoZWFkTWFuYWdlcj8ubW91bnRlZEluc3RhbmNlcz8uYWRkKHByb3BzLmNoaWxkcmVuKVxuICAgIGVtaXRDaGFuZ2UoKVxuICB9XG5cbiAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaGVhZE1hbmFnZXI/Lm1vdW50ZWRJbnN0YW5jZXM/LmFkZChwcm9wcy5jaGlsZHJlbilcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGVhZE1hbmFnZXI/Lm1vdW50ZWRJbnN0YW5jZXM/LmRlbGV0ZShwcm9wcy5jaGlsZHJlbilcbiAgICB9XG4gIH0pXG5cbiAgLy8gV2UgbmVlZCB0byBjYWxsIGB1cGRhdGVIZWFkYCBtZXRob2Qgd2hlbmV2ZXIgdGhlIGBTaWRlRWZmZWN0YCBpcyB0cmlnZ2VyIGluIGFsbFxuICAvLyBsaWZlLWN5Y2xlczogbW91bnQsIHVwZGF0ZSwgdW5tb3VudC4gSG93ZXZlciwgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGBTaWRlRWZmZWN0YHNcbiAgLy8gYmVpbmcgcmVuZGVyZWQsIHdlIG9ubHkgdHJpZ2dlciB0aGUgbWV0aG9kIGZyb20gdGhlIGxhc3Qgb25lLlxuICAvLyBUaGlzIGlzIGVuc3VyZWQgYnkga2VlcGluZyB0aGUgbGFzdCB1bmZsdXNoZWQgYHVwZGF0ZUhlYWRgIGluIHRoZSBgX3BlbmRpbmdVcGRhdGVgXG4gIC8vIHNpbmdsZXRvbiBpbiB0aGUgbGF5b3V0IGVmZmVjdCBwYXNzLCBhbmQgYWN0dWFsbHkgdHJpZ2dlciBpdCBpbiB0aGUgZWZmZWN0IHBhc3MuXG4gIHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaGVhZE1hbmFnZXIpIHtcbiAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHVzZUNsaWVudE9ubHlFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSkge1xuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKVxuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBudWxsXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKVxuICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG51bGxcbn1cbiJdLCJuYW1lcyI6WyJTaWRlRWZmZWN0IiwiaXNTZXJ2ZXIiLCJ3aW5kb3ciLCJ1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlQ2xpZW50T25seUVmZmVjdCIsInVzZUVmZmVjdCIsInByb3BzIiwiaGVhZE1hbmFnZXIiLCJyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZSIsImVtaXRDaGFuZ2UiLCJtb3VudGVkSW5zdGFuY2VzIiwiaGVhZEVsZW1lbnRzIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwiQm9vbGVhbiIsInVwZGF0ZUhlYWQiLCJhZGQiLCJjaGlsZHJlbiIsImRlbGV0ZSIsIl9wZW5kaW5nVXBkYXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/home/layout.tsx":
/*!*********************************!*\
  !*** ./src/app/home/layout.tsx ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ThemeContext: () => (/* binding */ ThemeContext),\n/* harmony export */   \"default\": () => (/* binding */ HomeLayout),\n/* harmony export */   useTheme: () => (/* binding */ useTheme)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/Header */ \"(app-pages-browser)/./src/components/Header.tsx\");\n/* __next_internal_client_entry_do_not_use__ ThemeContext,useTheme,default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst ThemeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    theme: 'light',\n    setTheme: ()=>{}\n});\nfunction useTheme() {\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ThemeContext);\n}\n_s(useTheme, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction HomeLayout(param) {\n    let { children } = param;\n    _s1();\n    const [theme, setTheme] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('light');\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"HomeLayout.useEffect\": ()=>{\n            if (true) {\n                setTheme(window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');\n                setMounted(true);\n            }\n        }\n    }[\"HomeLayout.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"HomeLayout.useEffect\": ()=>{\n            if (true) {\n                const html = document.documentElement;\n                if (theme === 'dark') {\n                    html.classList.add('dark');\n                    html.classList.remove('light');\n                } else {\n                    html.classList.remove('dark');\n                    html.classList.add('light');\n                }\n            }\n        }\n    }[\"HomeLayout.useEffect\"], [\n        theme\n    ]);\n    if (!mounted) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"opacity-0 min-h-screen\"\n    }, void 0, false, {\n        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\layout.tsx\",\n        lineNumber: 39,\n        columnNumber: 24\n    }, this);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ThemeContext.Provider, {\n        value: {\n            theme,\n            setTheme\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: theme === 'dark' ? 'dark flex flex-col min-h-screen bg-[#111] text-[#fff]' : 'flex flex-col min-h-screen bg-white text-gray-900',\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Header__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                    fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\layout.tsx\",\n                    lineNumber: 44,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                    className: \"flex-1\",\n                    children: children\n                }, void 0, false, {\n                    fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\layout.tsx\",\n                    lineNumber: 45,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\layout.tsx\",\n            lineNumber: 43,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\layout.tsx\",\n        lineNumber: 42,\n        columnNumber: 5\n    }, this);\n}\n_s1(HomeLayout, \"irO646EbSVqPL90dedilwyEs6oc=\");\n_c = HomeLayout;\nvar _c;\n$RefreshReg$(_c, \"HomeLayout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvaG9tZS9sYXlvdXQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUN5RjtBQUU1QztBQUV0QyxNQUFNTSw2QkFBZUwsb0RBQWFBLENBR3RDO0lBQUVNLE9BQU87SUFBU0MsVUFBVSxLQUFPO0FBQUUsR0FBRztBQUVwQyxTQUFTQzs7SUFDZCxPQUFPUCxpREFBVUEsQ0FBQ0k7QUFDcEI7R0FGZ0JHO0FBSUQsU0FBU0MsV0FBVyxLQUFxQztRQUFyQyxFQUFFQyxRQUFRLEVBQTJCLEdBQXJDOztJQUNqQyxNQUFNLENBQUNKLE9BQU9DLFNBQVMsR0FBR0wsK0NBQVFBLENBQW1CO0lBQ3JELE1BQU0sQ0FBQ1MsU0FBU0MsV0FBVyxHQUFHViwrQ0FBUUEsQ0FBQztJQUV2Q0MsZ0RBQVNBO2dDQUFDO1lBQ1IsSUFBSSxJQUE2QixFQUFFO2dCQUNqQ0ksU0FBU00sT0FBT0MsVUFBVSxDQUFDLGdDQUFnQ0MsT0FBTyxHQUFHLFNBQVM7Z0JBQzlFSCxXQUFXO1lBQ2I7UUFDRjsrQkFBRyxFQUFFO0lBRUxULGdEQUFTQTtnQ0FBQztZQUNSLElBQUksSUFBNkIsRUFBRTtnQkFDakMsTUFBTWEsT0FBT0MsU0FBU0MsZUFBZTtnQkFDckMsSUFBSVosVUFBVSxRQUFRO29CQUNwQlUsS0FBS0csU0FBUyxDQUFDQyxHQUFHLENBQUM7b0JBQ25CSixLQUFLRyxTQUFTLENBQUNFLE1BQU0sQ0FBQztnQkFDeEIsT0FBTztvQkFDTEwsS0FBS0csU0FBUyxDQUFDRSxNQUFNLENBQUM7b0JBQ3RCTCxLQUFLRyxTQUFTLENBQUNDLEdBQUcsQ0FBQztnQkFDckI7WUFDRjtRQUNGOytCQUFHO1FBQUNkO0tBQU07SUFFVixJQUFJLENBQUNLLFNBQVMscUJBQU8sOERBQUNXO1FBQUlDLFdBQVU7Ozs7OztJQUVwQyxxQkFDRSw4REFBQ2xCLGFBQWFtQixRQUFRO1FBQUNDLE9BQU87WUFBRW5CO1lBQU9DO1FBQVM7a0JBQzlDLDRFQUFDZTtZQUFJQyxXQUFXakIsVUFBVSxTQUFTLDBEQUEwRDs7OEJBQzNGLDhEQUFDRiwwREFBTUE7Ozs7OzhCQUNQLDhEQUFDc0I7b0JBQUtILFdBQVU7OEJBQVViOzs7Ozs7Ozs7Ozs7Ozs7OztBQUtsQztJQW5Dd0JEO0tBQUFBIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXHNyY1xcYXBwXFxob21lXFxsYXlvdXQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBGb290ZXIgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvRm9vdGVyXCI7XHJcbmltcG9ydCBIZWFkZXIgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvSGVhZGVyXCI7XHJcblxyXG5leHBvcnQgY29uc3QgVGhlbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDx7XHJcbiAgdGhlbWU6ICdsaWdodCcgfCAnZGFyayc7XHJcbiAgc2V0VGhlbWU6ICh0OiAnbGlnaHQnIHwgJ2RhcmsnKSA9PiB2b2lkO1xyXG59Pih7IHRoZW1lOiAnbGlnaHQnLCBzZXRUaGVtZTogKCkgPT4ge30gfSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGhlbWUoKSB7XHJcbiAgcmV0dXJuIHVzZUNvbnRleHQoVGhlbWVDb250ZXh0KTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZUxheW91dCh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XHJcbiAgY29uc3QgW3RoZW1lLCBzZXRUaGVtZV0gPSB1c2VTdGF0ZTwnbGlnaHQnIHwgJ2RhcmsnPignbGlnaHQnKTtcclxuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgc2V0VGhlbWUod2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0Jyk7XHJcbiAgICAgIHNldE1vdW50ZWQodHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGNvbnN0IGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgIGlmICh0aGVtZSA9PT0gJ2RhcmsnKSB7XHJcbiAgICAgICAgaHRtbC5jbGFzc0xpc3QuYWRkKCdkYXJrJyk7XHJcbiAgICAgICAgaHRtbC5jbGFzc0xpc3QucmVtb3ZlKCdsaWdodCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGh0bWwuY2xhc3NMaXN0LnJlbW92ZSgnZGFyaycpO1xyXG4gICAgICAgIGh0bWwuY2xhc3NMaXN0LmFkZCgnbGlnaHQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFt0aGVtZV0pO1xyXG5cclxuICBpZiAoIW1vdW50ZWQpIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cIm9wYWNpdHktMCBtaW4taC1zY3JlZW5cIiAvPjtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxUaGVtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3sgdGhlbWUsIHNldFRoZW1lIH19PlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17dGhlbWUgPT09ICdkYXJrJyA/ICdkYXJrIGZsZXggZmxleC1jb2wgbWluLWgtc2NyZWVuIGJnLVsjMTExXSB0ZXh0LVsjZmZmXScgOiAnZmxleCBmbGV4LWNvbCBtaW4taC1zY3JlZW4gYmctd2hpdGUgdGV4dC1ncmF5LTkwMCd9PlxyXG4gICAgICAgIDxIZWFkZXIgLz5cclxuICAgICAgICA8bWFpbiBjbGFzc05hbWU9XCJmbGV4LTFcIj57Y2hpbGRyZW59PC9tYWluPlxyXG4gICAgICAgIHsvKiA8Rm9vdGVyIC8+ICovfVxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvVGhlbWVDb250ZXh0LlByb3ZpZGVyPlxyXG4gICk7XHJcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiSGVhZGVyIiwiVGhlbWVDb250ZXh0IiwidGhlbWUiLCJzZXRUaGVtZSIsInVzZVRoZW1lIiwiSG9tZUxheW91dCIsImNoaWxkcmVuIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImh0bWwiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsInJlbW92ZSIsImRpdiIsImNsYXNzTmFtZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJtYWluIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/home/layout.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/home/page.tsx":
/*!*******************************!*\
  !*** ./src/app/home/page.tsx ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HomePage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_ChartContainer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/ChartContainer */ \"(app-pages-browser)/./src/components/ChartContainer.tsx\");\n/* harmony import */ var _components_TimeframeSelector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/TimeframeSelector */ \"(app-pages-browser)/./src/components/TimeframeSelector.tsx\");\n/* harmony import */ var _components_IndicatorToggle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/IndicatorToggle */ \"(app-pages-browser)/./src/components/IndicatorToggle.tsx\");\n/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./layout */ \"(app-pages-browser)/./src/app/home/layout.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction HomePage() {\n    _s();\n    const { theme } = (0,_layout__WEBPACK_IMPORTED_MODULE_5__.useTheme)();\n    const [timeframe, setTimeframe] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('1m');\n    const [indicators, setIndicators] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        rsi: false,\n        macd: false,\n        ema: false,\n        sma: false\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"container mx-auto px-2 py-4 max-w-5xl\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col md:flex-row md:items-center md:justify-between gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-col sm:flex-row gap-2 items-center justify-start\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_TimeframeSelector__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                            value: timeframe,\n                            onChange: setTimeframe\n                        }, void 0, false, {\n                            fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\page.tsx\",\n                            lineNumber: 17,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_IndicatorToggle__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                            value: indicators,\n                            onChange: setIndicators\n                        }, void 0, false, {\n                            fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\page.tsx\",\n                            lineNumber: 18,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\page.tsx\",\n                    lineNumber: 16,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\page.tsx\",\n                lineNumber: 15,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ChartContainer__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                theme: theme,\n                timeframe: timeframe,\n                indicators: indicators\n            }, void 0, false, {\n                fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\page.tsx\",\n                lineNumber: 21,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\app\\\\home\\\\page.tsx\",\n        lineNumber: 14,\n        columnNumber: 5\n    }, this);\n}\n_s(HomePage, \"/St5iVoMMTPW8/NKheXriTUgpQA=\", false, function() {\n    return [\n        _layout__WEBPACK_IMPORTED_MODULE_5__.useTheme\n    ];\n});\n_c = HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvaG9tZS9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQ3dDO0FBQ3FCO0FBQ007QUFDSjtBQUMzQjtBQUVyQixTQUFTTTs7SUFDdEIsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR0YsaURBQVFBO0lBQzFCLE1BQU0sQ0FBQ0csV0FBV0MsYUFBYSxHQUFHUiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNTLFlBQVlDLGNBQWMsR0FBR1YsK0NBQVFBLENBQUM7UUFBRVcsS0FBSztRQUFPQyxNQUFNO1FBQU9DLEtBQUs7UUFBT0MsS0FBSztJQUFNO0lBRS9GLHFCQUNFLDhEQUFDQztRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0Q7Z0JBQUlDLFdBQVU7MEJBQ2IsNEVBQUNEO29CQUFJQyxXQUFVOztzQ0FDYiw4REFBQ2QscUVBQWlCQTs0QkFBQ2UsT0FBT1Y7NEJBQVdXLFVBQVVWOzs7Ozs7c0NBQy9DLDhEQUFDTCxtRUFBZUE7NEJBQUNjLE9BQU9SOzRCQUFZUyxVQUFVUjs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBR2xELDhEQUFDVCxrRUFBY0E7Z0JBQUNLLE9BQU9BO2dCQUFPQyxXQUFXQTtnQkFBV0UsWUFBWUE7Ozs7Ozs7Ozs7OztBQUd0RTtHQWhCd0JKOztRQUNKRCw2Q0FBUUE7OztLQURKQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxzcmNcXGFwcFxcaG9tZVxccGFnZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IENoYXJ0Q29udGFpbmVyIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvQ2hhcnRDb250YWluZXInO1xyXG5pbXBvcnQgVGltZWZyYW1lU2VsZWN0b3IgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9UaW1lZnJhbWVTZWxlY3Rvcic7XHJcbmltcG9ydCBJbmRpY2F0b3JUb2dnbGUgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9JbmRpY2F0b3JUb2dnbGUnO1xyXG5pbXBvcnQgeyB1c2VUaGVtZSB9IGZyb20gJy4vbGF5b3V0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWVQYWdlKCkge1xyXG4gIGNvbnN0IHsgdGhlbWUgfSA9IHVzZVRoZW1lKCk7XHJcbiAgY29uc3QgW3RpbWVmcmFtZSwgc2V0VGltZWZyYW1lXSA9IHVzZVN0YXRlKCcxbScpO1xyXG4gIGNvbnN0IFtpbmRpY2F0b3JzLCBzZXRJbmRpY2F0b3JzXSA9IHVzZVN0YXRlKHsgcnNpOiBmYWxzZSwgbWFjZDogZmFsc2UsIGVtYTogZmFsc2UsIHNtYTogZmFsc2UgfSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBteC1hdXRvIHB4LTIgcHktNCBtYXgtdy01eGxcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IG1kOml0ZW1zLWNlbnRlciBtZDpqdXN0aWZ5LWJldHdlZW4gZ2FwLTIgbWItNFwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzbTpmbGV4LXJvdyBnYXAtMiBpdGVtcy1jZW50ZXIganVzdGlmeS1zdGFydFwiPlxyXG4gICAgICAgICAgPFRpbWVmcmFtZVNlbGVjdG9yIHZhbHVlPXt0aW1lZnJhbWV9IG9uQ2hhbmdlPXtzZXRUaW1lZnJhbWV9IC8+XHJcbiAgICAgICAgICA8SW5kaWNhdG9yVG9nZ2xlIHZhbHVlPXtpbmRpY2F0b3JzfSBvbkNoYW5nZT17c2V0SW5kaWNhdG9yc30gLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxDaGFydENvbnRhaW5lciB0aGVtZT17dGhlbWV9IHRpbWVmcmFtZT17dGltZWZyYW1lfSBpbmRpY2F0b3JzPXtpbmRpY2F0b3JzfSAvPlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsIkNoYXJ0Q29udGFpbmVyIiwiVGltZWZyYW1lU2VsZWN0b3IiLCJJbmRpY2F0b3JUb2dnbGUiLCJ1c2VUaGVtZSIsIkhvbWVQYWdlIiwidGhlbWUiLCJ0aW1lZnJhbWUiLCJzZXRUaW1lZnJhbWUiLCJpbmRpY2F0b3JzIiwic2V0SW5kaWNhdG9ycyIsInJzaSIsIm1hY2QiLCJlbWEiLCJzbWEiLCJkaXYiLCJjbGFzc05hbWUiLCJ2YWx1ZSIsIm9uQ2hhbmdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/home/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ChartContainer.tsx":
/*!*******************************************!*\
  !*** ./src/components/ChartContainer.tsx ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(app-pages-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n/* harmony import */ var _PriceButtons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PriceButtons */ \"(app-pages-browser)/./src/components/PriceButtons.tsx\");\n/* harmony import */ var _utils_binanceApi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/binanceApi */ \"(app-pages-browser)/./src/utils/binanceApi.ts\");\n/* harmony import */ var _hooks_useIndicators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../hooks/useIndicators */ \"(app-pages-browser)/./src/hooks/useIndicators.ts\");\n/* harmony import */ var _hooks_useBinanceSocket__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../hooks/useBinanceSocket */ \"(app-pages-browser)/./src/hooks/useBinanceSocket.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst ChartContainer = (param)=>{\n    let { theme = 'light', timeframe = '1m', indicators = {} } = param;\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candleSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const volumeSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Indicator series refs\n    const smaSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const emaSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const rsiSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const macdSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // State for chart data\n    const [candles, setCandles] = react__WEBPACK_IMPORTED_MODULE_1___default().useState([]);\n    const [volumes, setVolumes] = react__WEBPACK_IMPORTED_MODULE_1___default().useState([]);\n    // State for price buttons\n    const [currentPrice, setCurrentPrice] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(null);\n    const [price1MinAgo, setPrice1MinAgo] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChartContainer.useEffect\": ()=>{\n            if (!chartContainerRef.current) return;\n            // Remove old chart if exists\n            if (chartRef.current) {\n                try {\n                    chartRef.current.remove();\n                } catch (e) {}\n                chartRef.current = null;\n            }\n            // Reset all series refs to null to avoid 'Object is disposed' errors\n            candleSeriesRef.current = null;\n            volumeSeriesRef.current = null;\n            smaSeriesRef.current = null;\n            emaSeriesRef.current = null;\n            rsiSeriesRef.current = null;\n            macdSeriesRef.current = null;\n            // Dng trc tip prop theme  set mu chart\n            const isDark = theme === 'dark';\n            const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(chartContainerRef.current, {\n                width: chartContainerRef.current.clientWidth,\n                height: 400,\n                layout: {\n                    background: {\n                        color: isDark ? '#111' : '#fff'\n                    },\n                    textColor: isDark ? '#f3f4f6' : '#222'\n                },\n                grid: {\n                    vertLines: {\n                        color: isDark ? '#23262F' : '#eee'\n                    },\n                    horzLines: {\n                        color: isDark ? '#23262F' : '#eee'\n                    }\n                }\n            });\n            chartRef.current = chart;\n            // Candlestick series\n            const candleSeries = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.CandlestickSeries, {\n                upColor: '#26a69a',\n                downColor: '#ef5350',\n                borderVisible: false,\n                wickVisible: true\n            });\n            candleSeriesRef.current = candleSeries;\n            // Volume series (max 30% height)\n            const volumeSeries = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.HistogramSeries, {\n                color: '#26a69a',\n                priceFormat: {\n                    type: 'volume'\n                },\n                priceScaleId: ''\n            });\n            // Set scale margins for volume after creation\n            volumeSeries.priceScale().applyOptions({\n                scaleMargins: {\n                    top: 0.7,\n                    bottom: 0\n                }\n            });\n            volumeSeriesRef.current = volumeSeries;\n            // Responsive resize\n            const handleResize = {\n                \"ChartContainer.useEffect.handleResize\": ()=>{\n                    if (chartContainerRef.current) {\n                        chart.applyOptions({\n                            width: chartContainerRef.current.clientWidth\n                        });\n                    }\n                }\n            }[\"ChartContainer.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            return ({\n                \"ChartContainer.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    chart.remove();\n                }\n            })[\"ChartContainer.useEffect\"];\n        }\n    }[\"ChartContainer.useEffect\"], [\n        theme,\n        timeframe\n    ]);\n    // Fetch historical data from Binance REST API (refactored)\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect({\n        \"ChartContainer.useEffect\": ()=>{\n            let ignore = false;\n            async function fetchData() {\n                const data = await (0,_utils_binanceApi__WEBPACK_IMPORTED_MODULE_4__.GetCandles)(timeframe, 'BTCUSDT');\n                if (ignore) return;\n                setCandles(data.map({\n                    \"ChartContainer.useEffect.fetchData\": (c)=>({\n                            time: Math.floor(c.openTime / 1000),\n                            open: c.open,\n                            high: c.high,\n                            low: c.low,\n                            close: c.close\n                        })\n                }[\"ChartContainer.useEffect.fetchData\"]));\n                setVolumes(data.map({\n                    \"ChartContainer.useEffect.fetchData\": (c)=>({\n                            time: Math.floor(c.openTime / 1000),\n                            value: c.volume,\n                            color: c.close > c.open ? '#26a69a' : '#ef5350'\n                        })\n                }[\"ChartContainer.useEffect.fetchData\"]));\n            }\n            fetchData();\n            return ({\n                \"ChartContainer.useEffect\": ()=>{\n                    ignore = true;\n                }\n            })[\"ChartContainer.useEffect\"];\n        }\n    }[\"ChartContainer.useEffect\"], [\n        timeframe\n    ]);\n    // Compute indicators efficiently with useIndicators\n    const closes = candles.map((c)=>c.close);\n    const indicatorData = (0,_hooks_useIndicators__WEBPACK_IMPORTED_MODULE_5__.useIndicators)(closes, indicators);\n    // Real-time streaming from Binance WebSocket (refactored with hook)\n    (0,_hooks_useBinanceSocket__WEBPACK_IMPORTED_MODULE_6__.useBinanceSocket)((0,_utils_binanceApi__WEBPACK_IMPORTED_MODULE_4__.GetLiveCandle)(timeframe, 'BTCUSDT'), {\n        \"ChartContainer.useBinanceSocket\": (k)=>{\n            const time = Math.floor(k.t / 1000);\n            const newCandle = {\n                time,\n                open: +k.o,\n                high: +k.h,\n                low: +k.l,\n                close: +k.c\n            };\n            const newVolume = {\n                time,\n                value: +k.v,\n                color: +k.c > +k.o ? '#26a69a' : '#ef5350'\n            };\n            setCandles({\n                \"ChartContainer.useBinanceSocket\": (prev)=>{\n                    if (!prev.length) return [\n                        newCandle\n                    ];\n                    if (prev[prev.length - 1].time === time) {\n                        return [\n                            ...prev.slice(0, -1),\n                            newCandle\n                        ];\n                    } else if (prev[prev.length - 1].time < time) {\n                        return [\n                            ...prev,\n                            newCandle\n                        ];\n                    }\n                    return prev;\n                }\n            }[\"ChartContainer.useBinanceSocket\"]);\n            setVolumes({\n                \"ChartContainer.useBinanceSocket\": (prev)=>{\n                    if (!prev.length) return [\n                        newVolume\n                    ];\n                    if (prev[prev.length - 1].time === time) {\n                        return [\n                            ...prev.slice(0, -1),\n                            newVolume\n                        ];\n                    } else if (prev[prev.length - 1].time < time) {\n                        return [\n                            ...prev,\n                            newVolume\n                        ];\n                    }\n                    return prev;\n                }\n            }[\"ChartContainer.useBinanceSocket\"]);\n        }\n    }[\"ChartContainer.useBinanceSocket\"]);\n    // Update chart data when candles/volumes change\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect({\n        \"ChartContainer.useEffect\": ()=>{\n            if (candles.length && candleSeriesRef.current) {\n                candleSeriesRef.current.setData(candles);\n            }\n            if (volumes.length && volumeSeriesRef.current) {\n                volumeSeriesRef.current.setData(volumes);\n            }\n        }\n    }[\"ChartContainer.useEffect\"], [\n        candles,\n        volumes\n    ]);\n    // Compute and render indicators when toggled or candles change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChartContainer.useEffect\": ()=>{\n            if (!chartRef.current || !candles.length) return;\n            const chart = chartRef.current;\n            // Remove previous indicator series if exist\n            if (smaSeriesRef.current) {\n                chart.removeSeries(smaSeriesRef.current);\n                smaSeriesRef.current = null;\n            }\n            if (emaSeriesRef.current) {\n                chart.removeSeries(emaSeriesRef.current);\n                emaSeriesRef.current = null;\n            }\n            if (rsiSeriesRef.current) {\n                chart.removeSeries(rsiSeriesRef.current);\n                rsiSeriesRef.current = null;\n            }\n            if (macdSeriesRef.current) {\n                chart.removeSeries(macdSeriesRef.current);\n                macdSeriesRef.current = null;\n            }\n            // Use indicatorData from hook\n            // SMA\n            if (indicatorData.sma) {\n                smaSeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                    color: '#fbbf24',\n                    lineWidth: 2\n                });\n                smaSeriesRef.current.setData(candles.map({\n                    \"ChartContainer.useEffect\": (c, i)=>{\n                        var _indicatorData_sma_i;\n                        return {\n                            time: c.time,\n                            value: (_indicatorData_sma_i = indicatorData.sma[i]) !== null && _indicatorData_sma_i !== void 0 ? _indicatorData_sma_i : null\n                        };\n                    }\n                }[\"ChartContainer.useEffect\"]).filter({\n                    \"ChartContainer.useEffect\": (d)=>d.value !== null\n                }[\"ChartContainer.useEffect\"]));\n            }\n            // EMA\n            if (indicatorData.ema) {\n                emaSeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                    color: '#6366f1',\n                    lineWidth: 2\n                });\n                emaSeriesRef.current.setData(candles.map({\n                    \"ChartContainer.useEffect\": (c, i)=>{\n                        var _indicatorData_ema_i;\n                        return {\n                            time: c.time,\n                            value: (_indicatorData_ema_i = indicatorData.ema[i]) !== null && _indicatorData_ema_i !== void 0 ? _indicatorData_ema_i : null\n                        };\n                    }\n                }[\"ChartContainer.useEffect\"]).filter({\n                    \"ChartContainer.useEffect\": (d)=>d.value !== null\n                }[\"ChartContainer.useEffect\"]));\n            }\n            // RSI (as a separate pane)\n            if (indicatorData.rsi) {\n                rsiSeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                    color: '#10b981',\n                    lineWidth: 2,\n                    priceScaleId: 'rsi'\n                });\n                chart.priceScale('rsi', {\n                    autoScale: true\n                });\n                rsiSeriesRef.current.setData(candles.map({\n                    \"ChartContainer.useEffect\": (c, i)=>{\n                        var _indicatorData_rsi_i;\n                        return {\n                            time: c.time,\n                            value: (_indicatorData_rsi_i = indicatorData.rsi[i]) !== null && _indicatorData_rsi_i !== void 0 ? _indicatorData_rsi_i : null\n                        };\n                    }\n                }[\"ChartContainer.useEffect\"]).filter({\n                    \"ChartContainer.useEffect\": (d)=>d.value !== null\n                }[\"ChartContainer.useEffect\"]));\n            }\n            // MACD (as a separate pane)\n            if (indicatorData.macd) {\n                macdSeriesRef.current = chart.addSeries(lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineSeries, {\n                    color: '#f43f5e',\n                    lineWidth: 2,\n                    priceScaleId: 'macd'\n                });\n                chart.priceScale('macd', {\n                    autoScale: true\n                });\n                macdSeriesRef.current.setData(candles.map({\n                    \"ChartContainer.useEffect\": (c, i)=>{\n                        var _indicatorData_macd_macd_i;\n                        return {\n                            time: c.time,\n                            value: (_indicatorData_macd_macd_i = indicatorData.macd.macd[i]) !== null && _indicatorData_macd_macd_i !== void 0 ? _indicatorData_macd_macd_i : null\n                        };\n                    }\n                }[\"ChartContainer.useEffect\"]).filter({\n                    \"ChartContainer.useEffect\": (d)=>d.value !== null\n                }[\"ChartContainer.useEffect\"]));\n            // Optionally, add signal/histogram as well\n            }\n        }\n    }[\"ChartContainer.useEffect\"], [\n        indicatorData,\n        candles\n    ]);\n    // Handlers for price fetch buttons\n    const handleFetchCurrentPrice = ()=>{\n        if (candles.length) {\n            setCurrentPrice(candles[candles.length - 1].close);\n        }\n    };\n    const handleFetchPrice1MinAgo = ()=>{\n        if (candles.length > 1) {\n            setPrice1MinAgo(candles[candles.length - 2].close);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: chartContainerRef,\n        className: \"w-full min-h-[300px] max-h-[80vh] relative flex flex-col bg-white dark:bg-[#111] text-gray-900 dark:text-gray-100 rounded-lg shadow-md overflow-hidden md:h-[500px] lg:h-[600px]\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_PriceButtons__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n            currentPrice: currentPrice,\n            price1MinAgo: price1MinAgo,\n            onFetchCurrentPrice: handleFetchCurrentPrice,\n            onFetchPrice1MinAgo: handleFetchPrice1MinAgo\n        }, void 0, false, {\n            fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\ChartContainer.tsx\",\n            lineNumber: 219,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\ChartContainer.tsx\",\n        lineNumber: 218,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ChartContainer, \"UPhgWobC5v+c83HK1rD0IrOvSz8=\", false, function() {\n    return [\n        _hooks_useIndicators__WEBPACK_IMPORTED_MODULE_5__.useIndicators,\n        _hooks_useBinanceSocket__WEBPACK_IMPORTED_MODULE_6__.useBinanceSocket\n    ];\n});\n_c = ChartContainer;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChartContainer);\nvar _c;\n$RefreshReg$(_c, \"ChartContainer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0Q29udGFpbmVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUVpRDtBQUNnRDtBQUN2RDtBQUNzQjtBQUNUO0FBQ007QUFRN0QsTUFBTVksaUJBQWdEO1FBQUMsRUFBRUMsUUFBUSxPQUFPLEVBQUVDLFlBQVksSUFBSSxFQUFFQyxhQUFhLENBQUMsQ0FBQyxFQUFFOztJQUMzRyxNQUFNQyxvQkFBb0JkLDZDQUFNQSxDQUFpQjtJQUNqRCxNQUFNZSxXQUFXZiw2Q0FBTUEsQ0FBTTtJQUM3QixNQUFNZ0Isa0JBQWtCaEIsNkNBQU1BLENBQU07SUFDcEMsTUFBTWlCLGtCQUFrQmpCLDZDQUFNQSxDQUFNO0lBQ3BDLHdCQUF3QjtJQUN4QixNQUFNa0IsZUFBZWxCLDZDQUFNQSxDQUFNO0lBQ2pDLE1BQU1tQixlQUFlbkIsNkNBQU1BLENBQU07SUFDakMsTUFBTW9CLGVBQWVwQiw2Q0FBTUEsQ0FBTTtJQUNqQyxNQUFNcUIsZ0JBQWdCckIsNkNBQU1BLENBQU07SUFFbEMsdUJBQXVCO0lBQ3ZCLE1BQU0sQ0FBQ3NCLFNBQVNDLFdBQVcsR0FBR3pCLHFEQUFjLENBQVEsRUFBRTtJQUN0RCxNQUFNLENBQUMyQixTQUFTQyxXQUFXLEdBQUc1QixxREFBYyxDQUFRLEVBQUU7SUFFdEQsMEJBQTBCO0lBQzFCLE1BQU0sQ0FBQzZCLGNBQWNDLGdCQUFnQixHQUFHOUIscURBQWMsQ0FBZ0I7SUFDdEUsTUFBTSxDQUFDK0IsY0FBY0MsZ0JBQWdCLEdBQUdoQyxxREFBYyxDQUFnQjtJQUV0RUMsZ0RBQVNBO29DQUFDO1lBQ1IsSUFBSSxDQUFDZSxrQkFBa0JpQixPQUFPLEVBQUU7WUFDaEMsNkJBQTZCO1lBQzdCLElBQUloQixTQUFTZ0IsT0FBTyxFQUFFO2dCQUNwQixJQUFJO29CQUNGaEIsU0FBU2dCLE9BQU8sQ0FBQ0MsTUFBTTtnQkFDekIsRUFBRSxPQUFPQyxHQUFHLENBQUM7Z0JBQ2JsQixTQUFTZ0IsT0FBTyxHQUFHO1lBQ3JCO1lBQ0EscUVBQXFFO1lBQ3JFZixnQkFBZ0JlLE9BQU8sR0FBRztZQUMxQmQsZ0JBQWdCYyxPQUFPLEdBQUc7WUFDMUJiLGFBQWFhLE9BQU8sR0FBRztZQUN2QlosYUFBYVksT0FBTyxHQUFHO1lBQ3ZCWCxhQUFhVyxPQUFPLEdBQUc7WUFDdkJWLGNBQWNVLE9BQU8sR0FBRztZQUV4Qiw2Q0FBNkM7WUFDN0MsTUFBTUcsU0FBU3ZCLFVBQVU7WUFDekIsTUFBTXdCLFFBQVFsQywrREFBV0EsQ0FBQ2Esa0JBQWtCaUIsT0FBTyxFQUFFO2dCQUNuREssT0FBT3RCLGtCQUFrQmlCLE9BQU8sQ0FBQ00sV0FBVztnQkFDNUNDLFFBQVE7Z0JBQ1JDLFFBQVE7b0JBQ05DLFlBQVk7d0JBQUVDLE9BQU9QLFNBQVMsU0FBUztvQkFBTztvQkFDOUNRLFdBQVdSLFNBQVMsWUFBWTtnQkFDbEM7Z0JBQ0FTLE1BQU07b0JBQUVDLFdBQVc7d0JBQUVILE9BQU9QLFNBQVMsWUFBWTtvQkFBTztvQkFBR1csV0FBVzt3QkFBRUosT0FBT1AsU0FBUyxZQUFZO29CQUFPO2dCQUFFO1lBQy9HO1lBQ0FuQixTQUFTZ0IsT0FBTyxHQUFHSTtZQUVuQixxQkFBcUI7WUFDckIsTUFBTVcsZUFBZVgsTUFBTVksU0FBUyxDQUFDN0MsaUVBQWlCQSxFQUFFO2dCQUN0RDhDLFNBQVM7Z0JBQ1RDLFdBQVc7Z0JBQ1hDLGVBQWU7Z0JBQ2ZDLGFBQWE7WUFDZjtZQUNBbkMsZ0JBQWdCZSxPQUFPLEdBQUdlO1lBQzFCLGlDQUFpQztZQUNqQyxNQUFNTSxlQUFlakIsTUFBTVksU0FBUyxDQUFDNUMsK0RBQWVBLEVBQUU7Z0JBQ3BEc0MsT0FBTztnQkFDUFksYUFBYTtvQkFBRUMsTUFBTTtnQkFBUztnQkFDOUJDLGNBQWM7WUFDaEI7WUFDQSw4Q0FBOEM7WUFDOUNILGFBQWFJLFVBQVUsR0FBR0MsWUFBWSxDQUFDO2dCQUFFQyxjQUFjO29CQUFFQyxLQUFLO29CQUFLQyxRQUFRO2dCQUFFO1lBQUU7WUFDL0UzQyxnQkFBZ0JjLE9BQU8sR0FBR3FCO1lBRTFCLG9CQUFvQjtZQUNwQixNQUFNUzt5REFBZTtvQkFDbkIsSUFBSS9DLGtCQUFrQmlCLE9BQU8sRUFBRTt3QkFDN0JJLE1BQU1zQixZQUFZLENBQUM7NEJBQUVyQixPQUFPdEIsa0JBQWtCaUIsT0FBTyxDQUFDTSxXQUFXO3dCQUFDO29CQUNwRTtnQkFDRjs7WUFDQXlCLE9BQU9DLGdCQUFnQixDQUFDLFVBQVVGO1lBRWxDOzRDQUFPO29CQUNMQyxPQUFPRSxtQkFBbUIsQ0FBQyxVQUFVSDtvQkFDckMxQixNQUFNSCxNQUFNO2dCQUNkOztRQUNGO21DQUFHO1FBQUNyQjtRQUFPQztLQUFVO0lBRXJCLDJEQUEyRDtJQUMzRGQsc0RBQWU7b0NBQUM7WUFDZCxJQUFJbUUsU0FBUztZQUNiLGVBQWVDO2dCQUNiLE1BQU1DLE9BQU8sTUFBTTdELDZEQUFVQSxDQUFDTSxXQUFXO2dCQUN6QyxJQUFJcUQsUUFBUTtnQkFDWjFDLFdBQVc0QyxLQUFLQyxHQUFHOzBEQUFDQyxDQUFBQSxJQUFNOzRCQUN4QkMsTUFBTUMsS0FBS0MsS0FBSyxDQUFDSCxFQUFFSSxRQUFRLEdBQUc7NEJBQzlCQyxNQUFNTCxFQUFFSyxJQUFJOzRCQUNaQyxNQUFNTixFQUFFTSxJQUFJOzRCQUNaQyxLQUFLUCxFQUFFTyxHQUFHOzRCQUNWQyxPQUFPUixFQUFFUSxLQUFLO3dCQUNoQjs7Z0JBQ0FuRCxXQUFXeUMsS0FBS0MsR0FBRzswREFBQ0MsQ0FBQUEsSUFBTTs0QkFDeEJDLE1BQU1DLEtBQUtDLEtBQUssQ0FBQ0gsRUFBRUksUUFBUSxHQUFHOzRCQUM5QkssT0FBT1QsRUFBRVUsTUFBTTs0QkFDZnRDLE9BQU80QixFQUFFUSxLQUFLLEdBQUdSLEVBQUVLLElBQUksR0FBRyxZQUFZO3dCQUN4Qzs7WUFDRjtZQUNBUjtZQUNBOzRDQUFPO29CQUFRRCxTQUFTO2dCQUFNOztRQUNoQzttQ0FBRztRQUFDckQ7S0FBVTtJQUVkLG9EQUFvRDtJQUNwRCxNQUFNb0UsU0FBUzFELFFBQVE4QyxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVRLEtBQUs7SUFDdkMsTUFBTUksZ0JBQWdCekUsbUVBQWFBLENBQUN3RSxRQUFRbkU7SUFFNUMsb0VBQW9FO0lBQ3BFSix5RUFBZ0JBLENBQUNGLGdFQUFhQSxDQUFDSyxXQUFXOzJDQUFZLENBQUNzRTtZQUNyRCxNQUFNWixPQUFPQyxLQUFLQyxLQUFLLENBQUNVLEVBQUVDLENBQUMsR0FBRztZQUM5QixNQUFNQyxZQUFZO2dCQUNoQmQ7Z0JBQ0FJLE1BQU0sQ0FBQ1EsRUFBRUcsQ0FBQztnQkFDVlYsTUFBTSxDQUFDTyxFQUFFSSxDQUFDO2dCQUNWVixLQUFLLENBQUNNLEVBQUVLLENBQUM7Z0JBQ1RWLE9BQU8sQ0FBQ0ssRUFBRWIsQ0FBQztZQUNiO1lBQ0EsTUFBTW1CLFlBQVk7Z0JBQ2hCbEI7Z0JBQ0FRLE9BQU8sQ0FBQ0ksRUFBRU8sQ0FBQztnQkFDWGhELE9BQU8sQ0FBQ3lDLEVBQUViLENBQUMsR0FBRyxDQUFDYSxFQUFFRyxDQUFDLEdBQUcsWUFBWTtZQUNuQztZQUNBOUQ7bURBQVcsQ0FBQ21FO29CQUNWLElBQUksQ0FBQ0EsS0FBS0MsTUFBTSxFQUFFLE9BQU87d0JBQUNQO3FCQUFVO29CQUNwQyxJQUFJTSxJQUFJLENBQUNBLEtBQUtDLE1BQU0sR0FBRyxFQUFFLENBQUNyQixJQUFJLEtBQUtBLE1BQU07d0JBQ3ZDLE9BQU87K0JBQUlvQixLQUFLRSxLQUFLLENBQUMsR0FBRyxDQUFDOzRCQUFJUjt5QkFBVTtvQkFDMUMsT0FBTyxJQUFJTSxJQUFJLENBQUNBLEtBQUtDLE1BQU0sR0FBRyxFQUFFLENBQUNyQixJQUFJLEdBQUdBLE1BQU07d0JBQzVDLE9BQU87K0JBQUlvQjs0QkFBTU47eUJBQVU7b0JBQzdCO29CQUNBLE9BQU9NO2dCQUNUOztZQUNBaEU7bURBQVcsQ0FBQ2dFO29CQUNWLElBQUksQ0FBQ0EsS0FBS0MsTUFBTSxFQUFFLE9BQU87d0JBQUNIO3FCQUFVO29CQUNwQyxJQUFJRSxJQUFJLENBQUNBLEtBQUtDLE1BQU0sR0FBRyxFQUFFLENBQUNyQixJQUFJLEtBQUtBLE1BQU07d0JBQ3ZDLE9BQU87K0JBQUlvQixLQUFLRSxLQUFLLENBQUMsR0FBRyxDQUFDOzRCQUFJSjt5QkFBVTtvQkFDMUMsT0FBTyxJQUFJRSxJQUFJLENBQUNBLEtBQUtDLE1BQU0sR0FBRyxFQUFFLENBQUNyQixJQUFJLEdBQUdBLE1BQU07d0JBQzVDLE9BQU87K0JBQUlvQjs0QkFBTUY7eUJBQVU7b0JBQzdCO29CQUNBLE9BQU9FO2dCQUNUOztRQUNGOztJQUVBLGdEQUFnRDtJQUNoRDVGLHNEQUFlO29DQUFDO1lBQ2QsSUFBSXdCLFFBQVFxRSxNQUFNLElBQUkzRSxnQkFBZ0JlLE9BQU8sRUFBRTtnQkFDN0NmLGdCQUFnQmUsT0FBTyxDQUFDOEQsT0FBTyxDQUFDdkU7WUFDbEM7WUFDQSxJQUFJRyxRQUFRa0UsTUFBTSxJQUFJMUUsZ0JBQWdCYyxPQUFPLEVBQUU7Z0JBQzdDZCxnQkFBZ0JjLE9BQU8sQ0FBQzhELE9BQU8sQ0FBQ3BFO1lBQ2xDO1FBQ0Y7bUNBQUc7UUFBQ0g7UUFBU0c7S0FBUTtJQUVyQiwrREFBK0Q7SUFDL0QxQixnREFBU0E7b0NBQUM7WUFDUixJQUFJLENBQUNnQixTQUFTZ0IsT0FBTyxJQUFJLENBQUNULFFBQVFxRSxNQUFNLEVBQUU7WUFDMUMsTUFBTXhELFFBQVFwQixTQUFTZ0IsT0FBTztZQUM5Qiw0Q0FBNEM7WUFDNUMsSUFBSWIsYUFBYWEsT0FBTyxFQUFFO2dCQUFFSSxNQUFNMkQsWUFBWSxDQUFDNUUsYUFBYWEsT0FBTztnQkFBR2IsYUFBYWEsT0FBTyxHQUFHO1lBQU07WUFDbkcsSUFBSVosYUFBYVksT0FBTyxFQUFFO2dCQUFFSSxNQUFNMkQsWUFBWSxDQUFDM0UsYUFBYVksT0FBTztnQkFBR1osYUFBYVksT0FBTyxHQUFHO1lBQU07WUFDbkcsSUFBSVgsYUFBYVcsT0FBTyxFQUFFO2dCQUFFSSxNQUFNMkQsWUFBWSxDQUFDMUUsYUFBYVcsT0FBTztnQkFBR1gsYUFBYVcsT0FBTyxHQUFHO1lBQU07WUFDbkcsSUFBSVYsY0FBY1UsT0FBTyxFQUFFO2dCQUFFSSxNQUFNMkQsWUFBWSxDQUFDekUsY0FBY1UsT0FBTztnQkFBR1YsY0FBY1UsT0FBTyxHQUFHO1lBQU07WUFFdEcsOEJBQThCO1lBQzlCLE1BQU07WUFDTixJQUFJa0QsY0FBY2MsR0FBRyxFQUFFO2dCQUNyQjdFLGFBQWFhLE9BQU8sR0FBR0ksTUFBTVksU0FBUyxDQUFDM0MsMERBQVVBLEVBQUU7b0JBQUVxQyxPQUFPO29CQUFXdUQsV0FBVztnQkFBRTtnQkFDcEY5RSxhQUFhYSxPQUFPLENBQUM4RCxPQUFPLENBQUN2RSxRQUFROEMsR0FBRztnREFBQyxDQUFDQyxHQUFHNEI7NEJBQThCaEI7K0JBQXZCOzRCQUFFWCxNQUFNRCxFQUFFQyxJQUFJOzRCQUFFUSxPQUFPRyxDQUFBQSx1QkFBQUEsY0FBY2MsR0FBRyxDQUFDRSxFQUFFLGNBQXBCaEIsa0NBQUFBLHVCQUF3Qjt3QkFBSzs7K0NBQUlpQixNQUFNO2dEQUFDQyxDQUFBQSxJQUFLQSxFQUFFckIsS0FBSyxLQUFLOztZQUN0STtZQUNBLE1BQU07WUFDTixJQUFJRyxjQUFjbUIsR0FBRyxFQUFFO2dCQUNyQmpGLGFBQWFZLE9BQU8sR0FBR0ksTUFBTVksU0FBUyxDQUFDM0MsMERBQVVBLEVBQUU7b0JBQUVxQyxPQUFPO29CQUFXdUQsV0FBVztnQkFBRTtnQkFDcEY3RSxhQUFhWSxPQUFPLENBQUM4RCxPQUFPLENBQUN2RSxRQUFROEMsR0FBRztnREFBQyxDQUFDQyxHQUFHNEI7NEJBQThCaEI7K0JBQXZCOzRCQUFFWCxNQUFNRCxFQUFFQyxJQUFJOzRCQUFFUSxPQUFPRyxDQUFBQSx1QkFBQUEsY0FBY21CLEdBQUcsQ0FBQ0gsRUFBRSxjQUFwQmhCLGtDQUFBQSx1QkFBd0I7d0JBQUs7OytDQUFJaUIsTUFBTTtnREFBQ0MsQ0FBQUEsSUFBS0EsRUFBRXJCLEtBQUssS0FBSzs7WUFDdEk7WUFDQSwyQkFBMkI7WUFDM0IsSUFBSUcsY0FBY29CLEdBQUcsRUFBRTtnQkFDckJqRixhQUFhVyxPQUFPLEdBQUdJLE1BQU1ZLFNBQVMsQ0FBQzNDLDBEQUFVQSxFQUFFO29CQUFFcUMsT0FBTztvQkFBV3VELFdBQVc7b0JBQUd6QyxjQUFjO2dCQUFNO2dCQUN6R3BCLE1BQU1xQixVQUFVLENBQUMsT0FBTztvQkFBRThDLFdBQVc7Z0JBQUs7Z0JBQzFDbEYsYUFBYVcsT0FBTyxDQUFDOEQsT0FBTyxDQUFDdkUsUUFBUThDLEdBQUc7Z0RBQUMsQ0FBQ0MsR0FBRzRCOzRCQUE4QmhCOytCQUF2Qjs0QkFBRVgsTUFBTUQsRUFBRUMsSUFBSTs0QkFBRVEsT0FBT0csQ0FBQUEsdUJBQUFBLGNBQWNvQixHQUFHLENBQUNKLEVBQUUsY0FBcEJoQixrQ0FBQUEsdUJBQXdCO3dCQUFLOzsrQ0FBSWlCLE1BQU07Z0RBQUNDLENBQUFBLElBQUtBLEVBQUVyQixLQUFLLEtBQUs7O1lBQ3RJO1lBQ0EsNEJBQTRCO1lBQzVCLElBQUlHLGNBQWNzQixJQUFJLEVBQUU7Z0JBQ3RCbEYsY0FBY1UsT0FBTyxHQUFHSSxNQUFNWSxTQUFTLENBQUMzQywwREFBVUEsRUFBRTtvQkFBRXFDLE9BQU87b0JBQVd1RCxXQUFXO29CQUFHekMsY0FBYztnQkFBTztnQkFDM0dwQixNQUFNcUIsVUFBVSxDQUFDLFFBQVE7b0JBQUU4QyxXQUFXO2dCQUFLO2dCQUMzQ2pGLGNBQWNVLE9BQU8sQ0FBQzhELE9BQU8sQ0FBQ3ZFLFFBQVE4QyxHQUFHO2dEQUFDLENBQUNDLEdBQUc0Qjs0QkFBOEJoQjsrQkFBdkI7NEJBQUVYLE1BQU1ELEVBQUVDLElBQUk7NEJBQUVRLE9BQU9HLENBQUFBLDZCQUFBQSxjQUFjc0IsSUFBSSxDQUFDQSxJQUFJLENBQUNOLEVBQUUsY0FBMUJoQix3Q0FBQUEsNkJBQThCO3dCQUFLOzsrQ0FBSWlCLE1BQU07Z0RBQUNDLENBQUFBLElBQUtBLEVBQUVyQixLQUFLLEtBQUs7O1lBQzNJLDJDQUEyQztZQUM3QztRQUNGO21DQUFHO1FBQUNHO1FBQWUzRDtLQUFRO0lBRTNCLG1DQUFtQztJQUNuQyxNQUFNa0YsMEJBQTBCO1FBQzlCLElBQUlsRixRQUFRcUUsTUFBTSxFQUFFO1lBQ2xCL0QsZ0JBQWdCTixPQUFPLENBQUNBLFFBQVFxRSxNQUFNLEdBQUcsRUFBRSxDQUFDZCxLQUFLO1FBQ25EO0lBQ0Y7SUFDQSxNQUFNNEIsMEJBQTBCO1FBQzlCLElBQUluRixRQUFRcUUsTUFBTSxHQUFHLEdBQUc7WUFDdEI3RCxnQkFBZ0JSLE9BQU8sQ0FBQ0EsUUFBUXFFLE1BQU0sR0FBRyxFQUFFLENBQUNkLEtBQUs7UUFDbkQ7SUFDRjtJQUVBLHFCQUNFLDhEQUFDNkI7UUFBSUMsS0FBSzdGO1FBQW1COEYsV0FBVTtrQkFDckMsNEVBQUN2RyxxREFBWUE7WUFDWHNCLGNBQWNBO1lBQ2RFLGNBQWNBO1lBQ2RnRixxQkFBcUJMO1lBQ3JCTSxxQkFBcUJMOzs7Ozs7Ozs7OztBQUk3QjtHQW5OTS9GOztRQTBHa0JGLCtEQUFhQTtRQUduQ0MscUVBQWdCQTs7O0tBN0daQztBQXFOTixpRUFBZUEsY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxzcmNcXGNvbXBvbmVudHNcXENoYXJ0Q29udGFpbmVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUNoYXJ0LCBDYW5kbGVzdGlja1NlcmllcywgSGlzdG9ncmFtU2VyaWVzLCBMaW5lU2VyaWVzIH0gZnJvbSAnbGlnaHR3ZWlnaHQtY2hhcnRzJztcbmltcG9ydCBQcmljZUJ1dHRvbnMgZnJvbSAnLi9QcmljZUJ1dHRvbnMnO1xuaW1wb3J0IHsgR2V0Q2FuZGxlcywgR2V0TGl2ZUNhbmRsZSB9IGZyb20gJy4uL3V0aWxzL2JpbmFuY2VBcGknO1xuaW1wb3J0IHsgdXNlSW5kaWNhdG9ycyB9IGZyb20gJy4uL2hvb2tzL3VzZUluZGljYXRvcnMnO1xuaW1wb3J0IHsgdXNlQmluYW5jZVNvY2tldCB9IGZyb20gJy4uL2hvb2tzL3VzZUJpbmFuY2VTb2NrZXQnO1xuXG5pbnRlcmZhY2UgQ2hhcnRDb250YWluZXJQcm9wcyB7XG4gIHRoZW1lPzogJ2xpZ2h0JyB8ICdkYXJrJztcbiAgdGltZWZyYW1lPzogc3RyaW5nO1xuICBpbmRpY2F0b3JzPzogeyByc2k/OiBib29sZWFuOyBtYWNkPzogYm9vbGVhbjsgZW1hPzogYm9vbGVhbjsgc21hPzogYm9vbGVhbiB9O1xufVxuXG5jb25zdCBDaGFydENvbnRhaW5lcjogUmVhY3QuRkM8Q2hhcnRDb250YWluZXJQcm9wcz4gPSAoeyB0aGVtZSA9ICdsaWdodCcsIHRpbWVmcmFtZSA9ICcxbScsIGluZGljYXRvcnMgPSB7fSB9KSA9PiB7XG4gIGNvbnN0IGNoYXJ0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgY2FuZGxlU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIGNvbnN0IHZvbHVtZVNlcmllc1JlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xuICAvLyBJbmRpY2F0b3Igc2VyaWVzIHJlZnNcbiAgY29uc3Qgc21hU2VyaWVzUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIGNvbnN0IGVtYVNlcmllc1JlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xuICBjb25zdCByc2lTZXJpZXNSZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgY29uc3QgbWFjZFNlcmllc1JlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xuXG4gIC8vIFN0YXRlIGZvciBjaGFydCBkYXRhXG4gIGNvbnN0IFtjYW5kbGVzLCBzZXRDYW5kbGVzXSA9IFJlYWN0LnVzZVN0YXRlPGFueVtdPihbXSk7XG4gIGNvbnN0IFt2b2x1bWVzLCBzZXRWb2x1bWVzXSA9IFJlYWN0LnVzZVN0YXRlPGFueVtdPihbXSk7XG5cbiAgLy8gU3RhdGUgZm9yIHByaWNlIGJ1dHRvbnNcbiAgY29uc3QgW2N1cnJlbnRQcmljZSwgc2V0Q3VycmVudFByaWNlXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbcHJpY2UxTWluQWdvLCBzZXRQcmljZTFNaW5BZ29dID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAvLyBSZW1vdmUgb2xkIGNoYXJ0IGlmIGV4aXN0c1xuICAgIGlmIChjaGFydFJlZi5jdXJyZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjaGFydFJlZi5jdXJyZW50LnJlbW92ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBSZXNldCBhbGwgc2VyaWVzIHJlZnMgdG8gbnVsbCB0byBhdm9pZCAnT2JqZWN0IGlzIGRpc3Bvc2VkJyBlcnJvcnNcbiAgICBjYW5kbGVTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgdm9sdW1lU2VyaWVzUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIHNtYVNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICBlbWFTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgcnNpU2VyaWVzUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIG1hY2RTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XG5cbiAgICAvLyBEw7luZyB0cuG7sWMgdGnhur9wIHByb3AgdGhlbWUgxJHhu4Mgc2V0IG3DoHUgY2hhcnRcbiAgICBjb25zdCBpc0RhcmsgPSB0aGVtZSA9PT0gJ2RhcmsnO1xuICAgIGNvbnN0IGNoYXJ0ID0gY3JlYXRlQ2hhcnQoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCwge1xuICAgICAgd2lkdGg6IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IDQwMCxcbiAgICAgIGxheW91dDoge1xuICAgICAgICBiYWNrZ3JvdW5kOiB7IGNvbG9yOiBpc0RhcmsgPyAnIzExMScgOiAnI2ZmZicgfSxcbiAgICAgICAgdGV4dENvbG9yOiBpc0RhcmsgPyAnI2YzZjRmNicgOiAnIzIyMicsXG4gICAgICB9LFxuICAgICAgZ3JpZDogeyB2ZXJ0TGluZXM6IHsgY29sb3I6IGlzRGFyayA/ICcjMjMyNjJGJyA6ICcjZWVlJyB9LCBob3J6TGluZXM6IHsgY29sb3I6IGlzRGFyayA/ICcjMjMyNjJGJyA6ICcjZWVlJyB9IH0sXG4gICAgfSk7XG4gICAgY2hhcnRSZWYuY3VycmVudCA9IGNoYXJ0O1xuXG4gICAgLy8gQ2FuZGxlc3RpY2sgc2VyaWVzXG4gICAgY29uc3QgY2FuZGxlU2VyaWVzID0gY2hhcnQuYWRkU2VyaWVzKENhbmRsZXN0aWNrU2VyaWVzLCB7XG4gICAgICB1cENvbG9yOiAnIzI2YTY5YScsXG4gICAgICBkb3duQ29sb3I6ICcjZWY1MzUwJyxcbiAgICAgIGJvcmRlclZpc2libGU6IGZhbHNlLFxuICAgICAgd2lja1Zpc2libGU6IHRydWUsXG4gICAgfSk7XG4gICAgY2FuZGxlU2VyaWVzUmVmLmN1cnJlbnQgPSBjYW5kbGVTZXJpZXM7XG4gICAgLy8gVm9sdW1lIHNlcmllcyAobWF4IDMwJSBoZWlnaHQpXG4gICAgY29uc3Qgdm9sdW1lU2VyaWVzID0gY2hhcnQuYWRkU2VyaWVzKEhpc3RvZ3JhbVNlcmllcywge1xuICAgICAgY29sb3I6ICcjMjZhNjlhJyxcbiAgICAgIHByaWNlRm9ybWF0OiB7IHR5cGU6ICd2b2x1bWUnIH0sXG4gICAgICBwcmljZVNjYWxlSWQ6ICcnLFxuICAgIH0pO1xuICAgIC8vIFNldCBzY2FsZSBtYXJnaW5zIGZvciB2b2x1bWUgYWZ0ZXIgY3JlYXRpb25cbiAgICB2b2x1bWVTZXJpZXMucHJpY2VTY2FsZSgpLmFwcGx5T3B0aW9ucyh7IHNjYWxlTWFyZ2luczogeyB0b3A6IDAuNywgYm90dG9tOiAwIH0gfSk7XG4gICAgdm9sdW1lU2VyaWVzUmVmLmN1cnJlbnQgPSB2b2x1bWVTZXJpZXM7XG5cbiAgICAvLyBSZXNwb25zaXZlIHJlc2l6ZVxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmIChjaGFydENvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNoYXJ0LmFwcGx5T3B0aW9ucyh7IHdpZHRoOiBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudFdpZHRoIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBjaGFydC5yZW1vdmUoKTtcbiAgICB9O1xuICB9LCBbdGhlbWUsIHRpbWVmcmFtZV0pO1xuXG4gIC8vIEZldGNoIGhpc3RvcmljYWwgZGF0YSBmcm9tIEJpbmFuY2UgUkVTVCBBUEkgKHJlZmFjdG9yZWQpXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlnbm9yZSA9IGZhbHNlO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBHZXRDYW5kbGVzKHRpbWVmcmFtZSwgJ0JUQ1VTRFQnKTtcbiAgICAgIGlmIChpZ25vcmUpIHJldHVybjtcbiAgICAgIHNldENhbmRsZXMoZGF0YS5tYXAoYyA9PiAoe1xuICAgICAgICB0aW1lOiBNYXRoLmZsb29yKGMub3BlblRpbWUgLyAxMDAwKSxcbiAgICAgICAgb3BlbjogYy5vcGVuLFxuICAgICAgICBoaWdoOiBjLmhpZ2gsXG4gICAgICAgIGxvdzogYy5sb3csXG4gICAgICAgIGNsb3NlOiBjLmNsb3NlLFxuICAgICAgfSkpKTtcbiAgICAgIHNldFZvbHVtZXMoZGF0YS5tYXAoYyA9PiAoe1xuICAgICAgICB0aW1lOiBNYXRoLmZsb29yKGMub3BlblRpbWUgLyAxMDAwKSxcbiAgICAgICAgdmFsdWU6IGMudm9sdW1lLFxuICAgICAgICBjb2xvcjogYy5jbG9zZSA+IGMub3BlbiA/ICcjMjZhNjlhJyA6ICcjZWY1MzUwJyxcbiAgICAgIH0pKSk7XG4gICAgfVxuICAgIGZldGNoRGF0YSgpO1xuICAgIHJldHVybiAoKSA9PiB7IGlnbm9yZSA9IHRydWU7IH07XG4gIH0sIFt0aW1lZnJhbWVdKTtcblxuICAvLyBDb21wdXRlIGluZGljYXRvcnMgZWZmaWNpZW50bHkgd2l0aCB1c2VJbmRpY2F0b3JzXG4gIGNvbnN0IGNsb3NlcyA9IGNhbmRsZXMubWFwKGMgPT4gYy5jbG9zZSk7XG4gIGNvbnN0IGluZGljYXRvckRhdGEgPSB1c2VJbmRpY2F0b3JzKGNsb3NlcywgaW5kaWNhdG9ycyk7XG5cbiAgLy8gUmVhbC10aW1lIHN0cmVhbWluZyBmcm9tIEJpbmFuY2UgV2ViU29ja2V0IChyZWZhY3RvcmVkIHdpdGggaG9vaylcbiAgdXNlQmluYW5jZVNvY2tldChHZXRMaXZlQ2FuZGxlKHRpbWVmcmFtZSwgJ0JUQ1VTRFQnKSwgKGs6IGFueSkgPT4ge1xuICAgIGNvbnN0IHRpbWUgPSBNYXRoLmZsb29yKGsudCAvIDEwMDApO1xuICAgIGNvbnN0IG5ld0NhbmRsZSA9IHtcbiAgICAgIHRpbWUsXG4gICAgICBvcGVuOiAray5vLFxuICAgICAgaGlnaDogK2suaCxcbiAgICAgIGxvdzogK2subCxcbiAgICAgIGNsb3NlOiAray5jLFxuICAgIH07XG4gICAgY29uc3QgbmV3Vm9sdW1lID0ge1xuICAgICAgdGltZSxcbiAgICAgIHZhbHVlOiAray52LFxuICAgICAgY29sb3I6ICtrLmMgPiAray5vID8gJyMyNmE2OWEnIDogJyNlZjUzNTAnLFxuICAgIH07XG4gICAgc2V0Q2FuZGxlcygocHJldikgPT4ge1xuICAgICAgaWYgKCFwcmV2Lmxlbmd0aCkgcmV0dXJuIFtuZXdDYW5kbGVdO1xuICAgICAgaWYgKHByZXZbcHJldi5sZW5ndGggLSAxXS50aW1lID09PSB0aW1lKSB7XG4gICAgICAgIHJldHVybiBbLi4ucHJldi5zbGljZSgwLCAtMSksIG5ld0NhbmRsZV07XG4gICAgICB9IGVsc2UgaWYgKHByZXZbcHJldi5sZW5ndGggLSAxXS50aW1lIDwgdGltZSkge1xuICAgICAgICByZXR1cm4gWy4uLnByZXYsIG5ld0NhbmRsZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9KTtcbiAgICBzZXRWb2x1bWVzKChwcmV2KSA9PiB7XG4gICAgICBpZiAoIXByZXYubGVuZ3RoKSByZXR1cm4gW25ld1ZvbHVtZV07XG4gICAgICBpZiAocHJldltwcmV2Lmxlbmd0aCAtIDFdLnRpbWUgPT09IHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5wcmV2LnNsaWNlKDAsIC0xKSwgbmV3Vm9sdW1lXTtcbiAgICAgIH0gZWxzZSBpZiAocHJldltwcmV2Lmxlbmd0aCAtIDFdLnRpbWUgPCB0aW1lKSB7XG4gICAgICAgIHJldHVybiBbLi4ucHJldiwgbmV3Vm9sdW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBVcGRhdGUgY2hhcnQgZGF0YSB3aGVuIGNhbmRsZXMvdm9sdW1lcyBjaGFuZ2VcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY2FuZGxlcy5sZW5ndGggJiYgY2FuZGxlU2VyaWVzUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNhbmRsZVNlcmllc1JlZi5jdXJyZW50LnNldERhdGEoY2FuZGxlcyk7XG4gICAgfVxuICAgIGlmICh2b2x1bWVzLmxlbmd0aCAmJiB2b2x1bWVTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgdm9sdW1lU2VyaWVzUmVmLmN1cnJlbnQuc2V0RGF0YSh2b2x1bWVzKTtcbiAgICB9XG4gIH0sIFtjYW5kbGVzLCB2b2x1bWVzXSk7XG5cbiAgLy8gQ29tcHV0ZSBhbmQgcmVuZGVyIGluZGljYXRvcnMgd2hlbiB0b2dnbGVkIG9yIGNhbmRsZXMgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjaGFydFJlZi5jdXJyZW50IHx8ICFjYW5kbGVzLmxlbmd0aCkgcmV0dXJuO1xuICAgIGNvbnN0IGNoYXJ0ID0gY2hhcnRSZWYuY3VycmVudDtcbiAgICAvLyBSZW1vdmUgcHJldmlvdXMgaW5kaWNhdG9yIHNlcmllcyBpZiBleGlzdFxuICAgIGlmIChzbWFTZXJpZXNSZWYuY3VycmVudCkgeyBjaGFydC5yZW1vdmVTZXJpZXMoc21hU2VyaWVzUmVmLmN1cnJlbnQpOyBzbWFTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7IH1cbiAgICBpZiAoZW1hU2VyaWVzUmVmLmN1cnJlbnQpIHsgY2hhcnQucmVtb3ZlU2VyaWVzKGVtYVNlcmllc1JlZi5jdXJyZW50KTsgZW1hU2VyaWVzUmVmLmN1cnJlbnQgPSBudWxsOyB9XG4gICAgaWYgKHJzaVNlcmllc1JlZi5jdXJyZW50KSB7IGNoYXJ0LnJlbW92ZVNlcmllcyhyc2lTZXJpZXNSZWYuY3VycmVudCk7IHJzaVNlcmllc1JlZi5jdXJyZW50ID0gbnVsbDsgfVxuICAgIGlmIChtYWNkU2VyaWVzUmVmLmN1cnJlbnQpIHsgY2hhcnQucmVtb3ZlU2VyaWVzKG1hY2RTZXJpZXNSZWYuY3VycmVudCk7IG1hY2RTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7IH1cblxuICAgIC8vIFVzZSBpbmRpY2F0b3JEYXRhIGZyb20gaG9va1xuICAgIC8vIFNNQVxuICAgIGlmIChpbmRpY2F0b3JEYXRhLnNtYSkge1xuICAgICAgc21hU2VyaWVzUmVmLmN1cnJlbnQgPSBjaGFydC5hZGRTZXJpZXMoTGluZVNlcmllcywgeyBjb2xvcjogJyNmYmJmMjQnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICBzbWFTZXJpZXNSZWYuY3VycmVudC5zZXREYXRhKGNhbmRsZXMubWFwKChjLCBpKSA9PiAoeyB0aW1lOiBjLnRpbWUsIHZhbHVlOiBpbmRpY2F0b3JEYXRhLnNtYVtpXSA/PyBudWxsIH0pKS5maWx0ZXIoZCA9PiBkLnZhbHVlICE9PSBudWxsKSk7XG4gICAgfVxuICAgIC8vIEVNQVxuICAgIGlmIChpbmRpY2F0b3JEYXRhLmVtYSkge1xuICAgICAgZW1hU2VyaWVzUmVmLmN1cnJlbnQgPSBjaGFydC5hZGRTZXJpZXMoTGluZVNlcmllcywgeyBjb2xvcjogJyM2MzY2ZjEnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICBlbWFTZXJpZXNSZWYuY3VycmVudC5zZXREYXRhKGNhbmRsZXMubWFwKChjLCBpKSA9PiAoeyB0aW1lOiBjLnRpbWUsIHZhbHVlOiBpbmRpY2F0b3JEYXRhLmVtYVtpXSA/PyBudWxsIH0pKS5maWx0ZXIoZCA9PiBkLnZhbHVlICE9PSBudWxsKSk7XG4gICAgfVxuICAgIC8vIFJTSSAoYXMgYSBzZXBhcmF0ZSBwYW5lKVxuICAgIGlmIChpbmRpY2F0b3JEYXRhLnJzaSkge1xuICAgICAgcnNpU2VyaWVzUmVmLmN1cnJlbnQgPSBjaGFydC5hZGRTZXJpZXMoTGluZVNlcmllcywgeyBjb2xvcjogJyMxMGI5ODEnLCBsaW5lV2lkdGg6IDIsIHByaWNlU2NhbGVJZDogJ3JzaScgfSk7XG4gICAgICBjaGFydC5wcmljZVNjYWxlKCdyc2knLCB7IGF1dG9TY2FsZTogdHJ1ZSB9KTtcbiAgICAgIHJzaVNlcmllc1JlZi5jdXJyZW50LnNldERhdGEoY2FuZGxlcy5tYXAoKGMsIGkpID0+ICh7IHRpbWU6IGMudGltZSwgdmFsdWU6IGluZGljYXRvckRhdGEucnNpW2ldID8/IG51bGwgfSkpLmZpbHRlcihkID0+IGQudmFsdWUgIT09IG51bGwpKTtcbiAgICB9XG4gICAgLy8gTUFDRCAoYXMgYSBzZXBhcmF0ZSBwYW5lKVxuICAgIGlmIChpbmRpY2F0b3JEYXRhLm1hY2QpIHtcbiAgICAgIG1hY2RTZXJpZXNSZWYuY3VycmVudCA9IGNoYXJ0LmFkZFNlcmllcyhMaW5lU2VyaWVzLCB7IGNvbG9yOiAnI2Y0M2Y1ZScsIGxpbmVXaWR0aDogMiwgcHJpY2VTY2FsZUlkOiAnbWFjZCcgfSk7XG4gICAgICBjaGFydC5wcmljZVNjYWxlKCdtYWNkJywgeyBhdXRvU2NhbGU6IHRydWUgfSk7XG4gICAgICBtYWNkU2VyaWVzUmVmLmN1cnJlbnQuc2V0RGF0YShjYW5kbGVzLm1hcCgoYywgaSkgPT4gKHsgdGltZTogYy50aW1lLCB2YWx1ZTogaW5kaWNhdG9yRGF0YS5tYWNkLm1hY2RbaV0gPz8gbnVsbCB9KSkuZmlsdGVyKGQgPT4gZC52YWx1ZSAhPT0gbnVsbCkpO1xuICAgICAgLy8gT3B0aW9uYWxseSwgYWRkIHNpZ25hbC9oaXN0b2dyYW0gYXMgd2VsbFxuICAgIH1cbiAgfSwgW2luZGljYXRvckRhdGEsIGNhbmRsZXNdKTtcblxuICAvLyBIYW5kbGVycyBmb3IgcHJpY2UgZmV0Y2ggYnV0dG9uc1xuICBjb25zdCBoYW5kbGVGZXRjaEN1cnJlbnRQcmljZSA9ICgpID0+IHtcbiAgICBpZiAoY2FuZGxlcy5sZW5ndGgpIHtcbiAgICAgIHNldEN1cnJlbnRQcmljZShjYW5kbGVzW2NhbmRsZXMubGVuZ3RoIC0gMV0uY2xvc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaGFuZGxlRmV0Y2hQcmljZTFNaW5BZ28gPSAoKSA9PiB7XG4gICAgaWYgKGNhbmRsZXMubGVuZ3RoID4gMSkge1xuICAgICAgc2V0UHJpY2UxTWluQWdvKGNhbmRsZXNbY2FuZGxlcy5sZW5ndGggLSAyXS5jbG9zZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiByZWY9e2NoYXJ0Q29udGFpbmVyUmVmfSBjbGFzc05hbWU9XCJ3LWZ1bGwgbWluLWgtWzMwMHB4XSBtYXgtaC1bODB2aF0gcmVsYXRpdmUgZmxleCBmbGV4LWNvbCBiZy13aGl0ZSBkYXJrOmJnLVsjMTExXSB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC1ncmF5LTEwMCByb3VuZGVkLWxnIHNoYWRvdy1tZCBvdmVyZmxvdy1oaWRkZW4gbWQ6aC1bNTAwcHhdIGxnOmgtWzYwMHB4XVwiPlxuICAgICAgPFByaWNlQnV0dG9uc1xuICAgICAgICBjdXJyZW50UHJpY2U9e2N1cnJlbnRQcmljZX1cbiAgICAgICAgcHJpY2UxTWluQWdvPXtwcmljZTFNaW5BZ299XG4gICAgICAgIG9uRmV0Y2hDdXJyZW50UHJpY2U9e2hhbmRsZUZldGNoQ3VycmVudFByaWNlfVxuICAgICAgICBvbkZldGNoUHJpY2UxTWluQWdvPXtoYW5kbGVGZXRjaFByaWNlMU1pbkFnb31cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDaGFydENvbnRhaW5lcjtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsImNyZWF0ZUNoYXJ0IiwiQ2FuZGxlc3RpY2tTZXJpZXMiLCJIaXN0b2dyYW1TZXJpZXMiLCJMaW5lU2VyaWVzIiwiUHJpY2VCdXR0b25zIiwiR2V0Q2FuZGxlcyIsIkdldExpdmVDYW5kbGUiLCJ1c2VJbmRpY2F0b3JzIiwidXNlQmluYW5jZVNvY2tldCIsIkNoYXJ0Q29udGFpbmVyIiwidGhlbWUiLCJ0aW1lZnJhbWUiLCJpbmRpY2F0b3JzIiwiY2hhcnRDb250YWluZXJSZWYiLCJjaGFydFJlZiIsImNhbmRsZVNlcmllc1JlZiIsInZvbHVtZVNlcmllc1JlZiIsInNtYVNlcmllc1JlZiIsImVtYVNlcmllc1JlZiIsInJzaVNlcmllc1JlZiIsIm1hY2RTZXJpZXNSZWYiLCJjYW5kbGVzIiwic2V0Q2FuZGxlcyIsInVzZVN0YXRlIiwidm9sdW1lcyIsInNldFZvbHVtZXMiLCJjdXJyZW50UHJpY2UiLCJzZXRDdXJyZW50UHJpY2UiLCJwcmljZTFNaW5BZ28iLCJzZXRQcmljZTFNaW5BZ28iLCJjdXJyZW50IiwicmVtb3ZlIiwiZSIsImlzRGFyayIsImNoYXJ0Iiwid2lkdGgiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImxheW91dCIsImJhY2tncm91bmQiLCJjb2xvciIsInRleHRDb2xvciIsImdyaWQiLCJ2ZXJ0TGluZXMiLCJob3J6TGluZXMiLCJjYW5kbGVTZXJpZXMiLCJhZGRTZXJpZXMiLCJ1cENvbG9yIiwiZG93bkNvbG9yIiwiYm9yZGVyVmlzaWJsZSIsIndpY2tWaXNpYmxlIiwidm9sdW1lU2VyaWVzIiwicHJpY2VGb3JtYXQiLCJ0eXBlIiwicHJpY2VTY2FsZUlkIiwicHJpY2VTY2FsZSIsImFwcGx5T3B0aW9ucyIsInNjYWxlTWFyZ2lucyIsInRvcCIsImJvdHRvbSIsImhhbmRsZVJlc2l6ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaWdub3JlIiwiZmV0Y2hEYXRhIiwiZGF0YSIsIm1hcCIsImMiLCJ0aW1lIiwiTWF0aCIsImZsb29yIiwib3BlblRpbWUiLCJvcGVuIiwiaGlnaCIsImxvdyIsImNsb3NlIiwidmFsdWUiLCJ2b2x1bWUiLCJjbG9zZXMiLCJpbmRpY2F0b3JEYXRhIiwiayIsInQiLCJuZXdDYW5kbGUiLCJvIiwiaCIsImwiLCJuZXdWb2x1bWUiLCJ2IiwicHJldiIsImxlbmd0aCIsInNsaWNlIiwic2V0RGF0YSIsInJlbW92ZVNlcmllcyIsInNtYSIsImxpbmVXaWR0aCIsImkiLCJmaWx0ZXIiLCJkIiwiZW1hIiwicnNpIiwiYXV0b1NjYWxlIiwibWFjZCIsImhhbmRsZUZldGNoQ3VycmVudFByaWNlIiwiaGFuZGxlRmV0Y2hQcmljZTFNaW5BZ28iLCJkaXYiLCJyZWYiLCJjbGFzc05hbWUiLCJvbkZldGNoQ3VycmVudFByaWNlIiwib25GZXRjaFByaWNlMU1pbkFnbyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ChartContainer.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Header.tsx":
/*!***********************************!*\
  !*** ./src/components/Header.tsx ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var _ThemeToggle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ThemeToggle */ \"(app-pages-browser)/./src/components/ThemeToggle.tsx\");\n/* harmony import */ var _app_home_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../app/home/layout */ \"(app-pages-browser)/./src/app/home/layout.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst Header = ()=>{\n    _s();\n    const { theme, setTheme } = (0,_app_home_layout__WEBPACK_IMPORTED_MODULE_4__.useTheme)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: \"w-full flex items-center justify-between px-4 py-2 bg-[#181A20] border-b border-[#23262F]\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center gap-2 max-w-30\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    src: \"https://upload.wikimedia.org/wikipedia/commons/5/57/Binance_Logo.png\",\n                    alt: \"Logo\",\n                    width: 64,\n                    height: 64\n                }, void 0, false, {\n                    fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\Header.tsx\",\n                    lineNumber: 12,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\Header.tsx\",\n                lineNumber: 11,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ThemeToggle__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                theme: theme,\n                setTheme: setTheme\n            }, void 0, false, {\n                fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\Header.tsx\",\n                lineNumber: 15,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\Header.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Header, \"5ABGV54qnXKp6rHn7MS/8MjwRhQ=\", false, function() {\n    return [\n        _app_home_layout__WEBPACK_IMPORTED_MODULE_4__.useTheme\n    ];\n});\n_c = Header;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Header);\nvar _c;\n$RefreshReg$(_c, \"Header\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0hlYWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ0s7QUFDUztBQUNNO0FBRTlDLE1BQU1JLFNBQW1COztJQUN2QixNQUFNLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUFFLEdBQUdILDBEQUFRQTtJQUNwQyxxQkFDRSw4REFBQ0k7UUFBT0MsV0FBVTs7MEJBRWhCLDhEQUFDQztnQkFBSUQsV0FBVTswQkFDYiw0RUFBQ1Asa0RBQUtBO29CQUFDUyxLQUFJO29CQUF1RUMsS0FBSTtvQkFBT0MsT0FBTztvQkFBSUMsUUFBUTs7Ozs7Ozs7Ozs7MEJBR2xILDhEQUFDWCxvREFBV0E7Z0JBQUNHLE9BQU9BO2dCQUFPQyxVQUFVQTs7Ozs7Ozs7Ozs7O0FBRzNDO0dBWk1GOztRQUN3QkQsc0RBQVFBOzs7S0FEaENDO0FBY04saUVBQWVBLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcc3JjXFxjb21wb25lbnRzXFxIZWFkZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJztcclxuaW1wb3J0IFRoZW1lVG9nZ2xlIGZyb20gJy4vVGhlbWVUb2dnbGUnO1xyXG5pbXBvcnQgeyB1c2VUaGVtZSB9IGZyb20gJy4uL2FwcC9ob21lL2xheW91dCc7XHJcblxyXG5jb25zdCBIZWFkZXI6IFJlYWN0LkZDID0gKCkgPT4ge1xyXG4gIGNvbnN0IHsgdGhlbWUsIHNldFRoZW1lIH0gPSB1c2VUaGVtZSgpO1xyXG4gIHJldHVybiAoXHJcbiAgICA8aGVhZGVyIGNsYXNzTmFtZT1cInctZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gcHgtNCBweS0yIGJnLVsjMTgxQTIwXSBib3JkZXItYiBib3JkZXItWyMyMzI2MkZdXCI+XHJcbiAgICAgIHsvKiBMb2dvIGLDqm4gdHLDoWkgKi99XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgbWF4LXctMzBcIj5cclxuICAgICAgICA8SW1hZ2Ugc3JjPVwiaHR0cHM6Ly91cGxvYWQud2lraW1lZGlhLm9yZy93aWtpcGVkaWEvY29tbW9ucy81LzU3L0JpbmFuY2VfTG9nby5wbmdcIiBhbHQ9XCJMb2dvXCIgd2lkdGg9ezY0fSBoZWlnaHQ9ezY0fSAvPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgey8qIFRoZW1lVG9nZ2xlIGLDqm4gcGjhuqNpICovfVxyXG4gICAgICA8VGhlbWVUb2dnbGUgdGhlbWU9e3RoZW1lfSBzZXRUaGVtZT17c2V0VGhlbWV9IC8+XHJcbiAgICA8L2hlYWRlcj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSGVhZGVyO1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJJbWFnZSIsIlRoZW1lVG9nZ2xlIiwidXNlVGhlbWUiLCJIZWFkZXIiLCJ0aGVtZSIsInNldFRoZW1lIiwiaGVhZGVyIiwiY2xhc3NOYW1lIiwiZGl2Iiwic3JjIiwiYWx0Iiwid2lkdGgiLCJoZWlnaHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Header.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/IndicatorToggle.tsx":
/*!********************************************!*\
  !*** ./src/components/IndicatorToggle.tsx ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst INDICATORS = [\n    {\n        key: 'rsi',\n        label: 'RSI'\n    },\n    {\n        key: 'macd',\n        label: 'MACD'\n    },\n    {\n        key: 'ema',\n        label: 'EMA'\n    },\n    {\n        key: 'sma',\n        label: 'SMA'\n    }\n];\nconst IndicatorToggle = (param)=>{\n    let { value, onChange } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-wrap gap-2 justify-start items-center md:justify-start\",\n        children: [\n            \"Ch s k thut:\",\n            INDICATORS.map((ind)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                    className: \"flex items-center gap-1 text-xs md:text-sm dark:text-white cursor-pointer select-none\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"checkbox\",\n                            checked: !!value[ind.key],\n                            onChange: (e)=>onChange({\n                                    ...value,\n                                    [ind.key]: e.target.checked\n                                }),\n                            className: \"accent-blue-500\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\IndicatorToggle.tsx\",\n                            lineNumber: 20,\n                            columnNumber: 9\n                        }, undefined),\n                        ind.label\n                    ]\n                }, ind.key, true, {\n                    fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\IndicatorToggle.tsx\",\n                    lineNumber: 19,\n                    columnNumber: 7\n                }, undefined))\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\IndicatorToggle.tsx\",\n        lineNumber: 16,\n        columnNumber: 3\n    }, undefined);\n};\n_c = IndicatorToggle;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IndicatorToggle);\nvar _c;\n$RefreshReg$(_c, \"IndicatorToggle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0luZGljYXRvclRvZ2dsZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEI7QUFPMUIsTUFBTUMsYUFBYTtJQUNqQjtRQUFFQyxLQUFLO1FBQU9DLE9BQU87SUFBTTtJQUMzQjtRQUFFRCxLQUFLO1FBQVFDLE9BQU87SUFBTztJQUM3QjtRQUFFRCxLQUFLO1FBQU9DLE9BQU87SUFBTTtJQUMzQjtRQUFFRCxLQUFLO1FBQU9DLE9BQU87SUFBTTtDQUM1QjtBQUVELE1BQU1DLGtCQUFrRDtRQUFDLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUFFO3lCQUMxRSw4REFBQ0M7UUFBSUMsV0FBVTs7WUFBbUU7WUFFL0VQLFdBQVdRLEdBQUcsQ0FBQ0MsQ0FBQUEsb0JBQ2QsOERBQUNQO29CQUFvQkssV0FBVTs7c0NBQzdCLDhEQUFDRzs0QkFDQ0MsTUFBSzs0QkFDTEMsU0FBUyxDQUFDLENBQUNSLEtBQUssQ0FBQ0ssSUFBSVIsR0FBRyxDQUF1Qjs0QkFDL0NJLFVBQVVRLENBQUFBLElBQUtSLFNBQVM7b0NBQUUsR0FBR0QsS0FBSztvQ0FBRSxDQUFDSyxJQUFJUixHQUFHLENBQUMsRUFBRVksRUFBRUMsTUFBTSxDQUFDRixPQUFPO2dDQUFDOzRCQUNoRUwsV0FBVTs7Ozs7O3dCQUVYRSxJQUFJUCxLQUFLOzttQkFQQU8sSUFBSVIsR0FBRzs7Ozs7Ozs7Ozs7O0tBSm5CRTtBQWlCTixpRUFBZUEsZUFBZUEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxzcmNcXGNvbXBvbmVudHNcXEluZGljYXRvclRvZ2dsZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW50ZXJmYWNlIEluZGljYXRvclRvZ2dsZVByb3BzIHtcbiAgdmFsdWU6IHsgcnNpPzogYm9vbGVhbjsgbWFjZD86IGJvb2xlYW47IGVtYT86IGJvb2xlYW47IHNtYT86IGJvb2xlYW4gfTtcbiAgb25DaGFuZ2U6ICh2OiBhbnkpID0+IHZvaWQ7XG59XG5cbmNvbnN0IElORElDQVRPUlMgPSBbXG4gIHsga2V5OiAncnNpJywgbGFiZWw6ICdSU0knIH0sXG4gIHsga2V5OiAnbWFjZCcsIGxhYmVsOiAnTUFDRCcgfSxcbiAgeyBrZXk6ICdlbWEnLCBsYWJlbDogJ0VNQScgfSxcbiAgeyBrZXk6ICdzbWEnLCBsYWJlbDogJ1NNQScgfSxcbl07XG5cbmNvbnN0IEluZGljYXRvclRvZ2dsZTogUmVhY3QuRkM8SW5kaWNhdG9yVG9nZ2xlUHJvcHM+ID0gKHsgdmFsdWUsIG9uQ2hhbmdlIH0pID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBnYXAtMiBqdXN0aWZ5LXN0YXJ0IGl0ZW1zLWNlbnRlciBtZDpqdXN0aWZ5LXN0YXJ0XCI+XG4gICAgQ2jhu4kgc+G7kSBrxKkgdGh14bqtdDogXG4gICAge0lORElDQVRPUlMubWFwKGluZCA9PiAoXG4gICAgICA8bGFiZWwga2V5PXtpbmQua2V5fSBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMSB0ZXh0LXhzIG1kOnRleHQtc20gZGFyazp0ZXh0LXdoaXRlIGN1cnNvci1wb2ludGVyIHNlbGVjdC1ub25lXCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgY2hlY2tlZD17ISF2YWx1ZVtpbmQua2V5IGFzIGtleW9mIHR5cGVvZiB2YWx1ZV19XG4gICAgICAgICAgb25DaGFuZ2U9e2UgPT4gb25DaGFuZ2UoeyAuLi52YWx1ZSwgW2luZC5rZXldOiBlLnRhcmdldC5jaGVja2VkIH0pfVxuICAgICAgICAgIGNsYXNzTmFtZT1cImFjY2VudC1ibHVlLTUwMFwiXG4gICAgICAgIC8+XG4gICAgICAgIHtpbmQubGFiZWx9XG4gICAgICA8L2xhYmVsPlxuICAgICkpfVxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEluZGljYXRvclRvZ2dsZTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIklORElDQVRPUlMiLCJrZXkiLCJsYWJlbCIsIkluZGljYXRvclRvZ2dsZSIsInZhbHVlIiwib25DaGFuZ2UiLCJkaXYiLCJjbGFzc05hbWUiLCJtYXAiLCJpbmQiLCJpbnB1dCIsInR5cGUiLCJjaGVja2VkIiwiZSIsInRhcmdldCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/IndicatorToggle.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/PriceButtons.tsx":
/*!*****************************************!*\
  !*** ./src/components/PriceButtons.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst PriceButtons = (param)=>{\n    let { currentPrice, price1MinAgo, onFetchCurrentPrice, onFetchPrice1MinAgo } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col sm:flex-row gap-4 mt-4 items-center justify-center w-full px-2\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-row items-center bg-white dark:bg-gray-800 shadow-md rounded-lg p-3 mx-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: onFetchCurrentPrice,\n                        className: \"px-4 py-2 from-blue-500 to-blue-700 text-white font-semibold shadow hover:from-blue-600 hover:to-blue-800 transition-all duration-200 focus:outline-none\",\n                        children: \"Current Price\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\PriceButtons.tsx\",\n                        lineNumber: 18,\n                        columnNumber: 7\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"px-4 py-2 bg-gray-100 dark:bg-gray-700 text-blue-700 dark:text-blue-200 font-mono min-w-[120px] border-blue-200 dark:border-blue-800\",\n                        children: currentPrice !== null ? \" $\".concat(currentPrice) : '--'\n                    }, void 0, false, {\n                        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\PriceButtons.tsx\",\n                        lineNumber: 24,\n                        columnNumber: 7\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\PriceButtons.tsx\",\n                lineNumber: 17,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-row items-center bg-white dark:bg-gray-800 shadow-md rounded-lg p-3 mx-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: onFetchPrice1MinAgo,\n                        className: \"px-4 py-2 from-green-500 to-green-700 text-white font-semibold shadow hover:from-green-600 hover:to-green-800 transition-all duration-200 focus:outline-none \",\n                        children: \"Price 1 Min Ago\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\PriceButtons.tsx\",\n                        lineNumber: 29,\n                        columnNumber: 7\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"px-4 py-2 bg-gray-100 dark:bg-gray-700 text-green-700 dark:text-green-200 font-mono min-w-[140px] border-green-200 dark:border-green-800\",\n                        children: price1MinAgo !== null ? \" $\".concat(price1MinAgo) : '--'\n                    }, void 0, false, {\n                        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\PriceButtons.tsx\",\n                        lineNumber: 35,\n                        columnNumber: 7\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\PriceButtons.tsx\",\n                lineNumber: 28,\n                columnNumber: 5\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\PriceButtons.tsx\",\n        lineNumber: 16,\n        columnNumber: 3\n    }, undefined);\n};\n_c = PriceButtons;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PriceButtons);\nvar _c;\n$RefreshReg$(_c, \"PriceButtons\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1ByaWNlQnV0dG9ucy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEI7QUFTMUIsTUFBTUMsZUFBNEM7UUFBQyxFQUNqREMsWUFBWSxFQUNaQyxZQUFZLEVBQ1pDLG1CQUFtQixFQUNuQkMsbUJBQW1CLEVBQ3BCO3lCQUNDLDhEQUFDQztRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0Q7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDQzt3QkFDQ0MsU0FBU0w7d0JBQ1RHLFdBQVU7a0NBQ1g7Ozs7OztrQ0FHRCw4REFBQ0c7d0JBQUtILFdBQVU7a0NBQ2JMLGlCQUFpQixPQUFPLEtBQWtCLE9BQWJBLGdCQUFpQjs7Ozs7Ozs7Ozs7OzBCQUduRCw4REFBQ0k7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDQzt3QkFDQ0MsU0FBU0o7d0JBQ1RFLFdBQVU7a0NBQ1g7Ozs7OztrQ0FHRCw4REFBQ0c7d0JBQUtILFdBQVU7a0NBQ2JKLGlCQUFpQixPQUFPLEtBQWtCLE9BQWJBLGdCQUFpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTFCakRGO0FBZ0NOLGlFQUFlQSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXHNyY1xcY29tcG9uZW50c1xcUHJpY2VCdXR0b25zLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW50ZXJmYWNlIFByaWNlQnV0dG9uc1Byb3BzIHtcclxuICBjdXJyZW50UHJpY2U6IG51bWJlciB8IG51bGw7XHJcbiAgcHJpY2UxTWluQWdvOiBudW1iZXIgfCBudWxsO1xyXG4gIG9uRmV0Y2hDdXJyZW50UHJpY2U6ICgpID0+IHZvaWQ7XHJcbiAgb25GZXRjaFByaWNlMU1pbkFnbzogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuY29uc3QgUHJpY2VCdXR0b25zOiBSZWFjdC5GQzxQcmljZUJ1dHRvbnNQcm9wcz4gPSAoe1xyXG4gIGN1cnJlbnRQcmljZSxcclxuICBwcmljZTFNaW5BZ28sXHJcbiAgb25GZXRjaEN1cnJlbnRQcmljZSxcclxuICBvbkZldGNoUHJpY2UxTWluQWdvLFxyXG59KSA9PiAoXHJcbiAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNtOmZsZXgtcm93IGdhcC00IG10LTQgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHctZnVsbCBweC0yXCI+XHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGJnLXdoaXRlIGRhcms6YmctZ3JheS04MDAgc2hhZG93LW1kIHJvdW5kZWQtbGcgcC0zIG14LTJcIj5cclxuICAgICAgPGJ1dHRvblxyXG4gICAgICAgIG9uQ2xpY2s9e29uRmV0Y2hDdXJyZW50UHJpY2V9XHJcbiAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0yIGZyb20tYmx1ZS01MDAgdG8tYmx1ZS03MDAgdGV4dC13aGl0ZSBmb250LXNlbWlib2xkIHNoYWRvdyBob3Zlcjpmcm9tLWJsdWUtNjAwIGhvdmVyOnRvLWJsdWUtODAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxyXG4gICAgICA+XHJcbiAgICAgICAgQ3VycmVudCBQcmljZVxyXG4gICAgICA8L2J1dHRvbj5cclxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLWdyYXktMTAwIGRhcms6YmctZ3JheS03MDAgdGV4dC1ibHVlLTcwMCBkYXJrOnRleHQtYmx1ZS0yMDAgZm9udC1tb25vIG1pbi13LVsxMjBweF0gYm9yZGVyLWJsdWUtMjAwIGRhcms6Ym9yZGVyLWJsdWUtODAwXCI+XHJcbiAgICAgICAge2N1cnJlbnRQcmljZSAhPT0gbnVsbCA/IGAgJCR7Y3VycmVudFByaWNlfWAgOiAnLS0nfVxyXG4gICAgICA8L3NwYW4+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIgYmctd2hpdGUgZGFyazpiZy1ncmF5LTgwMCBzaGFkb3ctbWQgcm91bmRlZC1sZyBwLTMgbXgtMlwiPlxyXG4gICAgICA8YnV0dG9uXHJcbiAgICAgICAgb25DbGljaz17b25GZXRjaFByaWNlMU1pbkFnb31cclxuICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgZnJvbS1ncmVlbi01MDAgdG8tZ3JlZW4tNzAwIHRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCBzaGFkb3cgaG92ZXI6ZnJvbS1ncmVlbi02MDAgaG92ZXI6dG8tZ3JlZW4tODAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBmb2N1czpvdXRsaW5lLW5vbmUgXCJcclxuICAgICAgPlxyXG4gICAgICAgIFByaWNlIDEgTWluIEFnb1xyXG4gICAgICA8L2J1dHRvbj5cclxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLWdyYXktMTAwIGRhcms6YmctZ3JheS03MDAgdGV4dC1ncmVlbi03MDAgZGFyazp0ZXh0LWdyZWVuLTIwMCBmb250LW1vbm8gbWluLXctWzE0MHB4XSBib3JkZXItZ3JlZW4tMjAwIGRhcms6Ym9yZGVyLWdyZWVuLTgwMFwiPlxyXG4gICAgICAgIHtwcmljZTFNaW5BZ28gIT09IG51bGwgPyBgICQke3ByaWNlMU1pbkFnb31gIDogJy0tJ31cclxuICAgICAgPC9zcGFuPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcmljZUJ1dHRvbnM7Il0sIm5hbWVzIjpbIlJlYWN0IiwiUHJpY2VCdXR0b25zIiwiY3VycmVudFByaWNlIiwicHJpY2UxTWluQWdvIiwib25GZXRjaEN1cnJlbnRQcmljZSIsIm9uRmV0Y2hQcmljZTFNaW5BZ28iLCJkaXYiLCJjbGFzc05hbWUiLCJidXR0b24iLCJvbkNsaWNrIiwic3BhbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/PriceButtons.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ThemeToggle.tsx":
/*!****************************************!*\
  !*** ./src/components/ThemeToggle.tsx ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst ThemeToggle = (param)=>{\n    let { theme, setTheme } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        className: \"px-2 py-1 rounded border dark:bg-white dark:text-white\",\n        onClick: ()=>setTheme(theme === 'dark' ? 'light' : 'dark'),\n        \"aria-label\": \"Toggle theme\",\n        children: theme === 'dark' ? '' : ''\n    }, void 0, false, {\n        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\ThemeToggle.tsx\",\n        lineNumber: 9,\n        columnNumber: 3\n    }, undefined);\n};\n_c = ThemeToggle;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ThemeToggle);\nvar _c;\n$RefreshReg$(_c, \"ThemeToggle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1RoZW1lVG9nZ2xlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwQjtBQU8xQixNQUFNQyxjQUEwQztRQUFDLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUFFO3lCQUNsRSw4REFBQ0M7UUFDQ0MsV0FBVTtRQUNWQyxTQUFTLElBQU1ILFNBQVNELFVBQVUsU0FBUyxVQUFVO1FBQ3JESyxjQUFXO2tCQUVWTCxVQUFVLFNBQVMsT0FBTzs7Ozs7OztLQU56QkQ7QUFVTixpRUFBZUEsV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxzcmNcXGNvbXBvbmVudHNcXFRoZW1lVG9nZ2xlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbnRlcmZhY2UgVGhlbWVUb2dnbGVQcm9wcyB7XG4gIHRoZW1lOiAnbGlnaHQnIHwgJ2RhcmsnO1xuICBzZXRUaGVtZTogKHQ6ICdsaWdodCcgfCAnZGFyaycpID0+IHZvaWQ7XG59XG5cbmNvbnN0IFRoZW1lVG9nZ2xlOiBSZWFjdC5GQzxUaGVtZVRvZ2dsZVByb3BzPiA9ICh7IHRoZW1lLCBzZXRUaGVtZSB9KSA9PiAoXG4gIDxidXR0b25cbiAgICBjbGFzc05hbWU9XCJweC0yIHB5LTEgcm91bmRlZCBib3JkZXIgZGFyazpiZy13aGl0ZSBkYXJrOnRleHQtd2hpdGVcIlxuICAgIG9uQ2xpY2s9eygpID0+IHNldFRoZW1lKHRoZW1lID09PSAnZGFyaycgPyAnbGlnaHQnIDogJ2RhcmsnKX1cbiAgICBhcmlhLWxhYmVsPVwiVG9nZ2xlIHRoZW1lXCJcbiAgPlxuICAgIHt0aGVtZSA9PT0gJ2RhcmsnID8gJ/CfjJknIDogJ+KYgO+4jyd9XG4gIDwvYnV0dG9uPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgVGhlbWVUb2dnbGU7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJUaGVtZVRvZ2dsZSIsInRoZW1lIiwic2V0VGhlbWUiLCJidXR0b24iLCJjbGFzc05hbWUiLCJvbkNsaWNrIiwiYXJpYS1sYWJlbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ThemeToggle.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/TimeframeSelector.tsx":
/*!**********************************************!*\
  !*** ./src/components/TimeframeSelector.tsx ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst TIMEFRAMES = [\n    '1m',\n    '3m',\n    '5m',\n    '15m',\n    '30m',\n    '1h',\n    '2h',\n    '4h',\n    '6h',\n    '12h',\n    '1d',\n    '3d',\n    '1w',\n    '1M'\n];\nconst TimeframeSelector = (param)=>{\n    let { value, onChange } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-wrap gap-1 justify-start items-center md:justify-start\",\n        children: [\n            \"Khung thi gian:\",\n            TIMEFRAMES.map((tf)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    className: \"px-2 py-1 rounded text-xs md:text-sm transition-all \".concat(value === tf ? 'bg-blue-500 text-white' : 'bg-gray-200 dark:bg-gray-700 dark:text-white'),\n                    onClick: ()=>onChange(tf),\n                    children: tf\n                }, tf, false, {\n                    fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\TimeframeSelector.tsx\",\n                    lineNumber: 16,\n                    columnNumber: 7\n                }, undefined))\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\DO_AN\\\\btc-dashboard\\\\src\\\\components\\\\TimeframeSelector.tsx\",\n        lineNumber: 13,\n        columnNumber: 3\n    }, undefined);\n};\n_c = TimeframeSelector;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TimeframeSelector); // Timeframe selector buttons here\nvar _c;\n$RefreshReg$(_c, \"TimeframeSelector\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1RpbWVmcmFtZVNlbGVjdG9yLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwQjtBQU8xQixNQUFNQyxhQUFhO0lBQ2pCO0lBQU07SUFBTTtJQUFNO0lBQU87SUFBTztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU87SUFBTTtJQUFNO0lBQU07Q0FDbEY7QUFFRCxNQUFNQyxvQkFBc0Q7UUFBQyxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRTt5QkFDOUUsOERBQUNDO1FBQUlDLFdBQVU7O1lBQW1FO1lBRS9FTCxXQUFXTSxHQUFHLENBQUNDLENBQUFBLG1CQUNkLDhEQUFDQztvQkFFQ0gsV0FBVyx1REFBZ0osT0FBekZILFVBQVVLLEtBQUssMkJBQTJCO29CQUM1R0UsU0FBUyxJQUFNTixTQUFTSTs4QkFDeEJBO21CQUhLQTs7Ozs7Ozs7Ozs7O0tBTFBOO0FBYU4saUVBQWVBLGlCQUFpQkEsRUFBQyxDQUVqQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcc3JjXFxjb21wb25lbnRzXFxUaW1lZnJhbWVTZWxlY3Rvci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW50ZXJmYWNlIFRpbWVmcmFtZVNlbGVjdG9yUHJvcHMge1xuICB2YWx1ZTogc3RyaW5nO1xuICBvbkNoYW5nZTogKHY6IHN0cmluZykgPT4gdm9pZDtcbn1cblxuY29uc3QgVElNRUZSQU1FUyA9IFtcbiAgJzFtJywgJzNtJywgJzVtJywgJzE1bScsICczMG0nLCAnMWgnLCAnMmgnLCAnNGgnLCAnNmgnLCAnMTJoJywgJzFkJywgJzNkJywgJzF3JywgJzFNJ1xuXTtcblxuY29uc3QgVGltZWZyYW1lU2VsZWN0b3I6IFJlYWN0LkZDPFRpbWVmcmFtZVNlbGVjdG9yUHJvcHM+ID0gKHsgdmFsdWUsIG9uQ2hhbmdlIH0pID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBnYXAtMSBqdXN0aWZ5LXN0YXJ0IGl0ZW1zLWNlbnRlciBtZDpqdXN0aWZ5LXN0YXJ0XCI+XG4gICAgS2h1bmcgdGjhu51pIGdpYW46XG4gICAge1RJTUVGUkFNRVMubWFwKHRmID0+IChcbiAgICAgIDxidXR0b25cbiAgICAgICAga2V5PXt0Zn1cbiAgICAgICAgY2xhc3NOYW1lPXtgcHgtMiBweS0xIHJvdW5kZWQgdGV4dC14cyBtZDp0ZXh0LXNtIHRyYW5zaXRpb24tYWxsICR7dmFsdWUgPT09IHRmID8gJ2JnLWJsdWUtNTAwIHRleHQtd2hpdGUnIDogJ2JnLWdyYXktMjAwIGRhcms6YmctZ3JheS03MDAgZGFyazp0ZXh0LXdoaXRlJ31gfVxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBvbkNoYW5nZSh0Zil9XG4gICAgICA+e3RmfTwvYnV0dG9uPlxuICAgICkpfVxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVmcmFtZVNlbGVjdG9yO1xuXG4vLyBUaW1lZnJhbWUgc2VsZWN0b3IgYnV0dG9ucyBoZXJlXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJUSU1FRlJBTUVTIiwiVGltZWZyYW1lU2VsZWN0b3IiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwiZGl2IiwiY2xhc3NOYW1lIiwibWFwIiwidGYiLCJidXR0b24iLCJvbkNsaWNrIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/TimeframeSelector.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/useBinanceSocket.ts":
/*!***************************************!*\
  !*** ./src/hooks/useBinanceSocket.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useBinanceSocket: () => (/* binding */ useBinanceSocket)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * useBinanceSocket - React hook for efficient real-time Binance kline data\n * @param wsUrl WebSocket URL (from GetLiveCandle)\n * @param onKline callback for each kline message (parsed)\n * @returns { connect, disconnect, isConnected }\n */ function useBinanceSocket(wsUrl, onKline) {\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isConnected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useBinanceSocket.useEffect\": ()=>{\n            if (!wsUrl) return;\n            let ws = new window.WebSocket(wsUrl);\n            wsRef.current = ws;\n            isConnected.current = true;\n            ws.onmessage = ({\n                \"useBinanceSocket.useEffect\": (event)=>{\n                    try {\n                        const msg = JSON.parse(event.data);\n                        if (msg.k) onKline(msg.k);\n                    } catch (e) {}\n                }\n            })[\"useBinanceSocket.useEffect\"];\n            ws.onerror = ({\n                \"useBinanceSocket.useEffect\": ()=>{\n                    isConnected.current = false;\n                }\n            })[\"useBinanceSocket.useEffect\"];\n            ws.onclose = ({\n                \"useBinanceSocket.useEffect\": ()=>{\n                    isConnected.current = false;\n                }\n            })[\"useBinanceSocket.useEffect\"];\n            return ({\n                \"useBinanceSocket.useEffect\": ()=>{\n                    isConnected.current = false;\n                    ws === null || ws === void 0 ? void 0 : ws.close();\n                }\n            })[\"useBinanceSocket.useEffect\"];\n        }\n    }[\"useBinanceSocket.useEffect\"], [\n        wsUrl,\n        onKline\n    ]);\n    return {\n        connect: ()=>{\n            if (!wsRef.current && wsUrl) wsRef.current = new window.WebSocket(wsUrl);\n        },\n        disconnect: ()=>{\n            var _wsRef_current;\n            (_wsRef_current = wsRef.current) === null || _wsRef_current === void 0 ? void 0 : _wsRef_current.close();\n            wsRef.current = null;\n        },\n        isConnected: isConnected.current\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VCaW5hbmNlU29ja2V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQztBQUUxQzs7Ozs7Q0FLQyxHQUNNLFNBQVNFLGlCQUFpQkMsS0FBYSxFQUFFQyxPQUE2QjtJQUMzRSxNQUFNQyxRQUFRSiw2Q0FBTUEsQ0FBbUI7SUFDdkMsTUFBTUssY0FBY0wsNkNBQU1BLENBQUM7SUFFM0JELGdEQUFTQTtzQ0FBQztZQUNSLElBQUksQ0FBQ0csT0FBTztZQUNaLElBQUlJLEtBQXVCLElBQUlDLE9BQU9DLFNBQVMsQ0FBQ047WUFDaERFLE1BQU1LLE9BQU8sR0FBR0g7WUFDaEJELFlBQVlJLE9BQU8sR0FBRztZQUV0QkgsR0FBR0ksU0FBUzs4Q0FBRyxDQUFDQztvQkFDZCxJQUFJO3dCQUNGLE1BQU1DLE1BQU1DLEtBQUtDLEtBQUssQ0FBQ0gsTUFBTUksSUFBSTt3QkFDakMsSUFBSUgsSUFBSUksQ0FBQyxFQUFFYixRQUFRUyxJQUFJSSxDQUFDO29CQUMxQixFQUFFLFVBQU0sQ0FBQztnQkFDWDs7WUFDQVYsR0FBR1csT0FBTzs4Q0FBRztvQkFBUVosWUFBWUksT0FBTyxHQUFHO2dCQUFPOztZQUNsREgsR0FBR1ksT0FBTzs4Q0FBRztvQkFBUWIsWUFBWUksT0FBTyxHQUFHO2dCQUFPOztZQUNsRDs4Q0FBTztvQkFDTEosWUFBWUksT0FBTyxHQUFHO29CQUN0QkgsZUFBQUEseUJBQUFBLEdBQUlhLEtBQUs7Z0JBQ1g7O1FBQ0Y7cUNBQUc7UUFBQ2pCO1FBQU9DO0tBQVE7SUFFbkIsT0FBTztRQUNMaUIsU0FBUztZQUNQLElBQUksQ0FBQ2hCLE1BQU1LLE9BQU8sSUFBSVAsT0FBT0UsTUFBTUssT0FBTyxHQUFHLElBQUlGLE9BQU9DLFNBQVMsQ0FBQ047UUFDcEU7UUFDQW1CLFlBQVk7Z0JBQ1ZqQjthQUFBQSxpQkFBQUEsTUFBTUssT0FBTyxjQUFiTCxxQ0FBQUEsZUFBZWUsS0FBSztZQUNwQmYsTUFBTUssT0FBTyxHQUFHO1FBQ2xCO1FBQ0FKLGFBQWFBLFlBQVlJLE9BQU87SUFDbEM7QUFDRiIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxzcmNcXGhvb2tzXFx1c2VCaW5hbmNlU29ja2V0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIHVzZUJpbmFuY2VTb2NrZXQgLSBSZWFjdCBob29rIGZvciBlZmZpY2llbnQgcmVhbC10aW1lIEJpbmFuY2Uga2xpbmUgZGF0YVxuICogQHBhcmFtIHdzVXJsIFdlYlNvY2tldCBVUkwgKGZyb20gR2V0TGl2ZUNhbmRsZSlcbiAqIEBwYXJhbSBvbktsaW5lIGNhbGxiYWNrIGZvciBlYWNoIGtsaW5lIG1lc3NhZ2UgKHBhcnNlZClcbiAqIEByZXR1cm5zIHsgY29ubmVjdCwgZGlzY29ubmVjdCwgaXNDb25uZWN0ZWQgfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmluYW5jZVNvY2tldCh3c1VybDogc3RyaW5nLCBvbktsaW5lOiAoa2xpbmU6IGFueSkgPT4gdm9pZCkge1xuICBjb25zdCB3c1JlZiA9IHVzZVJlZjxXZWJTb2NrZXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgaXNDb25uZWN0ZWQgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF3c1VybCkgcmV0dXJuO1xuICAgIGxldCB3czogV2ViU29ja2V0IHwgbnVsbCA9IG5ldyB3aW5kb3cuV2ViU29ja2V0KHdzVXJsKTtcbiAgICB3c1JlZi5jdXJyZW50ID0gd3M7XG4gICAgaXNDb25uZWN0ZWQuY3VycmVudCA9IHRydWU7XG5cbiAgICB3cy5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIGlmIChtc2cuaykgb25LbGluZShtc2cuayk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfTtcbiAgICB3cy5vbmVycm9yID0gKCkgPT4geyBpc0Nvbm5lY3RlZC5jdXJyZW50ID0gZmFsc2U7IH07XG4gICAgd3Mub25jbG9zZSA9ICgpID0+IHsgaXNDb25uZWN0ZWQuY3VycmVudCA9IGZhbHNlOyB9O1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc0Nvbm5lY3RlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB3cz8uY2xvc2UoKTtcbiAgICB9O1xuICB9LCBbd3NVcmwsIG9uS2xpbmVdKTtcblxuICByZXR1cm4ge1xuICAgIGNvbm5lY3Q6ICgpID0+IHtcbiAgICAgIGlmICghd3NSZWYuY3VycmVudCAmJiB3c1VybCkgd3NSZWYuY3VycmVudCA9IG5ldyB3aW5kb3cuV2ViU29ja2V0KHdzVXJsKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3Q6ICgpID0+IHtcbiAgICAgIHdzUmVmLmN1cnJlbnQ/LmNsb3NlKCk7XG4gICAgICB3c1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9LFxuICAgIGlzQ29ubmVjdGVkOiBpc0Nvbm5lY3RlZC5jdXJyZW50LFxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUJpbmFuY2VTb2NrZXQiLCJ3c1VybCIsIm9uS2xpbmUiLCJ3c1JlZiIsImlzQ29ubmVjdGVkIiwid3MiLCJ3aW5kb3ciLCJXZWJTb2NrZXQiLCJjdXJyZW50Iiwib25tZXNzYWdlIiwiZXZlbnQiLCJtc2ciLCJKU09OIiwicGFyc2UiLCJkYXRhIiwiayIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiY2xvc2UiLCJjb25uZWN0IiwiZGlzY29ubmVjdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useBinanceSocket.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/useIndicators.ts":
/*!************************************!*\
  !*** ./src/hooks/useIndicators.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useIndicators: () => (/* binding */ useIndicators)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_indicators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/indicators */ \"(app-pages-browser)/./src/utils/indicators.ts\");\n\n\n/**\n * useIndicators - Efficiently compute all selected indicators for a candle array\n * @param closes Array of close prices\n * @param indicators Object: { rsi, macd, ema, sma }\n * @returns Object with indicator arrays (only those enabled)\n */ function useIndicators(closes, indicators) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useIndicators.useMemo\": ()=>{\n            const result = {};\n            if (indicators.sma) result.sma = (0,_utils_indicators__WEBPACK_IMPORTED_MODULE_1__.calculateSMA)(closes, 14);\n            if (indicators.ema) result.ema = (0,_utils_indicators__WEBPACK_IMPORTED_MODULE_1__.calculateEMA)(closes, 14);\n            if (indicators.rsi) result.rsi = (0,_utils_indicators__WEBPACK_IMPORTED_MODULE_1__.calculateRSI)(closes, 14);\n            if (indicators.macd) result.macd = (0,_utils_indicators__WEBPACK_IMPORTED_MODULE_1__.calculateMACD)(closes);\n            return result;\n        }\n    }[\"useIndicators.useMemo\"], [\n        closes,\n        indicators.sma,\n        indicators.ema,\n        indicators.rsi,\n        indicators.macd\n    ]);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VJbmRpY2F0b3JzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0M7QUFDOEQ7QUFFOUY7Ozs7O0NBS0MsR0FDTSxTQUFTSyxjQUFjQyxNQUFnQixFQUFFQyxVQUEyRTtJQUN6SCxPQUFPUCw4Q0FBT0E7aUNBQUM7WUFDYixNQUFNUSxTQUFjLENBQUM7WUFDckIsSUFBSUQsV0FBV0UsR0FBRyxFQUFFRCxPQUFPQyxHQUFHLEdBQUdSLCtEQUFZQSxDQUFDSyxRQUFRO1lBQ3RELElBQUlDLFdBQVdHLEdBQUcsRUFBRUYsT0FBT0UsR0FBRyxHQUFHUiwrREFBWUEsQ0FBQ0ksUUFBUTtZQUN0RCxJQUFJQyxXQUFXSSxHQUFHLEVBQUVILE9BQU9HLEdBQUcsR0FBR1IsK0RBQVlBLENBQUNHLFFBQVE7WUFDdEQsSUFBSUMsV0FBV0ssSUFBSSxFQUFFSixPQUFPSSxJQUFJLEdBQUdSLGdFQUFhQSxDQUFDRTtZQUNqRCxPQUFPRTtRQUNUO2dDQUFHO1FBQUNGO1FBQVFDLFdBQVdFLEdBQUc7UUFBRUYsV0FBV0csR0FBRztRQUFFSCxXQUFXSSxHQUFHO1FBQUVKLFdBQVdLLElBQUk7S0FBQztBQUM5RSIsInNvdXJjZXMiOlsiQzpcXERPX0FOXFxidGMtZGFzaGJvYXJkXFxzcmNcXGhvb2tzXFx1c2VJbmRpY2F0b3JzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjYWxjdWxhdGVTTUEsIGNhbGN1bGF0ZUVNQSwgY2FsY3VsYXRlUlNJLCBjYWxjdWxhdGVNQUNEIH0gZnJvbSAnLi4vdXRpbHMvaW5kaWNhdG9ycyc7XG5cbi8qKlxuICogdXNlSW5kaWNhdG9ycyAtIEVmZmljaWVudGx5IGNvbXB1dGUgYWxsIHNlbGVjdGVkIGluZGljYXRvcnMgZm9yIGEgY2FuZGxlIGFycmF5XG4gKiBAcGFyYW0gY2xvc2VzIEFycmF5IG9mIGNsb3NlIHByaWNlc1xuICogQHBhcmFtIGluZGljYXRvcnMgT2JqZWN0OiB7IHJzaSwgbWFjZCwgZW1hLCBzbWEgfVxuICogQHJldHVybnMgT2JqZWN0IHdpdGggaW5kaWNhdG9yIGFycmF5cyAob25seSB0aG9zZSBlbmFibGVkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5kaWNhdG9ycyhjbG9zZXM6IG51bWJlcltdLCBpbmRpY2F0b3JzOiB7IHJzaT86IGJvb2xlYW47IG1hY2Q/OiBib29sZWFuOyBlbWE/OiBib29sZWFuOyBzbWE/OiBib29sZWFuIH0pIHtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdDogYW55ID0ge307XG4gICAgaWYgKGluZGljYXRvcnMuc21hKSByZXN1bHQuc21hID0gY2FsY3VsYXRlU01BKGNsb3NlcywgMTQpO1xuICAgIGlmIChpbmRpY2F0b3JzLmVtYSkgcmVzdWx0LmVtYSA9IGNhbGN1bGF0ZUVNQShjbG9zZXMsIDE0KTtcbiAgICBpZiAoaW5kaWNhdG9ycy5yc2kpIHJlc3VsdC5yc2kgPSBjYWxjdWxhdGVSU0koY2xvc2VzLCAxNCk7XG4gICAgaWYgKGluZGljYXRvcnMubWFjZCkgcmVzdWx0Lm1hY2QgPSBjYWxjdWxhdGVNQUNEKGNsb3Nlcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW2Nsb3NlcywgaW5kaWNhdG9ycy5zbWEsIGluZGljYXRvcnMuZW1hLCBpbmRpY2F0b3JzLnJzaSwgaW5kaWNhdG9ycy5tYWNkXSk7XG59XG4iXSwibmFtZXMiOlsidXNlTWVtbyIsImNhbGN1bGF0ZVNNQSIsImNhbGN1bGF0ZUVNQSIsImNhbGN1bGF0ZVJTSSIsImNhbGN1bGF0ZU1BQ0QiLCJ1c2VJbmRpY2F0b3JzIiwiY2xvc2VzIiwiaW5kaWNhdG9ycyIsInJlc3VsdCIsInNtYSIsImVtYSIsInJzaSIsIm1hY2QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useIndicators.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/binanceApi.ts":
/*!*********************************!*\
  !*** ./src/utils/binanceApi.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GetCandles: () => (/* binding */ GetCandles),\n/* harmony export */   GetLiveCandle: () => (/* binding */ GetLiveCandle)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\nconst GetCandles = async (currentTimeFrame, currentCoin)=>{\n    try {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"/api/candles?symbol=\".concat(currentCoin, \"&interval=\").concat(currentTimeFrame));\n        return response.data.map((item)=>({\n                openTime: item[0],\n                open: parseFloat(item[1]),\n                high: parseFloat(item[2]),\n                low: parseFloat(item[3]),\n                close: parseFloat(item[4]),\n                volume: parseFloat(item[5]),\n                closeTime: item[6],\n                baseAssetVolume: parseFloat(item[7]),\n                numberOfTrades: item[8],\n                takerBuyVolume: parseFloat(item[9]),\n                takerBuyBaseAssetVolume: parseFloat(item[10]),\n                ignore: parseFloat(item[11])\n            }));\n    } catch (error) {\n        console.error(\"Error fetching candlestick data:\", error);\n        return [];\n    }\n};\nconst GetLiveCandle = (currentTimeFrame, currentCoin)=>{\n    return \"wss://stream.binance.com:9443/ws/\".concat(currentCoin.toLowerCase(), \"@kline_\").concat(currentTimeFrame);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9iaW5hbmNlQXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQjtBQWlCbkIsTUFBTUMsYUFBYSxPQUN4QkMsa0JBQ0FDO0lBRUEsSUFBSTtRQUNGLE1BQU1DLFdBQVcsTUFBTUosNkNBQUtBLENBQUNLLEdBQUcsQ0FHOUIsdUJBQStDSCxPQUF4QkMsYUFBWSxjQUE2QixPQUFqQkQ7UUFHakQsT0FBT0UsU0FBU0UsSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQ0MsT0FBVTtnQkFDbENDLFVBQVVELElBQUksQ0FBQyxFQUFFO2dCQUNqQkUsTUFBTUMsV0FBV0gsSUFBSSxDQUFDLEVBQUU7Z0JBQ3hCSSxNQUFNRCxXQUFXSCxJQUFJLENBQUMsRUFBRTtnQkFDeEJLLEtBQUtGLFdBQVdILElBQUksQ0FBQyxFQUFFO2dCQUN2Qk0sT0FBT0gsV0FBV0gsSUFBSSxDQUFDLEVBQUU7Z0JBQ3pCTyxRQUFRSixXQUFXSCxJQUFJLENBQUMsRUFBRTtnQkFDMUJRLFdBQVdSLElBQUksQ0FBQyxFQUFFO2dCQUNsQlMsaUJBQWlCTixXQUFXSCxJQUFJLENBQUMsRUFBRTtnQkFDbkNVLGdCQUFnQlYsSUFBSSxDQUFDLEVBQUU7Z0JBQ3ZCVyxnQkFBZ0JSLFdBQVdILElBQUksQ0FBQyxFQUFFO2dCQUNsQ1kseUJBQXlCVCxXQUFXSCxJQUFJLENBQUMsR0FBRztnQkFDNUNhLFFBQVFWLFdBQVdILElBQUksQ0FBQyxHQUFHO1lBQzdCO0lBQ0YsRUFBRSxPQUFPYyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxvQ0FBb0NBO1FBQ2xELE9BQU8sRUFBRTtJQUNYO0FBQ0YsRUFBRTtBQUVLLE1BQU1FLGdCQUFnQixDQUFDdEIsa0JBQTBCQztJQUN0RCxPQUFPLG9DQUF1RUQsT0FBbkNDLFlBQVlzQixXQUFXLElBQUcsV0FBMEIsT0FBakJ2QjtBQUNoRixFQUFFIiwic291cmNlcyI6WyJDOlxcRE9fQU5cXGJ0Yy1kYXNoYm9hcmRcXHNyY1xcdXRpbHNcXGJpbmFuY2VBcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuXG5leHBvcnQgdHlwZSBJQ2FuZGxlU3RpY2sgPSB7XG4gIG9wZW5UaW1lOiBudW1iZXI7XG4gIG9wZW46IG51bWJlcjtcbiAgaGlnaDogbnVtYmVyO1xuICBsb3c6IG51bWJlcjtcbiAgY2xvc2U6IG51bWJlcjtcbiAgdm9sdW1lOiBudW1iZXI7XG4gIGNsb3NlVGltZTogbnVtYmVyO1xuICBiYXNlQXNzZXRWb2x1bWU6IG51bWJlcjtcbiAgbnVtYmVyT2ZUcmFkZXM6IG51bWJlcjtcbiAgdGFrZXJCdXlWb2x1bWU6IG51bWJlcjtcbiAgdGFrZXJCdXlCYXNlQXNzZXRWb2x1bWU6IG51bWJlcjtcbiAgaWdub3JlOiBudW1iZXI7XG59O1xuXG5leHBvcnQgY29uc3QgR2V0Q2FuZGxlcyA9IGFzeW5jIChcbiAgY3VycmVudFRpbWVGcmFtZTogc3RyaW5nLFxuICBjdXJyZW50Q29pbjogc3RyaW5nXG4pOiBQcm9taXNlPElDYW5kbGVTdGlja1tdPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQ8XG4gICAgICBbbnVtYmVyLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgbnVtYmVyLCBzdHJpbmcsIG51bWJlciwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ11bXVxuICAgID4oXG4gICAgICBgL2FwaS9jYW5kbGVzP3N5bWJvbD0ke2N1cnJlbnRDb2lufSZpbnRlcnZhbD0ke2N1cnJlbnRUaW1lRnJhbWV9YFxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICBvcGVuVGltZTogaXRlbVswXSxcbiAgICAgIG9wZW46IHBhcnNlRmxvYXQoaXRlbVsxXSksXG4gICAgICBoaWdoOiBwYXJzZUZsb2F0KGl0ZW1bMl0pLFxuICAgICAgbG93OiBwYXJzZUZsb2F0KGl0ZW1bM10pLFxuICAgICAgY2xvc2U6IHBhcnNlRmxvYXQoaXRlbVs0XSksXG4gICAgICB2b2x1bWU6IHBhcnNlRmxvYXQoaXRlbVs1XSksXG4gICAgICBjbG9zZVRpbWU6IGl0ZW1bNl0sXG4gICAgICBiYXNlQXNzZXRWb2x1bWU6IHBhcnNlRmxvYXQoaXRlbVs3XSksXG4gICAgICBudW1iZXJPZlRyYWRlczogaXRlbVs4XSxcbiAgICAgIHRha2VyQnV5Vm9sdW1lOiBwYXJzZUZsb2F0KGl0ZW1bOV0pLFxuICAgICAgdGFrZXJCdXlCYXNlQXNzZXRWb2x1bWU6IHBhcnNlRmxvYXQoaXRlbVsxMF0pLFxuICAgICAgaWdub3JlOiBwYXJzZUZsb2F0KGl0ZW1bMTFdKSxcbiAgICB9KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGNhbmRsZXN0aWNrIGRhdGE6XCIsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBHZXRMaXZlQ2FuZGxlID0gKGN1cnJlbnRUaW1lRnJhbWU6IHN0cmluZywgY3VycmVudENvaW46IHN0cmluZykgPT4ge1xuICByZXR1cm4gYHdzczovL3N0cmVhbS5iaW5hbmNlLmNvbTo5NDQzL3dzLyR7Y3VycmVudENvaW4udG9Mb3dlckNhc2UoKX1Aa2xpbmVfJHtjdXJyZW50VGltZUZyYW1lfWA7XG59O1xuIl0sIm5hbWVzIjpbImF4aW9zIiwiR2V0Q2FuZGxlcyIsImN1cnJlbnRUaW1lRnJhbWUiLCJjdXJyZW50Q29pbiIsInJlc3BvbnNlIiwiZ2V0IiwiZGF0YSIsIm1hcCIsIml0ZW0iLCJvcGVuVGltZSIsIm9wZW4iLCJwYXJzZUZsb2F0IiwiaGlnaCIsImxvdyIsImNsb3NlIiwidm9sdW1lIiwiY2xvc2VUaW1lIiwiYmFzZUFzc2V0Vm9sdW1lIiwibnVtYmVyT2ZUcmFkZXMiLCJ0YWtlckJ1eVZvbHVtZSIsInRha2VyQnV5QmFzZUFzc2V0Vm9sdW1lIiwiaWdub3JlIiwiZXJyb3IiLCJjb25zb2xlIiwiR2V0TGl2ZUNhbmRsZSIsInRvTG93ZXJDYXNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/binanceApi.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/indicators.ts":
/*!*********************************!*\
  !*** ./src/utils/indicators.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateEMA: () => (/* binding */ calculateEMA),\n/* harmony export */   calculateMACD: () => (/* binding */ calculateMACD),\n/* harmony export */   calculateRSI: () => (/* binding */ calculateRSI),\n/* harmony export */   calculateSMA: () => (/* binding */ calculateSMA)\n/* harmony export */ });\n// Indicator calculation functions\n// Calculate Simple Moving Average (SMA)\nfunction calculateSMA(data, period) {\n    if (period <= 1 || data.length < period) return Array(data.length).fill(null);\n    const result = Array(period - 1).fill(null);\n    let sum = data.slice(0, period).reduce((a, b)=>a + b, 0);\n    result.push(sum / period);\n    for(let i = period; i < data.length; i++){\n        sum += data[i] - data[i - period];\n        result.push(sum / period);\n    }\n    return result;\n}\n// Calculate Exponential Moving Average (EMA)\nfunction calculateEMA(data, period) {\n    if (period <= 1 || data.length < period) return Array(data.length).fill(null);\n    const result = Array(period - 1).fill(null);\n    let ema = data.slice(0, period).reduce((a, b)=>a + b, 0) / period;\n    result.push(ema);\n    const k = 2 / (period + 1);\n    for(let i = period; i < data.length; i++){\n        ema = data[i] * k + ema * (1 - k);\n        result.push(ema);\n    }\n    return result;\n}\n// Calculate Relative Strength Index (RSI)\nfunction calculateRSI(data, period) {\n    if (period <= 1 || data.length <= period) return Array(data.length).fill(null);\n    const result = Array(period).fill(null);\n    let gain = 0, loss = 0;\n    for(let i = 1; i <= period; i++){\n        const diff = data[i] - data[i - 1];\n        if (diff >= 0) gain += diff;\n        else loss -= diff;\n    }\n    gain /= period;\n    loss /= period;\n    let rs = loss === 0 ? 100 : gain / loss;\n    result.push(100 - 100 / (1 + rs));\n    for(let i = period + 1; i < data.length; i++){\n        const diff = data[i] - data[i - 1];\n        if (diff >= 0) {\n            gain = (gain * (period - 1) + diff) / period;\n            loss = loss * (period - 1) / period;\n        } else {\n            gain = gain * (period - 1) / period;\n            loss = (loss * (period - 1) - diff) / period;\n        }\n        rs = loss === 0 ? 100 : gain / loss;\n        result.push(100 - 100 / (1 + rs));\n    }\n    return result;\n}\n// Calculate MACD (returns {macd, signal, histogram})\nfunction calculateMACD(data) {\n    let fastPeriod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 12, slowPeriod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 26, signalPeriod = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 9;\n    if (data.length < slowPeriod) {\n        return {\n            macd: Array(data.length).fill(null),\n            signal: Array(data.length).fill(null),\n            histogram: Array(data.length).fill(null)\n        };\n    }\n    const emaFast = calculateEMA(data, fastPeriod);\n    const emaSlow = calculateEMA(data, slowPeriod);\n    const macd = [];\n    for(let i = 0; i < data.length; i++){\n        if (emaFast[i] !== null && emaSlow[i] !== null) {\n            macd.push(emaFast[i] - emaSlow[i]);\n        } else {\n            macd.push(null);\n        }\n    }\n    const signal = calculateEMA(macd.map((v)=>v !== null && v !== void 0 ? v : 0), signalPeriod);\n    const histogram = macd.map((v, i)=>v !== null && signal[i] !== null ? v - signal[i] : null);\n    return {\n        macd,\n        signal,\n        histogram\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9pbmRpY2F0b3JzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxrQ0FBa0M7QUFFbEMsd0NBQXdDO0FBQ2pDLFNBQVNBLGFBQWFDLElBQWMsRUFBRUMsTUFBYztJQUN6RCxJQUFJQSxVQUFVLEtBQUtELEtBQUtFLE1BQU0sR0FBR0QsUUFBUSxPQUFPRSxNQUFNSCxLQUFLRSxNQUFNLEVBQUVFLElBQUksQ0FBQztJQUN4RSxNQUFNQyxTQUE0QkYsTUFBTUYsU0FBUyxHQUFHRyxJQUFJLENBQUM7SUFDekQsSUFBSUUsTUFBTU4sS0FBS08sS0FBSyxDQUFDLEdBQUdOLFFBQVFPLE1BQU0sQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQyxHQUFHO0lBQ3hETCxPQUFPTSxJQUFJLENBQUNMLE1BQU1MO0lBQ2xCLElBQUssSUFBSVcsSUFBSVgsUUFBUVcsSUFBSVosS0FBS0UsTUFBTSxFQUFFVSxJQUFLO1FBQ3pDTixPQUFPTixJQUFJLENBQUNZLEVBQUUsR0FBR1osSUFBSSxDQUFDWSxJQUFJWCxPQUFPO1FBQ2pDSSxPQUFPTSxJQUFJLENBQUNMLE1BQU1MO0lBQ3BCO0lBQ0EsT0FBT0k7QUFDVDtBQUVBLDZDQUE2QztBQUN0QyxTQUFTUSxhQUFhYixJQUFjLEVBQUVDLE1BQWM7SUFDekQsSUFBSUEsVUFBVSxLQUFLRCxLQUFLRSxNQUFNLEdBQUdELFFBQVEsT0FBT0UsTUFBTUgsS0FBS0UsTUFBTSxFQUFFRSxJQUFJLENBQUM7SUFDeEUsTUFBTUMsU0FBNEJGLE1BQU1GLFNBQVMsR0FBR0csSUFBSSxDQUFDO0lBQ3pELElBQUlVLE1BQU1kLEtBQUtPLEtBQUssQ0FBQyxHQUFHTixRQUFRTyxNQUFNLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUMsR0FBRyxLQUFLVDtJQUM3REksT0FBT00sSUFBSSxDQUFDRztJQUNaLE1BQU1DLElBQUksSUFBS2QsQ0FBQUEsU0FBUztJQUN4QixJQUFLLElBQUlXLElBQUlYLFFBQVFXLElBQUlaLEtBQUtFLE1BQU0sRUFBRVUsSUFBSztRQUN6Q0UsTUFBTWQsSUFBSSxDQUFDWSxFQUFFLEdBQUdHLElBQUlELE1BQU8sS0FBSUMsQ0FBQUE7UUFDL0JWLE9BQU9NLElBQUksQ0FBQ0c7SUFDZDtJQUNBLE9BQU9UO0FBQ1Q7QUFFQSwwQ0FBMEM7QUFDbkMsU0FBU1csYUFBYWhCLElBQWMsRUFBRUMsTUFBYztJQUN6RCxJQUFJQSxVQUFVLEtBQUtELEtBQUtFLE1BQU0sSUFBSUQsUUFBUSxPQUFPRSxNQUFNSCxLQUFLRSxNQUFNLEVBQUVFLElBQUksQ0FBQztJQUN6RSxNQUFNQyxTQUE0QkYsTUFBTUYsUUFBUUcsSUFBSSxDQUFDO0lBQ3JELElBQUlhLE9BQU8sR0FBR0MsT0FBTztJQUNyQixJQUFLLElBQUlOLElBQUksR0FBR0EsS0FBS1gsUUFBUVcsSUFBSztRQUNoQyxNQUFNTyxPQUFPbkIsSUFBSSxDQUFDWSxFQUFFLEdBQUdaLElBQUksQ0FBQ1ksSUFBSSxFQUFFO1FBQ2xDLElBQUlPLFFBQVEsR0FBR0YsUUFBUUU7YUFBV0QsUUFBUUM7SUFDNUM7SUFDQUYsUUFBUWhCO0lBQ1JpQixRQUFRakI7SUFDUixJQUFJbUIsS0FBS0YsU0FBUyxJQUFJLE1BQU1ELE9BQU9DO0lBQ25DYixPQUFPTSxJQUFJLENBQUMsTUFBTSxNQUFPLEtBQUlTLEVBQUM7SUFDOUIsSUFBSyxJQUFJUixJQUFJWCxTQUFTLEdBQUdXLElBQUlaLEtBQUtFLE1BQU0sRUFBRVUsSUFBSztRQUM3QyxNQUFNTyxPQUFPbkIsSUFBSSxDQUFDWSxFQUFFLEdBQUdaLElBQUksQ0FBQ1ksSUFBSSxFQUFFO1FBQ2xDLElBQUlPLFFBQVEsR0FBRztZQUNiRixPQUFPLENBQUNBLE9BQVFoQixDQUFBQSxTQUFTLEtBQUtrQixJQUFHLElBQUtsQjtZQUN0Q2lCLE9BQU8sT0FBU2pCLENBQUFBLFNBQVMsS0FBTUE7UUFDakMsT0FBTztZQUNMZ0IsT0FBTyxPQUFTaEIsQ0FBQUEsU0FBUyxLQUFNQTtZQUMvQmlCLE9BQU8sQ0FBQ0EsT0FBUWpCLENBQUFBLFNBQVMsS0FBS2tCLElBQUcsSUFBS2xCO1FBQ3hDO1FBQ0FtQixLQUFLRixTQUFTLElBQUksTUFBTUQsT0FBT0M7UUFDL0JiLE9BQU9NLElBQUksQ0FBQyxNQUFNLE1BQU8sS0FBSVMsRUFBQztJQUNoQztJQUNBLE9BQU9mO0FBQ1Q7QUFFQSxxREFBcUQ7QUFDOUMsU0FBU2dCLGNBQWNyQixJQUFjO1FBQUVzQixhQUFBQSxpRUFBYSxJQUFJQyxhQUFBQSxpRUFBYSxJQUFJQyxlQUFBQSxpRUFBZTtJQUM3RixJQUFJeEIsS0FBS0UsTUFBTSxHQUFHcUIsWUFBWTtRQUM1QixPQUFPO1lBQUVFLE1BQU10QixNQUFNSCxLQUFLRSxNQUFNLEVBQUVFLElBQUksQ0FBQztZQUFPc0IsUUFBUXZCLE1BQU1ILEtBQUtFLE1BQU0sRUFBRUUsSUFBSSxDQUFDO1lBQU91QixXQUFXeEIsTUFBTUgsS0FBS0UsTUFBTSxFQUFFRSxJQUFJLENBQUM7UUFBTTtJQUNoSTtJQUNBLE1BQU13QixVQUFVZixhQUFhYixNQUFNc0I7SUFDbkMsTUFBTU8sVUFBVWhCLGFBQWFiLE1BQU11QjtJQUNuQyxNQUFNRSxPQUEwQixFQUFFO0lBQ2xDLElBQUssSUFBSWIsSUFBSSxHQUFHQSxJQUFJWixLQUFLRSxNQUFNLEVBQUVVLElBQUs7UUFDcEMsSUFBSWdCLE9BQU8sQ0FBQ2hCLEVBQUUsS0FBSyxRQUFRaUIsT0FBTyxDQUFDakIsRUFBRSxLQUFLLE1BQU07WUFDOUNhLEtBQUtkLElBQUksQ0FBQyxPQUFRLENBQUNDLEVBQUUsR0FBZWlCLE9BQU8sQ0FBQ2pCLEVBQUU7UUFDaEQsT0FBTztZQUNMYSxLQUFLZCxJQUFJLENBQUM7UUFDWjtJQUNGO0lBQ0EsTUFBTWUsU0FBU2IsYUFBYVksS0FBS0ssR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxjQUFBQSxlQUFBQSxJQUFLLElBQUlQO0lBQ25ELE1BQU1HLFlBQVlGLEtBQUtLLEdBQUcsQ0FBQyxDQUFDQyxHQUFHbkIsSUFBTSxNQUFPLFFBQVFjLE1BQU0sQ0FBQ2QsRUFBRSxLQUFLLE9BQVFtQixJQUFLTCxNQUFNLENBQUNkLEVBQUUsR0FBYztJQUN0RyxPQUFPO1FBQUVhO1FBQU1DO1FBQVFDO0lBQVU7QUFDbkMiLCJzb3VyY2VzIjpbIkM6XFxET19BTlxcYnRjLWRhc2hib2FyZFxcc3JjXFx1dGlsc1xcaW5kaWNhdG9ycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbmRpY2F0b3IgY2FsY3VsYXRpb24gZnVuY3Rpb25zXG5cbi8vIENhbGN1bGF0ZSBTaW1wbGUgTW92aW5nIEF2ZXJhZ2UgKFNNQSlcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTTUEoZGF0YTogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyKTogKG51bWJlciB8IG51bGwpW10ge1xuICBpZiAocGVyaW9kIDw9IDEgfHwgZGF0YS5sZW5ndGggPCBwZXJpb2QpIHJldHVybiBBcnJheShkYXRhLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgY29uc3QgcmVzdWx0OiAobnVtYmVyIHwgbnVsbClbXSA9IEFycmF5KHBlcmlvZCAtIDEpLmZpbGwobnVsbCk7XG4gIGxldCBzdW0gPSBkYXRhLnNsaWNlKDAsIHBlcmlvZCkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gIHJlc3VsdC5wdXNoKHN1bSAvIHBlcmlvZCk7XG4gIGZvciAobGV0IGkgPSBwZXJpb2Q7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtICs9IGRhdGFbaV0gLSBkYXRhW2kgLSBwZXJpb2RdO1xuICAgIHJlc3VsdC5wdXNoKHN1bSAvIHBlcmlvZCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gQ2FsY3VsYXRlIEV4cG9uZW50aWFsIE1vdmluZyBBdmVyYWdlIChFTUEpXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRU1BKGRhdGE6IG51bWJlcltdLCBwZXJpb2Q6IG51bWJlcik6IChudW1iZXIgfCBudWxsKVtdIHtcbiAgaWYgKHBlcmlvZCA8PSAxIHx8IGRhdGEubGVuZ3RoIDwgcGVyaW9kKSByZXR1cm4gQXJyYXkoZGF0YS5sZW5ndGgpLmZpbGwobnVsbCk7XG4gIGNvbnN0IHJlc3VsdDogKG51bWJlciB8IG51bGwpW10gPSBBcnJheShwZXJpb2QgLSAxKS5maWxsKG51bGwpO1xuICBsZXQgZW1hID0gZGF0YS5zbGljZSgwLCBwZXJpb2QpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gcGVyaW9kO1xuICByZXN1bHQucHVzaChlbWEpO1xuICBjb25zdCBrID0gMiAvIChwZXJpb2QgKyAxKTtcbiAgZm9yIChsZXQgaSA9IHBlcmlvZDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBlbWEgPSBkYXRhW2ldICogayArIGVtYSAqICgxIC0gayk7XG4gICAgcmVzdWx0LnB1c2goZW1hKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBDYWxjdWxhdGUgUmVsYXRpdmUgU3RyZW5ndGggSW5kZXggKFJTSSlcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVSU0koZGF0YTogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyKTogKG51bWJlciB8IG51bGwpW10ge1xuICBpZiAocGVyaW9kIDw9IDEgfHwgZGF0YS5sZW5ndGggPD0gcGVyaW9kKSByZXR1cm4gQXJyYXkoZGF0YS5sZW5ndGgpLmZpbGwobnVsbCk7XG4gIGNvbnN0IHJlc3VsdDogKG51bWJlciB8IG51bGwpW10gPSBBcnJheShwZXJpb2QpLmZpbGwobnVsbCk7XG4gIGxldCBnYWluID0gMCwgbG9zcyA9IDA7XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IHBlcmlvZDsgaSsrKSB7XG4gICAgY29uc3QgZGlmZiA9IGRhdGFbaV0gLSBkYXRhW2kgLSAxXTtcbiAgICBpZiAoZGlmZiA+PSAwKSBnYWluICs9IGRpZmY7IGVsc2UgbG9zcyAtPSBkaWZmO1xuICB9XG4gIGdhaW4gLz0gcGVyaW9kO1xuICBsb3NzIC89IHBlcmlvZDtcbiAgbGV0IHJzID0gbG9zcyA9PT0gMCA/IDEwMCA6IGdhaW4gLyBsb3NzO1xuICByZXN1bHQucHVzaCgxMDAgLSAxMDAgLyAoMSArIHJzKSk7XG4gIGZvciAobGV0IGkgPSBwZXJpb2QgKyAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRpZmYgPSBkYXRhW2ldIC0gZGF0YVtpIC0gMV07XG4gICAgaWYgKGRpZmYgPj0gMCkge1xuICAgICAgZ2FpbiA9IChnYWluICogKHBlcmlvZCAtIDEpICsgZGlmZikgLyBwZXJpb2Q7XG4gICAgICBsb3NzID0gKGxvc3MgKiAocGVyaW9kIC0gMSkpIC8gcGVyaW9kO1xuICAgIH0gZWxzZSB7XG4gICAgICBnYWluID0gKGdhaW4gKiAocGVyaW9kIC0gMSkpIC8gcGVyaW9kO1xuICAgICAgbG9zcyA9IChsb3NzICogKHBlcmlvZCAtIDEpIC0gZGlmZikgLyBwZXJpb2Q7XG4gICAgfVxuICAgIHJzID0gbG9zcyA9PT0gMCA/IDEwMCA6IGdhaW4gLyBsb3NzO1xuICAgIHJlc3VsdC5wdXNoKDEwMCAtIDEwMCAvICgxICsgcnMpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBDYWxjdWxhdGUgTUFDRCAocmV0dXJucyB7bWFjZCwgc2lnbmFsLCBoaXN0b2dyYW19KVxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU1BQ0QoZGF0YTogbnVtYmVyW10sIGZhc3RQZXJpb2QgPSAxMiwgc2xvd1BlcmlvZCA9IDI2LCBzaWduYWxQZXJpb2QgPSA5KSB7XG4gIGlmIChkYXRhLmxlbmd0aCA8IHNsb3dQZXJpb2QpIHtcbiAgICByZXR1cm4geyBtYWNkOiBBcnJheShkYXRhLmxlbmd0aCkuZmlsbChudWxsKSwgc2lnbmFsOiBBcnJheShkYXRhLmxlbmd0aCkuZmlsbChudWxsKSwgaGlzdG9ncmFtOiBBcnJheShkYXRhLmxlbmd0aCkuZmlsbChudWxsKSB9O1xuICB9XG4gIGNvbnN0IGVtYUZhc3QgPSBjYWxjdWxhdGVFTUEoZGF0YSwgZmFzdFBlcmlvZCk7XG4gIGNvbnN0IGVtYVNsb3cgPSBjYWxjdWxhdGVFTUEoZGF0YSwgc2xvd1BlcmlvZCk7XG4gIGNvbnN0IG1hY2Q6IChudW1iZXIgfCBudWxsKVtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlbWFGYXN0W2ldICE9PSBudWxsICYmIGVtYVNsb3dbaV0gIT09IG51bGwpIHtcbiAgICAgIG1hY2QucHVzaCgoZW1hRmFzdFtpXSBhcyBudW1iZXIpIC0gKGVtYVNsb3dbaV0gYXMgbnVtYmVyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hY2QucHVzaChudWxsKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2lnbmFsID0gY2FsY3VsYXRlRU1BKG1hY2QubWFwKHYgPT4gdiA/PyAwKSwgc2lnbmFsUGVyaW9kKTtcbiAgY29uc3QgaGlzdG9ncmFtID0gbWFjZC5tYXAoKHYsIGkpID0+ICh2ICE9PSBudWxsICYmIHNpZ25hbFtpXSAhPT0gbnVsbCkgPyB2IC0gKHNpZ25hbFtpXSBhcyBudW1iZXIpIDogbnVsbCk7XG4gIHJldHVybiB7IG1hY2QsIHNpZ25hbCwgaGlzdG9ncmFtIH07XG59XG4iXSwibmFtZXMiOlsiY2FsY3VsYXRlU01BIiwiZGF0YSIsInBlcmlvZCIsImxlbmd0aCIsIkFycmF5IiwiZmlsbCIsInJlc3VsdCIsInN1bSIsInNsaWNlIiwicmVkdWNlIiwiYSIsImIiLCJwdXNoIiwiaSIsImNhbGN1bGF0ZUVNQSIsImVtYSIsImsiLCJjYWxjdWxhdGVSU0kiLCJnYWluIiwibG9zcyIsImRpZmYiLCJycyIsImNhbGN1bGF0ZU1BQ0QiLCJmYXN0UGVyaW9kIiwic2xvd1BlcmlvZCIsInNpZ25hbFBlcmlvZCIsIm1hY2QiLCJzaWduYWwiLCJoaXN0b2dyYW0iLCJlbWFGYXN0IiwiZW1hU2xvdyIsIm1hcCIsInYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/indicators.ts\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CDO_AN%5C%5Cbtc-dashboard%5C%5Csrc%5C%5Capp%5C%5Chome%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);